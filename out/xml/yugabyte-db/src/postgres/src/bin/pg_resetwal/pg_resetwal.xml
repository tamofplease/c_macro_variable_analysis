<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/pg_resetwal/pg_resetwal.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_resetwal.c
 *	  A utility to "zero out" the xlog when it's corrupt beyond recovery.
 *	  Can also rebuild pg_control if needed.
 *
 * The theory of operation is fairly simple:
 *	  1. Read the existing pg_control (which will include the last
 *		 checkpoint record).  If it is an old format then update to
 *		 current format.
 *	  2. If pg_control is corrupt, attempt to intuit reasonable values,
 *		 by scanning the old xlog if necessary.
 *	  3. Modify pg_control to reflect a "shutdown" state with a checkpoint
 *		 record at the start of xlog.
 *	  4. Flush the existing xlog files and write a new segment with
 *		 just a checkpoint record in it.  The new segment is positioned
 *		 just past the end of the old xlog, so that existing LSNs in
 *		 data pages will appear to be "in the past".
 * This is all pretty straightforward except for the intuition part of
 * step 2 ...
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/bin/pg_resetwal/pg_resetwal.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * We have to use postgres.h not postgres_fe.h here, because there's so much
 * backend-only stuff in the XLOG include files we need.  But we need a
 * frontend-ish environment otherwise.  Hence this ugly hack.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRONTEND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/fe_memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/restricted_token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/large_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>ControlFileData</name></type> <name>ControlFile</name></decl>;</decl_stmt> <comment type="block">/* pg_control values */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>newXlogSegNo</name></decl>;</decl_stmt>	<comment type="block">/* new XLOG segment # */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>guessed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* T if we had to guess at any values */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>set_xid_epoch</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>set_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>set_oldest_commit_ts_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>set_newest_commit_ts_xid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>set_oid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactId</name></type> <name>set_mxid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactOffset</name></type> <name>set_mxoff</name> <init>= <expr><operator>(</operator><name>MultiXactOffset</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>minXlogTli</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>minXlogSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>WalSegSz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>set_wal_segsize</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckDataVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GuessControlValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintControlValues</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>guessed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintNewControlValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RewriteControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FindEndOfXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KillExistingXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>KillExistingArchiveStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteEmptyXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"commit-timestamp-ids"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"pgdata"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"epoch"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"force"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"next-wal-file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"multixact-ids"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'m'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dry-run"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"next-oid"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"multixact-offset"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"next-transaction-id"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"wal-segsize"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>noupdate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>set_oldestmxid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>DataDir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>log_fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"pg_resetwal"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"pg_resetwal (PostgreSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"c:D:e:fl:m:no:O:x:"</literal></expr></argument>, <argument><expr><name>long_options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>DataDir</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name>force</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<expr_stmt><expr><name>noupdate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<expr_stmt><expr><name>set_xid_epoch</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*------
					  translator: the second %s is a command line argument (-e, etc) */</comment>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>set_xid_epoch</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transaction ID epoch (-e) must not be -1\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
				<expr_stmt><expr><name>set_xid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>set_xid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transaction ID (-x) must not be 0\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<expr_stmt><expr><name>set_oldest_commit_ts_xid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>set_newest_commit_ts_xid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr2</name> <operator>==</operator> <name>endptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>endptr2</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-c"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>set_oldest_commit_ts_xid</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
					<name>set_oldest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transaction ID (-c) must be either 0 or greater than or equal to 2\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>set_newest_commit_ts_xid</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
					<name>set_newest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: transaction ID (-c) must be either 0 or greater than or equal to 2\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>
				<expr_stmt><expr><name>set_oid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-o"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>set_oid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: OID (-o) must not be 0\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'m'</literal></expr>:</case>
				<expr_stmt><expr><name>set_mxid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>set_oldestmxid</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr2</name> <operator>==</operator> <name>endptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>endptr2</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>set_mxid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: multitransaction ID (-m) must not be 0\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * XXX It'd be nice to have more sanity checks here, e.g. so
				 * that oldest is not wrapped around w.r.t. nextMulti.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>set_oldestmxid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: oldest multitransaction ID (-m) must not be 0\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<expr_stmt><expr><name>set_mxoff</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-O"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>set_mxoff</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: multitransaction offset (-O) must not be -1\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"01234567890ABCDEFabcdef"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XLOG_FNAME_LEN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: invalid argument for option %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"-l"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * XLogFromFileName requires wal segment size which is not yet
				 * set. Hence wal details are set later on.
				 */</comment>
				<expr_stmt><expr><name>log_fname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name>set_wal_segsize</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>optarg</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: argument of --wal-segsize must be a number\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>set_wal_segsize</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
							<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: argument of --wal-segsize must be a power of 2 between 1 and 1024\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>DataDir</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>DataDir</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Complain if any arguments remain */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DataDir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: no data directory specified\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow pg_resetwal to be run as root, to avoid overwriting the
	 * ownership of files in the data directory. We need only check for root
	 * -- any other user won't have sufficient permissions to modify files in
	 * the data directory.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: cannot be executed by \"root\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"You must run %s as the PostgreSQL superuser.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>get_restricted_token</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set mask based on PGDATA permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read permissions of directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not change directory to \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check that data directory matches our server version */</comment>
	<expr_stmt><expr><call><name>CheckDataVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for a postmaster lock file --- if there is one, refuse to
	 * proceed, on grounds we might be interfering with a live installation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><literal type="string">"postmaster.pid"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"postmaster.pid"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: lock file \"%s\" exists\n"</literal>
						  <literal type="string">"Is a server running?  If not, delete the lock file and try again.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"postmaster.pid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Attempt to read the existing pg_control file
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadControlFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>GuessControlValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If no new WAL segment size was specified, use the control file value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>set_wal_segsize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>WalSegSz</name> <operator>=</operator> <name>set_wal_segsize</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>WalSegSz</name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogFromFileName</name><argument_list>(<argument><expr><name>log_fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minXlogTli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minXlogSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also look at existing segment files to set up newXlogSegNo
	 */</comment>
	<expr_stmt><expr><call><name>FindEndOfXLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not going to proceed with the reset, print the current control
	 * file parameters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>guessed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name><operator>)</operator> <operator>||</operator> <name>noupdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PrintControlValues</name><argument_list>(<argument><expr><name>guessed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust fields if required by switches.  (Do this now so that printout,
	 * if any, includes these values.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>set_xid_epoch</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <name>set_xid_epoch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name>set_xid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the moment, just set oldestXid to a value that will force
		 * immediate autovacuum-for-wraparound.  It's not clear whether adding
		 * user control of this is useful, so let's just do something that's
		 * reasonably safe.  The magic constant here corresponds to the
		 * maximum allowed value of autovacuum_freeze_max_age.
		 */</comment>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name> <operator>=</operator> <name>set_xid</name> <operator>-</operator> <literal type="number">2000000000</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_oldest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestCommitTsXid</name></name> <operator>=</operator> <name>set_oldest_commit_ts_xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>set_newest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>newestCommitTsXid</name></name> <operator>=</operator> <name>set_newest_commit_ts_xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_oid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextOid</name></name> <operator>=</operator> <name>set_oid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_mxid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMulti</name></name> <operator>=</operator> <name>set_mxid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name> <operator>=</operator> <name>set_oldestmxid</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name> <operator>+=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMultiDB</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_mxoff</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMultiOffset</name></name> <operator>=</operator> <name>set_mxoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>minXlogTli</name> <operator>&gt;</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <name>minXlogTli</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <name>minXlogTli</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_wal_segsize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name> <operator>=</operator> <name>WalSegSz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>minXlogSegNo</name> <operator>&gt;</operator> <name>newXlogSegNo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newXlogSegNo</name> <operator>=</operator> <name>minXlogSegNo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we had to guess anything, and -f was not given, just print the
	 * guessed values and exit.  Also print if -n is given.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>guessed</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name><operator>)</operator> <operator>||</operator> <name>noupdate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PrintNewControlValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noupdate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nIf these values seem acceptable, use -f to force reset.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Don't reset from a dirty pg_control without -f, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ControlFile</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>DB_SHUTDOWNED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"The database server was not shut down cleanly.\n"</literal>
				 <literal type="string">"Resetting the write-ahead log might cause data to be lost.\n"</literal>
				 <literal type="string">"If you want to proceed anyway, use -f to force reset.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Else, do the dirty deed.
	 */</comment>
	<expr_stmt><expr><call><name>RewriteControlFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>KillExistingXLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>KillExistingArchiveStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteEmptyXLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Write-ahead log reset\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Look at the version string stored in PG_VERSION and decide if this utility
 * can be run safely or not.
 *
 * We don't want to inject pg_control and WAL files that are for a different
 * major version; that can't do anything good.  Note that we don't treat
 * mismatching version info in pg_control as a reason to bail out, because
 * recovering from a corrupted pg_control is one of the main reasons for this
 * program to exist at all.  However, PG_VERSION is unlikely to get corrupted,
 * and if it were it would be easy to fix by hand.  So let's make this check
 * to prevent simple user errors.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckDataVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ver_file</name> <init>= <expr><literal type="string">"PG_VERSION"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>ver_fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>rawline</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ver_fd</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>ver_file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ver_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* version number has to be the first line read */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>ver_fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name>ver_fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: unexpected empty file \"%s\"\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ver_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ver_file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remove trailing newline, handling Windows newlines as well */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rawline</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rawline</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rawline</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rawline</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>, <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: data directory is of wrong version\n"</literal>
						  <literal type="string">"File \"%s\" contains \"%s\", which is not compatible with this program's version \"%s\".\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ver_file</name></expr></argument>, <argument><expr><name>rawline</name></expr></argument>, <argument><expr><name>PG_MAJORVERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>ver_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Try to read the existing pg_control file.
 *
 * This routine is also responsible for updating old pg_control versions
 * to the current format.  (Currently we don't do anything of the sort.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReadControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If pg_control is not there at all, or we can't read it, the odds
		 * are we've been handed a bad DataDir path, so give up. User can do
		 * "touch pg_control" to force us to proceed.
		 */</comment>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\" for reading: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"If you are sure the data directory path is correct, execute\n"</literal>
							  <literal type="string">"  touch %s\n"</literal>
							  <literal type="string">"and try again.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Use malloc to ensure we have a maxaligned buffer */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ControlFileData</name> <operator>*</operator><operator>)</operator> <name>buffer</name><operator>)</operator><operator>-&gt;</operator><name>pg_control_version</name> <operator>==</operator> <name>PG_CONTROL_VERSION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check the CRC. */</comment>
		<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>,
					<argument><expr><name>buffer</name></expr></argument>,
					<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>ControlFileData</name> <operator>*</operator><operator>)</operator> <name>buffer</name><operator>)</operator><operator>-&gt;</operator><name>crc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We will use the data but treat it as guessed. */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pg_control exists but has invalid CRC; proceed with caution\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>guessed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlFile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* return false if WAL segment size is not valid */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
					<argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%s: pg_control specifies invalid WAL segment size (%d byte); proceed with caution\n"</literal></expr></argument>,
							 <argument><expr><literal type="string">"%s: pg_control specifies invalid WAL segment size (%d bytes); proceed with caution\n"</literal></expr></argument>,
							 <argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Looks like it's a mess. */</comment>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: pg_control exists but is broken or wrong version; ignoring it\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Guess at pg_control values when we can't read the old ones.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GuessControlValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>sysidentifier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Set up a completely default set of pg_control values.
	 */</comment>
	<expr_stmt><expr><name>guessed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ControlFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>pg_control_version</name></name> <operator>=</operator> <name>PG_CONTROL_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>catalog_version_no</name></name> <operator>=</operator> <name>CATALOG_VERSION_NO</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a new unique installation identifier, since we can no longer use
	 * any old XLOG records.  See notes in xlog.c about the algorithm.
	 */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sysidentifier</name> <operator>|=</operator> <call><name>getpid</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>system_identifier</name></name> <operator>=</operator> <name>sysidentifier</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name> <operator>=</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>PrevTimeLineID</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>fullPageWrites</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstBootstrapObjectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMulti</name></name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMultiOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name> <operator>=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMultiDB</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestActiveXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPoint</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>unloggedLSN</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* minRecoveryPoint, backupStartPoint and backupEndPoint can be left zero */</comment>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>wal_level</name></name> <operator>=</operator> <name>WAL_LEVEL_MINIMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>wal_log_hints</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>MaxConnections</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_worker_processes</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>maxAlign</name></name> <operator>=</operator> <name>MAXIMUM_ALIGNOF</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>floatFormat</name></name> <operator>=</operator> <name>FLOATFORMAT_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>blcksz</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>relseg_size</name></name> <operator>=</operator> <name>RELSEG_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_blcksz</name></name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name> <operator>=</operator> <name>DEFAULT_XLOG_SEG_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>nameDataLen</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>indexMaxKeys</name></name> <operator>=</operator> <name>INDEX_MAX_KEYS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>toast_max_chunk_size</name></name> <operator>=</operator> <name>TOAST_MAX_CHUNK_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>loblksize</name></name> <operator>=</operator> <name>LOBLKSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>float4ByVal</name></name> <operator>=</operator> <name>FLOAT4PASSBYVAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>float8ByVal</name></name> <operator>=</operator> <name>FLOAT8PASSBYVAL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX eventually, should try to grovel through old XLOG to develop more
	 * accurate values for TimeLineID, nextXID, etc.
	 */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Print the guessed pg_control values when we had to guess.
 *
 * NB: this display should be just those fields that will not be
 * reset by RewriteControlFile().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintControlValues</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>guessed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sysident_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>guessed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Guessed pg_control values:\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Current pg_control values:\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Format system_identifier separately to keep platform-dependent format
	 * code out of the translatable message string.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sysident_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysident_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>ControlFile</name><operator>.</operator><name>system_identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"pg_control version number:            %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>pg_control_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Catalog version number:               %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>catalog_version_no</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Database system identifier:           %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>sysident_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's TimeLineID:       %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's full_page_writes: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><ternary><condition><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>fullPageWrites</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's NextXID:          %u:%u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's NextOID:          %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's NextMultiXactId:  %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMulti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's NextMultiOffset:  %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestXID:        %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestXID's DB:   %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestActiveXID:  %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestActiveXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestMultiXid:   %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestMulti's DB: %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's oldestCommitTsXid:%u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestCommitTsXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Latest checkpoint's newestCommitTsXid:%u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>newestCommitTsXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Maximum data alignment:               %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>maxAlign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't print floatFormat since can't say much useful about it */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Database block size:                  %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>blcksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Blocks per segment of large relation: %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>relseg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"WAL block size:                       %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_blcksz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Bytes per WAL segment:                %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Maximum length of identifiers:        %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>nameDataLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Maximum columns in an index:          %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>indexMaxKeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Maximum size of a TOAST chunk:        %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>toast_max_chunk_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Size of a large-object chunk:         %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>loblksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* This is no longer configurable, but users may still expect to see it: */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Date/time type storage:               %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"64-bit integers"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Float4 argument passing:              %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ControlFile</name><operator>.</operator><name>float4ByVal</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"by value"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"by reference"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Float8 argument passing:              %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>ControlFile</name><operator>.</operator><name>float8ByVal</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"by value"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"by reference"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Data page checksum version:           %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>data_checksum_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Print the values to be changed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintNewControlValues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* This will be always printed in order to keep format same. */</comment>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n\nValues to be changed:\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>,
				 <argument><expr><name>newXlogSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"First log segment after reset:        %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_mxid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NextMultiXactId:                      %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMulti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"OldestMultiXid:                       %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMulti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"OldestMulti's DB:                     %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_mxoff</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NextMultiOffset:                      %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextMultiOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_oid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NextOID:                              %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NextXID:                              %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"OldestXID:                            %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"OldestXID's DB:                       %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestXidDB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_xid_epoch</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"NextXID epoch:                        %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>nextXidEpoch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_oldest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"oldestCommitTsXid:                    %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>oldestCommitTsXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>set_newest_commit_ts_xid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"newestCommitTsXid:                    %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>newestCommitTsXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>set_wal_segsize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Bytes per WAL segment:                %u\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write out the new pg_control file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RewriteControlFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>PG_CONTROL_FILE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* need not be aligned */</comment>

	<comment type="block">/*
	 * For good luck, apply the same static assertions as in backend's
	 * WriteControlFile().
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PG_CONTROL_MAX_SAFE_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"pg_control is too large for atomic disk writes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PG_CONTROL_FILE_SIZE</name></expr></argument>,
					 <argument><expr><literal type="string">"sizeof(ControlFileData) exceeds PG_CONTROL_FILE_SIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust fields as needed to force an empty XLOG starting at
	 * newXlogSegNo.
	 */</comment>
	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>newXlogSegNo</name></expr></argument>, <argument><expr><name>SizeOfXLogLongPHD</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>,
							<argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>DB_SHUTDOWNED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>checkPoint</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>minRecoveryPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>minRecoveryPointTLI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>backupStartPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>backupEndPoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>backupEndRequired</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force the defaults for max_* settings. The values don't really matter
	 * as long as wal_level='minimal'; the postmaster will reset these fields
	 * anyway at startup.
	 */</comment>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>wal_level</name></name> <operator>=</operator> <name>WAL_LEVEL_MINIMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>wal_log_hints</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>track_commit_timestamp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>MaxConnections</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_worker_processes</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_prepared_xacts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ControlFile</name><operator>.</operator><name>max_locks_per_xact</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>

	<comment type="block">/* Contents are protected with a CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>.</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>.</operator><name>crc</name></name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>ControlFile</name></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>ControlFile</name><operator>.</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We write out PG_CONTROL_FILE_SIZE bytes into pg_control, zero-padding
	 * the excess over sizeof(ControlFileData).  This reduces the odds of
	 * premature-EOF errors when reading pg_control.  We'll still fail when we
	 * check the contents of the file, but hopefully with a more specific
	 * error than "couldn't read pg_control".
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ControlFile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>,
			  <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
			  <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not create pg_control file: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>PG_CONTROL_FILE_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PG_CONTROL_FILE_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write pg_control file: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: fsync error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Scan existing XLOG files and determine the highest existing WAL address
 *
 * On entry, ControlFile.checkPointCopy.redo and ControlFile.xlog_seg_size
 * are assumed valid (note that we allow the old xlog seg size to differ
 * from what we're using).  On exit, newXlogId and newXlogSeg are set to
 * suitable values for the beginning of replacement WAL (in our seg size).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindEndOfXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>segs_per_xlogid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>xlogbytepos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize the max() computation using the last checkpoint address from
	 * old pg_control.  Note that for the moment we are working with segment
	 * numbering according to the old xlog seg size.
	 */</comment>
	<expr_stmt><expr><name>segs_per_xlogid</name> <operator>=</operator> <operator>(</operator><call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0x0000000100000000</literal></expr></argument>)</argument_list></call> <operator>/</operator> <name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>newXlogSegNo</name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name> <operator>/</operator> <name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the pg_wal directory to find existing WAL segment files. We assume
	 * any present have been used; in most scenarios this should be
	 * conservative, because of xlog.c's attempts to pre-create files.
	 */</comment>
	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xldir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsPartialXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tli</name></decl>,
						<decl><type ref="prev"/><name>log</name></decl>,
						<decl><type ref="prev"/><name>seg</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note: We don't use XLogFromFileName here, because we want to
			 * use the segment size from the control file, not the size the
			 * pg_resetwal binary was compiled with
			 */</comment>
			<expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"%08X%08X%08X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>log</name><operator>)</operator> <operator>*</operator> <name>segs_per_xlogid</name> <operator>+</operator> <name>seg</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: we take the max of all files found, regardless of their
			 * timelines.  Another possibility would be to ignore files of
			 * timelines other than the target TLI, but this seems safer.
			 * Better too large a result than too small...
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>&gt;</operator> <name>newXlogSegNo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newXlogSegNo</name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, convert to new xlog seg size, and advance by one to ensure we
	 * are in virgin territory.
	 */</comment>
	<expr_stmt><expr><name>xlogbytepos</name> <operator>=</operator> <name>newXlogSegNo</name> <operator>*</operator> <name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newXlogSegNo</name> <operator>=</operator> <operator>(</operator><name>xlogbytepos</name> <operator>+</operator> <name><name>ControlFile</name><operator>.</operator><name>xlog_seg_size</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>WalSegSz</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newXlogSegNo</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove existing XLOG files
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KillExistingXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>XLOGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xldir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsPartialXLogFileName</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not delete file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>XLOGDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove existing archive status files
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>KillExistingArchiveStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARCHSTATDIR</name></cpp:macro> <cpp:value>XLOGDIR "/archive_status"</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ARCHSTATDIR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>ARCHSTATDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xldir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ARCHSTATDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>XLOG_FNAME_LEN</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>XLOG_FNAME_LEN</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>XLOG_FNAME_LEN</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>XLOG_FNAME_LEN</name></expr></argument>, <argument><expr><literal type="string">".partial.ready"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name> <operator>+</operator> <name>XLOG_FNAME_LEN</name></expr></argument>, <argument><expr><literal type="string">".partial.done"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>ARCHSTATDIR</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not delete file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not read directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ARCHSTATDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>closedir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not close directory \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ARCHSTATDIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write an empty XLOG file, containing only the checkpoint record
 * already set up in ControlFile.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteEmptyXLOG</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGAlignedXLogBlock</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogPageHeader</name></type> <name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogLongPageHeader</name></type> <name>longpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up the XLOG page header */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>XLogPageHeader</name><operator>)</operator> <name><name>buffer</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>=</operator> <name>XLOG_PAGE_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>=</operator> <name>XLP_LONG_HEADER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_tli</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name> <operator>-</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>longpage</name> <operator>=</operator> <operator>(</operator><name>XLogLongPageHeader</name><operator>)</operator> <name>page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>=</operator> <name><name>ControlFile</name><operator>.</operator><name>system_identifier</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>=</operator> <name>WalSegSz</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>longpage</name><operator>-&gt;</operator><name>xlp_xlog_blcksz</name></name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/* Insert the initial checkpoint record */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name>SizeOfXLogLongPHD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <operator>(</operator><name>XLogRecord</name> <operator>*</operator><operator>)</operator> <name>recptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_prev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>=</operator> <name>SizeOfXLogRecord</name> <operator>+</operator> <name>SizeOfXLogRecordDataHeaderShort</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_info</name></name> <operator>=</operator> <name>XLOG_CHECKPOINT_SHUTDOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_rmid</name></name> <operator>=</operator> <name>RM_XLOG_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>SizeOfXLogRecord</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>recptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>XLR_BLOCK_ID_DATA_SHORT</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>recptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name></name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator> <operator>+</operator> <name>SizeOfXLogRecord</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>SizeOfXLogRecord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>XLogRecord</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>crc</name></expr>;</expr_stmt>

	<comment type="block">/* Write the first page */</comment>
	<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ControlFile</name><operator>.</operator><name>checkPointCopy</name><operator>.</operator><name>ThisTimeLineID</name></name></expr></argument>,
				 <argument><expr><name>newXlogSegNo</name></expr></argument>, <argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
			  <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not open file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fill the rest of the file with zeroes */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nbytes</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</init> <condition><expr><name>nbytes</name> <operator>&lt;</operator> <name>WalSegSz</name></expr>;</condition> <incr><expr><name>nbytes</name> <operator>+=</operator> <name>XLOG_BLCKSZ</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XLOG_BLCKSZ</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: could not write file \"%s\": %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: fsync error: %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s resets the PostgreSQL write-ahead log.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n  %s [OPTION]... DATADIR\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --commit-timestamp-ids=XID,XID\n"</literal>
			 <literal type="string">"                                 set oldest and newest transactions bearing\n"</literal>
			 <literal type="string">"                                 commit timestamp (zero means no change)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" [-D, --pgdata=]DATADIR          data directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -e, --epoch=XIDEPOCH           set next transaction ID epoch\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --force                    force update to be done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -l, --next-wal-file=WALFILE    set minimum starting location for new WAL\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -m, --multixact-ids=MXID,MXID  set next and oldest multitransaction ID\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --dry-run                  no update, just show what would be done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o, --next-oid=OID             set next OID\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -O, --multixact-offset=OFFSET  set next multitransaction offset\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version                  output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -x, --next-transaction-id=XID  set next transaction ID\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"      --wal-segsize=SIZE         size of WAL segments, in megabytes\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                     show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nReport bugs to &lt;pgsql-bugs@postgresql.org&gt;.\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
