<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/pg_dump/pg_dump.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_dump.c
 *	  pg_dump is a utility for dumping out a postgres database
 *	  into a script file.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	pg_dump will read the system catalogs in a database and dump out a
 *	script that reproduces the schema in terms of SQL that is understood
 *	by PostgreSQL
 *
 *	Note that pg_dump runs in a transaction-snapshot mode transaction,
 *	so it sees a consistent snapshot of the database including system
 *	catalogs. However, it relies in part on various specialized backend
 *	functions like pg_get_indexdef(), and those things tend to look at
 *	the currently committed state.  So it is possible to get 'cache
 *	lookup failed' error if someone performs DDL changes while a dump is
 *	happening. The window for this sort of thing is from the acquisition
 *	of the transaction snapshot to getSchemaData() (when pg_dump acquires
 *	AccessShareLock on every table it intends to dump). It isn't very large,
 *	but it can happen.
 *
 *	http://archives.postgresql.org/pgsql-bugs/2010-02/msg00187.php
 *
 * IDENTIFICATION
 *	  src/bin/pg_dump/pg_dump.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TERMIOS_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;termios.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"getopt_long.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-fs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dumputils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_dump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pg_typedefs.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name></decl>;</decl_stmt>			<comment type="block">/* comment for an object */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classoid</name></decl>;</decl_stmt>		<comment type="block">/* object class (catalog OID) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>objoid</name></decl>;</decl_stmt>			<comment type="block">/* object OID */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name></decl>;</decl_stmt>		<comment type="block">/* subobject (table column #) */</comment>
}</block></struct></type> <name>CommentItem</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>provider</name></decl>;</decl_stmt>		<comment type="block">/* label provider of this security label */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>			<comment type="block">/* security label for an object */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classoid</name></decl>;</decl_stmt>		<comment type="block">/* object class (catalog OID) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>objoid</name></decl>;</decl_stmt>			<comment type="block">/* object OID */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name></decl>;</decl_stmt>		<comment type="block">/* subobject (table column #) */</comment>
}</block></struct></type> <name>SecLabelItem</name>;</typedef>

<typedef>typedef <type><enum>enum <name>OidOptions</name>
<block>{
	<decl><name>zeroAsOpaque</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>zeroAsAny</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
	<decl><name>zeroAsStar</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
	<decl><name>zeroAsNone</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>
}</block></enum></type> <name>OidOptions</name>;</typedef>

<comment type="block">/* global decls */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>g_verbose</name></decl>;</decl_stmt>			<comment type="block">/* User wants verbose narration of our
								 * activities. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>dosync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* Issue fsync() to make dump durable on disk. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pg_tablegroup_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pg_yb_tablegroup_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Array of pointers to extensions having configuration tables.
 * Used to update pg_extension catalog tables.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExtensionInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>yb_dumpable_extensions_with_config_relations</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Number of extensions in array: yb_dumpable_extensions_with_config_relations. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>yb_num_dumpable_extensions_with_config_relations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* subquery used to convert user ID (eg, datdba) to user name */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username_subquery</name></decl>;</decl_stmt>

<comment type="block">/*
 * For 8.0 and earlier servers, pulled from pg_database, for 8.1+ we use
 * FirstNormalObjectId - 1.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>g_last_builtin_oid</name></decl>;</decl_stmt> <comment type="block">/* value of the last builtin oid */</comment>

<comment type="block">/* The specified names/patterns should to match at least one entity */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>strict_names</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Object inclusion/exclusion lists
 *
 * The string lists record the patterns given by command-line switches,
 * which we then convert to lists of OIDs of matching objects.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>schema_include_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>schema_include_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>schema_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>schema_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>table_include_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>table_include_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>table_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>table_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type> <name>tabledata_exclude_patterns</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleOidList</name></type> <name>tabledata_exclude_oids</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char</name></type>		<name><name>g_opaque_type</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* name for the opaque type */</comment>

<comment type="block">/* placeholders for the delimiters for comments */</comment>
<decl_stmt><decl><type><name>char</name></type>		<name><name>g_comment_start</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type>		<name><name>g_comment_end</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>CatalogId</name></type> <name>nilCatalogId</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Macro for producing quoted, schema-qualified name of a dumpable object.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fmtQualifiedDumpable</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>fmtQualifiedId((obj)-&gt;dobj.namespace-&gt;dobj.name, \
				   (obj)-&gt;dobj.name)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_connection</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>use_role</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArchiveFormat</name></type> <name>parseArchiveFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_schema_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
							<parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_table_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						   <parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
						   <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type><name>findNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nsoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>refreshMatViewData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>guessConstraintInheritance</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>findComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
			 <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>collectComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>findSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
			  <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>collectSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDumpableObject</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nspinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpExtension</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpBaseType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEnumType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpRangeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpUndefinedType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDomain</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCompositeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCompositeTypeColComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpShellType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpProcLang</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpFunc</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCast</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTransform</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TransformInfo</name> <modifier>*</modifier></type><name>transform</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpr</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OprInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAccessMethod</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpclass</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpOpfamily</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpCollation</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CollInfo</name> <modifier>*</modifier></type><name>collinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpConversion</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConvInfo</name> <modifier>*</modifier></type><name>convinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpRule</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>RuleInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAgg</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEventTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableSchema</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTablegroup</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TablegroupInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpAttrDef</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>adinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSequence</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSequenceData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpIndex</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>IndxInfo</name> <modifier>*</modifier></type><name>indxinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpIndexAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpStatisticsExt</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpConstraint</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTableConstraintComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSParser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSDictionary</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSTemplate</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpTSConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpForeignDataWrapper</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>FdwInfo</name> <modifier>*</modifier></type><name>fdwinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpForeignServer</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpUserMappings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>servername</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDefaultACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CatalogId</name></type> <name>objCatId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>objDumpId</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>racls</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initacls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initracls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildArchiveDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findDumpableDependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
						 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nDeps</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>allocDeps</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>createBoundaryObjects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addBoundaryDependencies</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
						<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getDomainConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getTableData</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>makeTableDataInfo</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>buildMatViewRefreshDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getTableDataFKConstraints</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_function_arguments</name><parameter_list>(<parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcargs</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_agg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_function_arguments_old</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							  <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>format_function_signature</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						  <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convertRegProcReference</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getFormattedOperatorName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oproid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convertTSFunction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findLastBuiltinOid_V71</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getFormattedTypeName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>OidOptions</name></type> <name>opts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BlobInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>dumpBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPolicy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPublication</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpPublicationTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSubscription</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>  <name>getDatabaseOid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpDatabaseConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>outbuf</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEncoding</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpStdStrings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSearchPath</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_type_oids_by_type_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>pg_type_oid</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>force_array_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>binary_upgrade_set_type_oids_by_rel_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>pg_rel_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_set_pg_class_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
								 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>pg_class_oid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>binary_upgrade_extension_member</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objnamespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getAttrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrnum</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmtCopyColumnList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>nonemptyReloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>YbAppendReloptions2</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline_before</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1_prefix</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2_prefix</name></decl></parameter>,
						<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>YbAppendReloptions3</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline_before</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1_prefix</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2_prefix</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions3_prefix</name></decl></parameter>,
						<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendReloptionsArrayAH</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_synchronized_snapshot</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setupDumpWorker</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AHX</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>getRootTableInfo</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>catalogTableExists</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getYbTablePropertiesAndReloptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						<parameter><decl><type><name>YbTableProperties</name></type> <name>properties</name></decl></parameter>,
						<parameter><decl><type><name>PQExpBuffer</name></type> <name>reloptions_buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>relname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isDatabaseColocated</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getYbSplitClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ybDumpUpdatePgExtensionCatalog</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><literal type="string">"p"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>optindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestoreOptions</name> <modifier>*</modifier></type><name>ropt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Archive</name>    <modifier>*</modifier></type><name>fout</name></decl>;</decl_stmt>			<comment type="block">/* the script file */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>use_role</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numWorkers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>compressLevel</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plainText</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArchiveFormat</name></type> <name>archiveFormat</name> <init>= <expr><name>archUnknown</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArchiveMode</name></type> <name>archiveMode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>DumpOptions</name></type> <name>dopt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>no_serializable_deferrable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>long_options</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"data-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"blobs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'b'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-blobs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'B'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"clean"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"create"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"dbname"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'f'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"host"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"jobs"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-reconnect"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"oids"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-owner"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"schema"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-schema"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"schema-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"superuser"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"table"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-table"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'T'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"password"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"username"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'U'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-privileges"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-acl"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"compress"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'Z'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"encoding"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'E'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'?'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"masters"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'m'</literal></expr>}</block></expr>,

		<comment type="block">/*
		 * the following options don't have an equivalent short option letter
		 */</comment>
		<expr><block>{<expr><literal type="string">"attribute-inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"binary-upgrade"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"column-inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"disable-dollar-quoting"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>disable_dollar_quoting</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"disable-triggers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>disable_triggers</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"enable-row-security"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>enable_row_security</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"exclude-table-data"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"if-exists"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>if_exists</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"inserts"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"lock-wait-timeout"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-tablespaces"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>outputNoTablespaces</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"quote-all-identifiers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>quote_all_identifiers</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"load-via-partition-root"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>load_via_partition_root</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"role"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"serializable-deferrable"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>serializable_deferrable</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-serializable-deferrable"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>no_serializable_deferrable</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"snapshot"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"strict-names"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name>strict_names</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"use-set-session-authorization"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>use_setsessauth</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-comments"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_comments</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-publications"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_publications</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-security-labels"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-synchronized-snapshots"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_synchronized_snapshots</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-unlogged-table-data"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_unlogged_table_data</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-subscriptions"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_subscriptions</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-sync"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-tablegroups"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_tablegroups</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"no-tablegroup-creations"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>no_tablegroup_creations</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="string">"include-yb-metadata"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>include_yb_metadata</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"ysql_dump"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize what we need for parallel execution, especially for thread
	 * support on Windows.
	 */</comment>
	<expr_stmt><expr><call><name>init_parallel_dump_utils</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>g_verbose</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>g_comment_start</name></expr></argument>, <argument><expr><literal type="string">"-- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g_comment_end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>g_opaque_type</name></expr></argument>, <argument><expr><literal type="string">"opaque"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>help</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"ysql_dump (YSQL) "</literal> <name>PG_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>InitDumpOptions</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"abBcCd:E:f:F:h:j:m:n:N:oOp:RsS:t:T:U:vwWxZ:"</literal></expr></argument>,
							<argument><expr><name>long_options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>			<comment type="block">/* Dump data only */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'b'</literal></expr>:</case>			<comment type="block">/* Dump blobs */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'B'</literal></expr>:</case>			<comment type="block">/* Don't dump blobs */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dontOutputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'c'</literal></expr>:</case>			<comment type="block">/* clean (i.e., drop) schema prior to create */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputClean</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'C'</literal></expr>:</case>			<comment type="block">/* Create DB */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'d'</literal></expr>:</case>			<comment type="block">/* database name */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'E'</literal></expr>:</case>			<comment type="block">/* Dump encoding */</comment>
				<expr_stmt><expr><name>dumpencoding</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><name>format</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'h'</literal></expr>:</case>			<comment type="block">/* server host */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'j'</literal></expr>:</case>			<comment type="block">/* number of dump jobs */</comment>
				<expr_stmt><expr><name>numWorkers</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'m'</literal></expr>:</case>			<comment type="block">/* DEPRECATED and NOT USED: YB master hosts */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>master_hosts</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'n'</literal></expr>:</case>			<comment type="block">/* include schema(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_include_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'N'</literal></expr>:</case>			<comment type="block">/* exclude schema(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'o'</literal></expr>:</case>			<comment type="block">/* Dump oids */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>oids</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'O'</literal></expr>:</case>			<comment type="block">/* Don't reconnect to match owner */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputNoOwner</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'p'</literal></expr>:</case>			<comment type="block">/* server port */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pgport</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<comment type="block">/* no-op, still accepted for backwards compatibility */</comment>
				<break>break;</break>

			<case>case <expr><literal type="char">'s'</literal></expr>:</case>			<comment type="block">/* dump schema only */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'S'</literal></expr>:</case>			<comment type="block">/* Username for superuser in plain text output */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputSuperuser</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'t'</literal></expr>:</case>			<comment type="block">/* include table(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'T'</literal></expr>:</case>			<comment type="block">/* exclude table(s) */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>username</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'v'</literal></expr>:</case>			<comment type="block">/* verbose */</comment>
				<expr_stmt><expr><name>g_verbose</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'w'</literal></expr>:</case>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name>TRI_NO</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'W'</literal></expr>:</case>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name>TRI_YES</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'x'</literal></expr>:</case>			<comment type="block">/* skip ACL dump */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>aclsSkip</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="char">'Z'</literal></expr>:</case>			<comment type="block">/* Compression Level */</comment>
				<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>compressLevel</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>compressLevel</name></expr></argument> &gt;</argument_list></name> <literal type="number">9</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"compression level must be in range 0..9\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<comment type="block">/* This covers the long options. */</comment>
				<break>break;</break>

			<case>case <expr><literal type="number">2</literal></expr>:</case>				<comment type="block">/* lock-wait-timeout */</comment>
				<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>lockWaitTimeout</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">3</literal></expr>:</case>				<comment type="block">/* SET ROLE */</comment>
				<expr_stmt><expr><name>use_role</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">4</literal></expr>:</case>				<comment type="block">/* exclude table(s) data */</comment>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tabledata_exclude_patterns</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">5</literal></expr>:</case>				<comment type="block">/* section */</comment>
				<expr_stmt><expr><call><name>set_dump_section</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>dumpSections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">6</literal></expr>:</case>				<comment type="block">/* snapshot */</comment>
				<expr_stmt><expr><name>dumpsnapshot</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><literal type="number">7</literal></expr>:</case>				<comment type="block">/* no-sync */</comment>
				<expr_stmt><expr><name>dosync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<comment type="block">/* Enable by default serializable-deferrable mode if it's not explicitly disabled. */</comment>
	<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>serializable_deferrable</name></name> <operator>=</operator> <ternary><condition><expr><name>no_serializable_deferrable</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Non-option argument specifies database name as long as it wasn't
	 * already specified with -d / --dbname
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>dbname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Complain if any arguments remain */</comment>
	<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: too many command-line arguments (first is \"%s\")\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* --column-inserts implies --inserts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Binary upgrade mode implies dumping sequence data even in schema-only
	 * mode.  This is not exposed as a separate option, but kept separate
	 * internally for clarity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>.</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>sequence_data</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"options -s/--schema-only and -a/--data-only cannot be used together\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"options -c/--clean and -a/--data-only cannot be used together\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>oids</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: INSERT command cannot set OIDs: you won't be able to apply the dump!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"if you still want to dump inserts with OIDs, use --column-inserts\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>if_exists</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"option --if-exists requires option -c/--clean\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Identify archive format to emit */</comment>
	<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <call><name>parseArchiveFormat</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>archiveMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* archiveFormat specific setup */</comment>
	<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>==</operator> <name>archNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plainText</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Custom and directory formats are compressed by default, others not */</comment>
	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>==</operator> <name>archCustom</name> <operator>||</operator> <name>archiveFormat</name> <operator>==</operator> <name>archDirectory</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: requested compression not available in this "</literal>
				  <literal type="string">"installation -- archive will be uncompressed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>compressLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If emitting an archive format, we always want to emit a DATABASE item,
	 * in case --create is specified at pg_restore time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On Windows we can only have at most MAXIMUM_WAIT_OBJECTS (= 64 usually)
	 * parallel jobs because that's the maximum limit for the
	 * WaitForMultipleObjects() call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numWorkers</name> <operator>&lt;=</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<operator>||</operator> <name>numWorkers</name> <operator>&gt;</operator> <name>MAXIMUM_WAIT_OBJECTS</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid number of parallel jobs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Parallel backup only in the directory archive format so far */</comment>
	<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>!=</operator> <name>archDirectory</name> <operator>&amp;&amp;</operator> <name>numWorkers</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"parallel backup only supported by the directory format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Open the output file */</comment>
	<expr_stmt><expr><name>fout</name> <operator>=</operator> <call><name>CreateArchive</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>archiveFormat</name></expr></argument>, <argument><expr><name>compressLevel</name></expr></argument>, <argument><expr><name>dosync</name></expr></argument>,
						 <argument><expr><name>archiveMode</name></expr></argument>, <argument><expr><name>setupDumpWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make dump options accessible right away */</comment>
	<expr_stmt><expr><call><name>SetArchiveOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Register the cleanup hook */</comment>
	<expr_stmt><expr><call><name>on_exit_close_archive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let the archiver know how noisy to be */</comment>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>g_verbose</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We allow the server to be back to 8.0, and up to any minor release of
	 * our own major version.  (See also version check in pg_dumpall.c.)
	 */</comment>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>minRemoteVersion</name></name> <operator>=</operator> <literal type="number">80000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>maxRemoteVersion</name></name> <operator>=</operator> <operator>(</operator><name>PG_VERSION_NUM</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">99</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fout</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>=</operator> <name>numWorkers</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name></name> <operator>=</operator> <name>DefaultHost</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * DEPRECATED: Custom YB-Master host/port to use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>master_hosts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: ignoring the deprecated argument --masters (-m)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Open the database using the Archiver, so it knows about it. Errors mean
	 * death.
	 */</comment>
	<expr_stmt><expr><call><name>ConnectDatabase</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dopt</name><operator>.</operator><name>cparams</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setup_connection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dumpencoding</name></expr></argument>, <argument><expr><name>dumpsnapshot</name></expr></argument>, <argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Disable security label support if server version &lt; v9.1.x (prevents
	 * access to nonexistent pg_seclabel catalog)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On hot standbys, never try to dump unlogged table data, since it will
	 * just throw an error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>isStandby</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>no_unlogged_table_data</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Select the appropriate subquery to convert user IDs to names */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>username_subquery</name> <operator>=</operator> <literal type="string">"SELECT rolname FROM pg_catalog.pg_roles WHERE oid ="</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>username_subquery</name> <operator>=</operator> <literal type="string">"SELECT usename FROM pg_catalog.pg_user WHERE usesysid ="</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* check the version for the synchronized snapshots feature */</comment>
	<if_stmt><if>if <condition>(<expr><name>numWorkers</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90200</literal>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>no_synchronized_snapshots</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">"Synchronized snapshots are not supported by this server version.\n"</literal>
					  <literal type="string">"Run with --no-synchronized-snapshots instead if you do not need\n"</literal>
					  <literal type="string">"synchronized snapshots.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check the version when a snapshot is explicitly specified by user */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpsnapshot</name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">"Exported snapshots are not supported by this server version.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the last built-in OID, if needed (prior to 8.1)
	 *
	 * With 8.1 and above, we can just use FirstNormalObjectId - 1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>g_last_builtin_oid</name> <operator>=</operator> <call><name>findLastBuiltinOid_V71</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>g_last_builtin_oid</name> <operator>=</operator> <name>FirstNormalObjectId</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"last built-in OID is %u\n"</literal></expr></argument>, <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Expand schema selection patterns into OID lists */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>schema_include_patterns</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expand_schema_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_include_patterns</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>schema_include_oids</name></expr></argument>,
									<argument><expr><name>strict_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>schema_include_oids</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"no matching schemas were found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>expand_schema_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schema_exclude_patterns</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* non-matching exclusion patterns aren't an error */</comment>

	<comment type="block">/* Expand table selection patterns into OID lists */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_patterns</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_include_patterns</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
								   <argument><expr><name>strict_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"no matching tables were found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>table_exclude_patterns</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expand_table_name_patterns</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabledata_exclude_patterns</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>tabledata_exclude_oids</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* non-matching exclusion patterns aren't an error */</comment>

	<comment type="block">/*
	 * Dumping blobs is the default for dumps where an inclusion switch is not
	 * used (an "include everything" dump).  -B can be used to exclude blobs
	 * from those dumps.  -b can be used to include blobs even when an
	 * inclusion switch is used.
	 *
	 * -s means "schema only" and blobs are data, not schema, so we never
	 * include blobs when -s is used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>include_everything</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>.</operator><name>dontOutputBlobs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Update pg_tablegroup existence variables */</comment>
	<expr_stmt><expr><name>pg_yb_tablegroup_exists</name> <operator>=</operator> <call><name>catalogTableExists</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"pg_yb_tablegroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_tablegroup_exists</name> <operator>=</operator> <call><name>catalogTableExists</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"pg_tablegroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the database and create DumpableObject structs for all the
	 * objects we intend to dump.
	 */</comment>
	<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <call><name>getSchemaData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>guessConstraintInheritance</name><argument_list>(<argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>getTableData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>oids</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>buildMatViewRefreshDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getTableDataFKConstraints</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>.</operator><name>sequence_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getTableData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>.</operator><name>oids</name></name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In binary-upgrade mode, we do not have to worry about the actual blob
	 * data or the associated metadata that resides in the pg_largeobject and
	 * pg_largeobject_metadata tables, respectively.
	 *
	 * However, we do need to collect blob information as there may be
	 * comments or other information on blobs that we do need to dump out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>outputBlobs</name></name> <operator>||</operator> <name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getBlobs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Collect dependency data to assist in ordering the objects.
	 */</comment>
	<expr_stmt><expr><call><name>getDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lastly, create dummy objects to represent the section boundaries */</comment>
	<expr_stmt><expr><name>boundaryObjs</name> <operator>=</operator> <call><name>createBoundaryObjects</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get pointers to all the known DumpableObjects */</comment>
	<expr_stmt><expr><call><name>getDumpableObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dobjs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add dummy dependencies to enforce the dump section ordering.
	 */</comment>
	<expr_stmt><expr><call><name>addBoundaryDependencies</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><name>boundaryObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort the objects into a safe dump order (no forward references).
	 *
	 * We rely on dependency information to help us determine a safe order, so
	 * the initial sort is mostly for cosmetic purposes: we sort by name to
	 * ensure that logically identical schemas will dump identically.
	 */</comment>
	<expr_stmt><expr><call><name>sortDumpableObjectsByTypeName</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we do a parallel dump, we want the largest tables to go first */</comment>
	<if_stmt><if>if <condition>(<expr><name>archiveFormat</name> <operator>==</operator> <name>archDirectory</name> <operator>&amp;&amp;</operator> <name>numWorkers</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sortDataAndIndexObjectsBySize</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>sortDumpableObjects</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>,
						<argument><expr><name><name>boundaryObjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dumpId</name></expr></argument>, <argument><expr><name><name>boundaryObjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create archive TOC entries for all the objects to be dumped, in a safe
	 * order.
	 */</comment>

	<comment type="block">/* First the special ENCODING, STDSTRINGS, and SEARCHPATH entries. */</comment>
	<expr_stmt><expr><call><name>dumpEncoding</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpStdStrings</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumpSearchPath</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The database items are always next, unless we don't want them at all */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpDatabase</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dopt</name><operator>.</operator><name>db_oid</name></name> <operator>=</operator> <call><name>getDatabaseOid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now the rearrangeable objects. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpDumpableObject</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Add UPDATE Statement to update pg_extension catalog. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>.</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
		<name>yb_num_dumpable_extensions_with_config_relations</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ybDumpUpdatePgExtensionCatalog</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up options info to ensure we dump what we want.
	 */</comment>
	<expr_stmt><expr><name>ropt</name> <operator>=</operator> <call><name>NewRestoreOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>

	<comment type="block">/* if you change this list, see dumpOptionsFromRestoreOptions */</comment>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>dbname</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>dbname</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>dbname</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pgport</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pgport</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pgport</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>pghost</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>pghost</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>username</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>username</name></name></expr> ?</condition><then> <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>username</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>cparams</name><operator>.</operator><name>promptPassword</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dropSchema</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputClean</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dataOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>schemaOnly</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>if_exists</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>if_exists</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>column_inserts</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>column_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dumpSections</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dumpSections</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>aclsSkip</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>aclsSkip</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>superuser</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputSuperuser</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>createDB</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputCreateDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>noOwner</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputNoOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>noTablespace</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>outputNoTablespaces</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>disable_triggers</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>disable_triggers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>use_setsessauth</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>use_setsessauth</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>disable_dollar_quoting</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>dump_inserts</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>dump_inserts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_comments</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_comments</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_publications</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_security_labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>no_subscriptions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>lockWaitTimeout</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>include_everything</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>include_everything</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>enable_row_security</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>enable_row_security</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>sequence_data</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>sequence_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>=</operator> <name><name>dopt</name><operator>.</operator><name>binary_upgrade</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>compressLevel</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>compressLevel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ropt</name><operator>-&gt;</operator><name>suppressDumpWarnings</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* We've already shown them */</comment>

	<expr_stmt><expr><call><name>SetArchiveOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dopt</name></expr></argument>, <argument><expr><name>ropt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark which entries should be output */</comment>
	<expr_stmt><expr><call><name>ProcessArchiveRestoreOptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The archive's TOC entries are now marked as to which ones will actually
	 * be output, so we can set up their dependency lists properly. This isn't
	 * necessary for plain-text output, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BuildArchiveDependencies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * And finally we can do the actual output.
	 *
	 * Note: for non-plain-text output formats, the output file is written
	 * inside CloseArchive().  This is, um, bizarre; but not worth changing
	 * right now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plainText</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RestoreArchive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseArchive</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s dumps a database as a text file or to other formats.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nGeneral options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -f, --file=FILENAME          output file or directory name\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -F, --format=c|d|t|p         output file format (custom, directory, tar,\n"</literal>
			 <literal type="string">"                               plain text (default))\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -j, --jobs=NUM               use this many parallel jobs to dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -v, --verbose                verbose mode\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -V, --version                output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -Z, --compress=0-9           compression level for compressed formats\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --lock-wait-timeout=TIMEOUT  fail after waiting TIMEOUT for a table lock\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-sync                    do not wait for changes to be written safely to disk\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -?, --help                   show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nOptions controlling the output content:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -a, --data-only              dump only the data, not the schema\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -b, --blobs                  include large objects in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -B, --no-blobs               exclude large objects in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -c, --clean                  clean (drop) database objects before recreating\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -C, --create                 include commands to create database in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -E, --encoding=ENCODING      dump the data in encoding ENCODING\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -n, --schema=SCHEMA          dump the named schema(s) only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -N, --exclude-schema=SCHEMA  do NOT dump the named schema(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -o, --oids                   include OIDs in dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -O, --no-owner               skip restoration of object ownership in\n"</literal>
			 <literal type="string">"                               plain-text format\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -s, --schema-only            dump only the schema, no data\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -S, --superuser=NAME         superuser user name to use in plain-text format\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -t, --table=TABLE            dump the named table(s) only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -T, --exclude-table=TABLE    do NOT dump the named table(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -x, --no-privileges          do not dump privileges (grant/revoke)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --binary-upgrade             for use by upgrade utilities only\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --column-inserts             dump data as INSERT commands with column names\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --disable-dollar-quoting     disable dollar quoting, use SQL standard quoting\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --disable-triggers           disable triggers during data-only restore\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --enable-row-security        enable row security (dump only content user has\n"</literal>
			 <literal type="string">"                               access to)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --exclude-table-data=TABLE   do NOT dump data for the named table(s)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --if-exists                  use IF EXISTS when dropping objects\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --inserts                    dump data as INSERT commands, rather than COPY\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --include-yb-metadata        include Yugabyte-specific metadata, uses extended\n"</literal>
			 <literal type="string">"                               YSQL syntax not compatible with PostgreSQL.\n"</literal>
			 <literal type="string">"                               (As of now, doesn't automatically include some things\n"</literal>
			 <literal type="string">"                               like SPLIT details).\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --load-via-partition-root    load partitions via the root table\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-comments                do not dump comments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-publications            do not dump publications\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-security-labels         do not dump security label assignments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-subscriptions           do not dump subscriptions\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-synchronized-snapshots  do not use synchronized snapshots in parallel jobs\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-tablespaces             do not dump tablespace assignments\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-tablegroups             do not dump tablegroup assignments or creations\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-tablegroup-creations    do not dump tablegroup creations\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-unlogged-table-data     do not dump unlogged table data\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --quote-all-identifiers      quote all identifiers, even if not key words\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --section=SECTION            dump named section (pre-data, data, or post-data)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --serializable-deferrable    wait until the dump can run without anomalies\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --no-serializable-deferrable disable serializable-deferrable mode\n"</literal>
			 <literal type="string">"                               which is enabled by default\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --snapshot=SNAPSHOT          use given snapshot for the dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --strict-names               require table and/or schema include patterns to\n"</literal>
			 <literal type="string">"                               match at least one entity each\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --use-set-session-authorization\n"</literal>
			 <literal type="string">"                               use SET SESSION AUTHORIZATION commands instead of\n"</literal>
			 <literal type="string">"                               ALTER OWNER commands to set ownership\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=DBNAME      database to dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME      database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT          database server port number\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=NAME      connect as specified database user\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password        never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -W, --password           force password prompt (should happen automatically)\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  --role=ROLENAME          do SET ROLE before dump\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"  -m, --masters=HOST:PORT  DEPRECATED and NOT USED\n"</literal>
			 <literal type="string">"                           comma-separated list of YB-Master hosts and ports\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\nIf no database name is supplied, then the PGDATABASE environment\n"</literal>
			 <literal type="string">"variable value is used.\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Report bugs on https://github.com/YugaByte/yugabyte-db/issues/new\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_connection</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpencoding</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dumpsnapshot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>use_role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>AH</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>std_strings</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the client encoding if requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpencoding</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQsetClientEncoding</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>dumpencoding</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid client encoding \"%s\" specified\n"</literal></expr></argument>,
						  <argument><expr><name>dumpencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the active encoding and the standard_conforming_strings setting, so
	 * we know how to escape strings.
	 */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <call><name>PQclientEncoding</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>std_strings</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"standard_conforming_strings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>std_strings</name></name> <operator>=</operator> <operator>(</operator><name>std_strings</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>std_strings</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the role if requested.  In a parallel dump worker, we'll be passed
	 * use_role == NULL, but AH-&gt;use_role is already set (if user specified it
	 * originally) and we should use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_role</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>use_role</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set the role if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_role</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET ROLE %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save it for possible later use by parallel workers */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>use_role</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>use_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set the datestyle to ISO to ensure the dump's portability */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET DATESTYLE = ISO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Likewise, avoid using sql_standard intervalstyle */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET INTERVALSTYLE = POSTGRES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set extra_float_digits so that we can dump float data exactly (given
	 * correctly implemented float I/O code, anyway)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits TO 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET extra_float_digits TO 2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If synchronized scanning is supported, disable it, to prevent
	 * unpredictable changes in row ordering across a dump and reload.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET synchronize_seqscans TO off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Disable timeouts if supported.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET lock_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET idle_in_transaction_session_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Quote all identifiers, if requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>quote_all_identifiers</name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET quote_all_identifiers = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust row-security mode, if supported.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>enable_row_security</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET row_security = off"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET yb_format_funcs_include_yb_metadata = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Hack to avoid issue #12251 which fails if we perform "BEGIN" followed by
	 * "SET TRANSACTION ISOLATION LEVEL" when yb_enable_read_committed_isolation
	 * is true.
	 *
	 * TODO(Piyush): Remove this hack once the issue is fixed properly
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"SET DEFAULT_TRANSACTION_ISOLATION TO 'repeatable read'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start transaction-snapshot mode transaction to dump consistent data.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To support the combination of serializable_deferrable with the jobs
		 * option we use REPEATABLE READ for the worker connections that are
		 * passed a snapshot.  As long as the snapshot is acquired in a
		 * SERIALIZABLE, READ ONLY, DEFERRABLE transaction, its use within a
		 * REPEATABLE READ transaction provides the appropriate integrity
		 * guarantees.  This is a kluge, but safe for back-patching.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>serializable_deferrable</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
								<literal type="string">"SERIALIZABLE, READ ONLY, DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
								<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
								<literal type="string">"REPEATABLE READ, READ ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
							<argument><expr><literal type="string">"SET TRANSACTION ISOLATION LEVEL "</literal>
							<literal type="string">"SERIALIZABLE, READ ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If user specified a snapshot to use, select that.  In a parallel dump
	 * worker, we'll be passed dumpsnapshot == NULL, but AH-&gt;sync_snapshot_id
	 * is already set (if the server can handle it) and we should use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dumpsnapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>dumpsnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION SNAPSHOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>numWorkers</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal> <operator>&amp;&amp;</operator>
			 <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_synchronized_snapshots</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>isStandby</name></name> <operator>&amp;&amp;</operator> <name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"Synchronized snapshots on standby servers are not supported by this server version.\n"</literal>
						  <literal type="string">"Run with --no-synchronized-snapshots instead if you do not need\n"</literal>
						  <literal type="string">"synchronized snapshots.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


		<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>sync_snapshot_id</name></name> <operator>=</operator> <call><name>get_synchronized_snapshot</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Set up connection for a parallel worker process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupDumpWorker</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We want to re-select all the same values the master connection is
	 * using.  We'll have inherited directly-usable values in
	 * AH-&gt;sync_snapshot_id and AH-&gt;use_role, but we need to translate the
	 * inherited encoding value back to a string to pass to setup_connection.
	 */</comment>
	<expr_stmt><expr><call><name>setup_connection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
					 <argument><expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_synchronized_snapshot</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><literal type="string">"SELECT pg_catalog.pg_export_snapshot()"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ArchiveFormat</name></type>
<name>parseArchiveFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>ArchiveMode</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveFormat</name></type> <name>archiveFormat</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>mode</name> <operator>=</operator> <name>archModeWrite</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This is used by pg_dumpall, and is not documented */</comment>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>mode</name> <operator>=</operator> <name>archModeAppend</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archCustom</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"custom"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archCustom</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"directory"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archDirectory</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archNull</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="string">"tar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>archiveFormat</name> <operator>=</operator> <name>archTar</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid output format \"%s\" specified\n"</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>archiveFormat</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the OIDs of all schemas matching the given list of patterns,
 * and append them to the given OID list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_schema_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>,
							<parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The loop below runs multiple SELECTs might sometimes result in
	 * duplicate entries in the OID list, but we don't care.
	 */</comment>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>patterns</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT oid FROM pg_catalog.pg_namespace n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strict_names</name> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"no matching schemas were found for pattern \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the OIDs of all tables matching the given list of patterns,
 * and append them to the given OID list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_table_name_patterns</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
						   <parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>patterns</name></decl></parameter>, <parameter><decl><type><name>SimpleOidList</name> <modifier>*</modifier></type><name>oids</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>strict_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * this might sometimes result in duplicate entries in the OID list, but
	 * we don't care.
	 */</comment>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>patterns</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Query must remain ABSOLUTELY devoid of unqualified names.  This
		 * would be unnecessary given a pg_table_is_visible() variant taking a
		 * search_path argument.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.oid"</literal>
						  <literal type="string">"\nFROM pg_catalog.pg_class c"</literal>
						  <literal type="string">"\n     LEFT JOIN pg_catalog.pg_namespace n"</literal>
						  <literal type="string">"\n     ON n.oid OPERATOR(pg_catalog.=) c.relnamespace"</literal>
						  <literal type="string">"\nWHERE c.relkind OPERATOR(pg_catalog.=) ANY"</literal>
						  <literal type="string">"\n    (array['%c', '%c', '%c', '%c', '%c', '%c'])\n"</literal></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
						  <argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>processSQLNamePattern</name><argument_list>(<argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"n.nspname"</literal></expr></argument>, <argument><expr><literal type="string">"c.relname"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"pg_catalog.pg_table_is_visible(c.oid)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"RESET search_path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
											<argument><expr><name>ALWAYS_SECURE_SEARCH_PATH_SQL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strict_names</name> <operator>&amp;&amp;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"no matching tables were found for pattern \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>simple_oid_list_append</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkExtensionMembership
 *		Determine whether object is an extension member, and if so,
 *		record an appropriate dependency and set the object's dump flag.
 *
 * It's important to call this for each object that could be an extension
 * member.  Generally, we integrate this with determining the object's
 * to-be-dumped-ness, since extension membership overrides other rules for that.
 *
 * Returns true if object is an extension member, else false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkExtensionMembership</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>ext</name> <init>= <expr><call><name>findOwningExtension</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>catId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>ext_member</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Record dependency so that getDependencies needn't deal with that */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In 9.6 and above, mark the member object to have any non-initial ACL,
	 * policies, and security labels dumped.
	 *
	 * Note that any initial ACLs (see pg_init_privs) will be removed when we
	 * extract the information about the object.  We don't provide support for
	 * initial policies and security labels and it seems unlikely for those to
	 * ever exist, but we may have to revisit this later.
	 *
	 * Prior to 9.6, we do not include any extension member components.
	 *
	 * In binary upgrades, we still dump all components of the members
	 * individually, since the idea is to exactly reproduce the database
	 * contents rather than replace the extension contents with something
	 * different.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>&amp;</operator> <operator>(</operator><name>DUMP_COMPONENT_ACL</name> <operator>|</operator>
													<name>DUMP_COMPONENT_SECLABEL</name> <operator>|</operator>
													<name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableNamespace: policy-setting subroutine
 *		Mark a namespace as to be dumped or not
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableNamespace</name><parameter_list>(<parameter><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If specific tables are being dumped, do not dump any complete
	 * namespaces. If specific namespaces are being dumped, dump just those
	 * namespaces. Otherwise, dump all non-system namespaces.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>schema_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator>
			<ternary><condition><expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_include_oids</name></expr></argument>,
								   <argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal> <operator>&amp;&amp;</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In 9.6 and above, we dump out any ACLs defined in pg_catalog, if
		 * they are interesting (and not the original ACLs which were set at
		 * initdb time, see pg_init_privs).
		 */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"pg_"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"information_schema"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Other system schemas don't get dumped */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The public schema is a strange beast that sits in a sort of
		 * no-mans-land between being a system object and a user object.  We
		 * don't want to dump creation or comment commands for it, because
		 * that complicates matters for non-superuser use of pg_dump.  But we
		 * should dump any ACL changes that have occurred for it, and of
		 * course we should dump contained objects.
		 */</comment>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In any case, a namespace can be excluded by an exclusion switch
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>&amp;&amp;</operator>
		<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the schema belongs to an extension, allow extension membership to
	 * override the dump decision for the schema itself.  However, this does
	 * not change dump_contains, so this won't change what we do with objects
	 * within the schema.  (If they belong to the extension, they'll get
	 * suppressed by it, otherwise not.)
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableTable: policy-setting subroutine
 *		Mark a table as to be dumped or not
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableTable</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * If specific tables are being dumped, dump just those tables; else, dump
	 * according to the parent namespace's dump flag.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
												   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In any case, a table can be excluded by an exclusion switch
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;&amp;</operator>
		<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableType: policy-setting subroutine
 *		Mark a type as to be dumped or not
 *
 * If it's a table's rowtype or an autogenerated array type, we also apply a
 * special type code to facilitate sorting into the desired order.  (We don't
 * want to consider those to be ordinary types because that would bring tables
 * up into the datatype part of the dump order.)  We still set the object's
 * dump flag; that's not going to cause the dummy type to be dumped, but we
 * need it so that casts involving such types will be dumped correctly -- see
 * dumpCast.  This means the flag should be set the same as for the underlying
 * object (the table or base type).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableType</name><parameter_list>(<parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* skip complex types, except for standalone composite types */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>tyinfo</name><operator>-&gt;</operator><name>typrelkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tytable</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DUMMY_TYPE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tytable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tytable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* skip auto-generated array types */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>isArray</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DUMMY_TYPE</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fall through to set the dump flag; we assume that the subsequent
		 * rules will do the same thing as they would for the array's base
		 * type.  (We cannot reliably look up the base type here, since
		 * getTypes may not have processed it yet.)
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/* Dump based on if the contents of the namespace are being dumped */</comment>
	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableDefaultACL: policy-setting subroutine
 *		Mark a default ACL as to be dumped or not
 *
 * For per-schema default ACLs, dump if the schema is to be dumped.
 * Otherwise dump if we are dumping "everything".  Note that dataOnly
 * and aclsSkip are checked separately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableDefaultACL</name><parameter_list>(<parameter><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>dinfo</name></decl></parameter>, <parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Default ACLs can't be extension members */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* default ACLs are considered part of the namespace */</comment>
		<expr_stmt><expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableCast: policy-setting subroutine
 *		Mark a cast as to be dumped or not
 *
 * Casts do not belong to any particular namespace (since they haven't got
 * names), nor do they have identifiable owners.  To distinguish user-defined
 * casts from built-in ones, we must resort to checking whether the cast's
 * OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableCast</name><parameter_list>(<parameter><decl><type><name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cast</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * This would be DUMP_COMPONENT_ACL for from-initdb casts, but they do not
	 * support ACLs currently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableProcLang: policy-setting subroutine
 *		Mark a procedural language as to be dumped or not
 *
 * Procedural languages do not belong to any particular namespace.  To
 * identify built-in languages, we must resort to checking whether the
 * language's OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableProcLang</name><parameter_list>(<parameter><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plang</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * Only include procedural languages when we are dumping everything.
	 *
	 * For from-initdb procedural languages, only include ACLs, as we do for
	 * the pg_catalog namespace.  We need this because procedural languages do
	 * not live in any namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr> ?</condition><then>
				<expr><name>DUMP_COMPONENT_NONE</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_ACL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableAccessMethod: policy-setting subroutine
 *		Mark an access method as to be dumped or not
 *
 * Access methods do not belong to any particular namespace.  To identify
 * built-in access methods, we must resort to checking whether the
 * method's OID is in the range reserved for initdb.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableAccessMethod</name><parameter_list>(<parameter><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>method</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>method</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * This would be DUMP_COMPONENT_ACL for from-initdb access methods, but
	 * they do not support ACLs currently.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>method</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableExtension: policy-setting subroutine
 *		Mark an extension as to be dumped or not
 *
 * Built-in extensions should be skipped except for checking ACLs, since we
 * assume those will already be installed in the target database.  We identify
 * such extensions by their having OIDs in the range reserved for initdb.
 * We dump all user-added extensions by default, or none of them if
 * include_everything is false (i.e., a --schema or --table switch was given).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableExtension</name><parameter_list>(<parameter><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>, <parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Use DUMP_COMPONENT_ACL for built-in extensions, to allow users to
	 * change permissions on their member objects, if they wish to, and have
	 * those changes preserved.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>&lt;=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>g_last_builtin_oid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name> <operator>=</operator>
			<ternary><condition><expr><name><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then> <expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>:
			<expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpablePublicationTable: policy-setting subroutine
 *		Mark a publication table as to be dumped or not
 *
 * Publication tables have schemas, but those are ignored in decision making,
 * because publications are only dumped when we are dumping everything.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpablePublicationTable</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
		<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * selectDumpableObject: policy-setting subroutine
 *		Mark a generic dumpable object as to be dumped or not
 *
 * Use this only for object types without a special-case routine above.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selectDumpableObject</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>checkExtensionMembership</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* extension membership overrides all else */</comment>

	<comment type="block">/*
	 * Default policy is to dump if parent namespace is dumpable, or for
	 * non-namespace-associated items, dump if we're dumping "everything".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump_contains</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>include_everything</name></name></expr> ?</condition><then>
			<expr><name>DUMP_COMPONENT_ALL</name></expr> </then><else>: <expr><name>DUMP_COMPONENT_NONE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Dump a table's contents for loading using the COPY command
 *	- this routine is called by the Archiver when it wants the table
 *	  to be dumped.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpTableData_copy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name> <init>= <expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dcontext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>classname</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>	<name>hasoids</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type>	<name>oids</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: can't use getThreadLocalPQExpBuffer() here, we're calling fmtId
	 * which uses it already.
	 */</comment>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>clistBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>column_list</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"dumping contents of table \"%s.%s\"\n"</literal></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Specify the column list explicitly so that we have no possibility of
	 * retrieving data in the wrong column order.  (The default column
	 * ordering of COPY will not be what we want in certain corner cases
	 * involving ADD COLUMN and inheritance.)
	 */</comment>
	<expr_stmt><expr><name>column_list</name> <operator>=</operator> <call><name>fmtCopyColumnList</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oids</name> <operator>&amp;&amp;</operator> <name>hasoids</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COPY %s %s WITH OIDS TO stdout;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>column_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Note: this syntax is only supported in 8.2 and up */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COPY (SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* klugery to get rid of parens in column list */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>column_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>column_list</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>q</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"* "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FROM %s %s) TO stdout;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"COPY %s %s TO stdout;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>column_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_COPY_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copybuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* done or error */</comment>

		<if_stmt><if>if <condition>(<expr><name>copybuf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>copybuf</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>copybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ----------
		 * THROTTLE:
		 *
		 * There was considerable discussion in late July, 2000 regarding
		 * slowing down pg_dump when backing up large tables. Users with both
		 * slow &amp; fast (multi-processor) machines experienced performance
		 * degradation when doing a backup.
		 *
		 * Initial attempts based on sleeping for a number of ms for each ms
		 * of work were deemed too complex, then a simple 'sleep in each loop'
		 * implementation was suggested. The latter failed because the loop
		 * was too tight. Finally, the following was implemented:
		 *
		 * If throttle is non-zero, then
		 *		See how long since the last sleep.
		 *		Work out how long to sleep (based on ratio).
		 *		If sleep is more than 100ms, then
		 *			sleep
		 *			reset timer
		 *		EndIf
		 * EndIf
		 *
		 * where the throttle value was the number of ms to sleep per ms of
		 * work. The calculation was done in each loop.
		 *
		 * Most of the hard work is done in the backend, and this solution
		 * still did not work particularly well: on slow machines, the ratio
		 * was 50:1, and on medium paced machines, 1:1, and on fast
		 * multi-processor machines, it had little or no effect, for reasons
		 * that were unclear.
		 *
		 * Further discussion ensued, and the proposal was dropped.
		 *
		 * For those people who want this feature, it can be implemented using
		 * gettimeofday in each loop, calculating the time since last sleep,
		 * multiplying that by the sleep ratio, then if the result is more
		 * than a preset 'minimum sleep time' (say 100ms), call the 'select'
		 * function to sleep for a subsecond period ie.
		 *
		 * select(0, NULL, NULL, NULL, &amp;tvi);
		 *
		 * This will return after the interval specified in the structure tvi.
		 * Finally, call gettimeofday again to save the 'last sleep time'.
		 * ----------
		 */</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"\\.\n\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy data transfer failed */</comment>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Dumping the contents of table \"%s\" failed: PQgetCopyData() failed.\n"</literal></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Error message from server: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"The command was: %s\n"</literal></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check command status and return to normal libpq state */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Dumping the contents of table \"%s\" failed: PQgetResult() failed.\n"</literal></expr></argument>, <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Error message from server: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"The command was: %s\n"</literal></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do this to ensure we've pumped libpq back to idle state */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: unexpected extra results during COPY of table \"%s\"\n"</literal></expr></argument>,
				  <argument><expr><name>classname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dump table data using INSERT commands.
 *
 * Caution: when we restore from an archive file direct to database, the
 * INSERT commands emitted by this function have to be parsed by
 * pg_backup_db.c's ExecuteSimpleCommands(), which will not handle comments,
 * E'' strings, or dollar-quoted strings.  So don't emit anything like that.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpTableData_insert</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name> <init>= <expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dcontext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>insertStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>field</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DECLARE _pg_dump_cursor CURSOR FOR "</literal>
					  <literal type="string">"SELECT %s * FROM ONLY %s"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>oids</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"oid, "</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"FETCH 100 FROM _pg_dump_cursor"</literal></expr></argument>,
							  <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>PQnfields</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>tuple</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tuple</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>tuple</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * First time through, we build as much of the INSERT statement as
			 * possible in "insertStmt", which we can then just print for each
			 * line. If the table happens to have zero columns then this will
			 * be a complete statement, otherwise it will end in "VALUES(" and
			 * be ready to have the row's column values appended.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>insertStmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>targettab</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>insertStmt</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * When load-via-partition-root is set, get the root table
				 * name for the partition table, so that we can reload data
				 * through the root table.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>load_via_partition_root</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>targettab</name> <operator>=</operator> <call><name>getRootTableInfo</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>targettab</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>targettab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* corner case for zero-column table */</comment>
				<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT VALUES;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* append the list of column names if required */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>column_inserts</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>field</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>,
												 <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQfname</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING SYSTEM VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>, <argument><expr><literal type="string">"VALUES ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name><name>insertStmt</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if it is zero-column table then we're done */</comment>
			<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>field</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>field</name> <operator>&lt;</operator> <name>nfields</name></expr>;</condition> <incr><expr><name>field</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>field</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* XXX This code is partially duplicated in ruleutils.c */</comment>
				<switch>switch <condition>(<expr><call><name>PQftype</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>INT2OID</name></expr>:</case>
					<case>case <expr><name>INT4OID</name></expr>:</case>
					<case>case <expr><name>INT8OID</name></expr>:</case>
					<case>case <expr><name>OIDOID</name></expr>:</case>
					<case>case <expr><name>FLOAT4OID</name></expr>:</case>
					<case>case <expr><name>FLOAT8OID</name></expr>:</case>
					<case>case <expr><name>NUMERICOID</name></expr>:</case>
						<block>{<block_content>
							<comment type="block">/*
							 * These types are printed without quotes unless
							 * they contain values that aren't accepted by the
							 * scanner unquoted (e.g., 'NaN').  Note that
							 * strtod() and friends might accept NaN, so we
							 * can't use that to test.
							 *
							 * In reality we only need to defend against
							 * infinity and NaN, so we need not get too crazy
							 * about pattern matching here.
							 */</comment>
							<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"0123456789 +-eE."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						</block_content>}</block>
						<break>break;</break>

					<case>case <expr><name>BITOID</name></expr>:</case>
					<case>case <expr><name>VARBITOID</name></expr>:</case>
						<expr_stmt><expr><call><name>archprintf</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"B'%s'"</literal></expr></argument>,
								   <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>BOOLOID</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>

					<default>default:</default>
						<comment type="block">/* All other types are printed as string literals. */</comment>
						<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
											  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">");\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>archputs</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CLOSE _pg_dump_cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>insertStmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>insertStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getRootTableInfo:
 *     get the root TableInfo for the given partition table.
 */</comment>
<function><type><specifier>static</specifier> <name>TableInfo</name> <modifier>*</modifier></type>
<name>getRootTableInfo</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentTbinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>parentTbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentTbinfo</name><operator>-&gt;</operator><name>numParents</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <name><name>parentTbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>parentTbinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableData -
 *	  dump the contents of a single table
 *
 * Actually, this just makes an ArchiveEntry for the table contents.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>copyBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>clistBuf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DataDumperPtr</name></type> <name>dumpFn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>copyStmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copyFrom</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>dump_inserts</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Dump/restore using COPY */</comment>
		<expr_stmt><expr><name>dumpFn</name> <operator>=</operator> <name>dumpTableData_copy</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When load-via-partition-root is set, get the root table name for
		 * the partition table, so that we can reload data through the root
		 * table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>load_via_partition_root</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentTbinfo</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parentTbinfo</name> <operator>=</operator> <call><name>getRootTableInfo</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>copyFrom</name> <operator>=</operator> <call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentTbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>copyFrom</name> <operator>=</operator> <call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* must use 2 steps here 'cause fmtId is nonreentrant */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>, <argument><expr><literal type="string">"COPY %s "</literal></expr></argument>,
						  <argument><expr><name>copyFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>, <argument><expr><literal type="string">"%s %sFROM stdin;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtCopyColumnList</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>oids</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"WITH OIDS "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>copyStmt</name> <operator>=</operator> <name><name>copyBuf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Restore using INSERT */</comment>
		<expr_stmt><expr><name>dumpFn</name> <operator>=</operator> <name>dumpTableData_insert</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>copyStmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note: although the TableDataInfo is a full DumpableObject, we treat its
	 * dependency on its table as "special" and pass it to ArchiveEntry now.
	 * See comments for BuildArchiveDependencies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TABLE DATA"</literal></expr></argument>, <argument><expr><name>SECTION_DATA</name></expr></argument>,
					 <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>copyStmt</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>dumpFn</name></expr></argument>, <argument><expr><name>tdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>copyBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>clistBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * refreshMatViewData -
 *	  load or refresh the contents of a single materialized view
 *
 * Actually, this just makes an ArchiveEntry for the REFRESH MATERIALIZED VIEW
 * statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>refreshMatViewData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>

	<comment type="block">/* If the materialized view is not flagged as populated, skip this. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"REFRESH MATERIALIZED VIEW %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,	<comment type="block">/* catalog ID */</comment>
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,	<comment type="block">/* dump ID */</comment>
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <comment type="block">/* Name */</comment>
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <comment type="block">/* Namespace */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* Tablespace */</comment>
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,	<comment type="block">/* Owner */</comment>
					 <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* with oids */</comment>
					 <argument><expr><literal type="string">"MATERIALIZED VIEW DATA"</literal></expr></argument>,	<comment type="block">/* Desc */</comment>
					 <argument><expr><name>SECTION_POST_DATA</name></expr></argument>, <comment type="block">/* Section */</comment>
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,	<comment type="block">/* Create */</comment>
					 <argument><expr><literal type="string">""</literal></expr></argument>,		<comment type="block">/* Del */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* Copy */</comment>
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name></name></expr></argument>, <comment type="block">/* Deps */</comment>
					 <argument><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr></argument>,	<comment type="block">/* # Deps */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* Dumper */</comment>
					 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* Dumper Arg */</comment>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTableData -
 *	  set up dumpable objects representing the contents of tables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getTableData</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oids</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><name>relkind</name> <operator>||</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>relkind</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>makeTableDataInfo</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Make a dumpable object for the data of this specific table
 *
 * Note: we make a TableDataInfo if and only if we are going to dump the
 * table data; the "dump" flag in such objects isn't used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makeTableDataInfo</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Nothing to do if we already decided to dump the table.  This will
	 * happen for "config" tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Skip VIEWs (no data to dump) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip FOREIGN TABLEs (no data to dump) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Skip partitioned tables (data in partitions) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Don't dump data in unlogged tables, if so requested */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
		<name><name>dopt</name><operator>-&gt;</operator><name>no_unlogged_table_data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check that the data is not explicitly excluded */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tabledata_exclude_oids</name></expr></argument>,
							   <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, let's dump it */</comment>
	<expr_stmt><expr><name>tdinfo</name> <operator>=</operator> <operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableDataInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_REFRESH_MATVIEW</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SEQUENCE_SET</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TABLE_DATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Note: use tableoid 0 so that this object won't be mistaken for
	 * something that pg_depend entries apply to.
	 */</comment>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <name>oids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tdinfo</name><operator>-&gt;</operator><name>filtercond</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* might get set later */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>=</operator> <name>tdinfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The refresh for a materialized view must be dependent on the refresh for
 * any materialized view that this one is dependent on.
 *
 * This must be called after all the objects are created, but before they are
 * sorted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>buildMatViewRefreshDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>;</decl_stmt>

	<comment type="block">/* No Mat Views before 9.3. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"WITH RECURSIVE w AS "</literal>
						 <literal type="string">"( "</literal>
						 <literal type="string">"SELECT d1.objid, d2.refobjid, c2.relkind AS refrelkind "</literal>
						 <literal type="string">"FROM pg_depend d1 "</literal>
						 <literal type="string">"JOIN pg_class c1 ON c1.oid = d1.objid "</literal>
						 <literal type="string">"AND c1.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call>
						 <literal type="string">" JOIN pg_rewrite r1 ON r1.ev_class = d1.objid "</literal>
						 <literal type="string">"JOIN pg_depend d2 ON d2.classid = 'pg_rewrite'::regclass "</literal>
						 <literal type="string">"AND d2.objid = r1.oid "</literal>
						 <literal type="string">"AND d2.refobjid &lt;&gt; d1.objid "</literal>
						 <literal type="string">"JOIN pg_class c2 ON c2.oid = d2.refobjid "</literal>
						 <literal type="string">"AND c2.relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">") "</literal>
						 <literal type="string">"WHERE d1.classid = 'pg_class'::regclass "</literal>
						 <literal type="string">"UNION "</literal>
						 <literal type="string">"SELECT w.objid, d3.refobjid, c3.relkind "</literal>
						 <literal type="string">"FROM w "</literal>
						 <literal type="string">"JOIN pg_rewrite r3 ON r3.ev_class = w.refobjid "</literal>
						 <literal type="string">"JOIN pg_depend d3 ON d3.classid = 'pg_rewrite'::regclass "</literal>
						 <literal type="string">"AND d3.objid = r3.oid "</literal>
						 <literal type="string">"AND d3.refobjid &lt;&gt; w.refobjid "</literal>
						 <literal type="string">"JOIN pg_class c3 ON c3.oid = d3.refobjid "</literal>
						 <literal type="string">"AND c3.relkind IN ("</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call> <literal type="string">","</literal>
						 <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call> <literal type="string">") "</literal>
						 <literal type="string">") "</literal>
						 <literal type="string">"SELECT 'pg_class'::regclass::oid AS classid, objid, refobjid "</literal>
						 <literal type="string">"FROM w "</literal>
						 <literal type="string">"WHERE refrelkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>refobjId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>refdobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>reftbinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dataObj</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_REFRESH_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reftbinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>refdobj</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reftbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <name><name>reftbinfo</name><operator>-&gt;</operator><name>dataObj</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_REFRESH_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>reftbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTableDataFKConstraints -
 *	  add dump-order dependencies reflecting foreign key constraints
 *
 * This code is executed only in a data-only dump --- in schema+data dumps
 * we handle foreign key issues by not creating the FK constraints until
 * after the data is loaded.  In a data-only dump, however, we want to
 * order the table data objects in such a way that a table's referenced
 * tables are restored first.  (In the presence of circular references or
 * self-references this may be impossible; we'll detect and complain about
 * that during the dependency sorting step.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getTableDataFKConstraints</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numObjs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Search through all the dumpable objects for FK constraints */</comment>
	<expr_stmt><expr><call><name>getDumpableObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dobjs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_FK_CONSTRAINT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>cinfo</name> <init>= <expr><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>ftable</name></decl>;</decl_stmt>

			<comment type="block">/* Not interesting unless both tables are to be dumped */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cinfo</name><operator>-&gt;</operator><name>contable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>cinfo</name><operator>-&gt;</operator><name>contable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>ftable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>cinfo</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ftable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>ftable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Okay, make referencing table's TABLE_DATA object depend on the
			 * referenced table's TABLE_DATA object.
			 */</comment>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cinfo</name><operator>-&gt;</operator><name>contable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><name><name>ftable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * guessConstraintInheritance:
 *	In pre-8.4 databases, we can't tell for certain which constraints
 *	are inherited.  We assume a CHECK constraint is inherited if its name
 *	matches the name of any constraint in the parent.  Originally this code
 *	tried to compare the expression texts, but that can fail for various
 *	reasons --- for example, if the parent and child tables are in different
 *	schemas, reverse-listing of function calls may produce different text
 *	(schema-qualified or not) depending on search path.
 *
 *	In 8.4 and up we can rely on the conislocal field to decide which
 *	constraints must be dumped; much safer.
 *
 *	This function assumes all conislocal flags were initialized to true.
 *	It clears the flag on anything that seems to be inherited.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>guessConstraintInheritance</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

		<comment type="block">/* Sequences and views never have parents */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Don't bother computing anything for non-target tables, either */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numParents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* nothing to see here, move along */</comment>

		<comment type="block">/* scan for inherited CHECK constraints */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>constr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>l</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>l</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>pconstr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>l</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pconstr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PGresult</name><modifier>*</modifier></type>
<name>queryDatabaseData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>dbQry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Fetch the database-level properties for this database */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"(%s datdba) AS dba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, datminmxid, "</literal>
						  <literal type="string">"(SELECT array_agg(acl ORDER BY acl::text COLLATE \"C\") FROM ( "</literal>
						  <literal type="string">"  SELECT unnest(coalesce(datacl,acldefault('d',datdba))) AS acl "</literal>
						  <literal type="string">"  EXCEPT SELECT unnest(acldefault('d',datdba))) as datacls)"</literal>
						  <literal type="string">" AS datacl, "</literal>
						  <literal type="string">"(SELECT array_agg(acl ORDER BY acl::text COLLATE \"C\") FROM ( "</literal>
						  <literal type="string">"  SELECT unnest(acldefault('d',datdba)) AS acl "</literal>
						  <literal type="string">"  EXCEPT SELECT unnest(coalesce(datacl,acldefault('d',datdba)))) as rdatacls)"</literal>
						  <literal type="string">" AS rdatacl, "</literal>
						  <literal type="string">"datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"(%s datdba) AS dba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, datminmxid, "</literal>
						  <literal type="string">"datacl, '' as rdatacl, datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"(%s datdba) AS dba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"datcollate, datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, '' as rdatacl, datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"(%s datdba) AS dba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"NULL AS datcollate, NULL AS datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, '' as rdatacl, datistemplate, datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace, "</literal>
						  <literal type="string">"shobj_description(oid, 'pg_database') AS description "</literal>

						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, datname, "</literal>
						  <literal type="string">"(%s datdba) AS dba, "</literal>
						  <literal type="string">"pg_encoding_to_char(encoding) AS encoding, "</literal>
						  <literal type="string">"NULL AS datcollate, NULL AS datctype, datfrozenxid, 0 AS datminmxid, "</literal>
						  <literal type="string">"datacl, '' as rdatacl, datistemplate, "</literal>
						  <literal type="string">"-1 as datconnlimit, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = dattablespace) AS tablespace "</literal>
						  <literal type="string">"FROM pg_database "</literal>
						  <literal type="string">"WHERE datname = current_database()"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dbQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>getDatabaseOid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading database id\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dbQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name><modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>queryDatabaseData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i_oid</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>db_oid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>db_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDatabase:
 *	dump the database definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDatabase</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dbQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>creaQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_datname</name></decl>,
				<decl><type ref="prev"/><name>i_dba</name></decl>,
				<decl><type ref="prev"/><name>i_encoding</name></decl>,
				<decl><type ref="prev"/><name>i_collate</name></decl>,
				<decl><type ref="prev"/><name>i_ctype</name></decl>,
				<decl><type ref="prev"/><name>i_frozenxid</name></decl>,
				<decl><type ref="prev"/><name>i_minmxid</name></decl>,
				<decl><type ref="prev"/><name>i_datacl</name></decl>,
				<decl><type ref="prev"/><name>i_rdatacl</name></decl>,
				<decl><type ref="prev"/><name>i_datistemplate</name></decl>,
				<decl><type ref="prev"/><name>i_datconnlimit</name></decl>,
				<decl><type ref="prev"/><name>i_tablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogId</name></type>	<name>dbCatId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>dbDumpId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>datname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dba</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>encoding</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>collate</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ctype</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>datacl</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rdatacl</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>datistemplate</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>datconnlimit</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>frozenxid</name></decl>,
				<decl><type ref="prev"/><name>minmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qdatname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"saving database definition\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>queryDatabaseData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dba</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dba"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_encoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datcollate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ctype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datctype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_frozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_minmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rdatacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rdatacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datistemplate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datistemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_datconnlimit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datconnlimit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dbCatId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dopt</name><operator>-&gt;</operator><name>db_oid</name></name> <operator>=</operator> <name><name>dbCatId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>datname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dba</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_dba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_frozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_minmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datacl</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rdatacl</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_rdatacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datistemplate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datistemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datconnlimit</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_datconnlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdatname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare the CREATE DATABASE command.  We must specify encoding, locale,
	 * and tablespace since those can't be altered later.  Other DB properties
	 * are left to the DATABASE PROPERTIES entry, so that they can be applied
	 * after reconnecting to the target DB.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"CREATE DATABASE %s WITH TEMPLATE = template0"</literal></expr></argument>,
					  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" ENCODING = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>collate</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" LC_COLLATE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>collate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" LC_CTYPE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * While dumping create database statements, need to know whether the
	 * database is colocated or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isDatabaseColocated</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" colocated = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note: looking at dopt-&gt;outputNoTablespaces here is completely the wrong
	 * thing; the decision whether to specify a tablespace should be left till
	 * pg_restore, so that pg_restore --no-tablespaces applies.  Ideally we'd
	 * label the DATABASE entry with the tablespace and let the normal
	 * tablespace selection logic work ... but CREATE DATABASE doesn't pay
	 * attention to default_tablespace, so that won't work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>, <argument><expr><literal type="string">"pg_default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>outputNoTablespaces</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">" TABLESPACE = %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"DROP DATABASE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dbDumpId</name> <operator>=</operator> <call><name>createDumpId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
				 <argument><expr><name>dbCatId</name></expr></argument>,		<comment type="block">/* catalog ID */</comment>
				 <argument><expr><name>dbDumpId</name></expr></argument>,		<comment type="block">/* dump ID */</comment>
				 <argument><expr><name>datname</name></expr></argument>,		<comment type="block">/* Name */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* Namespace */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* Tablespace */</comment>
				 <argument><expr><name>dba</name></expr></argument>,			<comment type="block">/* Owner */</comment>
				 <argument><expr><name>false</name></expr></argument>,			<comment type="block">/* with oids */</comment>
				 <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>,	<comment type="block">/* Desc */</comment>
				 <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,	<comment type="block">/* Section */</comment>
				 <argument><expr><name><name>creaQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <comment type="block">/* Create */</comment>
				 <argument><expr><name><name>delQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,	<comment type="block">/* Del */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* Copy */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* Deps */</comment>
				 <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* # Deps */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,			<comment type="block">/* Dumper */</comment>
				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* Dumper Arg */</comment>

	<comment type="block">/* Compute correct tag for archive entry */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"DATABASE %s"</literal></expr></argument>, <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dump DB comment if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * 8.2 and up keep comments on shared objects in a shared table, so we
		 * cannot use the dumpComment() code used for other database objects.
		 * Be careful that the ArchiveEntry parameters match that function.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>comment</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>comment</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Generates warning when loaded into a differently-named
			 * database.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON DATABASE %s IS "</literal></expr></argument>, <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dba</name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
						 <argument><expr><name><name>dbQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name>dbDumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>qdatname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dba</name></expr></argument>,
					<argument><expr><name>dbCatId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dbDumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Dump DB security label, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>shres</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>seclabelQry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>seclabelQry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>buildShSecLabelQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"pg_database"</literal></expr></argument>, <argument><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shres</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>seclabelQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emitShSecLabels</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>shres</name></expr></argument>, <argument><expr><name>seclabelQry</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>seclabelQry</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dba</name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
						 <argument><expr><name><name>seclabelQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name>dbDumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>seclabelQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>shres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Dump ACL if any.  Note that we do not support initial privileges
	 * (pg_init_privs) on databases.
	 */</comment>
	<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>dbCatId</name></expr></argument>, <argument><expr><name>dbDumpId</name></expr></argument>, <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>,
			<argument><expr><name>qdatname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><name>dba</name></expr></argument>, <argument><expr><name>datacl</name></expr></argument>, <argument><expr><name>rdatacl</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now construct a DATABASE PROPERTIES archive entry to restore any
	 * non-default database-level properties.  (The reason this must be
	 * separate is that we cannot put any additional commands into the TOC
	 * entry that has CREATE DATABASE.  pg_restore would execute such a group
	 * in an implicit transaction block, and the backend won't allow CREATE
	 * DATABASE in that context.)
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>datconnlimit</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>datconnlimit</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"ALTER DATABASE %s CONNECTION LIMIT = %s;\n"</literal></expr></argument>,
						  <argument><expr><name>qdatname</name></expr></argument>, <argument><expr><name>datconnlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>datistemplate</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"ALTER DATABASE %s IS_TEMPLATE = true;\n"</literal></expr></argument>,
						  <argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The backend won't accept DROP DATABASE on a template database.  We
		 * can deal with that by removing the template marking before the DROP
		 * gets issued.  We'd prefer to use ALTER DATABASE IF EXISTS here, but
		 * since no such command is currently supported, fake it with a direct
		 * UPDATE on pg_database.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database "</literal>
							 <literal type="string">"SET datistemplate = false WHERE datname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add database-specific SET options */</comment>
	<expr_stmt><expr><call><name>dumpDatabaseConfig</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name><name>dbCatId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We stick this binary-upgrade query into the DATABASE PROPERTIES archive
	 * entry, too, for lack of a better place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set datfrozenxid and datminmxid.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_database\n"</literal>
						  <literal type="string">"SET datfrozenxid = '%u', datminmxid = '%u'\n"</literal>
						  <literal type="string">"WHERE datname = "</literal></expr></argument>,
						  <argument><expr><name>frozenxid</name></expr></argument>, <argument><expr><name>minmxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><name>datname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>creaQry</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name>datname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dba</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"DATABASE PROPERTIES"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>creaQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name>dbDumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * pg_largeobject and pg_largeobject_metadata come from the old system
	 * intact, so set their relfrozenxids and relminmxids.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>lo_res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>loFrozenQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>loOutQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_relfrozenxid</name></decl>,
					<decl><type ref="prev"/><name>i_relminmxid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * pg_largeobject
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, relminmxid\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
							  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
							  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, 0 AS relminmxid\n"</literal>
							  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
							  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
							  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>lo_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>loFrozenQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_relfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set pg_largeobject relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
						  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
						  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>LargeObjectRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><literal type="string">"pg_largeobject"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"pg_largeobject"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>loOutQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * pg_largeobject_metadata
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, relminmxid\n"</literal>
								  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
								  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
								  <argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>, <argument><expr><literal type="string">"SELECT relfrozenxid, 0 AS relminmxid\n"</literal>
								  <literal type="string">"FROM pg_catalog.pg_class\n"</literal>
								  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
								  <argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>lo_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>loFrozenQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i_relfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i_relminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="string">"relminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set pg_largeobject_metadata relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
							  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
							  <literal type="string">"WHERE oid = %u;\n"</literal></expr></argument>,
							  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_relminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><literal type="string">"pg_largeobject_metadata"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"pg_largeobject_metadata"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
						 <argument><expr><name><name>loOutQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>lo_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>loFrozenQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>loOutQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qdatname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dbQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>creaQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect any database-specific or role-and-database-specific SET options
 * for this database, and append them to outbuf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDatabaseConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>outbuf</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First collect database-specific options.  Pre-8.4 server versions lack
	 * unnest(), so we do this the hard way by querying once per subscript.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT setconfig[%d] FROM pg_db_role_setting "</literal>
							  <literal type="string">"WHERE setrole = 0 AND setdatabase = '%u'::oid"</literal></expr></argument>,
							  <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT datconfig[%d] FROM pg_database WHERE oid = '%u'::oid"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>makeAlterConfigCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now look for role-and-database-specific options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AH</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Here we can assume we have unnest() */</comment>
		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT rolname, unnest(setconfig) "</literal>
						  <literal type="string">"FROM pg_db_role_setting s, pg_roles r "</literal>
						  <literal type="string">"WHERE setrole = r.oid AND setdatabase = '%u'::oid"</literal></expr></argument>,
						  <argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>makeAlterConfigCommand</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"ROLE"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><literal type="string">"DATABASE"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>,
									   <argument><expr><name>outbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpEncoding: put the correct encoding into the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEncoding</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name> <init>= <expr><call><name>pg_encoding_to_char</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"saving encoding = %s\n"</literal></expr></argument>, <argument><expr><name>encname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET client_encoding = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>encname</name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"ENCODING"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
				 <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * dumpStdStrings: put the correct escape string behavior into the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpStdStrings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stdstrings</name> <init>= <expr><ternary><condition><expr><name><name>AH</name><operator>-&gt;</operator><name>std_strings</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"saving standard_conforming_strings = %s\n"</literal></expr></argument>,
				  <argument><expr><name>stdstrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SET standard_conforming_strings = '%s';\n"</literal></expr></argument>,
					  <argument><expr><name>stdstrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">"STDSTRINGS"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"STDSTRINGS"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
				 <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSearchPath: record the active search_path in the archive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSearchPath</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>qry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>path</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>schemanames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nschemanames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the result of current_schemas(), not the search_path GUC,
	 * because that might contain wildcards such as "$user", which won't
	 * necessarily have the same value during restore.  Also, this way avoids
	 * listing schemas that may appear in search_path but not actually exist,
	 * which seems like a prudent exclusion.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>AH</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT pg_catalog.current_schemas(false)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemanames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nschemanames</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not parse result of current_schemas()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We use set_config(), not a simple "SET search_path" command, because
	 * the latter has less-clean behavior if the search path is empty.  While
	 * that's likely to get fixed at some point, it seems like a good idea to
	 * be as backwards-compatible as possible in what we put into archives.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nschemanames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>schemanames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.set_config('search_path', "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>AH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><literal type="string">", false);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"saving search_path = %s\n"</literal></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
				 <argument><expr><literal type="string">"SEARCHPATH"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SEARCHPATH"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
				 <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also save it in AH-&gt;searchpath, in case we're doing plain text dump */</comment>
	<expr_stmt><expr><name><name>AH</name><operator>-&gt;</operator><name>searchpath</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemanames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>schemanames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * getBlobs:
 *	Collect schema-level data about large objects
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>blobQry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlobInfo</name>   <modifier>*</modifier></type><name>binfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>bdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lomowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lomacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rlomacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initlomacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrlomacl</name></decl>;</decl_stmt>

	<comment type="block">/* Verbose message */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading large objects\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch BLOB OIDs, and owner/ACL data if &gt;= 9.0 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>init_acl_subquery</name></expr></argument>,
						<argument><expr><name>init_racl_subquery</name></expr></argument>, <argument><expr><literal type="string">"l.lomacl"</literal></expr></argument>, <argument><expr><literal type="string">"l.lomowner"</literal></expr></argument>, <argument><expr><literal type="string">"'L'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT l.oid, (%s l.lomowner) AS rolname, "</literal>
						  <literal type="string">"%s AS lomacl, "</literal>
						  <literal type="string">"%s AS rlomacl, "</literal>
						  <literal type="string">"%s AS initlomacl, "</literal>
						  <literal type="string">"%s AS initrlomacl "</literal>
						  <literal type="string">"FROM pg_largeobject_metadata l "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(l.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_largeobject'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>init_acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>init_racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT oid, (%s lomowner) AS rolname, lomacl, "</literal>
						  <literal type="string">"NULL AS rlomacl, NULL AS initlomacl, "</literal>
						  <literal type="string">"NULL AS initrlomacl "</literal>
						  <literal type="string">" FROM pg_largeobject_metadata"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT DISTINCT loid AS oid, "</literal>
							 <literal type="string">"NULL::name AS rolname, NULL::oid AS lomacl, "</literal>
							 <literal type="string">"NULL::oid AS rlomacl, NULL::oid AS initlomacl, "</literal>
							 <literal type="string">"NULL::oid AS initrlomacl "</literal>
							 <literal type="string">" FROM pg_largeobject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>blobQry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lomowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lomacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lomacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rlomacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rlomacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initlomacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initlomacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrlomacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrlomacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each large object has its own BLOB archive entry.
	 */</comment>
	<expr_stmt><expr><name>binfo</name> <operator>=</operator> <operator>(</operator><name>BlobInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlobInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_BLOB</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <name>LargeObjectRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blobacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rblobacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rlomacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initblobacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initlomacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrblobacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrlomacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lomacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rlomacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initlomacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrlomacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In binary-upgrade mode for blobs, we do *not* dump out the data or
		 * the ACLs, should any exist.  The data and ACL (if any) will be
		 * copied by pg_upgrade, which simply copies the pg_largeobject and
		 * pg_largeobject_metadata tables.
		 *
		 * We *do* dump out the definition of the blob because we need that to
		 * make the restoration of the comments, and anything else, work since
		 * pg_upgrade copies the files behind pg_largeobject and
		 * pg_largeobject_metadata after the dump is restored.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>binfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DUMP_COMPONENT_DATA</name> <operator>|</operator> <name>DUMP_COMPONENT_ACL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we have any large objects, a "BLOBS" archive entry is needed. This
	 * is just a placeholder for sorting; it carries no data now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bdata</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>objType</name></name> <operator>=</operator> <name>DO_BLOB_DATA</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>catId</name></name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>bdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bdata</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"BLOBS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>blobQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBlob
 *
 * dump the definition (metadata) of the given large object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpBlob</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>BlobInfo</name> <modifier>*</modifier></type><name>binfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cquery</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.lo_create('%s');\n"</literal></expr></argument>,
					  <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dquery</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.lo_unlink('%s');\n"</literal></expr></argument>,
					  <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"BLOB"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>cquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>dquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump comment if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump security label if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump ACL if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>binfo</name><operator>-&gt;</operator><name>blobacl</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>,
				<argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>blobacl</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>rblobacl</name></name></expr></argument>,
				<argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>initblobacl</name></name></expr></argument>, <argument><expr><name><name>binfo</name><operator>-&gt;</operator><name>initrblobacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBlobs:
 *	dump the data contents of all large objects
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dumpBlobs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blobQry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blobFetchQry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>LOBBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"saving large objects\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Currently, we re-fetch all BLOB OIDs using a cursor.  Consider scanning
	 * the already-in-memory dumpable objects instead...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>blobQry</name> <operator>=</operator> <literal type="string">"DECLARE bloboid CURSOR FOR SELECT oid FROM pg_largeobject_metadata"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>blobQry</name> <operator>=</operator> <literal type="string">"DECLARE bloboid CURSOR FOR SELECT DISTINCT loid FROM pg_largeobject"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobQry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Command to fetch from cursor */</comment>
	<expr_stmt><expr><name>blobFetchQry</name> <operator>=</operator> <literal type="string">"FETCH 1000 IN bloboid"</literal></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<comment type="block">/* Do a fetch */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobFetchQry</name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process the tuples, if any */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>blobOid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>loFd</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>blobOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Open the BLOB */</comment>
			<expr_stmt><expr><name>loFd</name> <operator>=</operator> <call><name>lo_open</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><name>INV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>loFd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not open large object %u: %s"</literal></expr></argument>,
							  <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>StartBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now read it in chunks, sending data to archive */</comment>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>lo_read</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>loFd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LOBBUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"error reading large object %u: %s"</literal></expr></argument>,
								  <argument><expr><name>blobOid</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>WriteData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<expr_stmt><expr><call><name>lo_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>loFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EndBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>blobOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getPolicies
 *	  get information about all RLS policies on dumpable tables.
 */</comment>
<function><type><name>void</name></type>
<name>getPolicies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polpermissive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polroles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polqual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_polwithcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, check which tables have RLS enabled.  We represent RLS being
	 * enabled on a table by creating a PolicyInfo object with null polname.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore row security on tables not to be dumped */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rowsec</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: use tableoid 0 so that this object won't be mistaken for
			 * something that pg_depend entries apply to.
			 */</comment>
			<expr_stmt><expr><name>polinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PolicyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_POLICY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>poltable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polpermissive</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now, read all RLS policies, and create PolicyInfo objects for all those
	 * that are of interest.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading row-level security policies\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT oid, tableoid, pol.polrelid, pol.polname, pol.polcmd, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"pol.polpermissive, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"'t' as polpermissive, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"CASE WHEN pol.polroles = '{0}' THEN NULL ELSE "</literal>
					  <literal type="string">"   pg_catalog.array_to_string(ARRAY(SELECT pg_catalog.quote_ident(rolname) from pg_catalog.pg_roles WHERE oid = ANY(pol.polroles)), ', ') END AS polroles, "</literal>
					  <literal type="string">"pg_catalog.pg_get_expr(pol.polqual, pol.polrelid) AS polqual, "</literal>
					  <literal type="string">"pg_catalog.pg_get_expr(pol.polwithcheck, pol.polrelid) AS polwithcheck "</literal>
					  <literal type="string">"FROM pg_catalog.pg_policy pol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polcmd</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polcmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polpermissive</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polpermissive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polroles</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polroles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polqual</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polqual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_polwithcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"polwithcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>polinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PolicyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>polrelid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name>polrelid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Ignore row security on tables not to be dumped.  (This will
			 * result in some harmless wasted slots in polinfo[].)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_POLICY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
				<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>poltable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polcmd</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polcmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polpermissive</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polpermissive</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polroles</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polroles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polroles</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polroles</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polqual</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polqual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polqual</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polwithcheck</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polwithcheck</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>polinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>polwithcheck</name>
					<operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_polwithcheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPolicy
 *	  dump the definition of the given policy
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPolicy</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PolicyInfo</name> <modifier>*</modifier></type><name>polinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>polinfo</name><operator>-&gt;</operator><name>poltable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If polname is NULL, then this record is just indicating that ROW LEVEL
	 * SECURITY is enabled for the table. Dump as ALTER TABLE &lt;table&gt; ENABLE
	 * ROW LEVEL SECURITY.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ENABLE ROW LEVEL SECURITY;"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must emit the ROW SECURITY object's dependency on its table
		 * explicitly, because it will not match anything in pg_depend (unlike
		 * the case for other PolicyInfo objects).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><literal type="string">"ROW SECURITY"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
						 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR SELECT"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR INSERT"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR UPDATE"</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">" FOR DELETE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unexpected policy command type: %c\n"</literal></expr></argument>,
				  <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE POLICY %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON %s%s%s"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>!</operator><name><name>polinfo</name><operator>-&gt;</operator><name>polpermissive</name></name></expr> ?</condition><then> <expr><literal type="string">" AS RESTRICTIVE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TO %s"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polroles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" USING (%s)"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" WITH CHECK (%s)"</literal></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polwithcheck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP POLICY %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>polname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_POLICY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>polinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"POLICY"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getPublications
 *	  get information about publications
 */</comment>
<function><type><name>void</name></type>
<name>getPublications</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_puballtables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubinsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubupdate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubdelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubtruncate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the publications. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.pubname, "</literal>
						  <literal type="string">"(%s p.pubowner) AS rolname, "</literal>
						  <literal type="string">"p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, p.pubtruncate "</literal>
						  <literal type="string">"FROM pg_publication p"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.pubname, "</literal>
						  <literal type="string">"(%s p.pubowner) AS rolname, "</literal>
						  <literal type="string">"p.puballtables, p.pubinsert, p.pubupdate, p.pubdelete, false AS pubtruncate "</literal>
						  <literal type="string">"FROM pg_publication p"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_puballtables</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"puballtables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubinsert</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubinsert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubupdate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubupdate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubdelete</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubdelete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pubtruncate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubtruncate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pubinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PublicationInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PUBLICATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
			<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>puballtables</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_puballtables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubinsert</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubinsert</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubupdate</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubupdate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubdelete</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubdelete</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pubtruncate</name> <operator>=</operator>
			<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pubtruncate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of publication \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pubinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPublication
 *	  dump the definition of the given publication
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPublication</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PublicationInfo</name> <modifier>*</modifier></type><name>pubinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qpubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qpubname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP PUBLICATION %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE PUBLICATION %s"</literal></expr></argument>,
					  <argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>puballtables</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FOR ALL TABLES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" WITH (publish = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubinsert</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubupdate</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubdelete</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>pubtruncate</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"');\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				 <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
				 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>, <argument><expr><name>qpubname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"PUBLICATION"</literal></expr></argument>, <argument><expr><name>qpubname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pubinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qpubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getPublicationTables
 *	  get information about publication membership for dumpable tables.
 */</comment>
<function><type><name>void</name></type>
<name>getPublicationTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_publications</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only plain tables can be aded to publications. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore publication membership of tables whose definitions are not
		 * to be dumped.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading publication membership for table \"%s.%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the publication membership for the table. */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pr.tableoid, pr.oid, p.pubname "</literal>
						  <literal type="string">"FROM pg_publication_rel pr, pg_publication p "</literal>
						  <literal type="string">"WHERE pr.prrelid = '%u'"</literal>
						  <literal type="string">"  AND p.oid = pr.prpubid"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Table is not member of any publications. Clean up and return.
			 */</comment>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_pubname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pubname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pubrinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PublicationRelInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PUBLICATION_REL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
				<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pubname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_pubname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>pubtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>

			<comment type="block">/* Decide whether we want to dump it */</comment>
			<expr_stmt><expr><call><name>selectDumpablePublicationTable</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pubrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpPublicationTable
 *	  dump the definition of the given publication table mapping
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpPublicationTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>PublicationRelInfo</name> <modifier>*</modifier></type><name>pubrinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>pubtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>pubname</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER PUBLICATION %s ADD TABLE ONLY"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>pubname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There is no point in creating drop query as drop query as the drop is
	 * done by table drop.
	 */</comment>
	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>pubrinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><name>tag</name></expr></argument>,
				 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				 <argument><expr><literal type="string">"PUBLICATION TABLE"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
				 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is the currently connected user a superuser?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_superuser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>fout</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name><name>AH</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>, <argument><expr><literal type="string">"is_superuser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getSubscriptions
 *	  get information about subscriptions
 */</comment>
<function><type><name>void</name></type>
<name>getSubscriptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subconninfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subslotname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subsynccommit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_subpublications</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_subscriptions</name></name> <operator>||</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_superuser</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT count(*) FROM pg_subscription "</literal>
							  <literal type="string">"WHERE subdbid = (SELECT oid FROM pg_database"</literal>
							  <literal type="string">"                 WHERE datname = current_database())"</literal></expr></argument>,
							  <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: subscriptions not dumped because current user is not a superuser\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the subscriptions in current database. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT s.tableoid, s.oid, s.subname,"</literal>
					  <literal type="string">"(%s s.subowner) AS rolname, "</literal>
					  <literal type="string">" s.subconninfo, s.subslotname, s.subsynccommit, "</literal>
					  <literal type="string">" s.subpublications "</literal>
					  <literal type="string">"FROM pg_subscription s "</literal>
					  <literal type="string">"WHERE s.subdbid = (SELECT oid FROM pg_database"</literal>
					  <literal type="string">"                   WHERE datname = current_database())"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subconninfo</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subconninfo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subslotname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subslotname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subsynccommit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subsynccommit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_subpublications</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"subpublications"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subinfo</name> <operator>=</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SUBSCRIPTION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator>
			<call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subconninfo</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subconninfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subslotname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subslotname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subslotname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subslotname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subsynccommit</name> <operator>=</operator>
			<call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subsynccommit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subpublications</name> <operator>=</operator>
			<call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_subpublications</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of subscription \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>subinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSubscription
 *	  dump the definition of the given subscription
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSubscription</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>SubscriptionInfo</name> <modifier>*</modifier></type><name>subinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>publications</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qsubname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>pubnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npubnames</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qsubname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SUBSCRIPTION %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE SUBSCRIPTION %s CONNECTION "</literal></expr></argument>,
					  <argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subconninfo</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build list of quoted publications and append them to query. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subpublications</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pubnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npubnames</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
				  <argument><expr><literal type="string">"WARNING: could not parse subpublications array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pubnames</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pubnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pubnames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>npubnames</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>publications</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npubnames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>publications</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>publications</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>pubnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" PUBLICATION %s WITH (connect = false, slot_name = "</literal></expr></argument>, <argument><expr><name><name>publications</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>subslotname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subslotname</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subsynccommit</name></name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", synchronous_commit = %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>subsynccommit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				 <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				 <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
				 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>, <argument><expr><name>qsubname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SUBSCRIPTION"</literal></expr></argument>, <argument><expr><name>qsubname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>subinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>publications</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pubnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pubnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qsubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_type_oids_by_type_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name></type> <name>pg_type_oid</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>force_array_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>upgrade_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_type_array_oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_type_oid('%u'::pg_catalog.oid);\n\n"</literal></expr></argument>,
					  <argument><expr><name>pg_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we only support old &gt;= 8.3 for binary upgrades */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT typarray "</literal>
					  <literal type="string">"FROM pg_catalog.pg_type "</literal>
					  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid;"</literal></expr></argument>,
					  <argument><expr><name>pg_type_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_type_array_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typarray"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>force_array_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the old version didn't assign an array type, but the new version
		 * does, we must select an unused type OID to assign.  This currently
		 * only happens for domains, when upgrading pre-v11 to v11 and up.
		 *
		 * Note: local state here is kind of ugly, but we must have some,
		 * since we mustn't choose the same unused OID more than once.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>next_possible_free_oid</name> <init>= <expr><name>FirstNormalObjectId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_dup</name></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>next_possible_free_oid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT EXISTS(SELECT 1 "</literal>
							  <literal type="string">"FROM pg_catalog.pg_type "</literal>
							  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid);"</literal></expr></argument>,
							  <argument><expr><name>next_possible_free_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_dup</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>is_dup</name></expr>)</condition>;</do>

		<expr_stmt><expr><name>pg_type_array_oid</name> <operator>=</operator> <name>next_possible_free_oid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							 <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type array oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_array_pg_type_oid('%u'::pg_catalog.oid);\n\n"</literal></expr></argument>,
						  <argument><expr><name>pg_type_array_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>binary_upgrade_set_type_oids_by_rel_oid</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
										<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>pg_rel_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>upgrade_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>upgrade_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>toast_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we only support old &gt;= 8.3 for binary upgrades */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.reltype AS crel, t.reltype AS trel "</literal>
					  <literal type="string">"FROM pg_catalog.pg_class c "</literal>
					  <literal type="string">"LEFT JOIN pg_catalog.pg_class t ON "</literal>
					  <literal type="string">"  (c.reltoastrelid = t.oid) "</literal>
					  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid;"</literal></expr></argument>,
					  <argument><expr><name>pg_rel_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>upgrade_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_type_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"crel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>upgrade_buffer</name></expr></argument>,
											 <argument><expr><name>pg_type_oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"trel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Toast tables do not have pg_type array rows */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_type_toast_oid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
														  <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"trel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_type toast oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_toast_pg_type_oid('%u'::pg_catalog.oid);\n\n"</literal></expr></argument>,
						  <argument><expr><name>pg_type_toast_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>toast_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>toast_set</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_set_pg_class_oids</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
								 <parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>pg_class_oid</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>is_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>upgrade_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>upgrade_res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_class_reltoastrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pg_index_indexrelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.reltoastrelid, i.indexrelid "</literal>
					  <literal type="string">"FROM pg_catalog.pg_class c LEFT JOIN "</literal>
					  <literal type="string">"pg_catalog.pg_index i ON (c.reltoastrelid = i.indrelid AND i.indisvalid) "</literal>
					  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid;"</literal></expr></argument>,
					  <argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>upgrade_res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>upgrade_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class_reltoastrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"reltoastrelid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_index_indexrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>, <argument><expr><literal type="string">"indexrelid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						 <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_class oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_index</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_heap_pg_class_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
						  <argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* only tables have toast tables, not indexes */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>pg_class_reltoastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * One complexity is that the table definition might not require
			 * the creation of a TOAST table, and the TOAST table might have
			 * been created long after table creation, when the table was
			 * loaded with wide data.  By setting the TOAST oid we force
			 * creation of the TOAST heap and TOAST index by the backend so we
			 * can cleanly copy the files during binary upgrade.
			 */</comment>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_toast_pg_class_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
							  <argument><expr><name>pg_class_reltoastrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* every toast table has an index */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
							  <argument><expr><name>pg_index_indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_index_pg_class_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
						  <argument><expr><name>pg_class_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>upgrade_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the DumpableObject is a member of an extension, add a suitable
 * ALTER EXTENSION ADD command to the creation commands in upgrade_buffer.
 *
 * For somewhat historical reasons, objname should already be quoted,
 * but not objnamespace (if any).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>binary_upgrade_extension_member</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>upgrade_buffer</name></decl></parameter>,
								<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>extobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dobj</name><operator>-&gt;</operator><name>ext_member</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the parent extension.  We could avoid this search if we wanted to
	 * add a link field to DumpableObject, but the space costs of that would
	 * be considerable.  We assume that member objects could only have a
	 * direct dependency on their own extension, not any others.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>extobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>&amp;&amp;</operator> <name><name>extobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_EXTENSION</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>extobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not find parent extension for %s %s\n"</literal></expr></argument>,
					  <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>,
						 <argument><expr><literal type="string">"\n-- For binary upgrade, handle extension membership the hard way\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"ALTER EXTENSION %s ADD %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>objnamespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>objnamespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>objnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>upgrade_buffer</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getNamespaces:
 *	  read all namespaces in the system catalogs and return them in the
 * NamespaceInfo* structure
 *
 *	numNamespaces is set to the number of namespaces read in
 */</comment>
<function><type><name>NamespaceInfo</name> <modifier>*</modifier></type>
<name>getNamespaces</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numNamespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rnspacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initnspacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrnspacl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we fetch all namespaces including system ones, so that every object we
	 * read in can be linked to a containing namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>init_acl_subquery</name></expr></argument>,
						<argument><expr><name>init_racl_subquery</name></expr></argument>, <argument><expr><literal type="string">"n.nspacl"</literal></expr></argument>, <argument><expr><literal type="string">"n.nspowner"</literal></expr></argument>, <argument><expr><literal type="string">"'n'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT n.tableoid, n.oid, n.nspname, "</literal>
						  <literal type="string">"(%s nspowner) AS rolname, "</literal>
						  <literal type="string">"%s as nspacl, "</literal>
						  <literal type="string">"%s as rnspacl, "</literal>
						  <literal type="string">"%s as initnspacl, "</literal>
						  <literal type="string">"%s as initrnspacl "</literal>
						  <literal type="string">"FROM pg_namespace n "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip "</literal>
						  <literal type="string">"ON (n.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_namespace'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>init_acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>init_racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, nspname, "</literal>
						  <literal type="string">"(%s nspowner) AS rolname, "</literal>
						  <literal type="string">"nspacl, NULL as rnspacl, "</literal>
						  <literal type="string">"NULL AS initnspacl, NULL as initrnspacl "</literal>
						  <literal type="string">"FROM pg_namespace"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsinfo</name> <operator>=</operator> <operator>(</operator><name>NamespaceInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NamespaceInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rnspacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rnspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initnspacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initnspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrnspacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrnspacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_NAMESPACE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nspacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rnspacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rnspacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initnspacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initnspacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrnspacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrnspacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether to dump this namespace */</comment>
		<expr_stmt><expr><call><name>selectDumpableNamespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do not try to dump ACL if the ACL is empty or the default.
		 *
		 * This is useful because, for some schemas/objects, the only
		 * component we are going to try and dump is the ACL and if we can
		 * remove that then 'dump' goes to zero/false and we don't consider
		 * this object for dumping at all later on.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rnspacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initnspacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrnspacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of schema \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>nsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numNamespaces</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<return>return <expr><name>nsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findNamespace:
 *		given a namespace OID, look up the info read by getNamespaces
 */</comment>
<function><type><specifier>static</specifier> <name>NamespaceInfo</name> <modifier>*</modifier></type>
<name>findNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nsoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nsinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsinfo</name> <operator>=</operator> <call><name>findNamespaceByOid</name><argument_list>(<argument><expr><name>nsoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nsinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"schema with OID %u does not exist\n"</literal></expr></argument>, <argument><expr><name>nsoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getExtensions:
 *	  read all extensions in the system catalogs and return them in the
 * ExtensionInfo* structure
 *
 *	numExtensions is set to the number of extensions read in
 */</comment>
<function><type><name>ExtensionInfo</name> <modifier>*</modifier></type>
<name>getExtensions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extrelocatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extconfig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_extcondition</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before 9.1, there are no extensions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numExtensions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT x.tableoid, x.oid, "</literal>
						 <literal type="string">"x.extname, n.nspname, x.extrelocatable, x.extversion, x.extconfig, x.extcondition "</literal>
						 <literal type="string">"FROM pg_extension x "</literal>
						 <literal type="string">"JOIN pg_namespace n ON n.oid = x.extnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator> <name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>yb_dumpable_extensions_with_config_relations</name> <operator>=</operator> <operator>(</operator><name>ExtensionInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>yb_dumpable_extensions_with_config_relations</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>extinfo</name> <operator>=</operator> <operator>(</operator><name>ExtensionInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_nspname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extrelocatable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extrelocatable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extconfig</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extconfig"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_extcondition</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"extcondition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_EXTENSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>namespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relocatable</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extrelocatable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extversion</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extversion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extconfig</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extconfig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extcondition</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_extcondition</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Record dumpable extensions having configuration relations.
		 * (1) Check if we are in the YB mode.
		 * (2) Check if we need to dump the definition of an extension.
		 *	   That is, check if there is a corresponding row in pg_extension
		 *	   catalog for this extension.
		 * (3) Check if an extension has configuration relations.
		 *	   Configuration relations are recorded as an array of OID named
		 *	   extconfig in pg_extension catalog. PQgetvalue() retrieves its
		 *	   value as c-string. If the length of this c-string value is longer
		 *     than 2("{}"), then this extension has configuration relations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>strlen</name><argument_list>(<argument><expr><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extconfig</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>yb_dumpable_extensions_with_config_relations</name><index>[<expr><name>yb_num_dumpable_extensions_with_config_relations</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>yb_num_dumpable_extensions_with_config_relations</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numExtensions</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<return>return <expr><name>extinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTypes:
 *	  read all types in the system catalogs and return them in the
 * TypeInfo* structure
 *
 *	numTypes is set to the number of types read in
 *
 * NB: this must run after getFuncs() because we assume we can do
 * findFuncByOid().
 */</comment>
<function><type><name>TypeInfo</name> <modifier>*</modifier></type>
<name>getTypes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tyinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rtypacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_inittypacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrtypacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typrelkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typisdefined</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_isarray</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we include even the built-in types because those may be used as array
	 * elements by user-defined types
	 *
	 * we filter out the built-in types when we dump out the types
	 *
	 * same approach for undefined (shell) types and array types
	 *
	 * Note: as of 8.3 we can reliably detect whether a type is an
	 * auto-generated array type by checking the element type's typarray.
	 * (Before that the test is capable of generating false positives.) We
	 * still check for name beginning with '_', though, so as to avoid the
	 * cost of the subselect probe for all standard types.  This would have to
	 * be revisited if the backend ever allows renaming of array types.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"t.typacl"</literal></expr></argument>, <argument><expr><literal type="string">"t.typowner"</literal></expr></argument>, <argument><expr><literal type="string">"'T'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, t.typname, "</literal>
						  <literal type="string">"t.typnamespace, "</literal>
						  <literal type="string">"%s AS typacl, "</literal>
						  <literal type="string">"%s AS rtypacl, "</literal>
						  <literal type="string">"%s AS inittypacl, "</literal>
						  <literal type="string">"%s AS initrtypacl, "</literal>
						  <literal type="string">"(%s t.typowner) AS rolname, "</literal>
						  <literal type="string">"t.typelem, t.typrelid, "</literal>
						  <literal type="string">"CASE WHEN t.typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = t.typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"t.typtype, t.typisdefined, "</literal>
						  <literal type="string">"t.typname[0] = '_' AND t.typelem != 0 AND "</literal>
						  <literal type="string">"(SELECT typarray FROM pg_type te WHERE oid = t.typelem) = t.oid AS isarray "</literal>
						  <literal type="string">"FROM pg_type t "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(t.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_type'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, typname, "</literal>
						  <literal type="string">"typnamespace, typacl, NULL as rtypacl, "</literal>
						  <literal type="string">"NULL AS inittypacl, NULL AS initrtypacl, "</literal>
						  <literal type="string">"(%s typowner) AS rolname, "</literal>
						  <literal type="string">"typelem, typrelid, "</literal>
						  <literal type="string">"CASE WHEN typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"typtype, typisdefined, "</literal>
						  <literal type="string">"typname[0] = '_' AND typelem != 0 AND "</literal>
						  <literal type="string">"(SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray "</literal>
						  <literal type="string">"FROM pg_type"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, typname, "</literal>
						  <literal type="string">"typnamespace, NULL AS typacl, NULL as rtypacl, "</literal>
						  <literal type="string">"NULL AS inittypacl, NULL AS initrtypacl, "</literal>
						  <literal type="string">"(%s typowner) AS rolname, "</literal>
						  <literal type="string">"typelem, typrelid, "</literal>
						  <literal type="string">"CASE WHEN typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"typtype, typisdefined, "</literal>
						  <literal type="string">"typname[0] = '_' AND typelem != 0 AND "</literal>
						  <literal type="string">"(SELECT typarray FROM pg_type te WHERE oid = pg_type.typelem) = oid AS isarray "</literal>
						  <literal type="string">"FROM pg_type"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, typname, "</literal>
						  <literal type="string">"typnamespace, NULL AS typacl, NULL as rtypacl, "</literal>
						  <literal type="string">"NULL AS inittypacl, NULL AS initrtypacl, "</literal>
						  <literal type="string">"(%s typowner) AS rolname, "</literal>
						  <literal type="string">"typelem, typrelid, "</literal>
						  <literal type="string">"CASE WHEN typrelid = 0 THEN ' '::\"char\" "</literal>
						  <literal type="string">"ELSE (SELECT relkind FROM pg_class WHERE oid = typrelid) END AS typrelkind, "</literal>
						  <literal type="string">"typtype, typisdefined, "</literal>
						  <literal type="string">"typname[0] = '_' AND typelem != 0 AS isarray "</literal>
						  <literal type="string">"FROM pg_type"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tyinfo</name> <operator>=</operator> <operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TypeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rtypacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rtypacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_inittypacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inittypacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrtypacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrtypacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typelem</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typelem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typrelkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typrelkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_typisdefined</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typisdefined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_isarray</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"isarray"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rtypacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rtypacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inittypacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inittypacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrtypacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrtypacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typelem</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typelem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typrelkind</name> <operator>=</operator> <operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typrelkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>=</operator> <operator>*</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shellType</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typisdefined</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isDefined</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isDefined</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_isarray</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isArray</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isArray</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_typacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rtypacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inittypacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrtypacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a domain, fetch info about its constraints, if any
		 */</comment>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nDomChecks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>domChecks</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>getDomainConstraints</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If it's a base type, make a DumpableObject representing a shell
		 * definition of the type.  We will need to dump that ahead of the I/O
		 * functions for the type.  Similarly, range types need a shell
		 * definition in case they have a canonicalize function.
		 *
		 * Note: the shell type doesn't have a catId.  You might think it
		 * should copy the base type's catId, but then it might capture the
		 * pg_depend entries for the type, which we don't want.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_BASE</name> <operator>||</operator>
			 <name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>typtype</name> <operator>==</operator> <name>TYPTYPE_RANGE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stinfo</name> <operator>=</operator> <operator>(</operator><name>ShellTypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShellTypeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_SHELL_TYPE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>shellType</name> <operator>=</operator> <name>stinfo</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initially mark the shell type as not to be dumped.  We'll only
			 * dump it if the I/O or canonicalize functions need to be dumped;
			 * this is taken care of while sorting dependencies.
			 */</comment>
			<expr_stmt><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of data type \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>numTypes</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tyinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getOperators:
 *	  read all operators in the system catalogs and return them in the
 * OprInfo* structure
 *
 *	numOprs is set to the number of operators read in
 */</comment>
<function><type><name>OprInfo</name> <modifier>*</modifier></type>
<name>getOperators</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oprinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * find all operators, including builtin operators; we filter out
	 * system-defined operators at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, oprname, "</literal>
					  <literal type="string">"oprnamespace, "</literal>
					  <literal type="string">"(%s oprowner) AS rolname, "</literal>
					  <literal type="string">"oprkind, "</literal>
					  <literal type="string">"oprcode::oid AS oprcode "</literal>
					  <literal type="string">"FROM pg_operator"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOprs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprinfo</name> <operator>=</operator> <operator>(</operator><name>OprInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OprInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcode</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPERATOR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oprkind</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprkind</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oprcode</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oprcode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Operators do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of operator \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oprinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCollations:
 *	  read all collations in the system catalogs and return them in the
 * CollInfo* structure
 *
 *	numCollations is set to the number of collations read in
 */</comment>
<function><type><name>CollInfo</name> <modifier>*</modifier></type>
<name>getCollations</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numCollations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>collinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>

	<comment type="block">/* Collations didn't exist pre-9.1 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numCollations</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all collations, including builtin collations; we filter out
	 * system-defined collations at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, collname, "</literal>
					  <literal type="string">"collnamespace, "</literal>
					  <literal type="string">"(%s collowner) AS rolname "</literal>
					  <literal type="string">"FROM pg_collation"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numCollations</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>collinfo</name> <operator>=</operator> <operator>(</operator><name>CollInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CollInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_COLLATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_collname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_collnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collations do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>collinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>collinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getConversions:
 *	  read all conversions in the system catalogs and return them in the
 * ConvInfo* structure
 *
 *	numConversions is set to the number of conversions read in
 */</comment>
<function><type><name>ConvInfo</name> <modifier>*</modifier></type>
<name>getConversions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numConversions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConvInfo</name>   <modifier>*</modifier></type><name>convinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_connamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all conversions, including builtin conversions; we filter out
	 * system-defined conversions at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
					  <literal type="string">"connamespace, "</literal>
					  <literal type="string">"(%s conowner) AS rolname "</literal>
					  <literal type="string">"FROM pg_conversion"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numConversions</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>convinfo</name> <operator>=</operator> <operator>(</operator><name>ConvInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConvInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_connamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"connamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONVERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_connamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Conversions do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>convinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>convinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getAccessMethods:
 *	  read all user-defined access methods in the system catalogs and return
 *	  them in the AccessMethodInfo* structure
 *
 *	numAccessMethods is set to the number of access methods read in
 */</comment>
<function><type><name>AccessMethodInfo</name> <modifier>*</modifier></type>
<name>getAccessMethods</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numAccessMethods</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>aminfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amhandler</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amtype</name></decl>;</decl_stmt>

	<comment type="block">/* Before 9.6, there are no user-defined access methods */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numAccessMethods</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select all access methods from pg_am table */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, amname, amtype, "</literal>
					  <literal type="string">"amhandler::pg_catalog.regproc AS amhandler "</literal>
					  <literal type="string">"FROM pg_am"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numAccessMethods</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aminfo</name> <operator>=</operator> <operator>(</operator><name>AccessMethodInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AccessMethodInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amhandler</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amhandler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_ACCESS_METHOD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amhandler</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amhandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>amtype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableAccessMethod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Access methods do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>aminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>aminfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * getOpclasses:
 *	  read all opclasses in the system catalogs and return them in the
 * OpclassInfo* structure
 *
 *	numOpclasses is set to the number of opclasses read in
 */</comment>
<function><type><name>OpclassInfo</name> <modifier>*</modifier></type>
<name>getOpclasses</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOpclasses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * find all opclasses, including builtin opclasses; we filter out
	 * system-defined opclasses at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, opcname, "</literal>
					  <literal type="string">"opcnamespace, "</literal>
					  <literal type="string">"(%s opcowner) AS rolname "</literal>
					  <literal type="string">"FROM pg_opclass"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOpclasses</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>opcinfo</name> <operator>=</operator> <operator>(</operator><name>OpclassInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OpclassInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPCLASS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opcnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Op Classes do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of operator class \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>opcinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opcinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getOpfamilies:
 *	  read all opfamilies in the system catalogs and return them in the
 * OpfamilyInfo* structure
 *
 *	numOpfamilies is set to the number of opfamilies read in
 */</comment>
<function><type><name>OpfamilyInfo</name> <modifier>*</modifier></type>
<name>getOpfamilies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numOpfamilies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opfname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opfnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.3, there is no separate concept of opfamilies */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numOpfamilies</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all opfamilies, including builtin opfamilies; we filter out
	 * system-defined opfamilies at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, opfname, "</literal>
					  <literal type="string">"opfnamespace, "</literal>
					  <literal type="string">"(%s opfowner) AS rolname "</literal>
					  <literal type="string">"FROM pg_opfamily"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numOpfamilies</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>opfinfo</name> <operator>=</operator> <operator>(</operator><name>OpfamilyInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OpfamilyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opfnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opfnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_OPFAMILY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_opfnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extensions do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of operator family \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>opfinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opfinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getAggregates:
 *	  read all the user-defined aggregates in the system catalogs and
 * return them in the AggInfo* structure
 *
 * numAggs is set to the number of aggregates read in
 */</comment>
<function><type><name>AggInfo</name> <modifier>*</modifier></type>
<name>getAggregates</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numAggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggInfo</name>    <modifier>*</modifier></type><name>agginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_raggacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initaggacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initraggacl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all interesting aggregates.  See comment in getFuncs() for the
	 * rationale behind the filtering logic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>agg_check</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"p.proacl"</literal></expr></argument>, <argument><expr><literal type="string">"p.proowner"</literal></expr></argument>, <argument><expr><literal type="string">"'f'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>agg_check</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr> ?</condition><then> <expr><literal type="string">"p.prokind = 'a'"</literal></expr>
					 </then><else>: <expr><literal type="string">"p.proisagg"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, "</literal>
						  <literal type="string">"p.proname AS aggname, "</literal>
						  <literal type="string">"p.pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"p.pronargs, p.proargtypes, "</literal>
						  <literal type="string">"(%s p.proowner) AS rolname, "</literal>
						  <literal type="string">"%s AS aggacl, "</literal>
						  <literal type="string">"%s AS raggacl, "</literal>
						  <literal type="string">"%s AS initaggacl, "</literal>
						  <literal type="string">"%s AS initraggacl "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(p.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_proc'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE %s AND ("</literal>
						  <literal type="string">"p.pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog') OR "</literal>
						  <literal type="string">"p.proacl IS DISTINCT FROM pip.initprivs"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>agg_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">" OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, proname AS aggname, "</literal>
						  <literal type="string">"pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"pronargs, proargtypes, "</literal>
						  <literal type="string">"(%s proowner) AS rolname, "</literal>
						  <literal type="string">"proacl AS aggacl, "</literal>
						  <literal type="string">"NULL AS raggacl, "</literal>
						  <literal type="string">"NULL AS initaggacl, NULL AS initraggacl "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"WHERE proisagg AND ("</literal>
						  <literal type="string">"pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">" OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, proname AS aggname, "</literal>
						  <literal type="string">"pronamespace AS aggnamespace, "</literal>
						  <literal type="string">"CASE WHEN proargtypes[0] = 'pg_catalog.\"any\"'::pg_catalog.regtype THEN 0 ELSE 1 END AS pronargs, "</literal>
						  <literal type="string">"proargtypes, "</literal>
						  <literal type="string">"(%s proowner) AS rolname, "</literal>
						  <literal type="string">"proacl AS aggacl, "</literal>
						  <literal type="string">"NULL AS raggacl, "</literal>
						  <literal type="string">"NULL AS initaggacl, NULL AS initraggacl "</literal>
						  <literal type="string">"FROM pg_proc "</literal>
						  <literal type="string">"WHERE proisagg "</literal>
						  <literal type="string">"AND pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog')"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numAggs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>agginfo</name> <operator>=</operator> <operator>(</operator><name>AggInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AggInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proargtypes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargtypes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_raggacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"raggacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initaggacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initaggacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initraggacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initraggacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_AGG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>rolname</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of aggregate function \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>lang</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt> <comment type="block">/* not currently interesting */</comment>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>prorettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* not saved */</comment>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>proacl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>rproacl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_raggacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>initproacl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initaggacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>initrproacl</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initraggacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proargtypes</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>argtypes</name></name></expr></argument>,
						  <argument><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_aggacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_raggacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initaggacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initraggacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>agginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getFuncs:
 *	  read all the user-defined functions in the system catalogs and
 * return them in the FuncInfo* structure
 *
 * numFuncs is set to the number of functions read in
 */</comment>
<function><type><name>FuncInfo</name> <modifier>*</modifier></type>
<name>getFuncs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numFuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prolang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_pronargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prorettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rproacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initproacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrproacl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all interesting functions.  This is a bit complicated:
	 *
	 * 1. Always exclude aggregates; those are handled elsewhere.
	 *
	 * 2. Always exclude functions that are internally dependent on something
	 * else, since presumably those will be created as a result of creating
	 * the something else.  This currently acts only to suppress constructor
	 * functions for range types (so we only need it in 9.2 and up).  Note
	 * this is OK only because the constructors don't have any dependencies
	 * the range type doesn't have; otherwise we might not get creation
	 * ordering correct.
	 *
	 * 3. Otherwise, we normally exclude functions in pg_catalog.  However, if
	 * they're members of extensions and we are in binary-upgrade mode then
	 * include them, since we want to dump extension members individually in
	 * that mode.  Also, if they are used by casts or transforms then we need
	 * to gather the information about them, though they won't be dumped if
	 * they are built-in.  Also, in 9.6 and up, include functions in
	 * pg_catalog if they have an ACL different from what's shown in
	 * pg_init_privs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>not_agg_check</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"p.proacl"</literal></expr></argument>, <argument><expr><literal type="string">"p.proowner"</literal></expr></argument>, <argument><expr><literal type="string">"'f'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>not_agg_check</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr> ?</condition><then> <expr><literal type="string">"p.prokind &lt;&gt; 'a'"</literal></expr>
						 </then><else>: <expr><literal type="string">"NOT p.proisagg"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT p.tableoid, p.oid, p.proname, p.prolang, "</literal>
						  <literal type="string">"p.pronargs, p.proargtypes, p.prorettype, "</literal>
						  <literal type="string">"%s AS proacl, "</literal>
						  <literal type="string">"%s AS rproacl, "</literal>
						  <literal type="string">"%s AS initproacl, "</literal>
						  <literal type="string">"%s AS initrproacl, "</literal>
						  <literal type="string">"p.pronamespace, "</literal>
						  <literal type="string">"(%s p.proowner) AS rolname "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(p.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_proc'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE %s"</literal>
						  <literal type="string">"\n  AND NOT EXISTS (SELECT 1 FROM pg_depend "</literal>
						  <literal type="string">"WHERE classid = 'pg_proc'::regclass AND "</literal>
						  <literal type="string">"objid = p.oid AND deptype = 'i')"</literal>
						  <literal type="string">"\n  AND ("</literal>
						  <literal type="string">"\n  pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_cast"</literal>
						  <literal type="string">"\n  WHERE pg_cast.oid &gt; %u "</literal>
						  <literal type="string">"\n  AND p.oid = pg_cast.castfunc)"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_transform"</literal>
						  <literal type="string">"\n  WHERE pg_transform.oid &gt; %u AND "</literal>
						  <literal type="string">"\n  (p.oid = pg_transform.trffromsql"</literal>
						  <literal type="string">"\n  OR p.oid = pg_transform.trftosql))"</literal></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>not_agg_check</name></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							 <argument><expr><literal type="string">"\n  OR p.proacl IS DISTINCT FROM pip.initprivs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT tableoid, oid, proname, prolang, "</literal>
						  <literal type="string">"pronargs, proargtypes, prorettype, proacl, "</literal>
						  <literal type="string">"NULL as rproacl, "</literal>
						  <literal type="string">"NULL as initproacl, NULL AS initrproacl, "</literal>
						  <literal type="string">"pronamespace, "</literal>
						  <literal type="string">"(%s proowner) AS rolname "</literal>
						  <literal type="string">"FROM pg_proc p "</literal>
						  <literal type="string">"WHERE NOT proisagg"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  AND NOT EXISTS (SELECT 1 FROM pg_depend "</literal>
								 <literal type="string">"WHERE classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND deptype = 'i')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"\n  AND ("</literal>
						  <literal type="string">"\n  pronamespace != "</literal>
						  <literal type="string">"(SELECT oid FROM pg_namespace "</literal>
						  <literal type="string">"WHERE nspname = 'pg_catalog')"</literal>
						  <literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_cast"</literal>
						  <literal type="string">"\n  WHERE pg_cast.oid &gt; '%u'::oid"</literal>
						  <literal type="string">"\n  AND p.oid = pg_cast.castfunc)"</literal></expr></argument>,
						  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"\n  OR EXISTS (SELECT 1 FROM pg_transform"</literal>
							  <literal type="string">"\n  WHERE pg_transform.oid &gt; '%u'::oid"</literal>
							  <literal type="string">"\n  AND (p.oid = pg_transform.trffromsql"</literal>
							  <literal type="string">"\n  OR p.oid = pg_transform.trftosql))"</literal></expr></argument>,
							  <argument><expr><name>g_last_builtin_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
								 <argument><expr><literal type="string">"\n  OR EXISTS(SELECT 1 FROM pg_depend WHERE "</literal>
								 <literal type="string">"classid = 'pg_proc'::regclass AND "</literal>
								 <literal type="string">"objid = p.oid AND "</literal>
								 <literal type="string">"refclassid = 'pg_extension'::regclass AND "</literal>
								 <literal type="string">"deptype = 'e')"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numFuncs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>finfo</name> <operator>=</operator> <operator>(</operator><name>FuncInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FuncInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prolang</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prolang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_pronargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"pronargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proargtypes</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargtypes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prorettype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prorettype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rproacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rproacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initproacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initproacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrproacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrproacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FUNC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lang</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prolang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prorettype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prorettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>proacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rproacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rproacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initproacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initproacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrproacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrproacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_pronargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proargtypes</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argtypes</name></expr></argument>, <argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_proacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rproacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initproacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrproacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">"WARNING: owner of function \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>finfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>finfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>catalogTableExists</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tablename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT 1 FROM pg_class WHERE relname = '%s' "</literal>
					  <literal type="string">"AND relnamespace = 'pg_catalog'::regnamespace"</literal></expr></argument>,
					  <argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>exists</name> <init>= <expr><operator>(</operator><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTables
 *	  read all the tables (no indexes)
 * in the system catalogs return them in the TableInfo* structure
 *
 * numTables is set to the number of tables read in
 */</comment>
<function><type><name>TableInfo</name> <modifier>*</modifier></type>
<name>getTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reltableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rrelacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrelacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrrelacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relchecks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhastriggers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasrules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relrowsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relforcerowsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relhasoids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relfrozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relminmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastfrozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastminmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relpersistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relispopulated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relreplident</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_owning_tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_owning_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reltablespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_checkoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_toastreloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_reloftype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_relpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_is_identity_sequence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_changed_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_partkeydef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ispartition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_partbound</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all the tables and table-like objects.
	 *
	 * We include system catalogs, so that we can work if a user table is
	 * defined to inherit from a system catalog (pretty weird, but...)
	 *
	 * We ignore relations that are not ordinary tables, sequences, views,
	 * materialized views, composite types, or foreign tables.
	 *
	 * Composite-type table entries won't be dumped as such, but we have to
	 * make a DumpableObject for them so that we can track dependencies of the
	 * composite type (pg_depend entries for columns of the composite type
	 * link to the pg_class entry not the pg_type entry).
	 *
	 * Note: in this phase we should collect only a minimal amount of
	 * information about each table, basically just enough to decide if it is
	 * interesting. We must fetch all tables in this phase because otherwise
	 * we cannot correctly identify inherited columns, owned sequences, etc.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partkeydef</name> <init>= <expr><literal type="string">"NULL"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ispartition</name> <init>= <expr><literal type="string">"false"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>partbound</name> <init>= <expr><literal type="string">"NULL"</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>attacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>attracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>attinitacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>attinitracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Collect the information about any partitioned tables, which were
		 * added in PG10.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partkeydef</name> <operator>=</operator> <literal type="string">"pg_get_partkeydef(c.oid)"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ispartition</name> <operator>=</operator> <literal type="string">"c.relispartition"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>partbound</name> <operator>=</operator> <literal type="string">"pg_get_expr(c.relpartbound, c.oid)"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 *
		 * Left join to detect if any privileges are still as-set-at-init, in
		 * which case we won't dump out ACL commands for those.
		 */</comment>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"c.relacl"</literal></expr></argument>, <argument><expr><literal type="string">"c.relowner"</literal></expr></argument>,
						<argument><expr><literal type="string">"CASE WHEN c.relkind = "</literal> <call><name>CppAsString2</name><argument_list>(<argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call>
						<literal type="string">" THEN 's' ELSE 'r' END::\"char\""</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>attacl_subquery</name></expr></argument>, <argument><expr><name>attracl_subquery</name></expr></argument>, <argument><expr><name>attinitacl_subquery</name></expr></argument>,
						<argument><expr><name>attinitracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"at.attacl"</literal></expr></argument>, <argument><expr><literal type="string">"c.relowner"</literal></expr></argument>, <argument><expr><literal type="string">"'c'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"%s AS relacl, %s as rrelacl, "</literal>
						  <literal type="string">"%s AS initrelacl, %s as initrrelacl, "</literal>
						  <literal type="string">"c.relkind, c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, c.relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"tc.relminmxid AS tminmxid, "</literal>
						  <literal type="string">"c.relpersistence, c.relispopulated, "</literal>
						  <literal type="string">"c.relreplident, c.relpages, "</literal></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "</literal>
						  <literal type="string">"CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text "</literal>
						  <literal type="string">"WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"c.relkind = '%c' AND EXISTS (SELECT 1 FROM pg_depend WHERE classid = 'pg_class'::regclass AND objid = c.oid AND objsubid = 0 AND refclassid = 'pg_class'::regclass AND deptype = 'i') AS is_identity_sequence, "</literal>
						  <literal type="string">"EXISTS (SELECT 1 FROM pg_attribute at LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(c.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_class'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = at.attnum)"</literal>
						  <literal type="string">"WHERE at.attrelid = c.oid AND ("</literal>
						  <literal type="string">"%s IS NOT NULL "</literal>
						  <literal type="string">"OR %s IS NOT NULL "</literal>
						  <literal type="string">"OR %s IS NOT NULL "</literal>
						  <literal type="string">"OR %s IS NOT NULL"</literal>
						  <literal type="string">"))"</literal>
						  <literal type="string">"AS changed_acl, "</literal>
						  <literal type="string">"%s AS partkeydef, "</literal>
						  <literal type="string">"%s AS ispartition, "</literal>
						  <literal type="string">"%s AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name><name>attacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>attracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>attinitacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>attinitracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>partkeydef</name></expr></argument>,
						  <argument><expr><name>ispartition</name></expr></argument>,
						  <argument><expr><name>partbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype IN ('a', 'i')) "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(c.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_class'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>,
						  <argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>attacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>attracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>attinitacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>attinitracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"c.relrowsecurity, c.relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, c.relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"tc.relminmxid AS tminmxid, "</literal>
						  <literal type="string">"c.relpersistence, c.relispopulated, "</literal>
						  <literal type="string">"c.relreplident, c.relpages, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "</literal>
						  <literal type="string">"CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text "</literal>
						  <literal type="string">"WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, c.relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"tc.relminmxid AS tminmxid, "</literal>
						  <literal type="string">"c.relpersistence, c.relispopulated, "</literal>
						  <literal type="string">"c.relreplident, c.relpages, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "</literal>
						  <literal type="string">"CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text "</literal>
						  <literal type="string">"WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90300</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, c.relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"tc.relminmxid AS tminmxid, "</literal>
						  <literal type="string">"c.relpersistence, c.relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, c.relpages, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"array_remove(array_remove(c.reloptions,'check_option=local'),'check_option=cascaded') AS reloptions, "</literal>
						  <literal type="string">"CASE WHEN 'check_option=local' = ANY (c.reloptions) THEN 'LOCAL'::text "</literal>
						  <literal type="string">"WHEN 'check_option=cascaded' = ANY (c.reloptions) THEN 'CASCADED'::text ELSE NULL END AS checkoption, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, 0 AS relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"0 AS tminmxid, "</literal>
						  <literal type="string">"c.relpersistence, 't' as relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, c.relpages, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"c.reloptions AS reloptions, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>,
						  <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, 0 AS relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"0 AS tminmxid, "</literal>
						  <literal type="string">"'p' AS relpersistence, 't' as relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, c.relpages, "</literal>
						  <literal type="string">"CASE WHEN c.reloftype &lt;&gt; 0 THEN c.reloftype::pg_catalog.regtype ELSE NULL END AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"c.reloptions AS reloptions, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, c.relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, 0 AS relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"0 AS tminmxid, "</literal>
						  <literal type="string">"'p' AS relpersistence, 't' as relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, c.relpages, "</literal>
						  <literal type="string">"NULL AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"c.reloptions AS reloptions, "</literal>
						  <literal type="string">"tc.reloptions AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any (note this dependency is AUTO as of 8.2)
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, c.relname, "</literal>
						  <literal type="string">"c.relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"c.relkind, "</literal>
						  <literal type="string">"c.relnamespace, "</literal>
						  <literal type="string">"(%s c.relowner) AS rolname, "</literal>
						  <literal type="string">"c.relchecks, (c.reltriggers &lt;&gt; 0) AS relhastriggers, "</literal>
						  <literal type="string">"c.relhasindex, c.relhasrules, c.relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"c.relfrozenxid, 0 AS relminmxid, tc.oid AS toid, "</literal>
						  <literal type="string">"tc.relfrozenxid AS tfrozenxid, "</literal>
						  <literal type="string">"0 AS tminmxid, "</literal>
						  <literal type="string">"'p' AS relpersistence, 't' as relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, c.relpages, "</literal>
						  <literal type="string">"NULL AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"c.reloptions AS reloptions, "</literal>
						  <literal type="string">"NULL AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'a') "</literal>
						  <literal type="string">"LEFT JOIN pg_class tc ON (c.reltoastrelid = tc.oid) "</literal>
						  <literal type="string">"WHERE c.relkind in ('%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Left join to pick up dependency info linking sequences to their
		 * owning column, if any
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT c.tableoid, c.oid, relname, "</literal>
						  <literal type="string">"relacl, NULL as rrelacl, "</literal>
						  <literal type="string">"NULL AS initrelacl, NULL AS initrrelacl, "</literal>
						  <literal type="string">"relkind, relnamespace, "</literal>
						  <literal type="string">"(%s relowner) AS rolname, "</literal>
						  <literal type="string">"relchecks, (reltriggers &lt;&gt; 0) AS relhastriggers, "</literal>
						  <literal type="string">"relhasindex, relhasrules, relhasoids, "</literal>
						  <literal type="string">"'f'::bool AS relrowsecurity, "</literal>
						  <literal type="string">"'f'::bool AS relforcerowsecurity, "</literal>
						  <literal type="string">"0 AS relfrozenxid, 0 AS relminmxid,"</literal>
						  <literal type="string">"0 AS toid, "</literal>
						  <literal type="string">"0 AS tfrozenxid, 0 AS tminmxid,"</literal>
						  <literal type="string">"'p' AS relpersistence, 't' as relispopulated, "</literal>
						  <literal type="string">"'d' AS relreplident, relpages, "</literal>
						  <literal type="string">"NULL AS reloftype, "</literal>
						  <literal type="string">"d.refobjid AS owning_tab, "</literal>
						  <literal type="string">"d.refobjsubid AS owning_col, "</literal>
						  <literal type="string">"(SELECT spcname FROM pg_tablespace t WHERE t.oid = c.reltablespace) AS reltablespace, "</literal>
						  <literal type="string">"NULL AS reloptions, "</literal>
						  <literal type="string">"NULL AS toast_reloptions, "</literal>
						  <literal type="string">"NULL AS changed_acl, "</literal>
						  <literal type="string">"NULL AS partkeydef, "</literal>
						  <literal type="string">"false AS ispartition, "</literal>
						  <literal type="string">"NULL AS partbound "</literal>
						  <literal type="string">"FROM pg_class c "</literal>
						  <literal type="string">"LEFT JOIN pg_depend d ON "</literal>
						  <literal type="string">"(c.relkind = '%c' AND "</literal>
						  <literal type="string">"d.classid = c.tableoid AND d.objid = c.oid AND "</literal>
						  <literal type="string">"d.objsubid = 0 AND "</literal>
						  <literal type="string">"d.refclassid = c.tableoid AND d.deptype = 'i') "</literal>
						  <literal type="string">"WHERE relkind in ('%c', '%c', '%c', '%c') "</literal>
						  <literal type="string">"ORDER BY c.oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_RELATION</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>,
						  <argument><expr><name>RELKIND_VIEW</name></expr></argument>, <argument><expr><name>RELKIND_COMPOSITE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numTables</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Extract data from result and lock dumpable tables.  We do the locking
	 * before anything else, to minimize the window wherein a table could
	 * disappear under us.
	 *
	 * Note that we have to save info about all tables here, even when dumping
	 * only one, because we don't yet know which tables might be inheritance
	 * ancestors of the target table.
	 */</comment>
	<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_reltableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rrelacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rrelacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrelacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrelacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrrelacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrrelacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relchecks</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relchecks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhastriggers</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhastriggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasindex</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasrules</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasrules"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relrowsec</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relrowsecurity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relforcerowsec</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relforcerowsecurity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relhasoids</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relhasoids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastfrozenxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tfrozenxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastminmxid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tminmxid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relpersistence</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relpersistence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relispopulated</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relispopulated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relreplident</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_relpages</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relpages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_owning_tab</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"owning_tab"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_owning_col</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"owning_col"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reltablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reltablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_checkoption</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"checkoption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_toastreloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"toast_reloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_reloftype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"reloftype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_is_identity_sequence</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"is_identity_sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_changed_acl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"changed_acl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_partkeydef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partkeydef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ispartition</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ispartition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_partbound</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"partbound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Arrange to fail instead of waiting forever for a table lock.
		 *
		 * NB: this coding assumes that the only queries issued within the
		 * following loop are LOCK TABLEs; else the timeout may be undesirably
		 * applied to other things too.
		 */</comment>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralConn</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr></argument>, <argument><expr><call><name>GetConnection</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reltableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rrelacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rrelacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrelacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrelacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrrelacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrrelacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relkind</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relpersistence</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relpersistence</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasindex</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasindex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasrules</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasrules</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hastriggers</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhastriggers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rowsec</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relrowsec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forcerowsec</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relforcerowsec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hasoids</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relhasoids</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relispopulated</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relispopulated</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relreplident</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relreplident</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relpages</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relpages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_frozenxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_minmxid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloftype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloftype</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloftype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloftype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ncheck</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relchecks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_tab</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_tab</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_tab</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>owning_col</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_owning_col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reltablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reltablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_reloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i_checkoption</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_checkoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checkoption</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>checkoption</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_checkoption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>toast_reloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_toastreloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* other fields were zeroed above */</comment>

		<comment type="block">/*
		 * Decide whether we want to dump this table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>selectDumpableTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If the table-level and all column-level ACLs for this table are
		 * unchanged, then we don't need to worry about including the ACLs for
		 * this table.  If any column-level ACLs have been changed, the
		 * 'changed_acl' column from the query will indicate that.
		 *
		 * This can result in a significant performance improvement in cases
		 * where we are only looking to dump out the ACL (eg: pg_catalog).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_relacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rrelacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrelacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrrelacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_changed_acl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>interesting</name> <operator>=</operator> <ternary><condition><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dummy_view</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get set during sort */</comment>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>postponed_def</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* might get set during sort */</comment>

		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_identity_sequence</name> <operator>=</operator> <operator>(</operator><name>i_is_identity_sequence</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
										   <call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_is_identity_sequence</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Partition key string or NULL */</comment>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>partkeydef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partkeydef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ispartition</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ispartition</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>partbound</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_partbound</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Read-lock target tables to make sure they aren't DROPPED or altered
		 * in schema before we get around to dumping them.
		 *
		 * Note that we don't explicitly lock parents of the target tables; we
		 * assume our lock on the child is enough to prevent schema
		 * alterations to parent tables.
		 *
		 * NOTE: it'd be kinda nice to lock other relations too, not only
		 * plain or partitioned tables, but the backend doesn't presently
		 * allow that.
		 *
		 * We only need to lock the table for certain components; see
		 * pg_dump.h
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENTS_REQUIRING_LOCK</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS SHARE MODE"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Emit notice if join for owner failed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: owner of table \"%s\" appears to be invalid\n"</literal></expr></argument>,
					  <argument><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>lockWaitTimeout</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteSqlStatement</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SET statement_timeout = 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tblinfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * getTablegroups:
 *	  read all user-defined tablegroups in the system catalogs and return
 *	  them in the TablegroupInfo* structure
 *
 *	numTablegroups is set to the number of tablegroups read in
 */</comment>
<function><type><name>TablegroupInfo</name> <modifier>*</modifier></type>
<name>getTablegroups</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTablegroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TablegroupInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpracl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpinitacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpinitracl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grpoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_grptablespace</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pg_yb_tablegroup_exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pg_tablegroup_exists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTablegroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>init_racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>init_acl_subquery</name></expr></argument>,
					<argument><expr><name>init_racl_subquery</name></expr></argument>, <argument><expr><literal type="string">"tg.grpacl"</literal></expr></argument>, <argument><expr><literal type="string">"tg.grpowner"</literal></expr></argument>, <argument><expr><literal type="string">"'g'"</literal></expr></argument>,
					<argument><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select all tablegroups from pg_tablegroup or pg_yb_tablegroup table */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT grpname, tg.oid, grpoptions, "</literal>
					  <literal type="string">"(%s grpowner) AS owner, "</literal>
					  <literal type="string">"(%s) AS grptablespace, "</literal>
					  <literal type="string">"%s AS acl, "</literal>
					  <literal type="string">"%s AS racl, "</literal>
					  <literal type="string">"%s AS initacl, "</literal>
					  <literal type="string">"%s AS initracl "</literal>
					  <literal type="string">"FROM %s AS tg "</literal>
					  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
					  <literal type="string">"tg.oid = pip.objoid"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>pg_yb_tablegroup_exists</name></expr> ?</condition><then>
						  <expr><literal type="string">"SELECT spcname FROM pg_tablespace t WHERE t.oid = grptablespace"</literal></expr> </then><else>:
						  <expr><literal type="string">"NULL"</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					  <argument><expr><name><name>init_acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					  <argument><expr><name><name>init_racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>pg_yb_tablegroup_exists</name></expr> ?</condition><then> <expr><literal type="string">"pg_yb_tablegroup"</literal></expr> </then><else>: <expr><literal type="string">"pg_tablegroup"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>init_racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTablegroups</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tbinfo</name> <operator>=</operator> <operator>(</operator><name>TablegroupInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TablegroupInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_grpname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"grpname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"owner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"grpoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"acl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpracl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"racl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpinitacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grpinitracl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initracl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_grptablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"grptablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TABLEGROUP</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add the object to a global lookup map */</comment>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpowner</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grptablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grptablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpracl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpracl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpinitacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpinitacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpinitracl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpinitracl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>grpoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_grpoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tbinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getOwnedSeqs
 *	  identify owned sequences and mark them as dumpable if owning table is
 *
 * We used to do this in getTables(), but it's better to do it after the
 * index used by findTableByOid() has been set up.
 */</comment>
<function><type><name>void</name></type>
<name>getOwnedSeqs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Force sequences that are "owned" by table columns to be dumped whenever
	 * their owning table is being dumped.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>seqinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not an owned sequence */</comment>

		<expr_stmt><expr><name>owning_tab</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>owning_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"failed sanity check, parent table with OID %u of sequence with OID %u not found\n"</literal></expr></argument>,
						  <argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>, <argument><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Only dump identity sequences if we're going to dump the table that
		 * it belongs to.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>==</operator> <name>DUMP_COMPONENT_NONE</name> <operator>&amp;&amp;</operator>
			<name><name>seqinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_NONE</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise we need to dump the components that are being dumped for
		 * the table and any components which the sequence is explicitly
		 * marked with.
		 *
		 * We can't simply use the set of components which are being dumped
		 * for the table as the table might be in an extension (and only the
		 * non-extension components, eg: ACLs if changed, security labels, and
		 * policies, are being dumped) while the sequence is not (and
		 * therefore the definition and other components should also be
		 * dumped).
		 *
		 * If the sequence is part of the extension then it should be properly
		 * marked by checkExtensionMembership() and this will be a no-op as
		 * the table will be equivalently marked.
		 */</comment>
		<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>|</operator> <name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seqinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>!=</operator> <name>DUMP_COMPONENT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>seqinfo</name><operator>-&gt;</operator><name>interesting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getInherits
 *	  read all the inheritance information
 * from the system catalogs return them in the InhInfo* structure
 *
 * numInherits is set to the number of pairs read in
 */</comment>
<function><type><name>InhInfo</name> <modifier>*</modifier></type>
<name>getInherits</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numInherits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InhInfo</name>    <modifier>*</modifier></type><name>inhinfo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i_inhrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_inhparent</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all the inheritance information, excluding implicit inheritance
	 * via partitioning.  We handle that case using getPartitions(), because
	 * we want more information about partitions than just the parent-child
	 * relationship.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT inhrelid, inhparent FROM pg_inherits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numInherits</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>inhinfo</name> <operator>=</operator> <operator>(</operator><name>InhInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>InhInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_inhrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inhrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_inhparent</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"inhparent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inhrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhparent</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_inhparent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>inhinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getIndexes
 *	  get information about every index on a dumpable table
 *
 * Note: index data is not returned directly to the caller, but it
 * does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getIndexes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>indxinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_indexname</name></decl>,
				<decl><type ref="prev"/><name>i_parentidx</name></decl>,
				<decl><type ref="prev"/><name>i_indexdef</name></decl>,
				<decl><type ref="prev"/><name>i_indnkeyatts</name></decl>,
				<decl><type ref="prev"/><name>i_indnatts</name></decl>,
				<decl><type ref="prev"/><name>i_indkey</name></decl>,
				<decl><type ref="prev"/><name>i_indisclustered</name></decl>,
				<decl><type ref="prev"/><name>i_indisreplident</name></decl>,
				<decl><type ref="prev"/><name>i_indoption</name></decl>,
				<decl><type ref="prev"/><name>i_contype</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_condeferrable</name></decl>,
				<decl><type ref="prev"/><name>i_condeferred</name></decl>,
				<decl><type ref="prev"/><name>i_contableoid</name></decl>,
				<decl><type ref="prev"/><name>i_conoid</name></decl>,
				<decl><type ref="prev"/><name>i_condef</name></decl>,
				<decl><type ref="prev"/><name>i_tablespace</name></decl>,
				<decl><type ref="prev"/><name>i_indreloptions</name></decl>,
				<decl><type ref="prev"/><name>i_relpages</name></decl>,
				<decl><type ref="prev"/><name>i_indstatcols</name></decl>,
				<decl><type ref="prev"/><name>i_indstatvals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hasindex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore indexes of tables whose definitions are not to be dumped.
		 *
		 * We also need indexes on partitioned tables which have partitions to
		 * be dumped, in order to dump the indexes on the partitions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading indexes for table \"%s.%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The point of the messy-looking outer join is to find a constraint
		 * that is related by an internal dependency link to the index. If we
		 * find one, create a CONSTRAINT entry linked to the INDEX entry.  We
		 * assume an index won't have more than one internal dependency.
		 *
		 * As of 9.0 we don't need to look at pg_depend but can check for a
		 * match to pg_constraint.conindid.  The check on conrelid is
		 * redundant but useful because that column is indexed while conindid
		 * is not.
		 */</comment>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, "</literal>
							  <literal type="string">"t.relname AS indexname, "</literal>
							  <literal type="string">"inh.inhparent AS parentidx, "</literal>
							  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
							  <literal type="string">"i.indnkeyatts AS indnkeyatts, "</literal>
							  <literal type="string">"i.indnatts AS indnatts, "</literal>
							  <literal type="string">"i.indkey, i.indisclustered, "</literal>
							  <literal type="string">"i.indisreplident, i.indoption, t.relpages, "</literal>
							  <literal type="string">"c.contype, c.conname, "</literal>
							  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
							  <literal type="string">"c.tableoid AS contableoid, "</literal>
							  <literal type="string">"c.oid AS conoid, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, "</literal>
							  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
							  <literal type="string">"t.reloptions AS indreloptions, "</literal>
							  <literal type="string">"(SELECT pg_catalog.array_agg(attnum ORDER BY attnum) "</literal>
							  <literal type="string">"  FROM pg_catalog.pg_attribute "</literal>
							  <literal type="string">"  WHERE attrelid = i.indexrelid AND "</literal>
							  <literal type="string">"    attstattarget &gt;= 0) AS indstatcols,"</literal>
							  <literal type="string">"(SELECT pg_catalog.array_agg(attstattarget ORDER BY attnum) "</literal>
							  <literal type="string">"  FROM pg_catalog.pg_attribute "</literal>
							  <literal type="string">"  WHERE attrelid = i.indexrelid AND "</literal>
							  <literal type="string">"    attstattarget &gt;= 0) AS indstatvals "</literal>
							  <literal type="string">"FROM pg_catalog.pg_index i "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t2 ON (t2.oid = i.indrelid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
							  <literal type="string">"ON (i.indrelid = c.conrelid AND "</literal>
							  <literal type="string">"i.indexrelid = c.conindid AND "</literal>
							  <literal type="string">"c.contype IN ('p','u','x')) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_inherits inh "</literal>
							  <literal type="string">"ON (inh.inhrelid = indexrelid) "</literal>
							  <literal type="string">"WHERE i.indrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND (i.indisvalid OR t2.relkind = 'p') "</literal>
							  <literal type="string">"AND i.indisready "</literal>
							  <literal type="string">"ORDER BY indexname"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * the test on indisready is necessary in 9.2, and harmless in
			 * earlier/later versions
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, "</literal>
							  <literal type="string">"t.relname AS indexname, "</literal>
							  <literal type="string">"0 AS parentidx, "</literal>
							  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
							  <literal type="string">"i.indnatts AS indnkeyatts, "</literal>
							  <literal type="string">"i.indnatts AS indnatts, "</literal>
							  <literal type="string">"i.indkey, i.indisclustered, "</literal>
							  <literal type="string">"i.indisreplident, i.indoption, t.relpages, "</literal>
							  <literal type="string">"c.contype, c.conname, "</literal>
							  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
							  <literal type="string">"c.tableoid AS contableoid, "</literal>
							  <literal type="string">"c.oid AS conoid, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, "</literal>
							  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
							  <literal type="string">"t.reloptions AS indreloptions, "</literal>
							  <literal type="string">"'' AS indstatcols, "</literal>
							  <literal type="string">"'' AS indstatvals "</literal>
							  <literal type="string">"FROM pg_catalog.pg_index i "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
							  <literal type="string">"ON (i.indrelid = c.conrelid AND "</literal>
							  <literal type="string">"i.indexrelid = c.conindid AND "</literal>
							  <literal type="string">"c.contype IN ('p','u','x')) "</literal>
							  <literal type="string">"WHERE i.indrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND i.indisvalid AND i.indisready "</literal>
							  <literal type="string">"ORDER BY indexname"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * the test on indisready is necessary in 9.2, and harmless in
			 * earlier/later versions
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, "</literal>
							  <literal type="string">"t.relname AS indexname, "</literal>
							  <literal type="string">"0 AS parentidx, "</literal>
							  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
							  <literal type="string">"i.indnatts AS indnkeyatts, "</literal>
							  <literal type="string">"i.indnatts AS indnatts, "</literal>
							  <literal type="string">"i.indkey, i.indisclustered, "</literal>
							  <literal type="string">"false AS indisreplident, i.indoption, t.relpages, "</literal>
							  <literal type="string">"c.contype, c.conname, "</literal>
							  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
							  <literal type="string">"c.tableoid AS contableoid, "</literal>
							  <literal type="string">"c.oid AS conoid, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(c.oid, false) AS condef, "</literal>
							  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
							  <literal type="string">"t.reloptions AS indreloptions, "</literal>
							  <literal type="string">"'' AS indstatcols, "</literal>
							  <literal type="string">"'' AS indstatvals "</literal>
							  <literal type="string">"FROM pg_catalog.pg_index i "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
							  <literal type="string">"ON (i.indrelid = c.conrelid AND "</literal>
							  <literal type="string">"i.indexrelid = c.conindid AND "</literal>
							  <literal type="string">"c.contype IN ('p','u','x')) "</literal>
							  <literal type="string">"WHERE i.indrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND i.indisvalid AND i.indisready "</literal>
							  <literal type="string">"ORDER BY indexname"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80200</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, "</literal>
							  <literal type="string">"t.relname AS indexname, "</literal>
							  <literal type="string">"0 AS parentidx, "</literal>
							  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
							  <literal type="string">"i.indnatts AS indnkeyatts, "</literal>
							  <literal type="string">"i.indnatts AS indnatts, "</literal>
							  <literal type="string">"i.indkey, i.indisclustered, "</literal>
							  <literal type="string">"false AS indisreplident, i.indoption, t.relpages, "</literal>
							  <literal type="string">"c.contype, c.conname, "</literal>
							  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
							  <literal type="string">"c.tableoid AS contableoid, "</literal>
							  <literal type="string">"c.oid AS conoid, "</literal>
							  <literal type="string">"null AS condef, "</literal>
							  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
							  <literal type="string">"t.reloptions AS indreloptions, "</literal>
							  <literal type="string">"'' AS indstatcols, "</literal>
							  <literal type="string">"'' AS indstatvals "</literal>
							  <literal type="string">"FROM pg_catalog.pg_index i "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_depend d "</literal>
							  <literal type="string">"ON (d.classid = t.tableoid "</literal>
							  <literal type="string">"AND d.objid = t.oid "</literal>
							  <literal type="string">"AND d.deptype = 'i') "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
							  <literal type="string">"ON (d.refclassid = c.tableoid "</literal>
							  <literal type="string">"AND d.refobjid = c.oid) "</literal>
							  <literal type="string">"WHERE i.indrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND i.indisvalid "</literal>
							  <literal type="string">"ORDER BY indexname"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tableoid, t.oid, "</literal>
							  <literal type="string">"t.relname AS indexname, "</literal>
							  <literal type="string">"0 AS parentidx, "</literal>
							  <literal type="string">"pg_catalog.pg_get_indexdef(i.indexrelid) AS indexdef, "</literal>
							  <literal type="string">"t.relnatts AS indnkeyatts, "</literal>
							  <literal type="string">"t.relnatts AS indnatts, "</literal>
							  <literal type="string">"i.indkey, i.indisclustered, "</literal>
							  <literal type="string">"false AS indisreplident, i.indoption, t.relpages, "</literal>
							  <literal type="string">"c.contype, c.conname, "</literal>
							  <literal type="string">"c.condeferrable, c.condeferred, "</literal>
							  <literal type="string">"c.tableoid AS contableoid, "</literal>
							  <literal type="string">"c.oid AS conoid, "</literal>
							  <literal type="string">"null AS condef, "</literal>
							  <literal type="string">"(SELECT spcname FROM pg_catalog.pg_tablespace s WHERE s.oid = t.reltablespace) AS tablespace, "</literal>
							  <literal type="string">"null AS indreloptions, "</literal>
							  <literal type="string">"'' AS indstatcols, "</literal>
							  <literal type="string">"'' AS indstatvals "</literal>
							  <literal type="string">"FROM pg_catalog.pg_index i "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class t ON (t.oid = i.indexrelid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_depend d "</literal>
							  <literal type="string">"ON (d.classid = t.tableoid "</literal>
							  <literal type="string">"AND d.objid = t.oid "</literal>
							  <literal type="string">"AND d.deptype = 'i') "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_constraint c "</literal>
							  <literal type="string">"ON (d.refclassid = c.tableoid "</literal>
							  <literal type="string">"AND d.refobjid = c.oid) "</literal>
							  <literal type="string">"WHERE i.indrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"ORDER BY indexname"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indexname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_parentidx</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"parentidx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indexdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indexdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indnkeyatts</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indnkeyatts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indnatts</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indnatts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indkey</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indisclustered</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indisclustered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indisreplident</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indisreplident"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indoption</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indoption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_relpages</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"relpages"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_contype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_condeferrable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condeferrable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_condeferred</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_contableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_condef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tablespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indreloptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indreloptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indstatcols</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indstatcols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_indstatvals</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"indstatvals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <name>indxinfo</name> <operator>=</operator>
			<operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndxInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numIndexes</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>contype</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indexname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indextable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexdef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indexdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnkeyattrs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indnkeyatts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indnatts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tablespace</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tablespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indreloptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indreloptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indstatcols</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indstatcols</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indstatvals</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indstatvals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indkeys</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indkey</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indkeys</name></expr></argument>, <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indoptions</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indoption</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indoptions</name></expr></argument>, <argument><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indnattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indisclustered</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indisclustered</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indisreplident</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_indisreplident</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>parentidx</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_parentidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>relpages</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_relpages</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>contype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <name>contype</name> <operator>==</operator> <literal type="char">'u'</literal> <operator>||</operator> <name>contype</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If we found a constraint matching the index, create an
				 * entry for it.
				 */</comment>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <name>contype</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condeferrable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condeferred</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexconstraint</name> <operator>=</operator> <name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>contype</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>primaryKeyIndex</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Plain secondary index */</comment>
				<expr_stmt><expr><name><name>indxinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>indexconstraint</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getExtendedStatistics
 *	  get information about extended-statistics objects.
 *
 * Note: extended statistics data is not returned directly to the caller, but
 * it does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_stxname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_stxnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Extended statistics were new in v10 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, stxname, "</literal>
					  <literal type="string">"stxnamespace, (%s stxowner) AS rolname "</literal>
					  <literal type="string">"FROM pg_catalog.pg_statistic_ext"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_stxname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"stxname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_stxnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"stxnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>statsextinfo</name> <operator>=</operator> <operator>(</operator><name>StatsExtInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StatsExtInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_STATSEXT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_stxname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_stxnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Stats objects do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>statsextinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getConstraints
 *
 * Get info about constraints on dumpable tables.
 *
 * Currently handles foreign keys only.
 * Unique and primary key constraints are handled with indexes,
 * while check constraints are processed in getTableAttrs().
 */</comment>
<function><type><name>void</name></type>
<name>getConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_contableoid</name></decl>,
				<decl><type ref="prev"/><name>i_conoid</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_confrelid</name></decl>,
				<decl><type ref="prev"/><name>i_condef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For partitioned tables, foreign keys have no triggers so they must
		 * be included anyway in case some foreign keys are defined.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hastriggers</name></name> <operator>&amp;&amp;</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading foreign key constraints for table \"%s.%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT tableoid, oid, conname, confrelid, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS condef "</literal>
							  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
							  <literal type="string">"WHERE conrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND conparentid = 0 "</literal>
							  <literal type="string">"AND contype = 'f'"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT tableoid, oid, conname, confrelid, "</literal>
							  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS condef "</literal>
							  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
							  <literal type="string">"WHERE conrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND contype = 'f'"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_contableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_confrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"confrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_condef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FK_CONSTRAINT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_contableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_condef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_confrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getDomainConstraints
 *
 * Get info about constraints on a domain.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getDomainConstraints</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_conname</name></decl>,
				<decl><type ref="prev"/><name>i_consrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
						  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
						  <literal type="string">"convalidated "</literal>
						  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
						  <literal type="string">"WHERE contypid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY conname"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
						  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
						  <literal type="string">"true as convalidated "</literal>
						  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
						  <literal type="string">"WHERE contypid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY conname"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_consrc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"consrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>constrinfo</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name></name> <operator>=</operator> <name>constrinfo</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>validated</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>tyinfo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_consrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <operator>!</operator><name>validated</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the domain depend on the constraint, ensuring it won't be
		 * output till any constraint dependencies are OK.  If the constraint
		 * has not been validated, it's going to be dumped after the domain
		 * anyway, so this doesn't matter.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>validated</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
								<argument><expr><name><name>constrinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getRules
 *	  get basic information about every rule in the system
 *
 * numRules is set to the number of rules read in
 */</comment>
<function><type><name>RuleInfo</name> <modifier>*</modifier></type>
<name>getRules</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numRules</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleInfo</name>   <modifier>*</modifier></type><name>ruleinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rulename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ruletable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ev_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_is_instead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_ev_enabled</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
							 <literal type="string">"tableoid, oid, rulename, "</literal>
							 <literal type="string">"ev_class AS ruletable, ev_type, is_instead, "</literal>
							 <literal type="string">"ev_enabled "</literal>
							 <literal type="string">"FROM pg_rewrite "</literal>
							 <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
							 <literal type="string">"tableoid, oid, rulename, "</literal>
							 <literal type="string">"ev_class AS ruletable, ev_type, is_instead, "</literal>
							 <literal type="string">"'O'::char AS ev_enabled "</literal>
							 <literal type="string">"FROM pg_rewrite "</literal>
							 <literal type="string">"ORDER BY oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numRules</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ruleinfo</name> <operator>=</operator> <operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RuleInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rulename</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rulename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ruletable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ruletable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ev_type</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ev_type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_is_instead</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"is_instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_ev_enabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ev_enabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ruletableoid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_RULE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rulename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ruletableoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ruletable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>ruletableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"failed sanity check, parent table with OID %u of pg_rewrite entry with OID %u not found\n"</literal></expr></argument>,
						  <argument><expr><name>ruletableoid</name></expr></argument>, <argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ev_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_instead</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_is_instead</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_enabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_ev_enabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ruletable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the table is a view or materialized view, force its ON
			 * SELECT rule to be sorted before the view itself --- this
			 * ensures that any dependencies for the rule affect the table's
			 * positioning. Other rules are forced to appear after their
			 * table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
				 <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_instead</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
									<argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* We'll merge the rule into CREATE VIEW, if possible */</comment>
				<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>,
									<argument><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>ruletable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ruleinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ruleinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTriggers
 *	  get information about every trigger on a dumpable table
 *
 * Note: trigger data is not returned directly to the caller, but it
 * does get entered into the DumpableObject tables.
 */</comment>
<function><type><name>void</name></type>
<name>getTriggers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_tgname</name></decl>,
				<decl><type ref="prev"/><name>i_tgfname</name></decl>,
				<decl><type ref="prev"/><name>i_tgtype</name></decl>,
				<decl><type ref="prev"/><name>i_tgnargs</name></decl>,
				<decl><type ref="prev"/><name>i_tgargs</name></decl>,
				<decl><type ref="prev"/><name>i_tgisconstraint</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrname</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrrelid</name></decl>,
				<decl><type ref="prev"/><name>i_tgconstrrelname</name></decl>,
				<decl><type ref="prev"/><name>i_tgenabled</name></decl>,
				<decl><type ref="prev"/><name>i_tgisinternal</name></decl>,
				<decl><type ref="prev"/><name>i_tgdeferrable</name></decl>,
				<decl><type ref="prev"/><name>i_tginitdeferred</name></decl>,
				<decl><type ref="prev"/><name>i_tgdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>hastriggers</name></name> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading triggers for table \"%s.%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">130000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NB: think not to use pretty=true in pg_get_triggerdef.  It
			 * could result in non-forward-compatible dumps of WHEN clauses
			 * due to under-parenthesization.
			 *
			 * NB: We need to see tgisinternal triggers in partitions, in case
			 * the tgenabled flag has been changed from the parent.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tgname, "</literal>
							  <literal type="string">"t.tgfoid::pg_catalog.regproc AS tgfname, "</literal>
							  <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, "</literal>
							  <literal type="string">"t.tgenabled, t.tableoid, t.oid, t.tgisinternal "</literal>
							  <literal type="string">"FROM pg_catalog.pg_trigger t "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_trigger u ON u.oid = t.tgparentid "</literal>
							  <literal type="string">"WHERE t.tgrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND (NOT t.tgisinternal OR t.tgenabled != u.tgenabled)"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NB: We need to see tgisinternal triggers in partitions, in case
			 * the tgenabled flag has been changed from the parent. No
			 * tgparentid in version 11-12, so we have to match them via
			 * pg_depend.
			 *
			 * See above about pretty=true in pg_get_triggerdef.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tgname, "</literal>
							  <literal type="string">"t.tgfoid::pg_catalog.regproc AS tgfname, "</literal>
							  <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, "</literal>
							  <literal type="string">"t.tgenabled, t.tableoid, t.oid, t.tgisinternal "</literal>
							  <literal type="string">"FROM pg_catalog.pg_trigger t "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_depend AS d ON "</literal>
							  <literal type="string">" d.classid = 'pg_catalog.pg_trigger'::pg_catalog.regclass AND "</literal>
							  <literal type="string">" d.refclassid = 'pg_catalog.pg_trigger'::pg_catalog.regclass AND "</literal>
							  <literal type="string">" d.objid = t.oid "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_trigger AS pt ON pt.oid = refobjid "</literal>
							  <literal type="string">"WHERE t.tgrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND (NOT t.tgisinternal%s)"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr> ?</condition><then>
							  <expr><literal type="string">" OR t.tgenabled != pt.tgenabled"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* See above about pretty=true in pg_get_triggerdef */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT t.tgname, "</literal>
							  <literal type="string">"t.tgfoid::pg_catalog.regproc AS tgfname, "</literal>
							  <literal type="string">"pg_catalog.pg_get_triggerdef(t.oid, false) AS tgdef, "</literal>
							  <literal type="string">"t.tgenabled, false as tgisinternal, "</literal>
							  <literal type="string">"t.tableoid, t.oid "</literal>
							  <literal type="string">"FROM pg_catalog.pg_trigger t "</literal>
							  <literal type="string">"WHERE tgrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND NOT tgisinternal"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We ignore triggers that are tied to a foreign-key constraint
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT tgname, "</literal>
							  <literal type="string">"tgfoid::pg_catalog.regproc AS tgfname, "</literal>
							  <literal type="string">"tgtype, tgnargs, tgargs, tgenabled, "</literal>
							  <literal type="string">"false as tgisinternal, "</literal>
							  <literal type="string">"tgisconstraint, tgconstrname, tgdeferrable, "</literal>
							  <literal type="string">"tgconstrrelid, tginitdeferred, tableoid, oid, "</literal>
							  <literal type="string">"tgconstrrelid::pg_catalog.regclass AS tgconstrrelname "</literal>
							  <literal type="string">"FROM pg_catalog.pg_trigger t "</literal>
							  <literal type="string">"WHERE tgrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND tgconstraint = 0"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We ignore triggers that are tied to a foreign-key constraint,
			 * but in these versions we have to grovel through pg_constraint
			 * to find out
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT tgname, "</literal>
							  <literal type="string">"tgfoid::pg_catalog.regproc AS tgfname, "</literal>
							  <literal type="string">"tgtype, tgnargs, tgargs, tgenabled, "</literal>
							  <literal type="string">"tgisconstraint, tgconstrname, tgdeferrable, "</literal>
							  <literal type="string">"tgconstrrelid, tginitdeferred, tableoid, oid, "</literal>
							  <literal type="string">"tgconstrrelid::pg_catalog.regclass AS tgconstrrelname "</literal>
							  <literal type="string">"FROM pg_catalog.pg_trigger t "</literal>
							  <literal type="string">"WHERE tgrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND (NOT tgisconstraint "</literal>
							  <literal type="string">" OR NOT EXISTS"</literal>
							  <literal type="string">"  (SELECT 1 FROM pg_catalog.pg_depend d "</literal>
							  <literal type="string">"   JOIN pg_catalog.pg_constraint c ON (d.refclassid = c.tableoid AND d.refobjid = c.oid) "</literal>
							  <literal type="string">"   WHERE d.classid = t.tableoid AND d.objid = t.oid AND d.deptype = 'i' AND c.contype = 'f'))"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgnargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgnargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgargs</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgisconstraint</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgisconstraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgconstrname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgconstrrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgconstrrelname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgconstrrelname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgenabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgenabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgisinternal</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgisinternal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgdeferrable</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgdeferrable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tginitdeferred</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tginitdeferred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_tgdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tgdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tginfo</name> <operator>=</operator> <operator>(</operator><name>TriggerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TriggerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numTriggers</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>triggers</name></name> <operator>=</operator> <name>tginfo</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TRIGGER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgenabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgenabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisinternal</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgisinternal</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i_tgdef</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* remaining fields are not valid if we have tgdef */</comment>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgfname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgnargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgargs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tginitdeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdef</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgfname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgtype</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgnargs</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgnargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgargs</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgisconstraint</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgdeferrable</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgdeferrable</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tginitdeferred</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tginitdeferred</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgisconstraint</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"query produced null referenced table name for foreign key trigger \"%s\" on table \"%s\" (OID of table: %u)\n"</literal></expr></argument>,
										  <argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
										  <argument><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_tgconstrrelname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tginfo</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tgconstrrelname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getEventTriggers
 *	  get information about event triggers
 */</comment>
<function><type><name>EventTriggerInfo</name> <modifier>*</modifier></type>
<name>getEventTriggers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numEventTriggers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>,
				<decl><type ref="prev"/><name>i_oid</name></decl>,
				<decl><type ref="prev"/><name>i_evtname</name></decl>,
				<decl><type ref="prev"/><name>i_evtevent</name></decl>,
				<decl><type ref="prev"/><name>i_evtowner</name></decl>,
				<decl><type ref="prev"/><name>i_evttags</name></decl>,
				<decl><type ref="prev"/><name>i_evtfname</name></decl>,
				<decl><type ref="prev"/><name>i_evtenabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>

	<comment type="block">/* Before 9.3, there are no event triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numEventTriggers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT e.tableoid, e.oid, evtname, evtenabled, "</literal>
					  <literal type="string">"evtevent, (%s evtowner) AS evtowner, "</literal>
					  <literal type="string">"array_to_string(array("</literal>
					  <literal type="string">"select quote_literal(x) "</literal>
					  <literal type="string">" from unnest(evttags) as t(x)), ', ') as evttags, "</literal>
					  <literal type="string">"e.evtfoid::regproc as evtfname "</literal>
					  <literal type="string">"FROM pg_event_trigger e "</literal>
					  <literal type="string">"ORDER BY e.oid"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numEventTriggers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>evtinfo</name> <operator>=</operator> <operator>(</operator><name>EventTriggerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EventTriggerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtevent</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtevent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evttags</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evttags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtfname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtfname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_evtenabled</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"evtenabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_EVENT_TRIGGER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtevent</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtevent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtowner</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evttags</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evttags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtfname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtfname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>evtenabled</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_evtenabled</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Event Triggers do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>evtinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>evtinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getProcLangs
 *	  get basic information about every procedural language in the system
 *
 * numProcLangs is set to the number of langs read in
 *
 * NB: this must run after getFuncs() because we assume we can do
 * findFuncByOid().
 */</comment>
<function><type><name>ProcLangInfo</name> <modifier>*</modifier></type>
<name>getProcLangs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numProcLangs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>planginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanpltrusted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanplcallfoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_laninline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanvalidator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rlanacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initlanacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrlanacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_lanowner</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"l.lanacl"</literal></expr></argument>, <argument><expr><literal type="string">"l.lanowner"</literal></expr></argument>, <argument><expr><literal type="string">"'l'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pg_language has a laninline column */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT l.tableoid, l.oid, "</literal>
						  <literal type="string">"l.lanname, l.lanpltrusted, l.lanplcallfoid, "</literal>
						  <literal type="string">"l.laninline, l.lanvalidator, "</literal>
						  <literal type="string">"%s AS lanacl, "</literal>
						  <literal type="string">"%s AS rlanacl, "</literal>
						  <literal type="string">"%s AS initlanacl, "</literal>
						  <literal type="string">"%s AS initrlanacl, "</literal>
						  <literal type="string">"(%s l.lanowner) AS lanowner "</literal>
						  <literal type="string">"FROM pg_language l "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(l.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_language'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal>
						  <literal type="string">"WHERE l.lanispl "</literal>
						  <literal type="string">"ORDER BY l.oid"</literal></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pg_language has a laninline column */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"laninline, lanvalidator, lanacl, NULL AS rlanacl, "</literal>
						  <literal type="string">"NULL AS initlanacl, NULL AS initrlanacl, "</literal>
						  <literal type="string">"(%s lanowner) AS lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pg_language has a lanowner column */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"0 AS laninline, lanvalidator, lanacl, "</literal>
						  <literal type="string">"NULL AS rlanacl, "</literal>
						  <literal type="string">"NULL AS initlanacl, NULL AS initrlanacl, "</literal>
						  <literal type="string">"(%s lanowner) AS lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Languages are owned by the bootstrap superuser, OID 10 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"0 AS laninline, lanvalidator, lanacl, "</literal>
						  <literal type="string">"NULL AS rlanacl, "</literal>
						  <literal type="string">"NULL AS initlanacl, NULL AS initrlanacl, "</literal>
						  <literal type="string">"(%s '10') AS lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Languages are owned by the bootstrap superuser, sysid 1 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
						  <literal type="string">"lanname, lanpltrusted, lanplcallfoid, "</literal>
						  <literal type="string">"0 AS laninline, lanvalidator, lanacl, "</literal>
						  <literal type="string">"NULL AS rlanacl, "</literal>
						  <literal type="string">"NULL AS initlanacl, NULL AS initrlanacl, "</literal>
						  <literal type="string">"(%s '1') AS lanowner "</literal>
						  <literal type="string">"FROM pg_language "</literal>
						  <literal type="string">"WHERE lanispl "</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numProcLangs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>planginfo</name> <operator>=</operator> <operator>(</operator><name>ProcLangInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ProcLangInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanpltrusted</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanpltrusted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanplcallfoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanplcallfoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_laninline</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"laninline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanvalidator</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanvalidator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rlanacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rlanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initlanacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initlanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrlanacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrlanacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_lanowner</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanowner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_PROCLANG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanpltrusted</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanpltrusted</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanplcallfoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanplcallfoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>laninline</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_laninline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanvalidator</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanvalidator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rlanacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rlanacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initlanacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initlanacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrlanacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrlanacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lanowner</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanowner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableProcLang</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_lanacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rlanacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initlanacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrlanacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>planginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>planginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getCasts
 *	  get basic information about every cast in the system
 *
 * numCasts is set to the number of casts read in
 */</comment>
<function><type><name>CastInfo</name> <modifier>*</modifier></type>
<name>getCasts</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numCasts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CastInfo</name>   <modifier>*</modifier></type><name>castinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_casttarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castfunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_castmethod</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
							 <literal type="string">"castsource, casttarget, castfunc, castcontext, "</literal>
							 <literal type="string">"castmethod "</literal>
							 <literal type="string">"FROM pg_cast ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
							 <literal type="string">"castsource, casttarget, castfunc, castcontext, "</literal>
							 <literal type="string">"CASE WHEN castfunc = 0 THEN 'b' ELSE 'f' END AS castmethod "</literal>
							 <literal type="string">"FROM pg_cast ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numCasts</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>castinfo</name> <operator>=</operator> <operator>(</operator><name>CastInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CastInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castsource</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castsource"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_casttarget</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"casttarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castfunc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castfunc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castcontext</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castcontext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_castmethod</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"castmethod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>namebuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>sTypeInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tTypeInfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castsource</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castsource</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>casttarget</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_casttarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castfunc</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castfunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castcontext</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castcontext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castmethod</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_castmethod</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to name cast as concatenation of typnames.  This is only used
		 * for purposes of sorting.  If we fail to find either type, the name
		 * will be an empty string.
		 */</comment>
		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>castsource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tTypeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>casttarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sTypeInfo</name> <operator>&amp;&amp;</operator> <name>tTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
							  <argument><expr><name><name>sTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tTypeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableCast</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Casts do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>castinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>castinfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_language_name</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT lanname FROM pg_language WHERE oid = %u"</literal></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lanname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTransforms
 *	  get basic information about every transform in the system
 *
 * numTransforms is set to the number of transforms read in
 */</comment>
<function><type><name>TransformInfo</name> <modifier>*</modifier></type>
<name>getTransforms</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTransforms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransformInfo</name> <modifier>*</modifier></type><name>transforminfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trftype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trflang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trffromsql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_trftosql</name></decl>;</decl_stmt>

	<comment type="block">/* Transforms didn't exist pre-9.5 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTransforms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, "</literal>
					  <literal type="string">"trftype, trflang, trffromsql::oid, trftosql::oid "</literal>
					  <literal type="string">"FROM pg_transform "</literal>
					  <literal type="string">"ORDER BY 3,4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numTransforms</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>transforminfo</name> <operator>=</operator> <operator>(</operator><name>TransformInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransformInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trftype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trftype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trflang</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trflang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trffromsql</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trffromsql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_trftosql</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"trftosql"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>namebuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>typeInfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TRANSFORM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trftype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trflang</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trflang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trffromsql</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trffromsql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftosql</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_trftosql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to name transform as concatenation of type and language name.
		 * This is only used for purposes of sorting.  If we fail to find
		 * either, the name will be an empty string.
		 */</comment>
		<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>get_language_name</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>trflang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typeInfo</name> <operator>&amp;&amp;</operator> <name>lanname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>namebuf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
							  <argument><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>namebuf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>transforminfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>transforminfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTableAttrs -
 *	  for each interesting table, read info about its attributes
 *	  (names, types, default values, CHECK constraints, etc)
 *
 * This is implemented in a very inefficient way right now, looping
 * through the tblinfo and doing a join per table to find the attrs and their
 * types.  However, because we want type names and so forth to be named
 * relative to the schema of each table, we couldn't do it in just one
 * query.  (Maybe one query per schema?)
 *
 *	modifies tblinfo
 */</comment>
<function><type><name>void</name></type>
<name>getTableAttrs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attstattarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnotnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atthasdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attidentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attisdropped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attislocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attfdwoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attmissingval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasdefaults</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Don't bother to collect info for sequences */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Don't bother with uninteresting tables, either */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>interesting</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* find all the user attributes and their types */</comment>

		<comment type="block">/*
		 * we must read the attribute names in attribute number order! because
		 * we will use the attnum to index into the attnames array later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"finding the columns and types of table \"%s.%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* atthasmissing and attmissingval are new in 11 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions, "</literal>
							  <literal type="string">"CASE WHEN a.attcollation &lt;&gt; t.typcollation "</literal>
							  <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation, "</literal>
							  <literal type="string">"a.attidentity, "</literal>
							  <literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
							  <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
							  <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
							  <literal type="string">"FROM pg_catalog.pg_options_to_table(attfdwoptions) "</literal>
							  <literal type="string">"ORDER BY option_name"</literal>
							  <literal type="string">"), E',\n    ') AS attfdwoptions ,"</literal>
							  <literal type="string">"CASE WHEN a.atthasmissing AND NOT a.attisdropped "</literal>
							  <literal type="string">"THEN a.attmissingval ELSE null END AS attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * attidentity is new in version 10.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions, "</literal>
							  <literal type="string">"CASE WHEN a.attcollation &lt;&gt; t.typcollation "</literal>
							  <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation, "</literal>
							  <literal type="string">"a.attidentity, "</literal>
							  <literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
							  <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
							  <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
							  <literal type="string">"FROM pg_catalog.pg_options_to_table(attfdwoptions) "</literal>
							  <literal type="string">"ORDER BY option_name"</literal>
							  <literal type="string">"), E',\n    ') AS attfdwoptions ,"</literal>
							  <literal type="string">"NULL as attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * attfdwoptions is new in 9.2.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions, "</literal>
							  <literal type="string">"CASE WHEN a.attcollation &lt;&gt; t.typcollation "</literal>
							  <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation, "</literal>
							  <literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
							  <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
							  <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
							  <literal type="string">"FROM pg_catalog.pg_options_to_table(attfdwoptions) "</literal>
							  <literal type="string">"ORDER BY option_name"</literal>
							  <literal type="string">"), E',\n    ') AS attfdwoptions, "</literal>
							  <literal type="string">"NULL as attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * attcollation is new in 9.1.  Since we only want to dump COLLATE
			 * clauses for attributes whose collation is different from their
			 * type's default, we use a CASE here to suppress uninteresting
			 * attcollations cheaply.
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions, "</literal>
							  <literal type="string">"CASE WHEN a.attcollation &lt;&gt; t.typcollation "</literal>
							  <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation, "</literal>
							  <literal type="string">"NULL AS attfdwoptions, "</literal>
							  <literal type="string">"NULL as attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90000</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* attoptions is new in 9.0 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"array_to_string(a.attoptions, ', ') AS attoptions, "</literal>
							  <literal type="string">"0 AS attcollation, "</literal>
							  <literal type="string">"NULL AS attfdwoptions, "</literal>
							  <literal type="string">"NULL as attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* need left join here to not fail on dropped columns ... */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attnum, a.attname, a.atttypmod, "</literal>
							  <literal type="string">"a.attstattarget, a.attstorage, t.typstorage, "</literal>
							  <literal type="string">"a.attnotnull, a.atthasdef, a.attisdropped, "</literal>
							  <literal type="string">"a.attlen, a.attalign, a.attislocal, "</literal>
							  <literal type="string">"pg_catalog.format_type(t.oid,a.atttypmod) AS atttypname, "</literal>
							  <literal type="string">"'' AS attoptions, 0 AS attcollation, "</literal>
							  <literal type="string">"NULL AS attfdwoptions, "</literal>
							  <literal type="string">"NULL as attmissingval "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute a LEFT JOIN pg_catalog.pg_type t "</literal>
							  <literal type="string">"ON a.atttypid = t.oid "</literal>
							  <literal type="string">"WHERE a.attrelid = '%u'::pg_catalog.oid "</literal>
							  <literal type="string">"AND a.attnum &gt; 0::pg_catalog.int2 "</literal>
							  <literal type="string">"ORDER BY a.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_attnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_atttypname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_atttypmod</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypmod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attstattarget</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attstattarget"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_typstorage</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typstorage"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attnotnull</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnotnull"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_atthasdef</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atthasdef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attidentity</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attidentity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attisdropped</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attisdropped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attlen</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attalign</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attalign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attislocal</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attislocal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attcollation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attfdwoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attfdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_attmissingval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attmissingval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name></name> <operator>=</operator> <operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>primaryKeyIndex</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasdefaults</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"invalid column numbering in table \"%s\"\n"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_atttypname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypmod</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attstattarget</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attstorage</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_typstorage</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>i_attidentity</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attidentity</name></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>needs_override</name></name> <operator>||</operator> <operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attisdropped</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attalign</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attislocal</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attnotnull</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attfdwoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_attmissingval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* fix below */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i_atthasdef</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasdefaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* these flags will be set in flagInhAttrs() */</comment>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get info about column defaults
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasdefaults</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>attrdefs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numDefaults</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"finding default expressions of table \"%s.%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, adnum, "</literal>
							  <literal type="string">"pg_catalog.pg_get_expr(adbin, adrelid) AS adsrc "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attrdef "</literal>
							  <literal type="string">"WHERE adrelid = '%u'::pg_catalog.oid"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>numDefaults</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attrdefs</name> <operator>=</operator> <operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numDefaults</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numDefaults</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>adnum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>adnum</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>adnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>adnum</name> <operator>&gt;</operator> <name>ntups</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><literal type="string">"invalid adnum value %d for table \"%s\"\n"</literal></expr></argument>,
								  <argument><expr><name>adnum</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * dropped columns shouldn't have defaults, but just in case,
				 * ignore 'em
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_ATTRDEF</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adtable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>=</operator> <name>adnum</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>adef_expr</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Defaults on a VIEW must always be dumped as separate ALTER
				 * TABLE commands.  Defaults on regular tables are dumped as
				 * part of the CREATE TABLE if possible, which it won't be if
				 * the column is not going to be emitted explicitly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* column will be suppressed, print default separately */</comment>
					<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Mark the default as needing to appear before the table,
					 * so that any dependencies it has must be emitted before
					 * the CREATE TABLE.  If this is not possible, we'll
					 * change to "separate" mode while sorting dependencies.
					 */</comment>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get info about table CHECK constraints
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constrs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>numConstrs</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"finding check constraints for table \"%s.%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * convalidated is new in 9.2 (actually, it is there in 9.1,
				 * but it wasn't ever false for check constraints until 9.2).
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
								  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
								  <literal type="string">"conislocal, convalidated "</literal>
								  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
								  <literal type="string">"WHERE conrelid = '%u'::pg_catalog.oid "</literal>
								  <literal type="string">"   AND contype = 'c' "</literal>
								  <literal type="string">"ORDER BY conname"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* conislocal is new in 8.4 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
								  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
								  <literal type="string">"conislocal, true AS convalidated "</literal>
								  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
								  <literal type="string">"WHERE conrelid = '%u'::pg_catalog.oid "</literal>
								  <literal type="string">"   AND contype = 'c' "</literal>
								  <literal type="string">"ORDER BY conname"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, conname, "</literal>
								  <literal type="string">"pg_catalog.pg_get_constraintdef(oid) AS consrc, "</literal>
								  <literal type="string">"true AS conislocal, true AS convalidated "</literal>
								  <literal type="string">"FROM pg_catalog.pg_constraint "</literal>
								  <literal type="string">"WHERE conrelid = '%u'::pg_catalog.oid "</literal>
								  <literal type="string">"   AND contype = 'c' "</literal>
								  <literal type="string">"ORDER BY conname"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>numConstrs</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numConstrs</name> <operator>!=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"expected %d check constraint on table \"%s\" but found %d\n"</literal></expr></argument>,
										 <argument><expr><literal type="string">"expected %d check constraints on table \"%s\" but found %d\n"</literal></expr></argument>,
										 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>numConstrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"(The system catalogs might be corrupted.)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>constrs</name> <operator>=</operator> <operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numConstrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name></name> <operator>=</operator> <name>constrs</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numConstrs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>validated</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_CONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contable</name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condomain</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>contype</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condef</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>confrelid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferrable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>condeferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>conislocal</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * An unvalidated constraint needs to be dumped separately, so
				 * that potentially-violating existing data is loaded before
				 * the constraint.
				 */</comment>
				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name> <operator>=</operator> <operator>!</operator><name>validated</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Mark the constraint as needing to appear before the table
				 * --- this is so that any other dependencies of the
				 * constraint will be emitted before we try to create the
				 * table.  If the constraint is to be dumped separately, it
				 * will be dumped after data is loaded anyway, so don't do it.
				 * (There's an automatic dependency in the opposite direction
				 * anyway, so don't need to add one manually here.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name><name>constrs</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If the constraint is inherited, this will be detected later
				 * (in pre-8.4 databases).  We also detect later if the
				 * constraint must be split out from the table definition.
				 */</comment>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a column should be printed as part of table's CREATE TABLE.
 * Column number is zero-based.
 *
 * Normally this is always true, but it's false for dropped columns, as well
 * as those that were inherited without any local definition.  (If we print
 * such a column it will mistakenly get pg_attribute.attislocal set to true.)
 * However, in binary_upgrade mode, we must print all such columns anyway and
 * fix the attislocal/attisdropped state later, so as to keep control of the
 * physical column order.
 *
 * This function exists because there are scattered nonobvious places that
 * must be kept in sync with this decision.
 */</comment>
<function><type><name>bool</name></type>
<name>shouldPrintColumn</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>colno</name></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * getTSParsers:
 *	  read all text search parsers in the system catalogs and return them
 *	  in the TSParserInfo* structure
 *
 *	numTSParsers is set to the number of parsers read in
 */</comment>
<function><type><name>TSParserInfo</name> <modifier>*</modifier></type>
<name>getTSParsers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSParsers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsstart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prstoken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prsheadline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_prslextype</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.3, there is no built-in text search support */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTSParsers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find all text search objects, including builtin ones; we filter out
	 * system-defined objects at dump-out time.
	 */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, prsname, prsnamespace, "</literal>
						 <literal type="string">"prsstart::oid, prstoken::oid, "</literal>
						 <literal type="string">"prsend::oid, prsheadline::oid, prslextype::oid "</literal>
						 <literal type="string">"FROM pg_ts_parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSParsers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prsinfo</name> <operator>=</operator> <operator>(</operator><name>TSParserInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSParserInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsstart</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsstart"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prstoken</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prstoken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsend</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prsheadline</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prsheadline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_prslextype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prslextype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSPARSER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsstart</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsstart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prstoken</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prstoken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsend</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsend</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prsheadline</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prsheadline</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prslextype</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_prslextype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Text Search Parsers do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>prsinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prsinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSDictionaries:
 *	  read all text search dictionaries in the system catalogs and return them
 *	  in the TSDictInfo* structure
 *
 *	numTSDicts is set to the number of dictionaries read in
 */</comment>
<function><type><name>TSDictInfo</name> <modifier>*</modifier></type>
<name>getTSDictionaries</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSDicts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dicttemplate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictinitoption</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.3, there is no built-in text search support */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTSDicts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, dictname, "</literal>
					  <literal type="string">"dictnamespace, (%s dictowner) AS rolname, "</literal>
					  <literal type="string">"dicttemplate, dictinitoption "</literal>
					  <literal type="string">"FROM pg_ts_dict"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSDicts</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dictinfo</name> <operator>=</operator> <operator>(</operator><name>TSDictInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSDictInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictinitoption</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictinitoption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dicttemplate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dicttemplate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSDICT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dicttemplate</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dicttemplate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictinitoption</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictinitoption</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictinitoption</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictinitoption</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Text Search Dictionaries do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>dictinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dictinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSTemplates:
 *	  read all text search templates in the system catalogs and return them
 *	  in the TSTemplateInfo* structure
 *
 *	numTSTemplates is set to the number of templates read in
 */</comment>
<function><type><name>TSTemplateInfo</name> <modifier>*</modifier></type>
<name>getTSTemplates</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSTemplates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmplinit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tmpllexize</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.3, there is no built-in text search support */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTSTemplates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, tmplname, "</literal>
						 <literal type="string">"tmplnamespace, tmplinit::oid, tmpllexize::oid "</literal>
						 <literal type="string">"FROM pg_ts_template"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSTemplates</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmplinfo</name> <operator>=</operator> <operator>(</operator><name>TSTemplateInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSTemplateInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmplinit</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmplinit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tmpllexize</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tmpllexize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSTEMPLATE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmplinit</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmplinit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tmpllexize</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tmpllexize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Text Search Templates do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>tmplinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tmplinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTSConfigurations:
 *	  read all text search configurations in the system catalogs and return
 *	  them in the TSConfigInfo* structure
 *
 *	numTSConfigs is set to the number of configurations read in
 */</comment>
<function><type><name>TSConfigInfo</name> <modifier>*</modifier></type>
<name>getTSConfigurations</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTSConfigs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_cfgparser</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.3, there is no built-in text search support */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numTSConfigs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, cfgname, "</literal>
					  <literal type="string">"cfgnamespace, (%s cfgowner) AS rolname, cfgparser "</literal>
					  <literal type="string">"FROM pg_ts_config"</literal></expr></argument>,
					  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numTSConfigs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>cfginfo</name> <operator>=</operator> <operator>(</operator><name>TSConfigInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSConfigInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_cfgparser</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"cfgparser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_TSCONFIG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator>
			<call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						  <argument><expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cfgparser</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_cfgparser</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Text Search Configurations do not currently have ACLs. */</comment>
		<expr_stmt><expr><name><name>cfginfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cfginfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getForeignDataWrappers:
 *	  read all foreign-data wrappers in the system catalogs and return
 *	  them in the FdwInfo* structure
 *
 *	numForeignDataWrappers is set to the number of fdws read in
 */</comment>
<function><type><name>FdwInfo</name> <modifier>*</modifier></type>
<name>getForeignDataWrappers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numForeignDataWrappers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FdwInfo</name>    <modifier>*</modifier></type><name>fdwinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwhandler</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwvalidator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rfdwacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initfdwacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrfdwacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_fdwoptions</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.4, there are no foreign-data wrappers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numForeignDataWrappers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"f.fdwacl"</literal></expr></argument>, <argument><expr><literal type="string">"f.fdwowner"</literal></expr></argument>, <argument><expr><literal type="string">"'F'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT f.tableoid, f.oid, f.fdwname, "</literal>
						  <literal type="string">"(%s f.fdwowner) AS rolname, "</literal>
						  <literal type="string">"f.fdwhandler::pg_catalog.regproc, "</literal>
						  <literal type="string">"f.fdwvalidator::pg_catalog.regproc, "</literal>
						  <literal type="string">"%s AS fdwacl, "</literal>
						  <literal type="string">"%s AS rfdwacl, "</literal>
						  <literal type="string">"%s AS initfdwacl, "</literal>
						  <literal type="string">"%s AS initrfdwacl, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(f.fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper f "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(f.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_foreign_data_wrapper'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, fdwname, "</literal>
						  <literal type="string">"(%s fdwowner) AS rolname, "</literal>
						  <literal type="string">"fdwhandler::pg_catalog.regproc, "</literal>
						  <literal type="string">"fdwvalidator::pg_catalog.regproc, fdwacl, "</literal>
						  <literal type="string">"NULL as rfdwacl, "</literal>
						  <literal type="string">"NULL as initfdwacl, NULL AS initrfdwacl, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, fdwname, "</literal>
						  <literal type="string">"(%s fdwowner) AS rolname, "</literal>
						  <literal type="string">"'-' AS fdwhandler, "</literal>
						  <literal type="string">"fdwvalidator::pg_catalog.regproc, fdwacl, "</literal>
						  <literal type="string">"NULL as rfdwacl, "</literal>
						  <literal type="string">"NULL as initfdwacl, NULL AS initrfdwacl, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(fdwoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS fdwoptions "</literal>
						  <literal type="string">"FROM pg_foreign_data_wrapper"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numForeignDataWrappers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fdwinfo</name> <operator>=</operator> <operator>(</operator><name>FdwInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FdwInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwhandler</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwhandler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwvalidator</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwvalidator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rfdwacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rfdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initfdwacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initfdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrfdwacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrfdwacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_fdwoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"fdwoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FDW</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwhandler</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwhandler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwvalidator</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwvalidator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fdwacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rfdwacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rfdwacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initfdwacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initfdwacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrfdwacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrfdwacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_fdwacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rfdwacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initfdwacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrfdwacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fdwinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fdwinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getForeignServers:
 *	  read all foreign servers in the system catalogs and return
 *	  them in the ForeignServerInfo * structure
 *
 *	numForeignServers is set to the number of servers read in
 */</comment>
<function><type><name>ForeignServerInfo</name> <modifier>*</modifier></type>
<name>getForeignServers</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numForeignServers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rolname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvfdw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvversion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rsrvacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initsrvacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrsrvacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_srvoptions</name></decl>;</decl_stmt>

	<comment type="block">/* Before 8.4, there are no foreign servers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numForeignServers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"f.srvacl"</literal></expr></argument>, <argument><expr><literal type="string">"f.srvowner"</literal></expr></argument>, <argument><expr><literal type="string">"'S'"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT f.tableoid, f.oid, f.srvname, "</literal>
						  <literal type="string">"(%s f.srvowner) AS rolname, "</literal>
						  <literal type="string">"f.srvfdw, f.srvtype, f.srvversion, "</literal>
						  <literal type="string">"%s AS srvacl, "</literal>
						  <literal type="string">"%s AS rsrvacl, "</literal>
						  <literal type="string">"%s AS initsrvacl, "</literal>
						  <literal type="string">"%s AS initrsrvacl, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(f.srvoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS srvoptions "</literal>
						  <literal type="string">"FROM pg_foreign_server f "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip "</literal>
						  <literal type="string">"ON (f.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_foreign_server'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT tableoid, oid, srvname, "</literal>
						  <literal type="string">"(%s srvowner) AS rolname, "</literal>
						  <literal type="string">"srvfdw, srvtype, srvversion, srvacl, "</literal>
						  <literal type="string">"NULL AS rsrvacl, "</literal>
						  <literal type="string">"NULL AS initsrvacl, NULL AS initrsrvacl, "</literal>
						  <literal type="string">"array_to_string(ARRAY("</literal>
						  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
						  <literal type="string">"quote_literal(option_value) "</literal>
						  <literal type="string">"FROM pg_options_to_table(srvoptions) "</literal>
						  <literal type="string">"ORDER BY option_name"</literal>
						  <literal type="string">"), E',\n    ') AS srvoptions "</literal>
						  <literal type="string">"FROM pg_foreign_server"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numForeignServers</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>srvinfo</name> <operator>=</operator> <operator>(</operator><name>ForeignServerInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ForeignServerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rolname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rolname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvfdw</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvfdw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rsrvacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rsrvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initsrvacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initsrvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrsrvacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrsrvacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_srvoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_FOREIGN_SERVER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rolname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvfdw</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvfdw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvtype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvversion</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvversion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>srvacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rsrvacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rsrvacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initsrvacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initsrvacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrsrvacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrsrvacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableObject</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name><operator>)</operator></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not try to dump ACL if no ACL exists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_srvacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rsrvacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initsrvacl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrsrvacl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>srvinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DUMP_COMPONENT_ACL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>srvinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getDefaultACLs:
 *	  read all default ACL information in the system catalogs and return
 *	  them in the DefaultACLInfo structure
 *
 *	numDefaultACLs is set to the number of ACLs read in
 */</comment>
<function><type><name>DefaultACLInfo</name> <modifier>*</modifier></type>
<name>getDefaultACLs</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numDefaultACLs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclrole</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclobjtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_defaclacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_rdefaclacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initdefaclacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_initrdefaclacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>ntups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&lt;</operator> <literal type="number">90000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>numDefaultACLs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Global entries (with defaclnamespace=0) replace the hard-wired
		 * default ACL for their object type.  We should dump them as deltas
		 * from the default ACL, since that will be used as a starting point
		 * for interpreting the ALTER DEFAULT PRIVILEGES commands.  On the
		 * other hand, non-global entries can only add privileges not revoke
		 * them.  We must dump those as-is (i.e., as deltas from an empty
		 * ACL).  We implement that by passing NULL as the object type for
		 * acldefault(), which works because acldefault() is STRICT.
		 *
		 * We can use defaclobjtype as the object type for acldefault(),
		 * except for the case of 'S' (DEFACLOBJ_SEQUENCE) which must be
		 * converted to 's'.
		 */</comment>
		<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
						<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"defaclacl"</literal></expr></argument>, <argument><expr><literal type="string">"defaclrole"</literal></expr></argument>,
						<argument><expr><literal type="string">"CASE WHEN defaclnamespace = 0 THEN"</literal>
						<literal type="string">"	  CASE WHEN defaclobjtype = 'S' THEN 's'::\"char\""</literal>
						<literal type="string">"	  ELSE defaclobjtype END "</literal>
						<literal type="string">"ELSE NULL END"</literal></expr></argument>,
						<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT d.oid, d.tableoid, "</literal>
						  <literal type="string">"(%s d.defaclrole) AS defaclrole, "</literal>
						  <literal type="string">"d.defaclnamespace, "</literal>
						  <literal type="string">"d.defaclobjtype, "</literal>
						  <literal type="string">"%s AS defaclacl, "</literal>
						  <literal type="string">"%s AS rdefaclacl, "</literal>
						  <literal type="string">"%s AS initdefaclacl, "</literal>
						  <literal type="string">"%s AS initrdefaclacl "</literal>
						  <literal type="string">"FROM pg_default_acl d "</literal>
						  <literal type="string">"LEFT JOIN pg_init_privs pip ON "</literal>
						  <literal type="string">"(d.oid = pip.objoid "</literal>
						  <literal type="string">"AND pip.classoid = 'pg_default_acl'::regclass "</literal>
						  <literal type="string">"AND pip.objsubid = 0) "</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>,
						  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid, tableoid, "</literal>
						  <literal type="string">"(%s defaclrole) AS defaclrole, "</literal>
						  <literal type="string">"defaclnamespace, "</literal>
						  <literal type="string">"defaclobjtype, "</literal>
						  <literal type="string">"defaclacl, "</literal>
						  <literal type="string">"NULL AS rdefaclacl, "</literal>
						  <literal type="string">"NULL AS initdefaclacl, "</literal>
						  <literal type="string">"NULL AS initrdefaclacl "</literal>
						  <literal type="string">"FROM pg_default_acl"</literal></expr></argument>,
						  <argument><expr><name>username_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>numDefaultACLs</name> <operator>=</operator> <name>ntups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>daclinfo</name> <operator>=</operator> <operator>(</operator><name>DefaultACLInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DefaultACLInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_tableoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclrole</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclrole"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclnamespace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclnamespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclobjtype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclobjtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_defaclacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"defaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_rdefaclacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rdefaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initdefaclacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initdefaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_initrdefaclacl</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"initrdefaclacl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_DEFAULT_ACL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tableoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* cheesy ... is it worth coming up with a better object name? */</comment>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclobjtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nspid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <call><name>findNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>defaclrole</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclrole</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>defaclobjtype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclobjtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>defaclacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_defaclacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rdefaclacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_rdefaclacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initdefaclacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initdefaclacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>initrdefaclacl</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_initrdefaclacl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Decide whether we want to dump it */</comment>
		<expr_stmt><expr><call><name>selectDumpableDefaultACL</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>daclinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>dopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>daclinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpComment --
 *
 * This routine is used to dump any comments associated with the
 * object handed to this routine. The routine takes the object type
 * and object name (ready to print, except for schema decoration), plus
 * the namespace and owner of the object (for labeling the ArchiveEntry),
 * plus catalog ID and subid which are the lookup key for pg_description,
 * plus the dump ID for the object (for setting a dependency).
 * If a matching pg_description entry is found, it is dumped.
 *
 * Note: in some cases, such as comments for triggers and rules, the "type"
 * string really looks like, e.g., "TRIGGER name ON".  This is a bit of a hack
 * but it doesn't seem worth complicating the API for all callers to make
 * it cleaner.
 *
 * Note: although this routine takes a dumpId for dependency purposes,
 * that purpose is just to mark the dependency in the emitted dump file
 * for possible future use by pg_restore.  We do NOT use it for determining
 * ordering of the comment in the dump file, because this routine is called
 * after dependency sorting occurs.  This routine should be called just after
 * calling ArchiveEntry() for the specified object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Comments are schema not data ... except blob comments are data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We do dump blob comments in binary-upgrade mode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search for comments associated with catalogId, using table */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is there one matching the subid? */</comment>
	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>==</operator> <name>subid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If a comment exists, build COMMENT ON statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON %s "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>namespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We mark comments as SECTION_NONE because they really belong in the
		 * same section as their parent, whether that is pre-data or
		 * post-data.
		 */</comment>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name>dumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableComment --
 *
 * As above, but dump comments for both the specified table (or view)
 * and its columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Comments are SCHEMA not data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search for comments associated with relation, using table */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If comments exist, build COMMENT ON statements */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>objsubid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON %s %s IS "</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
						 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>objsubid</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>objsubid</name> <operator>&lt;=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
						 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findComments --
 *
 * Find the comment(s), if any, associated with the given object.  All the
 * objsubid values associated with the given classoid/objoid are found with
 * one search.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>,
			 <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* static storage for table of comments */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>CommentItem</name> <modifier>*</modifier></type><name>comments</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ncomments</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>middle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatch</name></decl>;</decl_stmt>

	<comment type="block">/* Get comments if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>collectComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do binary search to find some item matching the object.
	 */</comment>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <operator>&amp;</operator><name><name>comments</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <operator>&amp;</operator><name><name>comments</name><index>[<expr><name>ncomments</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* found a match */</comment>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&gt;</operator> <name>high</name></expr>)</condition>				<comment type="block">/* no matches */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now determine how many items match the object.  The search loop
	 * invariant still holds: only items between low and high inclusive could
	 * match.
	 */</comment>
	<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objoid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>middle</name> <operator>+=</operator> <name>nmatch</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nmatch</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collectComments --
 *
 * Construct a table of all comments available for database objects.
 * We used to do per-object queries for the comments, but it's much faster
 * to pull them all over at once, and on most databases the memory cost
 * isn't high.
 *
 * The table is sorted by classoid/objid/objsubid for speed in lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>collectComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CommentItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_description</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objsubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT description, classoid, objoid, objsubid "</literal>
						 <literal type="string">"FROM pg_catalog.pg_description "</literal>
						 <literal type="string">"ORDER BY classoid, objoid, objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct lookup table containing OIDs in numeric form */</comment>

	<expr_stmt><expr><name>i_description</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_classoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objsubid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>comments</name> <operator>=</operator> <operator>(</operator><name>CommentItem</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommentItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>descr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>comments</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Do NOT free the PGresult since we are keeping pointers into it */</comment>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>comments</name></expr>;</expr_stmt>
	<return>return <expr><name>ntups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDumpableObject
 *
 * This routine and its subsidiaries are responsible for creating
 * ArchiveEntries (TOC objects) for each object to be dumped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDumpableObject</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DO_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpNamespace</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>NamespaceInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpExtension</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ExtensionInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SHELL_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpShellType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ShellTypeInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpFunc</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_AGG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAgg</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>AggInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPERATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpr</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>OprInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_ACCESS_METHOD</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAccessMethod</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>AccessMethodInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPCLASS</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpclass</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>OpclassInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_OPFAMILY</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpOpfamily</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>OpfamilyInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_COLLATION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpCollation</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>CollInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CONVERSION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConversion</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ConvInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTable</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTablegroup</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TablegroupInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_ATTRDEF</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpAttrDef</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpIndex</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_INDEX_ATTACH</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpIndexAttach</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexAttachInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_STATSEXT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpStatisticsExt</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>StatsExtInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_REFRESH_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>refreshMatViewData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_RULE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpRule</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTrigger</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TriggerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpEventTrigger</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>EventTriggerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConstraint</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FK_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpConstraint</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PROCLANG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpProcLang</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ProcLangInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_CAST</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpCast</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>CastInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTransform</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TransformInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SEQUENCE_SET</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpSequenceData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TABLE_DATA</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTableData</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_DUMMY_TYPE</name></expr>:</case>
			<comment type="block">/* table rowtypes and array types are never dumped separately */</comment>
			<break>break;</break>
		<case>case <expr><name>DO_TSPARSER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSParser</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TSParserInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSDICT</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSDictionary</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TSDictInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSTEMPLATE</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSTemplate</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TSTemplateInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_TSCONFIG</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpTSConfig</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>TSConfigInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FDW</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpForeignDataWrapper</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>FdwInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpForeignServer</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>ForeignServerInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_DEFAULT_ACL</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpDefaultACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>DefaultACLInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_BLOB</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpBlob</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>BlobInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_BLOB_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
							 <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"BLOBS"</literal></expr></argument>, <argument><expr><name>SECTION_DATA</name></expr></argument>,
							 <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>dumpBlobs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_POLICY</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPolicy</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>PolicyInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPublication</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>PublicationInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PUBLICATION_REL</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpPublicationTable</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>PublicationRelInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_SUBSCRIPTION</name></expr>:</case>
			<expr_stmt><expr><call><name>dumpSubscription</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>(</operator><name>SubscriptionInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DO_PRE_DATA_BOUNDARY</name></expr>:</case>
		<case>case <expr><name>DO_POST_DATA_BOUNDARY</name></expr>:</case>
			<comment type="block">/* never dumped, nothing to do */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * dumpNamespace
 *	  writes out to fout the queries to recreate a user-defined namespace
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpNamespace</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nspinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qnspname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qnspname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SCHEMA %s;\n"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE SCHEMA %s;\n"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Schema Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>, <argument><expr><name>qnspname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"SCHEMA"</literal></expr></argument>,
				<argument><expr><name>qnspname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>nspacl</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>rnspacl</name></name></expr></argument>,
				<argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>initnspacl</name></name></expr></argument>, <argument><expr><name><name>nspinfo</name><operator>-&gt;</operator><name>initrnspacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qnspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpExtension
 *	  writes out to fout the queries to recreate an extension
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpExtension</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qextname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qextname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTENSION %s;\n"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In a regular dump, we simply create the extension, intentionally
		 * not specifying a version, so that the destination installation's
		 * default version is used.
		 *
		 * Use of IF NOT EXISTS here is unlike our behavior for other object
		 * types; but there are various scenarios in which it's convenient to
		 * manually create the desired extension before restoring, so we
		 * prefer to allow it to exist already.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE EXTENSION IF NOT EXISTS %s WITH SCHEMA %s;\n"</literal></expr></argument>,
						  <argument><expr><name>qextname</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In binary-upgrade mode, it's critical to reproduce the state of the
		 * database exactly, so our procedure is to create an empty extension,
		 * restore all the contained objects normally, and add them to the
		 * extension one by one.  This function performs just the first of
		 * those steps.  binary_upgrade_extension_member() takes care of
		 * adding member objects as they're created.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"-- For binary upgrade, create an empty extension and insert objects into it\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We unconditionally create the extension, so we must drop it if it
		 * exists.  This could happen if the user deleted 'plpgsql' and then
		 * readded it, causing its oid to be greater than g_last_builtin_oid.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DROP EXTENSION IF EXISTS %s;\n"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_create_empty_extension("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>namespace</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>extinfo</name><operator>-&gt;</operator><name>relocatable</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extversion</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we're pushing extconfig (an OID array) back into
		 * pg_extension exactly as-is.  This is OK because pg_class OIDs are
		 * preserved in binary upgrade.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extconfig</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extconfig</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extcondition</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extcondition</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>extobj</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>extobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>extobj</name> <operator>&amp;&amp;</operator> <name><name>extobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_EXTENSION</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>n</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>extobj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"]::pg_catalog.text[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Extension Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <argument><expr><name>qextname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpType
 *	  writes out to fout the queries to recreate a user-defined type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Dump out in proper style */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_BASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpBaseType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpDomain</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpCompositeType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpEnumType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpRangeType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>isDefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpUndefinedType</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: typtype of data type \"%s\" appears to be invalid\n"</literal></expr></argument>,
				  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpEnumType
 *	  writes out to fout the queries to recreate a user-defined enum type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEnumType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enum_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid, enumlabel "</literal>
						  <literal type="string">"FROM pg_catalog.pg_enum "</literal>
						  <literal type="string">"WHERE enumtypid = '%u'"</literal>
						  <literal type="string">"ORDER BY enumsortorder"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid, enumlabel "</literal>
						  <literal type="string">"FROM pg_catalog.pg_enum "</literal>
						  <literal type="string">"WHERE enumtypid = '%u'"</literal>
						  <literal type="string">"ORDER BY oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * CASCADE shouldn't be required here as for normal types since the I/O
	 * functions are generic and do not get dropped.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS ENUM ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Labels with server-assigned oids */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"enumlabel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Labels with dump-assigned (preserved) oids */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>enum_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"enumlabel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, must preserve pg_enum oids\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_pg_enum_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
							  <argument><expr><name>enum_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE %s ADD VALUE "</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpRangeType
 *	  writes out to fout the queries to recreate a user-defined range type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpRangeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collationOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.format_type(rngsubtype, NULL) AS rngsubtype, "</literal>
					  <literal type="string">"opc.opcname AS opcname, "</literal>
					  <literal type="string">"(SELECT nspname FROM pg_catalog.pg_namespace nsp "</literal>
					  <literal type="string">"  WHERE nsp.oid = opc.opcnamespace) AS opcnsp, "</literal>
					  <literal type="string">"opc.opcdefault, "</literal>
					  <literal type="string">"CASE WHEN rngcollation = st.typcollation THEN 0 "</literal>
					  <literal type="string">"     ELSE rngcollation END AS collation, "</literal>
					  <literal type="string">"rngcanonical, rngsubdiff "</literal>
					  <literal type="string">"FROM pg_catalog.pg_range r, pg_catalog.pg_type st, "</literal>
					  <literal type="string">"     pg_catalog.pg_opclass opc "</literal>
					  <literal type="string">"WHERE st.oid = rngsubtype AND opc.oid = rngsubopc AND "</literal>
					  <literal type="string">"rngtypid = '%u'"</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * CASCADE shouldn't be required here as for normal types since the I/O
	 * functions are generic and do not get dropped.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS RANGE ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    subtype = %s"</literal></expr></argument>,
					  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngsubtype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* print subtype_opclass only if not default for subtype */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="char">'t'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcnsp"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    subtype_opclass = %s."</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>collationOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collationOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name> <init>= <expr><call><name>findCollationByOid</name><argument_list>(<argument><expr><name>collationOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    collation = %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>procname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngcanonical"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    canonical = %s"</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"rngsubdiff"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    subtype_diff = %s"</literal></expr></argument>, <argument><expr><name>procname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpUndefinedType
 *	  writes out to fout the queries to recreate a !typisdefined type
 *
 * This is a shell type, but we use different terminology to distinguish
 * this case from where we have to emit a shell type definition to break
 * circular dependencies.  An undefined type shouldn't ever have anything
 * depending on it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpUndefinedType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpBaseType
 *	  writes out to fout the queries to recreate a user-defined base type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpBaseType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typinput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typreceive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typsend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typmodin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typmodout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typanalyze</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typreceiveoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typsendoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodinoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typmodoutoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typanalyzeoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typispreferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typstorage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typcollatable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typdefault_is_literal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Fetch type-specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typlen, "</literal>
						  <literal type="string">"typinput, typoutput, typreceive, typsend, "</literal>
						  <literal type="string">"typmodin, typmodout, typanalyze, "</literal>
						  <literal type="string">"typreceive::pg_catalog.oid AS typreceiveoid, "</literal>
						  <literal type="string">"typsend::pg_catalog.oid AS typsendoid, "</literal>
						  <literal type="string">"typmodin::pg_catalog.oid AS typmodinoid, "</literal>
						  <literal type="string">"typmodout::pg_catalog.oid AS typmodoutoid, "</literal>
						  <literal type="string">"typanalyze::pg_catalog.oid AS typanalyzeoid, "</literal>
						  <literal type="string">"typcategory, typispreferred, "</literal>
						  <literal type="string">"typdelim, typbyval, typalign, typstorage, "</literal>
						  <literal type="string">"(typcollation &lt;&gt; 0) AS typcollatable, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 0) AS typdefaultbin, typdefault "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typlen, "</literal>
						  <literal type="string">"typinput, typoutput, typreceive, typsend, "</literal>
						  <literal type="string">"typmodin, typmodout, typanalyze, "</literal>
						  <literal type="string">"typreceive::pg_catalog.oid AS typreceiveoid, "</literal>
						  <literal type="string">"typsend::pg_catalog.oid AS typsendoid, "</literal>
						  <literal type="string">"typmodin::pg_catalog.oid AS typmodinoid, "</literal>
						  <literal type="string">"typmodout::pg_catalog.oid AS typmodoutoid, "</literal>
						  <literal type="string">"typanalyze::pg_catalog.oid AS typanalyzeoid, "</literal>
						  <literal type="string">"typcategory, typispreferred, "</literal>
						  <literal type="string">"typdelim, typbyval, typalign, typstorage, "</literal>
						  <literal type="string">"false AS typcollatable, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 0) AS typdefaultbin, typdefault "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Before 8.4, pg_get_expr does not allow 0 for its second arg */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typlen, "</literal>
						  <literal type="string">"typinput, typoutput, typreceive, typsend, "</literal>
						  <literal type="string">"typmodin, typmodout, typanalyze, "</literal>
						  <literal type="string">"typreceive::pg_catalog.oid AS typreceiveoid, "</literal>
						  <literal type="string">"typsend::pg_catalog.oid AS typsendoid, "</literal>
						  <literal type="string">"typmodin::pg_catalog.oid AS typmodinoid, "</literal>
						  <literal type="string">"typmodout::pg_catalog.oid AS typmodoutoid, "</literal>
						  <literal type="string">"typanalyze::pg_catalog.oid AS typanalyzeoid, "</literal>
						  <literal type="string">"'U' AS typcategory, false AS typispreferred, "</literal>
						  <literal type="string">"typdelim, typbyval, typalign, typstorage, "</literal>
						  <literal type="string">"false AS typcollatable, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, typdefault "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typlen, "</literal>
						  <literal type="string">"typinput, typoutput, typreceive, typsend, "</literal>
						  <literal type="string">"'-' AS typmodin, '-' AS typmodout, "</literal>
						  <literal type="string">"typanalyze, "</literal>
						  <literal type="string">"typreceive::pg_catalog.oid AS typreceiveoid, "</literal>
						  <literal type="string">"typsend::pg_catalog.oid AS typsendoid, "</literal>
						  <literal type="string">"0 AS typmodinoid, 0 AS typmodoutoid, "</literal>
						  <literal type="string">"typanalyze::pg_catalog.oid AS typanalyzeoid, "</literal>
						  <literal type="string">"'U' AS typcategory, false AS typispreferred, "</literal>
						  <literal type="string">"typdelim, typbyval, typalign, typstorage, "</literal>
						  <literal type="string">"false AS typcollatable, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, typdefault "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typlen"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typinput</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typinput"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typoutput</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typoutput"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typreceive</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typreceive"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typsend</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typsend"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodout</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodout"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typanalyze</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typanalyze"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typreceiveoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typreceiveoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typsendoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typsendoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodinoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodinoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmodoutoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typmodoutoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typanalyzeoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typanalyzeoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typcategory</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcategory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typispreferred</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typispreferred"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typdelim</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdelim"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typbyval"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typalign"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typstorage</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typstorage"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typcollatable</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcollatable"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdefault_is_literal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* it needs quotes */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The reason we include CASCADE is that the circular dependency between
	 * the type and its I/O functions makes it impossible to drop the type any
	 * other way.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s CASCADE;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might already have a shell type, but setting pg_type_oid is
	 * harmless, and in any case we'd better set the array type OID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"CREATE TYPE %s (\n"</literal>
					  <literal type="string">"    INTERNALLENGTH = %s"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>typlen</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"variable"</literal></expr> </then><else>: <expr><name>typlen</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* regproc result is sufficiently quoted already */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    INPUT = %s"</literal></expr></argument>, <argument><expr><name>typinput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    OUTPUT = %s"</literal></expr></argument>, <argument><expr><name>typoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typreceiveoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    RECEIVE = %s"</literal></expr></argument>, <argument><expr><name>typreceive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typsendoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    SEND = %s"</literal></expr></argument>, <argument><expr><name>typsend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typmodinoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    TYPMOD_IN = %s"</literal></expr></argument>, <argument><expr><name>typmodin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typmodoutoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    TYPMOD_OUT = %s"</literal></expr></argument>, <argument><expr><name>typmodout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typanalyzeoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ANALYZE = %s"</literal></expr></argument>, <argument><expr><name>typanalyze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typcollatable</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    COLLATABLE = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    DEFAULT = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typdefault_is_literal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>elemType</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>elemType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>, <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ELEMENT = %s"</literal></expr></argument>, <argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typcategory</name></expr></argument>, <argument><expr><literal type="string">"U"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    CATEGORY = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typcategory</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typispreferred</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    PREFERRED = true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdelim</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>typdelim</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    DELIMITER = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdelim</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = char"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"s"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = int2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"i"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = int4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typalign</name></expr></argument>, <argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    ALIGNMENT = double"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = plain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"e"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = external"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = extended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typstorage</name></expr></argument>, <argument><expr><literal type="string">"m"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    STORAGE = main"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typbyval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    PASSEDBYVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpDomain
 *	  writes out to fout the queries to recreate a user-defined domain
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDomain</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typnotnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typdefault_is_literal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Fetch domain specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* typcollation is new in 9.1 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT t.typnotnull, "</literal>
						  <literal type="string">"pg_catalog.format_type(t.typbasetype, t.typtypmod) AS typdefn, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(t.typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, "</literal>
						  <literal type="string">"t.typdefault, "</literal>
						  <literal type="string">"CASE WHEN t.typcollation &lt;&gt; u.typcollation "</literal>
						  <literal type="string">"THEN t.typcollation ELSE 0 END AS typcollation "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type t "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_type u ON (t.typbasetype = u.oid) "</literal>
						  <literal type="string">"WHERE t.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT typnotnull, "</literal>
						  <literal type="string">"pg_catalog.format_type(typbasetype, typtypmod) AS typdefn, "</literal>
						  <literal type="string">"pg_catalog.pg_get_expr(typdefaultbin, 'pg_catalog.pg_type'::pg_catalog.regclass) AS typdefaultbin, "</literal>
						  <literal type="string">"typdefault, 0 AS typcollation "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typnotnull</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typnotnull"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typdefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefn"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefaultbin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typdefault"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typdefault_is_literal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* it needs quotes */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typdefault</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>typcollation</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"typcollation"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* force array type */</comment>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"CREATE DOMAIN %s AS %s"</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>,
					  <argument><expr><name>typdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print collation only if different from base type's collation */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name>typcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>typnotnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typdefault</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typdefault_is_literal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>typdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add any CHECK constraints for the domain
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>domcheck</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>domcheck</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n\tCONSTRAINT %s %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP DOMAIN %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Domain Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"DOMAIN"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump any per-constraint comments */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tyinfo</name><operator>-&gt;</operator><name>nDomChecks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>domcheck</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>domChecks</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>conprefix</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s ON DOMAIN"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>conprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
						<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						<argument><expr><name><name>domcheck</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCompositeType
 *	  writes out to fout the queries to recreate a user-defined stand-alone
 *	  composite type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCompositeType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>dropped</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualtypname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_atttypdefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attisdropped</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_atts</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch type specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * attcollation is new in 9.1.  Since we only want to dump COLLATE
		 * clauses for attributes whose collation is different from their
		 * type's default, we use a CASE here to suppress uninteresting
		 * attcollations cheaply.  atttypid will be 0 for dropped columns;
		 * collation does not matter for those.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname, "</literal>
						  <literal type="string">"pg_catalog.format_type(a.atttypid, a.atttypmod) AS atttypdefn, "</literal>
						  <literal type="string">"a.attlen, a.attalign, a.attisdropped, "</literal>
						  <literal type="string">"CASE WHEN a.attcollation &lt;&gt; at.typcollation "</literal>
						  <literal type="string">"THEN a.attcollation ELSE 0 END AS attcollation "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type ct "</literal>
						  <literal type="string">"JOIN pg_catalog.pg_attribute a ON a.attrelid = ct.typrelid "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_type at ON at.oid = a.atttypid "</literal>
						  <literal type="string">"WHERE ct.oid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY a.attnum "</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Since ALTER TYPE could not drop columns until 9.1, attisdropped
		 * should always be false.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT a.attname, "</literal>
						  <literal type="string">"pg_catalog.format_type(a.atttypid, a.atttypmod) AS atttypdefn, "</literal>
						  <literal type="string">"a.attlen, a.attalign, a.attisdropped, "</literal>
						  <literal type="string">"0 AS attcollation "</literal>
						  <literal type="string">"FROM pg_catalog.pg_type ct, pg_catalog.pg_attribute a "</literal>
						  <literal type="string">"WHERE ct.oid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND a.attrelid = ct.typrelid "</literal>
						  <literal type="string">"ORDER BY a.attnum "</literal></expr></argument>,
						  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_atttypdefn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"atttypdefn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attlen</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attlen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attalign</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attalign"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attisdropped</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attisdropped"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attcollation</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attcollation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualtypname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s AS ("</literal></expr></argument>,
					  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>actual_atts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>atttypdefn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>attisdropped</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypdefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_atttypdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attlen</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attalign</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attisdropped</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attisdropped</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attisdropped</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Format properly if not first attr */</comment>
		<if_stmt><if>if <condition>(<expr><name>actual_atts</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>atttypdefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add collation if not default for the column type */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
									  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This is a dropped attribute and we're in binary_upgrade mode.
			 * Insert a placeholder for it in the CREATE TYPE command, and set
			 * length and alignment with direct UPDATE to the catalogs
			 * afterwards. See similar code in dumpTableSchema().
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s INTEGER /* dummy */"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* stash separately for insertion after the CREATE TYPE */</comment>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>,
								 <argument><expr><literal type="string">"\n-- For binary upgrade, recreate dropped column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
							  <literal type="string">"SET attlen = %s, "</literal>
							  <literal type="string">"attalign = '%s', attbyval = false\n"</literal>
							  <literal type="string">"WHERE attname = "</literal></expr></argument>, <argument><expr><name>attlen</name></expr></argument>, <argument><expr><name>attalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"ALTER TYPE %s "</literal></expr></argument>,
							  <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>, <argument><expr><literal type="string">"DROP ATTRIBUTE %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>dropped</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TYPE %s;\n"</literal></expr></argument>, <argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
										<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Dump Type Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>, <argument><expr><name>qtypname</name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"TYPE"</literal></expr></argument>,
				<argument><expr><name>qtypname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rtypacl</name></name></expr></argument>,
				<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>inittypacl</name></name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>initrtypacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>dropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dump any per-column comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpCompositeTypeColComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCompositeTypeColComments
 *	  writes out to fout the queries to recreate comments on the columns of
 *	  a user-defined stand-alone composite type
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCompositeTypeColComments</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TypeInfo</name> <modifier>*</modifier></type><name>tyinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommentItem</name> <modifier>*</modifier></type><name>comments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncomments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pgClassOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_attnum</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-comments is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>no_comments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT c.tableoid, a.attname, a.attnum "</literal>
					  <literal type="string">"FROM pg_catalog.pg_class c, pg_catalog.pg_attribute a "</literal>
					  <literal type="string">"WHERE c.oid = '%u' AND c.oid = a.attrelid "</literal>
					  <literal type="string">"  AND NOT a.attisdropped "</literal>
					  <literal type="string">"ORDER BY a.attnum "</literal></expr></argument>,
					  <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch column attnames */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pgClassOid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tableoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Search for comments associated with type's pg_class OID */</comment>
	<expr_stmt><expr><name>ncomments</name> <operator>=</operator> <call><name>findComments</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							 <argument><expr><name>pgClassOid</name></expr></argument>,
							 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no comments exist, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>ncomments</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build COMMENT ON statements */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_attnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_attname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"attname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>ncomments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>comments</name><operator>-&gt;</operator><name>objsubid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>attname</name></expr>)</condition>			<comment type="block">/* just in case we don't find it */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name> <init>= <expr><name><name>comments</name><operator>-&gt;</operator><name>descr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"COMMENT ON COLUMN %s."</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
						 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COMMENT"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
						 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>comments</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ncomments</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpShellType
 *	  writes out to fout the queries to create a shell type
 *
 * We dump a shell definition in advance of the I/O functions for the type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpShellType</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ShellTypeInfo</name> <modifier>*</modifier></type><name>stinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note the lack of a DROP command for the shell type; any required DROP
	 * is driven off the base type entry, instead.  This interacts with
	 * _printTocEntry()'s use of the presence of a DROP command to decide
	 * whether an entry needs an ALTER OWNER command.  We don't want to alter
	 * the shell type's owner immediately on creation; that should happen only
	 * after it's filled in, otherwise the backend complains.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_type_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												 <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TYPE %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>stinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>stinfo</name><operator>-&gt;</operator><name>baseType</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"SHELL TYPE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpProcLang
 *		  writes out to fout the queries to recreate a user-defined
 *		  procedural language
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpProcLang</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ProcLangInfo</name> <modifier>*</modifier></type><name>plang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qlanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>funcInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>inlineInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>validatorInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to find the support function(s).  It is not an error if we don't
	 * find them --- if the functions are in the pg_catalog schema, as is
	 * standard in 8.1 and up, then we won't have loaded them. (In this case
	 * we will emit a parameterless CREATE LANGUAGE command, which will
	 * require PL template knowledge in the backend to reload.)
	 */</comment>

	<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanplcallfoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>funcInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* treat not-dumped same as not-found */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>inlineInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>inlineInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inlineInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inlineInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>validatorInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>validatorInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>validatorInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>validatorInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the functions are dumpable then emit a traditional CREATE LANGUAGE
	 * with parameters.  Otherwise, we'll write a parameterless command, which
	 * will rely on data from pg_pltemplate.
	 */</comment>
	<expr_stmt><expr><name>useParams</name> <operator>=</operator> <operator>(</operator><name>funcInfo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>inlineInfo</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>validatorInfo</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qlanname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP PROCEDURAL LANGUAGE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>useParams</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sPROCEDURAL LANGUAGE %s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>plang</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUSTED "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" HANDLER %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>funcInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>laninline</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" INLINE %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>inlineInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanvalidator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" VALIDATOR %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>validatorInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If not dumping parameters, then use CREATE OR REPLACE so that the
		 * command will not fail if the language is preinstalled in the target
		 * database.  We restrict the use of REPLACE to this case so as to
		 * eliminate the risk of replacing a language with incompatible
		 * parameter settings: this command will only succeed at all if there
		 * is a pg_pltemplate entry, and if there is one, the existing entry
		 * must match it too.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE PROCEDURAL LANGUAGE %s"</literal></expr></argument>,
						  <argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>plang</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"PROCEDURAL LANGUAGE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Proc Lang Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
					<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>, <argument><expr><name>qlanname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>,
					 <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>plang</name><operator>-&gt;</operator><name>lanpltrusted</name></name> <operator>&amp;&amp;</operator> <name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"LANGUAGE"</literal></expr></argument>,
				<argument><expr><name>qlanname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanowner</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>lanacl</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>rlanacl</name></name></expr></argument>,
				<argument><expr><name><name>plang</name><operator>-&gt;</operator><name>initlanacl</name></name></expr></argument>, <argument><expr><name><name>plang</name><operator>-&gt;</operator><name>initrlanacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qlanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_function_arguments: generate function name and argument list
 *
 * This is used when we can rely on pg_get_function_arguments to format
 * the argument list.  Note, however, that pg_get_function_arguments
 * does not special-case zero-argument aggregates.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_function_arguments</name><parameter_list>(<parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcargs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_agg</name> <operator>&amp;&amp;</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"(*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * format_function_arguments_old: generate function name and argument list
 *
 * The argument type names are qualified if needed.  The function name
 * is never qualified.
 *
 * This is used only with pre-8.4 servers, so we aren't expecting to see
 * VARIADIC or TABLE arguments, nor are there any defaults for arguments.
 *
 * Any or all of allargtypes, argmodes, argnames may be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_function_arguments_old</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
							  <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nallargs</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nallargs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <ternary><condition><expr><name>allargtypes</name></expr> ?</condition><then> <expr><call><name>atooid</name><argument_list>(<argument><expr><name><name>allargtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>finfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>argmodes</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>argmodes</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PROARGMODE_IN</name></expr>:</case>
					<expr_stmt><expr><name>argmode</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>PROARGMODE_OUT</name></expr>:</case>
					<expr_stmt><expr><name>argmode</name> <operator>=</operator> <literal type="string">"OUT "</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>PROARGMODE_INOUT</name></expr>:</case>
					<expr_stmt><expr><name>argmode</name> <operator>=</operator> <literal type="string">"INOUT "</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus value in proargmodes array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>argmode</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>argmode</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>argname</name> <operator>=</operator> <ternary><condition><expr><name>argnames</name></expr> ?</condition><then> <expr><name><name>argnames</name><index>[<expr><name>j</name></expr>]</index></name></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argname</name> <operator>&amp;&amp;</operator> <name><name>argname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>argmode</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>argname</name></expr> ?</condition><then> <expr><call><name>fmtId</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>argname</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * format_function_signature: generate function name and argument list
 *
 * This is like format_function_arguments_old except that only a minimal
 * list of input argument types is generated; this is sufficient to
 * reference the function, but not to define it.
 *
 * If honor_quotes is false then the function name is never quoted.
 * This is appropriate for use in TOC tags, but not in SQL commands.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_function_signature</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>fn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>honor_quotes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>fn</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * dumpFunc:
 *	  dump out one function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpFunc</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>FuncInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>asPart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcsig</name></decl>;</decl_stmt>		<comment type="block">/* identity signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcfullsig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* full signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcsig_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proretset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>probin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funciargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proallargtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proargmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proargnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>protrftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prokind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>provolatile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proisstrict</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prosecdef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proleakproof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proconfig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>procost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prorows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proparallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rettypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nallargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>allargtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argmodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>configitems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nconfigitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>asPart</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch function-specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * prokind was added in 11
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(oid) AS funciargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_result(oid) AS funcresult, "</literal>
						  <literal type="string">"array_to_string(protrftypes, ' ') AS protrftypes, "</literal>
						  <literal type="string">"prokind, provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"proleakproof, proconfig, procost, prorows, "</literal>
						  <literal type="string">"proparallel, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * proparallel was added in 9.6
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(oid) AS funciargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_result(oid) AS funcresult, "</literal>
						  <literal type="string">"array_to_string(protrftypes, ' ') AS protrftypes, "</literal>
						  <literal type="string">"CASE WHEN proiswindow THEN 'w' ELSE 'f' END AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"proleakproof, proconfig, procost, prorows, "</literal>
						  <literal type="string">"proparallel, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * protrftypes was added in 9.5
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(oid) AS funciargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_result(oid) AS funcresult, "</literal>
						  <literal type="string">"array_to_string(protrftypes, ' ') AS protrftypes, "</literal>
						  <literal type="string">"CASE WHEN proiswindow THEN 'w' ELSE 'f' END AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"proleakproof, proconfig, procost, prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90200</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * proleakproof was added in 9.2
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(oid) AS funciargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_result(oid) AS funcresult, "</literal>
						  <literal type="string">"CASE WHEN proiswindow THEN 'w' ELSE 'f' END AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"proleakproof, proconfig, procost, prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In 8.4 and up we rely on pg_get_function_arguments and
		 * pg_get_function_result instead of examining proallargtypes etc.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(oid) AS funciargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_result(oid) AS funcresult, "</literal>
						  <literal type="string">"CASE WHEN proiswindow THEN 'w' ELSE 'f' END AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"false AS proleakproof, "</literal>
						  <literal type="string">" proconfig, procost, prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"proallargtypes, proargmodes, proargnames, "</literal>
						  <literal type="string">"'f' AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"false AS proleakproof, "</literal>
						  <literal type="string">"proconfig, procost, prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"proallargtypes, proargmodes, proargnames, "</literal>
						  <literal type="string">"'f' AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"false AS proleakproof, "</literal>
						  <literal type="string">"null AS proconfig, 0 AS procost, 0 AS prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT proretset, prosrc, probin, "</literal>
						  <literal type="string">"null AS proallargtypes, "</literal>
						  <literal type="string">"null AS proargmodes, "</literal>
						  <literal type="string">"proargnames, "</literal>
						  <literal type="string">"'f' AS prokind, "</literal>
						  <literal type="string">"provolatile, proisstrict, prosecdef, "</literal>
						  <literal type="string">"false AS proleakproof, "</literal>
						  <literal type="string">"null AS proconfig, 0 AS procost, 0 AS prorows, "</literal>
						  <literal type="string">"(SELECT lanname FROM pg_catalog.pg_language WHERE oid = prolang) AS lanname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_proc "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proretset</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proretset"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prosrc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>probin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"probin"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funciargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funciargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcresult</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcresult"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proallargtypes</name> <operator>=</operator> <name>proargmodes</name> <operator>=</operator> <name>proargnames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>proallargtypes</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proallargtypes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proargmodes</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargmodes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proargnames</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proargnames"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <name>funciargs</name> <operator>=</operator> <name>funcresult</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"protrftypes"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>protrftypes</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"protrftypes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>protrftypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>prokind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prokind"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>provolatile</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"provolatile"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proisstrict</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proisstrict"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prosecdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prosecdef"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proleakproof</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proleakproof"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proconfig</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proconfig"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>procost</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"procost"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prorows</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"prorows"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"lanname"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See backend/commands/functioncmds.c for details of how the 'AS' clause
	 * is used.  In 8.4 and up, an unused probin is NULL (here ""); previous
	 * versions would set it to "-".  There are no known cases in which prosrc
	 * is unused, so the tests below for "-" are probably useless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>probin</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>probin</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">"AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>probin</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * where we have bin, use dollar quoting if allowed and src
			 * contains quote or backslash; else use regular quoting.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name> <operator>||</operator>
				<operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralDQ</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><literal type="string">"AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* with no bin, dollar quote src unconditionally if allowed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>disable_dollar_quoting</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringLiteralDQ</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>nallargs</name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>	<comment type="block">/* unless we learn different from allargs */</comment>

	<if_stmt><if>if <condition>(<expr><name>proallargtypes</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>proallargtypes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>proallargtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allargtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>nitems</name> <operator>&lt;</operator> <name><name>finfo</name><operator>-&gt;</operator><name>nargs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not parse proallargtypes array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>allargtypes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>allargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>allargtypes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nallargs</name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proargmodes</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>proargmodes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>proargmodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>nitems</name> <operator>!=</operator> <name>nallargs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not parse proargmodes array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>argmodes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>argmodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proargnames</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>proargnames</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>proargnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>nitems</name> <operator>!=</operator> <name>nallargs</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not parse proargnames array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>argnames</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proconfig</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>proconfig</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name>proconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>configitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigitems</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not parse proconfig array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>configitems</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>configitems</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nconfigitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>funcargs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 8.4 or later; we rely on server-side code for most of the work */</comment>
		<expr_stmt><expr><name>funcfullsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>funciargs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* pre-8.4, do it ourselves */</comment>
		<expr_stmt><expr><name>funcsig</name> <operator>=</operator> <call><name>format_function_arguments_old</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
												<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>nallargs</name></expr></argument>, <argument><expr><name>allargtypes</name></expr></argument>,
												<argument><expr><name>argmodes</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>funcsig_tag</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"PROCEDURE"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyword</name> <operator>=</operator> <literal type="string">"FUNCTION"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* works for window functions too */</comment>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP %s %s.%s;\n"</literal></expr></argument>,
					  <argument><expr><name>keyword</name></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s %s.%s"</literal></expr></argument>,
					  <argument><expr><name>keyword</name></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>funcfullsig</name></expr> ?</condition><then> <expr><name>funcfullsig</name></expr> </then><else>:
					  <expr><name>funcsig</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* no result type to output */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>funcresult</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RETURNS %s"</literal></expr></argument>, <argument><expr><name>funcresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rettypename</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>,
										   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RETURNS %s%s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><operator>(</operator><name><name>proretset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"SETOF "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>rettypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rettypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    LANGUAGE %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>protrftypes</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>protrftypes</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>typeids</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>FUNC_MAX_ARGS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TRANSFORM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>parseOidArray</name><argument_list>(<argument><expr><name>protrftypes</name></expr></argument>, <argument><expr><name>typeids</name></expr></argument>, <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FOR TYPE %s"</literal></expr></argument>,
							  <argument><expr><call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>typeids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prokind</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROKIND_WINDOW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" WINDOW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" IMMUTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" STABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>provolatile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized provolatile value for function \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proisstrict</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" STRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prosecdef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" SECURITY DEFINER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proleakproof</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" LEAKPROOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * COST and ROWS are emitted only if present and not default, so as not to
	 * break backwards-compatibility of the dump without need.  Keep this code
	 * in sync with the defaults in functioncmds.c.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>, <argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>, <argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* default cost is 1 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COST %s"</literal></expr></argument>, <argument><expr><name>procost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* default cost is 100 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>procost</name></expr></argument>, <argument><expr><literal type="string">"100"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COST %s"</literal></expr></argument>, <argument><expr><name>procost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proretset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>prorows</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>prorows</name></expr></argument>, <argument><expr><literal type="string">"1000"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ROWS %s"</literal></expr></argument>, <argument><expr><name>prorows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proparallel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_SAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL SAFE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_RESTRICTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL RESTRICTED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized proparallel value for function \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconfigitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* we feel free to scribble on configitems[] here */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>configitem</name> <init>= <expr><name><name>configitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    SET %s TO "</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Variables that are marked GUC_LIST_QUOTE were already fully quoted
		 * by flatten_set_variable_args() before they were put into the
		 * proconfig array.  However, because the quoting rules used there
		 * aren't exactly like SQL's, we have to break the list value apart
		 * and then quote the elements as string literals.  (The elements may
		 * be double-quoted as-is, but we can't just feed them to the SQL
		 * parser; it would do the wrong thing with elements that are
		 * zero-length or longer than NAMEDATALEN.)
		 *
		 * Variables that are not so marked should just be emitted as simple
		 * string literals.  If the variable is not known to
		 * variable_is_guc_list_quote(), we'll do that; this makes it unsafe
		 * to use GUC_LIST_QUOTE for extension variables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>variable_is_guc_list_quote</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>nameptr</name></decl>;</decl_stmt>

			<comment type="block">/* Parse string into list of identifiers */</comment>
			<comment type="block">/* this shouldn't fail really */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>nameptr</name> <operator>=</operator> <name>namelist</name></expr>;</init> <condition><expr><operator>*</operator><name>nameptr</name></expr>;</condition> <incr><expr><name>nameptr</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>nameptr</name> <operator>!=</operator> <name>namelist</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>*</operator><name>nameptr</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    %s;\n"</literal></expr></argument>, <argument><expr><name><name>asPart</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
										<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>funcsig_tag</name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Function Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
					<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>funcsig</name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name>keyword</name></expr></argument>,
				<argument><expr><name>funcsig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>proacl</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>rproacl</name></name></expr></argument>,
				<argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>initproacl</name></name></expr></argument>, <argument><expr><name><name>finfo</name><operator>-&gt;</operator><name>initrproacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>asPart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>funcfullsig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcfullsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>funcsig_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>allargtypes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>allargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>argmodes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>argnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>configitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Dump a user-defined cast
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCast</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CastInfo</name> <modifier>*</modifier></type><name>cast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>castargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>funcInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sourceType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>targetType</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot dump if we don't have the cast function's info */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>funcInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>funcInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not find function definition for function with OID %u\n"</literal></expr></argument>,
						  <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>labelq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>castargs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sourceType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>castsource</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>casttarget</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP CAST (%s AS %s);\n"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE CAST (%s AS %s) "</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castmethod</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COERCION_METHOD_BINARY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITHOUT FUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_METHOD_INOUT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITH INOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COERCION_METHOD_FUNCTION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>funcInfo</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>funcInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Always qualify the function name (format_function_signature
				 * won't qualify it).
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"WITH FUNCTION %s.%s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>funcInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus value in pg_cast.castfunc or pg_cast.castmethod field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus value in pg_cast.castmethod field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" AS ASSIGNMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>castcontext</name></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">" AS IMPLICIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"CAST (%s AS %s)"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>castargs</name></expr></argument>, <argument><expr><literal type="string">"(%s AS %s)"</literal></expr></argument>,
					  <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cast</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"CAST"</literal></expr></argument>, <argument><expr><name><name>castargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"CAST"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Cast Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CAST"</literal></expr></argument>, <argument><expr><name><name>castargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cast</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sourceType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>castargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump a transform
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTransform</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TransformInfo</name> <modifier>*</modifier></type><name>transform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>defqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>labelq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>transformargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>fromsqlFuncInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>tosqlFuncInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lanname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>transformType</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot dump if we don't have the transform functions' info */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fromsqlFuncInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fromsqlFuncInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not find function definition for function with OID %u\n"</literal></expr></argument>,
						  <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tosqlFuncInfo</name> <operator>=</operator> <call><name>findFuncByOid</name><argument_list>(<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tosqlFuncInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not find function definition for function with OID %u\n"</literal></expr></argument>,
						  <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>defqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>labelq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transformargs</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lanname</name> <operator>=</operator> <call><name>get_language_name</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trflang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transformType</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>trftype</name></name></expr></argument>, <argument><expr><name>zeroAsNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP TRANSFORM FOR %s LANGUAGE %s;\n"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"CREATE TRANSFORM FOR %s LANGUAGE %s ("</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus transform definition, at least one of trffromsql and trftosql should be nonzero\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fromsqlFuncInfo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>fromsqlFuncInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Always qualify the function name (format_function_signature
			 * won't qualify it).
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"FROM SQL WITH FUNCTION %s.%s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>fromsqlFuncInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus value in pg_transform.trffromsql field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trftosql</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>trffromsql</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tosqlFuncInfo</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fsig</name> <init>= <expr><call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tosqlFuncInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Always qualify the function name (format_function_signature
			 * won't qualify it).
			 */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">"TO SQL WITH FUNCTION %s.%s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tosqlFuncInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: bogus value in pg_transform.trftosql field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>, <argument><expr><literal type="string">"TRANSFORM FOR %s LANGUAGE %s"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>transformargs</name></expr></argument>, <argument><expr><literal type="string">"FOR %s LANGUAGE %s"</literal></expr></argument>,
					  <argument><expr><name>transformType</name></expr></argument>, <argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>transform</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TRANSFORM"</literal></expr></argument>, <argument><expr><name><name>transformargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>labelq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TRANSFORM"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>defqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dependencies</name></name></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>nDeps</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Transform Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TRANSFORM"</literal></expr></argument>, <argument><expr><name><name>transformargs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>transform</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lanname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>transformType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>defqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>labelq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>transformargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * dumpOpr
 *	  write out a single operator definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpr</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OprInfo</name> <modifier>*</modifier></type><name>oprinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>oprid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprnegate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprrest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprjoin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcanmerge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_oprcanhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprnegate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprrest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprjoin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcanmerge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprcanhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprregproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprref</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * some operators are invalid because they were the result of user
	 * defining operators before commutators exist
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>oprcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprid</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>details</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oprkind, "</literal>
						  <literal type="string">"oprcode::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"oprleft::pg_catalog.regtype, "</literal>
						  <literal type="string">"oprright::pg_catalog.regtype, "</literal>
						  <literal type="string">"oprcom, "</literal>
						  <literal type="string">"oprnegate, "</literal>
						  <literal type="string">"oprrest::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"oprjoin::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"oprcanmerge, oprcanhash "</literal>
						  <literal type="string">"FROM pg_catalog.pg_operator "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT oprkind, "</literal>
						  <literal type="string">"oprcode::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"oprleft::pg_catalog.regtype, "</literal>
						  <literal type="string">"oprright::pg_catalog.regtype, "</literal>
						  <literal type="string">"oprcom, "</literal>
						  <literal type="string">"oprnegate, "</literal>
						  <literal type="string">"oprrest::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"oprjoin::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"(oprlsortop != 0) AS oprcanmerge, "</literal>
						  <literal type="string">"oprcanhash "</literal>
						  <literal type="string">"FROM pg_catalog.pg_operator "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_oprkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcode</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprleft</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprleft"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprright</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprright"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcom</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcom"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprnegate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprnegate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprrest</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprrest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprjoin</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprjoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcanmerge</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcanmerge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_oprcanhash</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"oprcanhash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprkind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcode</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprleft</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprright</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcom</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprnegate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprnegate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprrest</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprrest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprjoin</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprjoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcanmerge</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcanmerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprcanhash</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_oprcanhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>oprcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">"    FUNCTION = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">"%s ("</literal></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * right unary means there's a left arg and left unary means there's a
	 * right arg
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    LEFTARG = %s"</literal></expr></argument>, <argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"l"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>oprkind</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    RIGHTARG = %s"</literal></expr></argument>, <argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">", %s)"</literal></expr></argument>, <argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>, <argument><expr><literal type="string">", NONE)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oprref</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>oprcom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprref</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    COMMUTATOR = %s"</literal></expr></argument>, <argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oprref</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>oprnegate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprref</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    NEGATOR = %s"</literal></expr></argument>, <argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprcanmerge</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MERGES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprcanhash</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    HASHES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>oprrest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    RESTRICT = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oprregproc</name> <operator>=</operator> <call><name>convertRegProcReference</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>oprjoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprregproc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    JOIN = %s"</literal></expr></argument>, <argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oprregproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR %s.%s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR %s.%s (\n%s\n);\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>details</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>, <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR"</literal></expr></argument>, <argument><expr><name><name>oprid</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>oprinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a function reference obtained from pg_operator
 *
 * Returns allocated string of what to print, or NULL if function references
 * is InvalidOid. Returned string is expected to be free'd by the caller.
 *
 * The input is a REGPROCEDURE display; we have to strip the argument-types
 * part.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convertRegProcReference</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>paren</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inquote</name></decl>;</decl_stmt>

	<comment type="block">/* In all cases "-" means a null reference */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* find non-double-quoted left paren */</comment>
	<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>paren</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>paren</name></expr>;</condition> <incr><expr><name>paren</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>paren</name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>inquote</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>paren</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>paren</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inquote</name> <operator>=</operator> <operator>!</operator><name>inquote</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getFormattedOperatorName - retrieve the operator name for the
 * given operator OID (presented in string form).
 *
 * Returns an allocated string, or NULL if the given OID is invalid.
 * Caller is responsible for free'ing result string.
 *
 * What we produce has the format "OPERATOR(schema.oprname)".  This is only
 * useful in commands where the operator's argument types can be inferred from
 * context.  We always schema-qualify the name, though.  The predecessor to
 * this code tried to skip the schema qualification if possible, but that led
 * to wrong results in corner cases, such as if an operator and its negator
 * are in different schemas.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getFormattedOperatorName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oproid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oprInfo</name></decl>;</decl_stmt>

	<comment type="block">/* In all cases "0" means a null reference */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oprInfo</name> <operator>=</operator> <call><name>findOprByOid</name><argument_list>(<argument><expr><call><name>atooid</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprInfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not find operator with OID %s\n"</literal></expr></argument>,
				  <argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"OPERATOR(%s.%s)"</literal></expr></argument>,
					<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>oprInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name><name>oprInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a function OID obtained from pg_ts_parser or pg_ts_template
 *
 * It is sufficient to use REGPROC rather than REGPROCEDURE, since the
 * argument lists of these functions are predetermined.  Note that the
 * caller should ensure we are in the proper schema, because the results
 * are search path dependent!
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convertTSFunction</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>query</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"SELECT '%u'::pg_catalog.regproc"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAccessMethod
 *	  write out a single access method definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAccessMethod</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AccessMethodInfo</name> <modifier>*</modifier></type><name>aminfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qamname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qamname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE ACCESS METHOD %s "</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>amtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AMTYPE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"TYPE INDEX "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: invalid type \"%c\" of access method \"%s\"\n"</literal></expr></argument>,
					  <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>amtype</name></name></expr></argument>, <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"HANDLER %s;\n"</literal></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP ACCESS METHOD %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"ACCESS METHOD"</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"ACCESS METHOD"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Access Method Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"ACCESS METHOD"</literal></expr></argument>, <argument><expr><name>qamname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aminfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qamname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpOpclass
 *	  write out a single operator class definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpclass</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OpclassInfo</name> <modifier>*</modifier></type><name>opcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>nameusing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opckeytype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamilyname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_opcfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opckeytype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamilyname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nameusing</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get additional fields from the pg_opclass row */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT opcintype::pg_catalog.regtype, "</literal>
						  <literal type="string">"opckeytype::pg_catalog.regtype, "</literal>
						  <literal type="string">"opcdefault, opcfamily, "</literal>
						  <literal type="string">"opfname AS opcfamilyname, "</literal>
						  <literal type="string">"nspname AS opcfamilynsp, "</literal>
						  <literal type="string">"(SELECT amname FROM pg_catalog.pg_am WHERE oid = opcmethod) AS amname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_opclass c "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = opcfamily "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT opcintype::pg_catalog.regtype, "</literal>
						  <literal type="string">"opckeytype::pg_catalog.regtype, "</literal>
						  <literal type="string">"opcdefault, NULL AS opcfamily, "</literal>
						  <literal type="string">"NULL AS opcfamilyname, "</literal>
						  <literal type="string">"NULL AS opcfamilynsp, "</literal>
						  <literal type="string">"(SELECT amname FROM pg_catalog.pg_am WHERE oid = opcamid) AS amname "</literal>
						  <literal type="string">"FROM pg_catalog.pg_opclass "</literal>
						  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_opcintype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcintype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opckeytype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opckeytype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcdefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcdefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamilyname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamilyname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_opcfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"opcfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* opcintype may still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcintype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opckeytype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opckeytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcdefault</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* opcfamily will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>opcfamily</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcfamilyname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_opcfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* amname will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>amname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR CLASS %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the fixed portion of the CREATE command */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR CLASS %s\n    "</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opcdefault</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FOR TYPE %s USING %s"</literal></expr></argument>,
					  <argument><expr><name>opcintype</name></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>opcfamilyname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FAMILY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>opcfamilyname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opckeytype</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"STORAGE %s"</literal></expr></argument>,
						  <argument><expr><name>opckeytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fetch and print the OPERATOR entries (pg_amop rows).
	 *
	 * Print only those opfamily members that are tied to the opclass by
	 * pg_depend entries.
	 *
	 * XXX RECHECK is gone as of 8.4, but we'll still print it if dumping an
	 * older server's opclass in which it is used.  This is to avoid
	 * hard-to-detect breakage if a newer pg_dump is used to dump from an
	 * older server and then reload into that old version.  This can go away
	 * once 8.3 is so old as to not be of interest to anyone.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"opfname AS sortfamily, "</literal>
						  <literal type="string">"nspname AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao JOIN pg_catalog.pg_depend ON "</literal>
						  <literal type="string">"(classid = 'pg_catalog.pg_amop'::pg_catalog.regclass AND objid = ao.oid) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = amopsortfamily "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND amopfamily = '%s'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
						  <argument><expr><name>opcfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Here, we print all entries since there are no opfamilies and hence
		 * no loose operators to worry about.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop "</literal>
						  <literal type="string">"WHERE amopclaid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amopstrategy</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopstrategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amopreqcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopreqcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amopopr</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amopopr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_sortfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"sortfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_sortfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"sortfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>amopstrategy</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amopreqcheck</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopreqcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amopopr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortfamily</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR %s %s"</literal></expr></argument>,
						  <argument><expr><name>amopstrategy</name></expr></argument>, <argument><expr><name>amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOR ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>amopreqcheck</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RECHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fetch and print the FUNCTION entries (pg_amproc rows).
	 *
	 * Print only those opfamily members that are tied to the opclass by
	 * pg_depend entries.
	 *
	 * We print the amproclefttype/amprocrighttype even though in most cases
	 * the backend could deduce the right values, because of the corner case
	 * of a btree sort support function for a cross-type comparison.  That's
	 * only allowed in 9.2 and later, but for simplicity print them in all
	 * versions that have the columns.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80300</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amprocnum, "</literal>
						  <literal type="string">"amproc::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"amproclefttype::pg_catalog.regtype, "</literal>
						  <literal type="string">"amprocrighttype::pg_catalog.regtype "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amproc ap, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opclass'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amproc'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ap.oid "</literal>
						  <literal type="string">"ORDER BY amprocnum"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amprocnum, "</literal>
						  <literal type="string">"amproc::pg_catalog.regprocedure, "</literal>
						  <literal type="string">"'' AS amproclefttype, "</literal>
						  <literal type="string">"'' AS amprocrighttype "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amproc "</literal>
						  <literal type="string">"WHERE amopclaid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amprocnum"</literal></expr></argument>,
						  <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amprocnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amprocnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amproclefttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amproclefttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_amprocrighttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amprocrighttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>amprocnum</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amproclefttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproclefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>amprocrighttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION %s"</literal></expr></argument>, <argument><expr><name>amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>amproclefttype</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>amprocrighttype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (%s, %s)"</literal></expr></argument>, <argument><expr><name>amproclefttype</name></expr></argument>, <argument><expr><name>amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If needComma is still false it means we haven't added anything after
	 * the AS keyword.  To avoid printing broken SQL, append a dummy STORAGE
	 * clause with the same datatype.  This isn't sanctioned by the
	 * documentation, but actually DefineOpClass will treat it as a no-op.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"STORAGE %s"</literal></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Class Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR CLASS"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>opcinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>opcfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpOpfamily
 *	  write out a single operator family definition
 *
 * Note: this also dumps any "loose" operator members that aren't bound to a
 * specific opclass within the opfamily.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpOpfamily</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>OpfamilyInfo</name> <modifier>*</modifier></type><name>opfinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>nameusing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res_ops</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res_procs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopreqcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amopopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sortfamilynsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amproclefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>amprocrighttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nameusing</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch only those opfamily members that are tied directly to the
	 * opfamily by pg_depend entries.
	 *
	 * XXX RECHECK is gone as of 8.4, but we'll still print it if dumping an
	 * older server's opclass in which it is used.  This is to avoid
	 * hard-to-detect breakage if a newer pg_dump is used to dump from an
	 * older server and then reload into that old version.  This can go away
	 * once 8.3 is so old as to not be of interest to anyone.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"opfname AS sortfamily, "</literal>
						  <literal type="string">"nspname AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao JOIN pg_catalog.pg_depend ON "</literal>
						  <literal type="string">"(classid = 'pg_catalog.pg_amop'::pg_catalog.regclass AND objid = ao.oid) "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_opfamily f ON f.oid = amopsortfamily "</literal>
						  <literal type="string">"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = opfnamespace "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND amopfamily = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, false AS amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amopstrategy, amopreqcheck, "</literal>
						  <literal type="string">"amopopr::pg_catalog.regoperator, "</literal>
						  <literal type="string">"NULL AS sortfamily, "</literal>
						  <literal type="string">"NULL AS sortfamilynsp "</literal>
						  <literal type="string">"FROM pg_catalog.pg_amop ao, pg_catalog.pg_depend "</literal>
						  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
						  <literal type="string">"AND classid = 'pg_catalog.pg_amop'::pg_catalog.regclass "</literal>
						  <literal type="string">"AND objid = ao.oid "</literal>
						  <literal type="string">"ORDER BY amopstrategy"</literal></expr></argument>,
						  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res_ops</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT amprocnum, "</literal>
					  <literal type="string">"amproc::pg_catalog.regprocedure, "</literal>
					  <literal type="string">"amproclefttype::pg_catalog.regtype, "</literal>
					  <literal type="string">"amprocrighttype::pg_catalog.regtype "</literal>
					  <literal type="string">"FROM pg_catalog.pg_amproc ap, pg_catalog.pg_depend "</literal>
					  <literal type="string">"WHERE refclassid = 'pg_catalog.pg_opfamily'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND refobjid = '%u'::pg_catalog.oid "</literal>
					  <literal type="string">"AND classid = 'pg_catalog.pg_amproc'::pg_catalog.regclass "</literal>
					  <literal type="string">"AND objid = ap.oid "</literal>
					  <literal type="string">"ORDER BY amprocnum"</literal></expr></argument>,
					  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_procs</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get additional fields from the pg_opfamily row */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"(SELECT amname FROM pg_catalog.pg_am WHERE oid = opfmethod) AS amname "</literal>
					  <literal type="string">"FROM pg_catalog.pg_opfamily "</literal>
					  <literal type="string">"WHERE oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
					  <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_amname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"amname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* amname will still be needed after we PQclear res */</comment>
	<expr_stmt><expr><name>amname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP OPERATOR FAMILY %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build the fixed portion of the CREATE command */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE OPERATOR FAMILY %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" USING %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we need an ALTER to add loose members? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER OPERATOR FAMILY %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>opfinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" USING %s ADD\n    "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now fetch and print the OPERATOR entries (pg_amop rows).
		 */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_amopstrategy</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopstrategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amopreqcheck</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopreqcheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amopopr</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"amopopr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_sortfamily</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"sortfamily"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_sortfamilynsp</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><literal type="string">"sortfamilynsp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>amopstrategy</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amopreqcheck</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopreqcheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amopopr</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortfamily</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sortfamilynsp</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_sortfamilynsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR %s %s"</literal></expr></argument>,
							  <argument><expr><name>amopstrategy</name></expr></argument>, <argument><expr><name>amopopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOR ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamilynsp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>sortfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>amopreqcheck</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" RECHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now fetch and print the FUNCTION entries (pg_amproc rows).
		 */</comment>
		<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i_amprocnum</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amprocnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amproclefttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amproclefttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_amprocrighttype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><literal type="string">"amprocrighttype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>amprocnum</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amproclefttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amproclefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>amprocrighttype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_amprocrighttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ,\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"FUNCTION %s (%s, %s) %s"</literal></expr></argument>,
							  <argument><expr><name>amprocnum</name></expr></argument>, <argument><expr><name>amproclefttype</name></expr></argument>, <argument><expr><name>amprocrighttype</name></expr></argument>,
							  <argument><expr><name>amproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
										<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Operator Family Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR FAMILY"</literal></expr></argument>, <argument><expr><name><name>nameusing</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>opfinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res_procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>nameusing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpCollation
 *	  write out a single collation definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpCollation</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CollInfo</name> <modifier>*</modifier></type><name>collinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qcollname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collprovider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collcollate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_collctype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collprovider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collcollate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collctype</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qcollname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get collation-specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						  <literal type="string">"collprovider, "</literal>
						  <literal type="string">"collcollate, "</literal>
						  <literal type="string">"collctype, "</literal>
						  <literal type="string">"collversion "</literal>
						  <literal type="string">"FROM pg_catalog.pg_collation c "</literal>
						  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						  <literal type="string">"'c' AS collprovider, "</literal>
						  <literal type="string">"collcollate, "</literal>
						  <literal type="string">"collctype, "</literal>
						  <literal type="string">"NULL AS collversion "</literal>
						  <literal type="string">"FROM pg_catalog.pg_collation c "</literal>
						  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_collprovider</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collprovider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collcollate</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collcollate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_collctype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collctype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>collprovider</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collprovider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collcollate</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collctype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP COLLATION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>collinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE COLLATION %s ("</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>collinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"provider = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"libc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"icu"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>collprovider</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* to allow dumping pg_catalog; not accepted on input */</comment>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">"unrecognized collation provider: %s\n"</literal></expr></argument>,
					  <argument><expr><name>collprovider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", locale = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", lc_collate = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collcollate</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", lc_ctype = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>collctype</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For binary upgrade, carry over the collation version.  For normal
	 * dump/restore, omit the version, so that it is computed upon restore.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i_collversion</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i_collversion</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"collversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collversion</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", version = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
								  <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_collversion</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"COLLATION"</literal></expr></argument>, <argument><expr><name>qcollname</name></expr></argument>,
										<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"COLLATION"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Collation Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"COLLATION"</literal></expr></argument>, <argument><expr><name>qcollname</name></expr></argument>,
					<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>collinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qcollname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpConversion
 *	  write out a single conversion definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpConversion</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConvInfo</name> <modifier>*</modifier></type><name>convinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qconvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conforencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_contoencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_condefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conforencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contoencoding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>condefault</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qconvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get conversion-specific details */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"pg_catalog.pg_encoding_to_char(conforencoding) AS conforencoding, "</literal>
					  <literal type="string">"pg_catalog.pg_encoding_to_char(contoencoding) AS contoencoding, "</literal>
					  <literal type="string">"conproc, condefault "</literal>
					  <literal type="string">"FROM pg_catalog.pg_conversion c "</literal>
					  <literal type="string">"WHERE c.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
					  <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_conforencoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conforencoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_contoencoding</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"contoencoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_conproc</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conproc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_condefault</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"condefault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conforencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_conforencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>contoencoding</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_contoencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conproc</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_conproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>condefault</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_condefault</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONVERSION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>convinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sCONVERSION %s FOR "</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><operator>(</operator><name>condefault</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DEFAULT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>convinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>conforencoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>contoencoding</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* regproc output is already sufficiently quoted */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FROM %s;\n"</literal></expr></argument>, <argument><expr><name>conproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>, <argument><expr><name>qconvname</name></expr></argument>,
										<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Conversion Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"CONVERSION"</literal></expr></argument>, <argument><expr><name>qconvname</name></expr></argument>,
					<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>convinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qconvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * format_aggregate_signature: generate aggregate name and argument list
 *
 * The argument type names are qualified if needed.  The aggregate name
 * is never qualified.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_aggregate_signature</name><parameter_list>(<parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>honor_quotes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBufferData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>honor_quotes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(*)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>getFormattedTypeName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>argtypes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name>zeroAsOpaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							  <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAgg
 *	  write out a single aggregate definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAgg</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AggInfo</name> <modifier>*</modifier></type><name>agginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>details</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsig</name></decl>;</decl_stmt>			<comment type="block">/* identity signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggfullsig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* full signature */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsig_tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggcombinefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggdeserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggminvtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggsortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggmtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_agginitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_aggminitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_convertok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_proparallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggcombinefn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggdeserialfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggminvtransfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmfinalfn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>aggfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>aggmfinalextra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggmfinalmodify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggsortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aggsortconvop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtranstype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggmtransspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>agginitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggminitval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>convertok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proparallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>defaultfinalmodify</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>details</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get aggregate-specific details */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"aggcombinefn, aggserialfn, aggdeserialfn, aggmtransfn, "</literal>
						  <literal type="string">"aggminvtransfn, aggmfinalfn, aggmtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"aggfinalextra, aggmfinalextra, "</literal>
						  <literal type="string">"aggfinalmodify, aggmfinalmodify, "</literal>
						  <literal type="string">"aggsortop, "</literal>
						  <literal type="string">"aggkind, "</literal>
						  <literal type="string">"aggtransspace, agginitval, "</literal>
						  <literal type="string">"aggmtransspace, aggminitval, "</literal>
						  <literal type="string">"true AS convertok, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs, "</literal>
						  <literal type="string">"p.proparallel "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"aggcombinefn, aggserialfn, aggdeserialfn, aggmtransfn, "</literal>
						  <literal type="string">"aggminvtransfn, aggmfinalfn, aggmtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"aggfinalextra, aggmfinalextra, "</literal>
						  <literal type="string">"'0' AS aggfinalmodify, '0' AS aggmfinalmodify, "</literal>
						  <literal type="string">"aggsortop, "</literal>
						  <literal type="string">"aggkind, "</literal>
						  <literal type="string">"aggtransspace, agginitval, "</literal>
						  <literal type="string">"aggmtransspace, aggminitval, "</literal>
						  <literal type="string">"true AS convertok, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs, "</literal>
						  <literal type="string">"p.proparallel "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"'-' AS aggcombinefn, '-' AS aggserialfn, "</literal>
						  <literal type="string">"'-' AS aggdeserialfn, aggmtransfn, aggminvtransfn, "</literal>
						  <literal type="string">"aggmfinalfn, aggmtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"aggfinalextra, aggmfinalextra, "</literal>
						  <literal type="string">"'0' AS aggfinalmodify, '0' AS aggmfinalmodify, "</literal>
						  <literal type="string">"aggsortop, "</literal>
						  <literal type="string">"aggkind, "</literal>
						  <literal type="string">"aggtransspace, agginitval, "</literal>
						  <literal type="string">"aggmtransspace, aggminitval, "</literal>
						  <literal type="string">"true AS convertok, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"'-' AS aggcombinefn, '-' AS aggserialfn, "</literal>
						  <literal type="string">"'-' AS aggdeserialfn, '-' AS aggmtransfn, "</literal>
						  <literal type="string">"'-' AS aggminvtransfn, '-' AS aggmfinalfn, "</literal>
						  <literal type="string">"0 AS aggmtranstype, false AS aggfinalextra, "</literal>
						  <literal type="string">"false AS aggmfinalextra, "</literal>
						  <literal type="string">"'0' AS aggfinalmodify, '0' AS aggmfinalmodify, "</literal>
						  <literal type="string">"aggsortop, "</literal>
						  <literal type="string">"'n' AS aggkind, "</literal>
						  <literal type="string">"0 AS aggtransspace, agginitval, "</literal>
						  <literal type="string">"0 AS aggmtransspace, NULL AS aggminitval, "</literal>
						  <literal type="string">"true AS convertok, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_arguments(p.oid) AS funcargs, "</literal>
						  <literal type="string">"pg_catalog.pg_get_function_identity_arguments(p.oid) AS funciargs "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80100</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"'-' AS aggcombinefn, '-' AS aggserialfn, "</literal>
						  <literal type="string">"'-' AS aggdeserialfn, '-' AS aggmtransfn, "</literal>
						  <literal type="string">"'-' AS aggminvtransfn, '-' AS aggmfinalfn, "</literal>
						  <literal type="string">"0 AS aggmtranstype, false AS aggfinalextra, "</literal>
						  <literal type="string">"false AS aggmfinalextra, "</literal>
						  <literal type="string">"'0' AS aggfinalmodify, '0' AS aggmfinalmodify, "</literal>
						  <literal type="string">"aggsortop, "</literal>
						  <literal type="string">"'n' AS aggkind, "</literal>
						  <literal type="string">"0 AS aggtransspace, agginitval, "</literal>
						  <literal type="string">"0 AS aggmtransspace, NULL AS aggminitval, "</literal>
						  <literal type="string">"true AS convertok "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT aggtransfn, "</literal>
						  <literal type="string">"aggfinalfn, aggtranstype::pg_catalog.regtype, "</literal>
						  <literal type="string">"'-' AS aggcombinefn, '-' AS aggserialfn, "</literal>
						  <literal type="string">"'-' AS aggdeserialfn, '-' AS aggmtransfn, "</literal>
						  <literal type="string">"'-' AS aggminvtransfn, '-' AS aggmfinalfn, "</literal>
						  <literal type="string">"0 AS aggmtranstype, false AS aggfinalextra, "</literal>
						  <literal type="string">"false AS aggmfinalextra, "</literal>
						  <literal type="string">"'0' AS aggfinalmodify, '0' AS aggmfinalmodify, "</literal>
						  <literal type="string">"0 AS aggsortop, "</literal>
						  <literal type="string">"'n' AS aggkind, "</literal>
						  <literal type="string">"0 AS aggtransspace, agginitval, "</literal>
						  <literal type="string">"0 AS aggmtransspace, NULL AS aggminitval, "</literal>
						  <literal type="string">"true AS convertok "</literal>
						  <literal type="string">"FROM pg_catalog.pg_aggregate a, pg_catalog.pg_proc p "</literal>
						  <literal type="string">"WHERE a.aggfnoid = p.oid "</literal>
						  <literal type="string">"AND p.oid = '%u'::pg_catalog.oid"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_aggtransfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtransfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggfinalfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggcombinefn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggcombinefn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggserialfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggserialfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggdeserialfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggdeserialfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmtransfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtransfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggminvtransfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggminvtransfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmfinalfn</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalfn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggfinalextra</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalextra"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmfinalextra</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalextra"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggfinalmodify</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggfinalmodify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmfinalmodify</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmfinalmodify"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggsortop</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggsortop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggkind</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggkind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggtranstype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtranstype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggtransspace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggtransspace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmtranstype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtranstype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggmtransspace</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggmtransspace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_agginitval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"agginitval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_aggminitval</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"aggminitval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_convertok</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"convertok"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_proparallel</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aggtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggcombinefn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggcombinefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggserialfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggdeserialfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggdeserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggminvtransfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggminvtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalfn</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalextra</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggfinalextra</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalextra</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmfinalextra</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggfinalmodify</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggfinalmodify</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmfinalmodify</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmfinalmodify</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggsortop</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggsortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggkind</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggkind</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggtranstype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggtransspace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtranstype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggmtransspace</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggmtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>agginitval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_agginitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aggminitval</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggminitval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>convertok</name> <operator>=</operator> <operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_convertok</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'t'</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 8.4 or later; we rely on server-side code for most of the work */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcargs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funciargs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funcargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funciargs</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"funciargs"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggfullsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>funcargs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>funciargs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* pre-8.4, do it ourselves */</comment>
		<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_aggregate_signature</name><argument_list>(<argument><expr><name>agginfo</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>aggsig_tag</name> <operator>=</operator> <call><name>format_aggregate_signature</name><argument_list>(<argument><expr><name>agginfo</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i_proparallel</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"proparallel"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>proparallel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>convertok</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: aggregate function %s could not be dumped correctly for this database version; ignored\n"</literal></expr></argument>,
				  <argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggfullsig</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggfullsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* identify default modify flag for aggkind (must match DefineAggregate) */</comment>
	<expr_stmt><expr><name>defaultfinalmodify</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>aggkind</name> <operator>==</operator> <name>AGGKIND_NORMAL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AGGMODIFY_READ_ONLY</name></expr> </then><else>: <expr><name>AGGMODIFY_READ_WRITE</name></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* replace omitted flags for old versions */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggfinalmodify</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggfinalmodify</name> <operator>=</operator> <name>defaultfinalmodify</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggmfinalmodify</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>aggmfinalmodify</name> <operator>=</operator> <name>defaultfinalmodify</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* regproc and regtype output is already sufficiently quoted */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">"    SFUNC = %s,\n    STYPE = %s"</literal></expr></argument>,
					  <argument><expr><name>aggtransfn</name></expr></argument>, <argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggtransspace</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SSPACE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_agginitval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    INITCOND = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><name>agginitval</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggfinalfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC = %s"</literal></expr></argument>,
						  <argument><expr><name>aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggfinalextra</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggfinalmodify</name> <operator>!=</operator> <name>defaultfinalmodify</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>aggfinalmodify</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = READ_ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = SHAREABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    FINALFUNC_MODIFY = READ_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized aggfinalmodify value for aggregate \"%s\"\n"</literal></expr></argument>,
								  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggcombinefn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    COMBINEFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggcombinefn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggserialfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SERIALFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggdeserialfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    DESERIALFUNC = %s"</literal></expr></argument>, <argument><expr><name>aggdeserialfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmtransfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MSFUNC = %s,\n    MINVFUNC = %s,\n    MSTYPE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmtransfn</name></expr></argument>,
						  <argument><expr><name>aggminvtransfn</name></expr></argument>,
						  <argument><expr><name>aggmtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmtransspace</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MSSPACE = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmtransspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_aggminitval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MINITCOND = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><name>aggminitval</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>aggmfinalfn</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC = %s"</literal></expr></argument>,
						  <argument><expr><name>aggmfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggmfinalextra</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggmfinalmodify</name> <operator>!=</operator> <name>defaultfinalmodify</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>aggmfinalmodify</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = READ_ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = SHAREABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    MFINALFUNC_MODIFY = READ_WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized aggmfinalmodify value for aggregate \"%s\"\n"</literal></expr></argument>,
								  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>aggsortconvop</name> <operator>=</operator> <call><name>getFormattedOperatorName</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>aggsortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggsortconvop</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    SORTOP = %s"</literal></expr></argument>,
						  <argument><expr><name>aggsortconvop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsortconvop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggkind</name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    HYPOTHETICAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>proparallel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_SAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    PARALLEL = safe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>PROPARALLEL_RESTRICTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>details</name></expr></argument>, <argument><expr><literal type="string">",\n    PARALLEL = restricted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>proparallel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized proparallel value for function \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP AGGREGATE %s.%s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE AGGREGATE %s.%s (\n%s\n);\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><ternary><condition><expr><name>aggfullsig</name></expr> ?</condition><then> <expr><name>aggfullsig</name></expr> </then><else>: <expr><name>aggsig</name></expr></else></ternary></expr></argument>, <argument><expr><name><name>details</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
										<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>aggsig_tag</name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Aggregate Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since there is no GRANT ON AGGREGATE syntax, we have to make the ACL
	 * command look like a function's GRANT; in particular this affects the
	 * syntax for zero-argument aggregates and ordered-set aggregates.
	 */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aggsig</name> <operator>=</operator> <call><name>format_function_signature</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				<argument><expr><literal type="string">"FUNCTION"</literal></expr></argument>, <argument><expr><name>aggsig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rolname</name></name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>proacl</name></name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>rproacl</name></name></expr></argument>,
				<argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>initproacl</name></name></expr></argument>, <argument><expr><name><name>agginfo</name><operator>-&gt;</operator><name>aggfn</name><operator>.</operator><name>initrproacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggfullsig</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggfullsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aggsig_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSParser
 *	  write out a single text search parser
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSParser</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSParserInfo</name> <modifier>*</modifier></type><name>prsinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qprsname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qprsname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH PARSER %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>prsinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    START = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    GETTOKEN = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prstoken</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    END = %s,\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsend</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsheadline</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    HEADLINE = %s,\n"</literal></expr></argument>,
						  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prsheadline</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    LEXTYPES = %s );\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>prslextype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH PARSER %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>prsinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>, <argument><expr><name>qprsname</name></expr></argument>,
										<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Parser Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH PARSER"</literal></expr></argument>, <argument><expr><name>qprsname</name></expr></argument>,
					<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>prsinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qprsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSDictionary
 *	  write out a single text search dictionary
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSDictionary</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSDictInfo</name> <modifier>*</modifier></type><name>dictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qdictname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmplname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdictname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch name and namespace of the dictionary's template */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT nspname, tmplname "</literal>
					  <literal type="string">"FROM pg_ts_template p, pg_namespace n "</literal>
					  <literal type="string">"WHERE p.oid = '%u' AND n.oid = tmplnamespace"</literal></expr></argument>,
					  <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dicttemplate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmplname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH DICTIONARY %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>dictinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    TEMPLATE = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tmplname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the dictinitoption can be dumped straight into the command */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dictinitoption</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    %s"</literal></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dictinitoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" );\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH DICTIONARY %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>dictinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>, <argument><expr><name>qdictname</name></expr></argument>,
										<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Dictionary Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY"</literal></expr></argument>, <argument><expr><name>qdictname</name></expr></argument>,
					<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dictinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qdictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSTemplate
 *	  write out a single text search template
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSTemplate</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSTemplateInfo</name> <modifier>*</modifier></type><name>tmplinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtmplname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtmplname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH TEMPLATE %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tmplinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmplinit</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    INIT = %s,\n"</literal></expr></argument>,
						  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmplinit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    LEXIZE = %s );\n"</literal></expr></argument>,
					  <argument><expr><call><name>convertTSFunction</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>tmpllexize</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH TEMPLATE %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tmplinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>, <argument><expr><name>qtmplname</name></expr></argument>,
										<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><literal type="string">""</literal></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Template Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH TEMPLATE"</literal></expr></argument>, <argument><expr><name>qtmplname</name></expr></argument>,
					<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					<argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tmplinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtmplname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTSConfig
 *	  write out a single text search configuration
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTSConfig</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TSConfigInfo</name> <modifier>*</modifier></type><name>cfginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qcfgname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prsname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_tokenname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_dictname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qcfgname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch name and namespace of the config's parser */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT nspname, prsname "</literal>
					  <literal type="string">"FROM pg_ts_parser p, pg_namespace n "</literal>
					  <literal type="string">"WHERE p.oid = '%u' AND n.oid = prsnamespace"</literal></expr></argument>,
					  <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>cfgparser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prsname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TEXT SEARCH CONFIGURATION %s (\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    PARSER = %s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s );\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>prsname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT\n"</literal>
					  <literal type="string">"  ( SELECT alias FROM pg_catalog.ts_token_type('%u'::pg_catalog.oid) AS t\n"</literal>
					  <literal type="string">"    WHERE t.tokid = m.maptokentype ) AS tokenname,\n"</literal>
					  <literal type="string">"  m.mapdict::pg_catalog.regdictionary AS dictname\n"</literal>
					  <literal type="string">"FROM pg_catalog.pg_ts_config_map AS m\n"</literal>
					  <literal type="string">"WHERE m.mapcfg = '%u'\n"</literal>
					  <literal type="string">"ORDER BY m.mapcfg, m.maptokentype, m.mapseqno"</literal></expr></argument>,
					  <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>cfgparser</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_tokenname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tokenname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_dictname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"dictname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tokenname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_tokenname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dictname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_dictname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>tokenname</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>i_tokenname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* starting a new token type, so start a new command */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TEXT SEARCH CONFIGURATION %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* tokenname needs quoting, dictname does NOT */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD MAPPING FOR %s WITH %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>tokenname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ntups</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TEXT SEARCH CONFIGURATION %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>cfginfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>, <argument><expr><name>qcfgname</name></expr></argument>,
										<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Configuration Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION"</literal></expr></argument>, <argument><expr><name>qcfgname</name></expr></argument>,
					<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cfginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qcfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpForeignDataWrapper
 *	  write out a single foreign-data wrapper definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpForeignDataWrapper</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>FdwInfo</name> <modifier>*</modifier></type><name>fdwinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qfdwname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qfdwname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE FOREIGN DATA WRAPPER %s"</literal></expr></argument>,
					  <argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwhandler</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" HANDLER %s"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" VALIDATOR %s"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwvalidator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP FOREIGN DATA WRAPPER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Foreign Data Wrapper Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle the ACL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				<argument><expr><literal type="string">"FOREIGN DATA WRAPPER"</literal></expr></argument>, <argument><expr><name>qfdwname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
				<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>fdwacl</name></name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>rfdwacl</name></name></expr></argument>,
				<argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>initfdwacl</name></name></expr></argument>, <argument><expr><name><name>fdwinfo</name><operator>-&gt;</operator><name>initrfdwacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qfdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpForeignServer
 *	  write out a foreign server definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpForeignServer</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ForeignServerInfo</name> <modifier>*</modifier></type><name>srvinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qsrvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fdwname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qsrvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* look up the foreign-data wrapper */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT fdwname "</literal>
					  <literal type="string">"FROM pg_foreign_data_wrapper w "</literal>
					  <literal type="string">"WHERE w.oid = '%u'"</literal></expr></argument>,
					  <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvfdw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fdwname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE SERVER %s"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" TYPE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvtype</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" VERSION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvversion</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" FOREIGN DATA WRAPPER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvoptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP SERVER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SERVER"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Foreign Server Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle the ACL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				<argument><expr><literal type="string">"FOREIGN SERVER"</literal></expr></argument>, <argument><expr><name>qsrvname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
				<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>srvacl</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rsrvacl</name></name></expr></argument>,
				<argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>initsrvacl</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>initrsrvacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump user mappings */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_USERMAP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpUserMappings</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
						 <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>srvinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qsrvname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpUserMappings
 *
 * This routine is used to dump any user mappings associated with the
 * server handed to this routine. Should be called after ArchiveEntry()
 * for the server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpUserMappings</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>servername</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
				 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_usename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_umoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We read from the publicly accessible view pg_user_mappings, so as not
	 * to fail if run by a non-superuser.  Note that the view will show
	 * umoptions as null if the user hasn't got privileges for the associated
	 * server; this means that pg_dump will dump such a mapping, but with no
	 * OPTIONS clause.  A possible alternative is to skip such mappings
	 * altogether, but it's not clear that that's an improvement.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT usename, "</literal>
					  <literal type="string">"array_to_string(ARRAY("</literal>
					  <literal type="string">"SELECT quote_ident(option_name) || ' ' || "</literal>
					  <literal type="string">"quote_literal(option_value) "</literal>
					  <literal type="string">"FROM pg_options_to_table(umoptions) "</literal>
					  <literal type="string">"ORDER BY option_name"</literal>
					  <literal type="string">"), E',\n    ') AS umoptions "</literal>
					  <literal type="string">"FROM pg_user_mappings "</literal>
					  <literal type="string">"WHERE srvid = '%u' "</literal>
					  <literal type="string">"ORDER BY usename"</literal></expr></argument>,
					  <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_usename</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"usename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_umoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"umoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>usename</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>umoptions</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>usename</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_usename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>umoptions</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_umoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE USER MAPPING FOR %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>usename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" SERVER %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>umoptions</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>umoptions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name>umoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP USER MAPPING FOR %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>usename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">" SERVER %s;\n"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"USER MAPPING %s SERVER %s"</literal></expr></argument>,
						  <argument><expr><name>usename</name></expr></argument>, <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name>namespace</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"USER MAPPING"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>dumpId</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write out default privileges information
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpDefaultACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>DefaultACLInfo</name> <modifier>*</modifier></type><name>daclinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>aclsSkip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEFACLOBJ_RELATION</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"TABLES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"SEQUENCES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"FUNCTIONS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"TYPES"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DEFACLOBJ_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"SCHEMAS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* shouldn't get here */</comment>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"unrecognized object type in default privileges: %d\n"</literal></expr></argument>,
						  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>daclinfo</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT PRIVILEGES FOR %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the actual command(s) for this tuple */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildDefaultACLCommands</name><argument_list>(<argument><expr><name>type</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
								 <expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclacl</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>rdefaclacl</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>initdefaclacl</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>initrdefaclacl</name></name></expr></argument>,
								 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclrole</name></name></expr></argument>,
								 <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>,
								 <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not parse default ACL list (%s)\n"</literal></expr></argument>,
					  <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr> ?</condition><then> <expr><name><name>daclinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>daclinfo</name><operator>-&gt;</operator><name>defaclrole</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT ACL"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 * Write out grant/revoke information
 *
 * 'objCatId' is the catalog ID of the underlying object.
 * 'objDumpId' is the dump ID of the underlying object.
 * 'type' must be one of
 *		TABLE, SEQUENCE, FUNCTION, LANGUAGE, SCHEMA, DATABASE, TABLESPACE,
 *		FOREIGN DATA WRAPPER, SERVER, or LARGE OBJECT.
 * 'name' is the formatted name of the object.  Must be quoted etc. already.
 * 'subname' is the formatted name of the sub-object, if any.  Must be quoted.
 *		(Currently we assume that subname is only provided for table columns.)
 * 'nspname' is the namespace the object is in (NULL if none).
 * 'owner' is the owner, NULL if there is no owner (for languages).
 * 'acls' contains the ACL string of the object from the appropriate system
 * 		catalog field; it will be passed to buildACLCommands for building the
 * 		appropriate GRANT commands.
 * 'racls' contains the ACL string of any initial-but-now-revoked ACLs of the
 * 		object; it will be passed to buildACLCommands for building the
 * 		appropriate REVOKE commands.
 * 'initacls' In binary-upgrade mode, ACL string of the object's initial
 * 		privileges, to be recorded into pg_init_privs
 * 'initracls' In binary-upgrade mode, ACL string of the object's
 * 		revoked-from-default privileges, to be recorded into pg_init_privs
 *
 * NB: initacls/initracls are needed because extensions can set privileges on
 * an object during the extension's script file and we record those into
 * pg_init_privs as that object's initial privileges.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpACL</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>CatalogId</name></type> <name>objCatId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>objDumpId</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subname</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>racls</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initacls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>initracls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>sql</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if ACL dump is not enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>aclsSkip</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* --data-only skips ACLs *except* BLOB ACLs */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if this object has had any initial ACLs included for it.
	 * If so, we are in binary upgrade mode and these are the ACLs to turn
	 * into GRANT and REVOKE statements to set and record the initial
	 * privileges for an extension object.  Let the backend know that these
	 * are to be recorded by calling binary_upgrade_set_record_init_privs()
	 * before and after.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>initacls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>initracls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(true);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
							  <argument><expr><name>initacls</name></expr></argument>, <argument><expr><name>initracls</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
							  <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><literal type="string">"could not parse initial GRANT ACL list (%s) or initial REVOKE ACL list (%s) for object \"%s\" (%s)\n"</literal></expr></argument>,
						  <argument><expr><name>initacls</name></expr></argument>, <argument><expr><name>initracls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_record_init_privs(false);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildACLCommands</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
						  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>racls</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
						  <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><literal type="string">"could not parse GRANT ACL list (%s) or REVOKE ACL list (%s) for object \"%s\" (%s)\n"</literal></expr></argument>,
					  <argument><expr><name>acls</name></expr></argument>, <argument><expr><name>racls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sql</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s.%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>owner</name></expr> ?</condition><then> <expr><name>owner</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"ACL"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
					 <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name>objDumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSecLabel
 *
 * This routine is used to dump any security labels associated with the
 * object handed to this routine. The routine takes the object type
 * and object name (ready to print, except for schema decoration), plus
 * the namespace and owner of the object (for labeling the ArchiveEntry),
 * plus catalog ID and subid which are the lookup key for pg_seclabel,
 * plus the dump ID for the object (for setting a dependency).
 * If a matching pg_seclabel entry is found, it is dumped.
 *
 * Note: although this routine takes a dumpId for dependency purposes,
 * that purpose is just to mark the dependency in the emitted dump file
 * for possible future use by pg_restore.  We do NOT use it for determining
 * ordering of the label in the dump file, because this routine is called
 * after dependency sorting occurs.  This routine should be called just after
 * calling ArchiveEntry() for the specified object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
			 <parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subid</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlabels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-security-labels is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Security labels are schema not data ... except blob labels are data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We do dump blob security labels in binary-upgrade mode */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>schemaOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search for security labels associated with catalogId, using table */</comment>
	<expr_stmt><expr><name>nlabels</name> <operator>=</operator> <call><name>findSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore label entries for which the subid doesn't match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>!=</operator> <name>subid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>namespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s IS "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>tag</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name>dumpId</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableSecLabel
 *
 * As above, but dump security label for both the specified table (or view)
 * and its columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableSecLabel</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlabels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>target</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing, if --no-security-labels is supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>no_security_labels</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* SecLabel are SCHEMA not data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search for comments associated with relation, using table */</comment>
	<expr_stmt><expr><name>nlabels</name> <operator>=</operator> <call><name>findSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
							<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>,
							<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If security labels exist, build SECURITY LABEL statements */</comment>
	<if_stmt><if>if <condition>(<expr><name>nlabels</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlabels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>provider</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>provider</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>objsubid</name> <init>= <expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>objsubid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* first fmtXXX result must be consumed before calling again */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"COLUMN %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL FOR %s ON %s IS "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SECURITY LABEL"</literal></expr></argument>, <argument><expr><name>SECTION_NONE</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findSecLabels
 *
 * Find the security label(s), if any, associated with the given object.
 * All the objsubid values associated with the given classoid/objoid are
 * found with one search.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* static storage for table of security labels */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nlabels</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>middle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatch</name></decl>;</decl_stmt>

	<comment type="block">/* Get security labels if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name>nlabels</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nlabels</name> <operator>=</operator> <call><name>collectSecLabels</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nlabels</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>			<comment type="block">/* no labels, so no match is possible */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do binary search to find some item matching the object.
	 */</comment>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <operator>&amp;</operator><name><name>labels</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <operator>&amp;</operator><name><name>labels</name><index>[<expr><name>nlabels</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&lt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>objoid</name> <operator>&gt;</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* found a match */</comment>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>low</name> <operator>&gt;</operator> <name>high</name></expr>)</condition>				<comment type="block">/* no matches */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now determine how many items match the object.  The search loop
	 * invariant still holds: only items between low and high inclusive could
	 * match.
	 */</comment>
	<expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objoid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>middle</name> <operator>+=</operator> <name>nmatch</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>middle</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>classoid</name></name> <operator>||</operator>
			<name>objoid</name> <operator>!=</operator> <name><name>middle</name><operator>-&gt;</operator><name>objoid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>middle</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nmatch</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collectSecLabels
 *
 * Construct a table of all security labels available for database objects.
 * It's much faster to pull them all at once.
 *
 * The table is sorted by classoid/objid/objsubid for speed in lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>collectSecLabels</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>SecLabelItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_provider</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_objsubid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecLabelItem</name> <modifier>*</modifier></type><name>labels</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT label, provider, classoid, objoid, objsubid "</literal>
						 <literal type="string">"FROM pg_catalog.pg_seclabel "</literal>
						 <literal type="string">"ORDER BY classoid, objoid, objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct lookup table containing OIDs in numeric form */</comment>
	<expr_stmt><expr><name>i_label</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_provider</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"provider"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_classoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objoid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objoid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objsubid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objsubid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>labels</name> <operator>=</operator> <operator>(</operator><name>SecLabelItem</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SecLabelItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>provider</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>classoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objoid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objsubid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Do NOT free the PGresult since we are keeping pointers into it */</comment>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>labels</name></expr>;</expr_stmt>
	<return>return <expr><name>ntups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTable
 *	  write out to fout the declarations (not data) of a user-defined table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTable</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namecopy</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * noop if we are not dumping anything about this table, or if we are
	 * doing a data-only dump
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSequence</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableSchema</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Handle the ACL here */</comment>
	<expr_stmt><expr><name>namecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objtype</name> <init>=
		<expr><ternary><condition><expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"SEQUENCE"</literal></expr> </then><else>: <expr><literal type="string">"TABLE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
				<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
				<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relacl</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rrelacl</name></name></expr></argument>,
				<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>initrelacl</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>initrrelacl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Handle column ACLs, if any.  Note: we pull these with a separate query
	 * rather than trying to fetch them during getTableAttrs, so that we won't
	 * miss ACLs on system columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>acl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>racl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initacl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>initracl_subquery</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>buildACLQueries</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>, <argument><expr><name>racl_subquery</name></expr></argument>, <argument><expr><name>initacl_subquery</name></expr></argument>,
							<argument><expr><name>initracl_subquery</name></expr></argument>, <argument><expr><literal type="string">"at.attacl"</literal></expr></argument>, <argument><expr><literal type="string">"c.relowner"</literal></expr></argument>, <argument><expr><literal type="string">"'c'"</literal></expr></argument>,
							<argument><expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT at.attname, "</literal>
							  <literal type="string">"%s AS attacl, "</literal>
							  <literal type="string">"%s AS rattacl, "</literal>
							  <literal type="string">"%s AS initattacl, "</literal>
							  <literal type="string">"%s AS initrattacl "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute at "</literal>
							  <literal type="string">"JOIN pg_catalog.pg_class c ON (at.attrelid = c.oid) "</literal>
							  <literal type="string">"LEFT JOIN pg_catalog.pg_init_privs pip ON "</literal>
							  <literal type="string">"(at.attrelid = pip.objoid "</literal>
							  <literal type="string">"AND pip.classoid = 'pg_catalog.pg_class'::pg_catalog.regclass "</literal>
							  <literal type="string">"AND at.attnum = pip.objsubid) "</literal>
							  <literal type="string">"WHERE at.attrelid = '%u'::pg_catalog.oid AND "</literal>
							  <literal type="string">"NOT at.attisdropped "</literal>
							  <literal type="string">"AND ("</literal>
							  <literal type="string">"%s IS NOT NULL OR "</literal>
							  <literal type="string">"%s IS NOT NULL OR "</literal>
							  <literal type="string">"%s IS NOT NULL OR "</literal>
							  <literal type="string">"%s IS NOT NULL)"</literal>
							  <literal type="string">"ORDER BY at.attnum"</literal></expr></argument>,
							  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>,
							  <argument><expr><name><name>acl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>racl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>initacl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							  <argument><expr><name><name>initracl_subquery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>acl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>racl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initacl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>initracl_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
							  <argument><expr><literal type="string">"SELECT attname, attacl, NULL as rattacl, "</literal>
							  <literal type="string">"NULL AS initattacl, NULL AS initrattacl "</literal>
							  <literal type="string">"FROM pg_catalog.pg_attribute "</literal>
							  <literal type="string">"WHERE attrelid = '%u'::pg_catalog.oid AND NOT attisdropped "</literal>
							  <literal type="string">"AND attacl IS NOT NULL "</literal>
							  <literal type="string">"ORDER BY attnum"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attacl</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rattacl</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initattacl</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>initrattacl</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attnamecopy</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attnamecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Column's GRANT type is always TABLE */</comment>
			<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					<argument><expr><literal type="string">"TABLE"</literal></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>, <argument><expr><name>attnamecopy</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name>attacl</name></expr></argument>, <argument><expr><name>rattacl</name></expr></argument>, <argument><expr><name>initattacl</name></expr></argument>, <argument><expr><name>initrattacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>attnamecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the AS clause for a view or materialized view. The semicolon is
 * stripped because a materialized view must add a WITH NO DATA clause.
 *
 * This returns a new buffer which must be freed by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PQExpBuffer</name></type>
<name>createViewAsClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch the view definition */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_viewdef('%u'::pg_catalog.oid) AS viewdef"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"query to obtain definition of view \"%s\" returned no data\n"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"query to obtain definition of view \"%s\" returned more than one definition\n"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>PQgetlength</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"definition of view \"%s\" appears to be empty (length zero)\n"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Strip off the trailing semicolon so that other things may follow. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a dummy AS clause for a view.  This is used when the real view
 * definition has to be postponed because of circular dependencies.
 * We must duplicate the view's external properties -- column names and types
 * (including collation) -- so that it works for subsequent references.
 *
 * This returns a new buffer which must be freed by the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>PQExpBuffer</name></type>
<name>createDummyViewAsClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"NULL::%s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must add collation if not default for the type, because CREATE OR
		 * REPLACE VIEW won't change it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
								  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTablegroup
 *    write the declaration of one user-defined tablegroup
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTablegroup</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TablegroupInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing, if include_yb_metadata is not supplied
	 * or if --no-tablegroups or --no-tablegroup-creation is supplied.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>no_tablegroups</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>no_tablegroup_creations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>PQExpBuffer</name></type>  <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>  <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	    <modifier>*</modifier></type><name>namecopy</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set the next tablegroup oid to be used in yb_binary_restore mode.
	 * It's necessary to reuse the old tablegroup oid during the backup
	 * restoring to match tablegroup parent table.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
						 <argument><expr><literal type="string">"\n-- For YB tablegroup backup, must preserve pg_yb_tablegroup oid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_next_tablegroup_oid('%u'::pg_catalog.oid);\n"</literal></expr></argument>,
					  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>namecopy</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLEGROUP %s"</literal></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpoptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nWITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpoptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLEGROUP %s;\n"</literal></expr></argument>, <argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
					 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,	<comment type="block">/* catalog ID */</comment>
					 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,	<comment type="block">/* dump ID */</comment>
					 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,		<comment type="block">/* Name */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,  				<comment type="block">/* Namespace */</comment>
					 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grptablespace</name></name></expr></argument>,	<comment type="block">/* Tablespace */</comment>
					 <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpowner</name></name></expr></argument>,		<comment type="block">/* Owner */</comment>
					 <argument><expr><name>false</name></expr></argument>,					<comment type="block">/* with oids */</comment>
					 <argument><expr><literal type="string">"TABLEGROUP"</literal></expr></argument>,			<comment type="block">/* Desc */</comment>
					 <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,		<comment type="block">/* Section */</comment>
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,				<comment type="block">/* Create */</comment>
					 <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,			<comment type="block">/* Del */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* Copy */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* Deps */</comment>
					 <argument><expr><literal type="number">0</literal></expr></argument>,						<comment type="block">/* # Deps */</comment>
					 <argument><expr><name>NULL</name></expr></argument>,					<comment type="block">/* Dumper */</comment>
					 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>					<comment type="block">/* Dumper Arg */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpacl</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_ACL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpACL</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <argument><expr><literal type="string">"LARGE OBJECT"</literal></expr></argument>,
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* subname */</comment>
				<argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Namespace */</comment>
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpowner</name></name></expr></argument>, <comment type="block">/* Owner */</comment>
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpacl</name></name></expr></argument>, <comment type="block">/* ACLs */</comment>
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpracl</name></name></expr></argument>, <comment type="block">/* rACLs */</comment>
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpinitacl</name></name></expr></argument>, <comment type="block">/* initACLs */</comment>
				<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>grpinitracl</name></name></expr></argument> <comment type="block">/* initrACLs */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>namecopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableSchema
 *	  write the declaration (not data) of one user-defined table or view
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableSchema</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>actual_atts</name></decl>;</decl_stmt>	<comment type="block">/* number of attrs in this CREATE statement */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reltypename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srvname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ftoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_rel_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
												<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is it a table or a view? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note: keep this code in sync with the is_view case in dumpRule()
		 */</comment>

		<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"VIEW"</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP VIEW %s;\n"</literal></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE VIEW %s"</literal></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dummy_view</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createDummyViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dummy_view</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  WITH %s CHECK OPTION"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i_srvname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>i_ftoptions</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"FOREIGN TABLE"</literal></expr>;</expr_stmt>

					<comment type="block">/* retrieve name of foreign server and generic options */</comment>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT fs.srvname, "</literal>
									  <literal type="string">"pg_catalog.array_to_string(ARRAY("</literal>
									  <literal type="string">"SELECT pg_catalog.quote_ident(option_name) || "</literal>
									  <literal type="string">"' ' || pg_catalog.quote_literal(option_value) "</literal>
									  <literal type="string">"FROM pg_catalog.pg_options_to_table(ftoptions) "</literal>
									  <literal type="string">"ORDER BY option_name"</literal>
									  <literal type="string">"), E',\n    ') AS ftoptions "</literal>
									  <literal type="string">"FROM pg_catalog.pg_foreign_table ft "</literal>
									  <literal type="string">"JOIN pg_catalog.pg_foreign_server fs "</literal>
									  <literal type="string">"ON (fs.oid = ft.ftserver) "</literal>
									  <literal type="string">"WHERE ft.ftrelid = '%u'"</literal></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i_srvname</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"srvname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i_ftoptions</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"ftoptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>srvname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_ftoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
				<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"MATERIALIZED VIEW"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>srvname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>reltypename</name> <operator>=</operator> <literal type="string">"TABLE"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>srvname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ftoptions</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>numParents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP %s %s;\n"</literal></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CREATE %s%s %s"</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr> ?</condition><then>
						  <expr><literal type="string">"UNLOGGED "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>reltypename</name></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Attach to type, if reloftype; except in case of a binary upgrade,
		 * we dump the table normally and attach it to the type afterward.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" OF %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the table is a partition, dump it as such; except in the case of
		 * a binary upgrade, we dump the table normally and attach it to the
		 * parent afterward.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * With partitions, unlike inheritance, there can only be one
			 * parent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid number of parents %d for table \"%s\"\n"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" PARTITION OF %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Dump the attributes */</comment>
			<expr_stmt><expr><name>actual_atts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally, dump if it's locally defined in this table, and
				 * not dropped.  But for binary upgrade, we'll dump all the
				 * columns, and then fix up the dropped and nonlocal cases
				 * below.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Default value --- suppress if to be printed separately.
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type>		<name>has_default</name> <init>= <expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
											   <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>separate</name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Not Null constraint --- suppress if inherited, except
					 * in binary-upgrade case where that won't work.
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type>		<name>has_notnull</name> <init>= <expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator>
											   <operator>(</operator><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>||</operator>
												<name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Skip column if fully defined by reloftype or the
					 * partition parent.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>has_default</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_notnull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* Format properly if not first attr */</comment>
					<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>

					<comment type="block">/* Attribute name */</comment>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * ALTER TABLE DROP COLUMN clears
						 * pg_attribute.atttypid, so we will not have gotten a
						 * valid type name; insert INTEGER as a stopgap. We'll
						 * clean things up later.
						 */</comment>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INTEGER /* dummy */"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Skip all the rest, too */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Attribute type
					 *
					 * In binary-upgrade mode, we always include the type. If
					 * we aren't in binary-upgrade mode, then we skip the type
					 * when creating a typed table ('OF type_name') or a
					 * partition ('PARTITION OF'), since the type comes from
					 * the parent/partitioned table.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
										  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>atttypnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Add collation if not default for the type */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>coll</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>coll</name> <operator>=</operator> <call><name>findCollationByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>coll</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
											  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>coll</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>has_default</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>,
										  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>adef_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>has_notnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Add non-inherited CHECK constraints, if any.
			 */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator> <operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Add a PRIMARY KEY constraint if it exists, unless this is
			 * table partition, and the primary key is being defined by the
			 * parent partitioned table.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>parent_has_primary_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>parent_has_primary_key</name> <operator>=</operator> <name><name>parentRel</name><operator>-&gt;</operator><name>primaryKeyIndex</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>primaryKeyIndex</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>parent_has_primary_key</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndxInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>primaryKeyIndex</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>actual_atts</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">",\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s PRIMARY KEY("</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>doing_hash</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>indnattrs</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>col_name</name> <init>= <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name><name>index</name><operator>-&gt;</operator><name>indkeys</name><index>[<expr><name>n</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>indoption</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>indoptions</name><index>[<expr><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>doing_hash</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>indoption</name> <operator>&amp;</operator> <name>INDOPTION_HASH</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">") HASH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>doing_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>doing_hash</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>indoption</name> <operator>&amp;</operator> <name>INDOPTION_HASH</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>doing_hash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>col_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>indoption</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><name>doing_hash</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ASC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>doing_hash</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">") HASH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>actual_atts</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>actual_atts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
					   <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We must have a parenthesized attribute list, even though
				 * empty, when not using the OF TYPE or PARTITION OF syntax.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" (\n)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Emit the INHERITS clause, except if this is a partition. */</comment>
			<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nINHERITS ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nPARTITION BY %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>partkeydef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nSERVER %s"</literal></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>srvname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the table properties from YB, if relevant. */</comment>
		<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_properties</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name>
			 <operator>||</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>yb_properties</name> <operator>=</operator> <operator>(</operator><name>YbTableProperties</name><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbTablePropertiesData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>yb_reloptions</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>getYbTablePropertiesAndReloptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>yb_properties</name></expr></argument>, <argument><expr><name>yb_reloptions</name></expr></argument>,
			<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>YbAppendReloptions3</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* newline_before*/</comment>,
			<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
			<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_reloptions</name></name></expr></argument>, <argument><expr><literal type="string">"toast."</literal></expr></argument>,
			<argument><expr><name><name>yb_reloptions</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
			<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>yb_reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Additional properties for YB table or index. */</comment>
		<if_stmt><if>if <condition>(<expr><name>yb_properties</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>yb_properties</name><operator>-&gt;</operator><name>num_hash_key_columns</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* For hash-table. */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nSPLIT INTO %"</literal> <name>PRIu64</name> <literal type="string">" TABLETS"</literal></expr></argument>, <argument><expr><name><name>yb_properties</name><operator>-&gt;</operator><name>num_tablets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>yb_properties</name><operator>-&gt;</operator><name>num_tablets</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* For range-table. */</comment>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>range_split_clause</name> <init>= <expr><call><name>getYbSplitClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n%s"</literal></expr></argument>, <argument><expr><name>range_split_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>range_split_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else - single shard table - supported, no need to add anything */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>no_tablegroups</name></name> <operator>&amp;&amp;</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
				<call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TablegroupInfo</name> <modifier>*</modifier></type><name>tablegroup</name> <init>= <expr><call><name>findTablegroupByOid</name><argument_list>(<argument><expr><name><name>yb_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>tablegroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not find tablegroup definition with OID %u\n"</literal></expr></argument>,
						<argument><expr><name><name>yb_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nTABLEGROUP %s"</literal></expr></argument>, <argument><expr><name><name>tablegroup</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/* Dump generic options if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>ftoptions</name> <operator>&amp;&amp;</operator> <name><name>ftoptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nOPTIONS (\n    %s\n)"</literal></expr></argument>, <argument><expr><name>ftoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * For materialized views, create the AS clause just like a view. At
		 * this point, we always mark the view as not populated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s;\n"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s\n  WITH NO DATA;\n"</literal></expr></argument>,
								  <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * in binary upgrade mode, update the catalog with any missing values
		 * that might be present.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- set missing value.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
										 <argument><expr><literal type="string">"SELECT pg_catalog.binary_upgrade_set_missing_value("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attmissingval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">");\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To create binary-compatible heap files, we have to ensure the same
		 * physical column order, including dropped columns, as in the
		 * original.  Therefore, we create dropped columns above and drop them
		 * here, also updating their attlen/attalign values so that the
		 * dropped column can be skipped properly.  (We do not bother with
		 * restoring the original attbyval setting.)  Also, inheritance
		 * relationships are set up by doing ALTER TABLE INHERIT rather than
		 * using an INHERITS clause --- the latter would possibly mess up the
		 * column order.  That also means we have to take care about setting
		 * attislocal correctly, plus fix up any inherited CHECK constraints.
		 * Analogously, we set up typed tables using ALTER TABLE / OF here.
		 *
		 * We process foreign and partitioned tables here, even though they
		 * lack heap storage, because they can participate in inheritance
		 * relationships and we want this stuff to be consistent across the
		 * inheritance tree.  We can exclude indexes, toast tables, sequences
		 * and matviews, even though they have storage, because we don't
		 * support altering or dropping columns in them, nor can they be part
		 * of inheritance trees.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, recreate dropped column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
									  <literal type="string">"SET attlen = %d, "</literal>
									  <literal type="string">"attalign = '%c', attbyval = false\n"</literal>
									  <literal type="string">"WHERE attname = "</literal></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attlen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attalign</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
						<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER FOREIGN TABLE ONLY %s "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"DROP COLUMN %s;\n"</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>attislocal</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, recreate inherited column.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_attribute\n"</literal>
										 <literal type="string">"SET attislocal = false\n"</literal>
										 <literal type="string">"WHERE attname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND attrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator> <name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up inherited constraint.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ADD CONSTRAINT %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_constraint\n"</literal>
									 <literal type="string">"SET conislocal = false\n"</literal>
									 <literal type="string">"WHERE contype = 'c' AND conname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>constr</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n  AND conrelid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up inheritance and partitioning this way.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parentRel</name> <init>= <expr><name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* In the partitioning case, we alter the parent */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>,
										  <argument><expr><literal type="string">"ALTER TABLE ONLY %s ATTACH PARTITION "</literal></expr></argument>,
										  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s INHERIT "</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/* Partition needs specifying the bounds */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>ispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s %s;\n"</literal></expr></argument>,
										  <argument><expr><name>qualrelname</name></expr></argument>,
										  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>partbound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>,
										  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set up typed tables this way.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s OF %s;\n"</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In binary_upgrade mode, arrange to restore the old relfrozenxid and
		 * relminmxid of all vacuumable relations.  (While vacuum.c processes
		 * TOAST tables semi-independently, here we see them only as children
		 * of other relations; so this "if" lacks RELKIND_TOASTVALUE, and the
		 * child toast table is handled below.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set heap's relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
							  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
							  <literal type="string">"WHERE oid = "</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>frozenxid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>minmxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The toast table will have the same OID at restore, so we
				 * can safely target it by OID.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, set toast's relfrozenxid and relminmxid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
								  <literal type="string">"SET relfrozenxid = '%u', relminmxid = '%u'\n"</literal>
								  <literal type="string">"WHERE oid = '%u';\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_frozenxid</name></name></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_minmxid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>toast_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In binary_upgrade mode, restore matviews' populated status by
		 * poking pg_class directly.  This is pretty ugly, but we can't use
		 * REFRESH MATERIALIZED VIEW since it's possible that some underlying
		 * matview is not populated even though this matview is; in any case,
		 * we want to transfer the matview's heap storage, not run REFRESH.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relispopulated</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\n-- For binary upgrade, mark materialized view as populated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"UPDATE pg_catalog.pg_class\n"</literal>
								 <literal type="string">"SET relispopulated = 't'\n"</literal>
								 <literal type="string">"WHERE oid = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qualrelname</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"::pg_catalog.regclass;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Dump additional per-column properties that we can't handle in the
		 * main CREATE TABLE command.
		 */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* None of this applies to dropped columns */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If we didn't dump the column definition explicitly above, and
			 * it is NOT NULL and did not inherit that property from a parent,
			 * we have to mark it separately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>tbinfo</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s SET NOT NULL;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column statistics information. We only issue an ALTER
			 * TABLE statement if the attstattarget entry for this column is
			 * non-negative (i.e. it's not the default value)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STATISTICS %d;\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstattarget</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column storage information.  The statement is only
			 * dumped if the storage has been changed from the type's default.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>typstorage</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attstorage</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'p'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"PLAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'e'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"EXTERNAL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'m'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"MAIN"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'x'</literal></expr>:</case>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <literal type="string">"EXTENDED"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name>storage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></switch>

				<comment type="block">/*
				 * Only dump the statement if it's a storage type we recognize
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>storage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
									  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
									  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STORAGE %s;\n"</literal></expr></argument>,
									  <argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column attributes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET (%s);\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attoptions</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Dump per-column fdw options.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
				<name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER FOREIGN TABLE %s "</literal></expr></argument>,
								  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"OPTIONS (\n    %s\n);\n"</literal></expr></argument>,
								  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attfdwoptions</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * dump properties we only have ALTER TABLE syntax for
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		 <name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>!=</operator> <name>REPLICA_IDENTITY_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* nothing to do, will be set when the index is dumped */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_NOTHING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY NOTHING;\n"</literal></expr></argument>,
							  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY FULL;\n"</literal></expr></argument>,
							  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s SET WITH OIDS;\n"</literal></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>forcerowsec</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s FORCE ROW LEVEL SECURITY;\n"</literal></expr></argument>,
						  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><name>qrelname</name></expr></argument>,
										<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></else></ternary></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>reltypename</name></expr></argument>, <argument><expr><literal type="string">"TABLE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>hasoids</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>,
					 <argument><expr><name>reltypename</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>postponed_def</name></name></expr> ?</condition><then>
					 <expr><name>SECTION_POST_DATA</name></expr> </then><else>: <expr><name>SECTION_PRE_DATA</name></expr></else></ternary></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/* Dump Table Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Table Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>reltypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump comments on inlined table constraints */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>ncheck</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>constr</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>checkexprs</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constr</name><operator>-&gt;</operator><name>separate</name></name> <operator>||</operator> <operator>!</operator><name><name>constr</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dumpTableConstraintComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpAttrDef --- dump an attribute's default-value declaration
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpAttrDef</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>adinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>adinfo</name><operator>-&gt;</operator><name>adtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>adnum</name> <init>= <expr><name><name>adinfo</name><operator>-&gt;</operator><name>adnum</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qualrelname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if table definition not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Skip if not "separate"; it was dumped in the table's definition */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>adinfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qualrelname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
					  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s SET DEFAULT %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>adef_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
					  <argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s DROP DEFAULT;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>adinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qualrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getAttrName: extract the correct name for an attribute
 *
 * The array tblInfo-&gt;attnames[] only provides names of user attributes;
 * if a system attribute number is supplied, we have to fake it.
 * We also do a little bit of bounds checking for safety's sake.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getAttrName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attrnum</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attrnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attrnum</name> <operator>&lt;=</operator> <name><name>tblInfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>tblInfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>attrnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name>attrnum</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"ctid"</literal></expr>;</return>
		<case>case <expr><name>ObjectIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"oid"</literal></expr>;</return>
		<case>case <expr><name>MinTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"xmin"</literal></expr>;</return>
		<case>case <expr><name>MinCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"cmin"</literal></expr>;</return>
		<case>case <expr><name>MaxTransactionIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"xmax"</literal></expr>;</return>
		<case>case <expr><name>MaxCommandIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"cmax"</literal></expr>;</return>
		<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"tableoid"</literal></expr>;</return>
		<case>case <expr><name>YBTupleIdAttributeNumber</name></expr>:</case>
			<return>return <expr><literal type="string">"ybctid"</literal></expr>;</return>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid column number %d for table \"%s\"\n"</literal></expr></argument>,
				  <argument><expr><name>attrnum</name></expr></argument>, <argument><expr><name><name>tblInfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * dumpIndex
 *	  write out to fout a user-defined index
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpIndex</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>IndxInfo</name> <modifier>*</modifier></type><name>indxinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indextable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_constraint</name> <init>= <expr><operator>(</operator><name><name>indxinfo</name><operator>-&gt;</operator><name>indexconstraint</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qindxname</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qindxname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's an associated constraint, don't dump the index per se, but
	 * do dump any comment for it.  (This is safe because dependency ordering
	 * will have ensured the constraint is emitted first.)	Note that the
	 * emitted comment has to be shown as depending on the constraint, not the
	 * index, in such cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_constraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indstatcols</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indstatcols</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indstatvals</name> <init>= <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indstatvals</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>indstatcolsarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>indstatvalsarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nstatcols</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nstatvals</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Plain secondary index */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indexdef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Append ALTER TABLE commands as needed to set properties that we
		 * only have ALTER TABLE syntax for.  Keep this in sync with the
		 * similar code in dumpConstraint!
		 */</comment>

		<comment type="block">/* If the index is clustered, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s CLUSTER"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>,
							  <argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the index has any statistics on some of its columns, generate
		 * the associated ALTER INDEX queries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>parsePGArray</name><argument_list>(<argument><expr><name>indstatcols</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indstatcolsarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nstatcols</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>parsePGArray</name><argument_list>(<argument><expr><name>indstatvals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indstatvalsarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nstatvals</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>nstatcols</name> <operator>==</operator> <name>nstatvals</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nstatcols</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER INDEX %s "</literal></expr></argument>,
								  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>indxinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note that this is a column number, so no quotes should be
				 * used.
				 */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER COLUMN %s "</literal></expr></argument>,
								  <argument><expr><name><name>indstatcolsarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"SET STATISTICS %s;\n"</literal></expr></argument>,
								  <argument><expr><name><name>indstatvalsarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If the index defines identity, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY USING"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INDEX %s;\n"</literal></expr></argument>,
							  <argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>indxinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><literal type="string">"INDEX"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
						 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>indstatcolsarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>indstatcolsarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>indstatvalsarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>indstatvalsarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump Index Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"INDEX"</literal></expr></argument>, <argument><expr><name>qindxname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_constraint</name></expr> ?</condition><then> <expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indexconstraint</name></name></expr> </then><else>:
					<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qindxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpIndexAttach
 *	  write out to fout a partitioned-index attachment clause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpIndexAttach</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionIdx</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER INDEX %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>parentIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ATTACH PARTITION %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>partitionIdx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>attachinfo</name><operator>-&gt;</operator><name>parentIdx</name><operator>-&gt;</operator><name>indextable</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"INDEX ATTACH"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpStatisticsExt
 *	  write out to fout an extended statistics object
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpStatisticsExt</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>StatsExtInfo</name> <modifier>*</modifier></type><name>statsextinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qstatsextname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stxdef</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qstatsextname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
					  <literal type="string">"pg_catalog.pg_get_statisticsobjdef('%u'::pg_catalog.oid)"</literal></expr></argument>,
					  <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stxdef</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Result of pg_get_statisticsobjdef is complete except for semicolon */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name>stxdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP STATISTICS %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>statsextinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>,
					 <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"STATISTICS"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump Statistics Comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"STATISTICS"</literal></expr></argument>, <argument><expr><name>qstatsextname</name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><name><name>statsextinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qstatsextname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpConstraint
 *	  write out to fout a user-defined constraint
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpConstraint</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>contable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name> <operator>||</operator> <name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delq</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'u'</literal> <operator>||</operator>
		<name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Index-related constraint */</comment>
		<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>indxinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indxinfo</name> <operator>=</operator> <operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>conindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>indxinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"missing index for constraint \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>q</name></expr></argument>,
											 <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_unique_index_constraint</name> <init>=
			<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indexdef</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the constraint type is unique and index definition (indexdef)
		 * exists, it means a constraint exists for this table which is
		 * backed by an unique index.
		 * Note: when indexdef is not set to null, it means either
		 * unique or non-unique index exists for a table. The indexdef
		 * contains the full YSQL command to create the index.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_unique_index_constraint</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>index_def_prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"CREATE UNIQUE INDEX "</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indexdef</name></name></expr></argument>, <argument><expr><name>index_def_prefix</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>index_def_prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%sNONCONCURRENTLY %s;\n\n"</literal></expr></argument>,
							  <argument><expr><name>index_def_prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indxinfo</name><operator>-&gt;</operator><name>indexdef</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* pg_get_constraintdef should have provided everything */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'p'</literal></expr> ?</condition><then> <expr><literal type="string">"PRIMARY KEY"</literal></expr> </then><else>: <expr><literal type="string">"UNIQUE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If a table has an unique constraint with index definition,
			 * then ALTER TABLE ADD CONSTRAINT UNIQUE command must append
			 * the USING INDEX syntax followed by the unique index name in
			 * order to attach the index as a constraint type.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_unique_index_constraint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"USING INDEX %s"</literal></expr></argument>,
								  <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<comment type="block">/*
			 * If a table has a non-unique constraint or does not have an
			 * index definition, the original ALTER TABLE ADD CONSTRAINT
			 * command is used and the rest of the query is constructed.
			 */</comment>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>indkey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>indkey</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>indkey</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>,
									<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnattrs</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">") INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnattrs</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>indkey</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indkeys</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>indkey</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>getAttrName</name><argument_list>(<argument><expr><name>indkey</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>==</operator> <name><name>indxinfo</name><operator>-&gt;</operator><name>indnkeyattrs</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>,
									<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>

				<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Get the table and index properties from YB, if relevant. */</comment>
			<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_table_properties</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>YbTableProperties</name></type> <name>yb_index_properties</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'u'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>yb_table_properties</name> <operator>=</operator> <operator>(</operator><name>YbTableProperties</name><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbTablePropertiesData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>yb_index_properties</name> <operator>=</operator> <operator>(</operator><name>YbTableProperties</name><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbTablePropertiesData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>yb_table_reloptions</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>yb_index_reloptions</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>getYbTablePropertiesAndReloptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>yb_table_properties</name></expr></argument>, <argument><expr><name>yb_table_reloptions</name></expr></argument>,
				<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>getYbTablePropertiesAndReloptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>yb_index_properties</name></expr></argument>, <argument><expr><name>yb_index_reloptions</name></expr></argument>,
				<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Issue #11600: if tablegroups mismatch between the table and its
			 * constraint, we cannot currently replicate that.
			 * We have to fail to prevent inconsistency upon yb_backup restore.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name> <operator>&amp;&amp;</operator>
				<call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>yb_table_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>yb_index_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name> <operator>!=</operator> <name><name>yb_table_properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="string">"table %s and its constraint %s have mismatching tablegroups!\n"</literal>
							  <literal type="string">"This case cannot currently be handled, see issue "</literal>
							  <literal type="string">"https://github.com/yugabyte/yugabyte-db/issues/11600\n"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>YbAppendReloptions2</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* newline_before*/</comment>,
				<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indreloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
				<argument><expr><name><name>yb_index_reloptions</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
				<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>yb_table_reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>yb_index_reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>condeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INITIALLY DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Append ALTER TABLE commands as needed to set properties that we
		 * only have ALTER TABLE syntax for.  Keep this in sync with the
		 * similar code in dumpIndex!
		 */</comment>

		<comment type="block">/* If the index is clustered, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s CLUSTER"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" ON %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If the index defines identity, we need to record that. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indxinfo</name><operator>-&gt;</operator><name>indisreplident</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE ONLY %s REPLICA IDENTITY USING"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* index name is not qualified in this syntax */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">" INDEX %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE ONLY %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name><name>indxinfo</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
						 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>only</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Foreign keys on partitioned tables are always declared as
		 * inheriting to partitions; for all other cases, emit them as
		 * applying ONLY directly to the named table, because that's how they
		 * work for regular inherited tables.
		 */</comment>
		<expr_stmt><expr><name>only</name> <operator>=</operator> <ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * XXX Potentially wrap in a 'SET CONSTRAINTS OFF' block so that the
		 * current table data is not processed
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s%s\n"</literal></expr></argument>,
						  <argument><expr><name>only</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s%s "</literal></expr></argument>,
						  <argument><expr><name>only</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
						 <argument><expr><name>tag</name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><literal type="string">"FK CONSTRAINT"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
						 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>tbinfo</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CHECK constraint on a table */</comment>

		<comment type="block">/* Ignore if not to be dumped separately, or if it was inherited */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>&amp;&amp;</operator> <name><name>coninfo</name><operator>-&gt;</operator><name>conislocal</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not ONLY since we want it to propagate to children */</comment>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
							 <argument><expr><name>tag</name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
							 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator> <name>tbinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CHECK constraint on a domain */</comment>
		<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>tyinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>condomain</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore if not to be dumped separately */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"ALTER DOMAIN %s\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"    ADD CONSTRAINT %s %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>condef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"ALTER DOMAIN %s "</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tyinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>, <argument><expr><literal type="string">"DROP CONSTRAINT %s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
							 <argument><expr><name>tag</name></expr></argument>,
							 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>tyinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><literal type="string">"CHECK CONSTRAINT"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
							 <argument><expr><name><name>q</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delq</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %c\n"</literal></expr></argument>,
					  <argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Dump Constraint Comments --- only works for table constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name>tbinfo</name> <operator>&amp;&amp;</operator> <name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>&amp;&amp;</operator>
		<name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpTableConstraintComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>coninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTableConstraintComment --- dump a constraint's comment if any
 *
 * This is split out because we need the function in two different places
 * depending on whether the constraint is dumped as part of CREATE TABLE
 * or as a separate ALTER command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTableConstraintComment</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ConstraintInfo</name> <modifier>*</modifier></type><name>coninfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>coninfo</name><operator>-&gt;</operator><name>contable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>conprefix</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>, <argument><expr><literal type="string">"CONSTRAINT %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>conprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name><name>coninfo</name><operator>-&gt;</operator><name>separate</name></name></expr> ?</condition><then> <expr><name><name>coninfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr> </then><else>: <expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>conprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findLastBuiltinOid_V71 -
 *
 * find the last built in oid
 *
 * For 7.1 through 8.0, we do this by retrieving datlastsysoid from the
 * pg_database entry for the current database.  (Note: current_database()
 * requires 7.3; pg_dump requires 8.0 now.)
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findLastBuiltinOid_V71</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>last_oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
									  <argument><expr><literal type="string">"SELECT datlastsysoid FROM pg_database WHERE datname = current_database()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_oid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"datlastsysoid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>last_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSequence
 *	  write the declaration (not data) of one user-defined sequence
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSequence</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>startv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>incby</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>maxv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>minv</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cache</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>seqtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cycled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_ascending</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>default_minv</name></decl>,
				<decl><type ref="prev"/><name>default_maxv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>bufm</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>bufx</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qseqname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>qseqname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">100000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT format_type(seqtypid, NULL), "</literal>
						  <literal type="string">"seqstart, seqincrement, "</literal>
						  <literal type="string">"seqmax, seqmin, "</literal>
						  <literal type="string">"seqcache, seqcycle "</literal>
						  <literal type="string">"FROM pg_catalog.pg_sequence "</literal>
						  <literal type="string">"WHERE seqrelid = '%u'::oid"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before PostgreSQL 10, sequence metadata is in the sequence itself.
		 *
		 * Note: it might seem that 'bigint' potentially needs to be
		 * schema-qualified, but actually that's a keyword.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT 'bigint' AS sequence_type, "</literal>
						  <literal type="string">"start_value, increment_by, max_value, min_value, "</literal>
						  <literal type="string">"cache_value, is_cycled FROM %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT 'bigint' AS sequence_type, "</literal>
						  <literal type="string">"0 AS start_value, increment_by, max_value, min_value, "</literal>
						  <literal type="string">"cache_value, is_cycled FROM %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d row (expected 1)\n"</literal></expr></argument>,
								 <argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d rows (expected 1)\n"</literal></expr></argument>,
								 <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>seqtype</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>startv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>incby</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minv</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cycled</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Calculate default limits for a sequence of this type */</comment>
	<expr_stmt><expr><name>is_ascending</name> <operator>=</operator> <operator>(</operator><name><name>incby</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"smallint"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT16_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT16_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT32_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT32_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"bigint"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>PG_INT64_MIN</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_maxv</name> <operator>=</operator> <ternary><condition><expr><name>is_ascending</name></expr> ?</condition><then> <expr><name>PG_INT64_MAX</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unrecognized sequence type: %s\n"</literal></expr></argument>, <argument><expr><name>seqtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_minv</name> <operator>=</operator> <name>default_maxv</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * 64-bit strtol() isn't very portable, so convert the limits to strings
	 * and compare that way.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufm</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>default_minv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bufx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>default_maxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't print minv/maxv if they match the respective default limit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>minv</name></expr></argument>, <argument><expr><name>bufm</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>minv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>maxv</name></expr></argument>, <argument><expr><name>bufx</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identity sequences are not to be dropped separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP SEQUENCE %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>binary_upgrade_set_pg_class_oids</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
											 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>binary_upgrade_set_type_oids_by_rel_oid</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
												<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"ALTER COLUMN %s ADD GENERATED "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attidentity</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_BY_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"BY DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" AS IDENTITY (\n    SEQUENCE NAME %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"CREATE SEQUENCE %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>seqtype</name></expr></argument>, <argument><expr><literal type="string">"bigint"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    AS %s\n"</literal></expr></argument>, <argument><expr><name>seqtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fout</name><operator>-&gt;</operator><name>remoteVersion</name></name> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    START WITH %s\n"</literal></expr></argument>, <argument><expr><name>startv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    INCREMENT BY %s\n"</literal></expr></argument>, <argument><expr><name>incby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>minv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    MINVALUE %s\n"</literal></expr></argument>, <argument><expr><name>minv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    NO MINVALUE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>maxv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    MAXVALUE %s\n"</literal></expr></argument>, <argument><expr><name>maxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    NO MAXVALUE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"    CACHE %s%s"</literal></expr></argument>,
					  <argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>cycled</name></expr> ?</condition><then> <expr><literal type="string">"\n    CYCLE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n);\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* binary_upgrade:	no need to clear TOAST table oid */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
										<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the sequence is owned by a table column, emit the ALTER for it as a
	 * separate TOC entry immediately following the sequence's own entry. It's
	 * OK to do this rather than using full sorting logic, because the
	 * dependency that tells us it's owned will have forced the table to be
	 * created first.  We can't just include the ALTER in the TOC entry
	 * because it will fail if we haven't reassigned the sequence owner to
	 * match the table's owner.
	 *
	 * We need not schema-qualify the table reference because both sequence
	 * and table must be in the same schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>is_identity_sequence</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>owning_tab</name> <init>= <expr><call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>owning_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"failed sanity check, parent table with OID %u of sequence with OID %u not found\n"</literal></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_tab</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>owning_tab</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER SEQUENCE %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OWNED BY %s"</literal></expr></argument>,
							  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>owning_tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">".%s;\n"</literal></expr></argument>,
							  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>owning_tab</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>owning_col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE OWNED BY"</literal></expr></argument>, <argument><expr><name>SECTION_PRE_DATA</name></expr></argument>,
							 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump Sequence Comments and Security Labels */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_SECLABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSecLabel</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>, <argument><expr><name>qseqname</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qseqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpSequenceData
 *	  write the data of one user-defined sequence
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpSequenceData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableDataInfo</name> <modifier>*</modifier></type><name>tdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tdinfo</name><operator>-&gt;</operator><name>tdtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>called</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT last_value, is_called FROM %s"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d row (expected 1)\n"</literal></expr></argument>,
								 <argument><expr><literal type="string">"query to get data of sequence \"%s\" returned %d rows (expected 1)\n"</literal></expr></argument>,
								 <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>called</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.setval("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", %s, %s);\n"</literal></expr></argument>,
					  <argument><expr><name>last</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>called</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tdinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>nilCatalogId</name></expr></argument>, <argument><expr><call><name>createDumpId</name><argument_list>()</argument_list></call></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"SEQUENCE SET"</literal></expr></argument>, <argument><expr><name>SECTION_DATA</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpTrigger
 *	  write the declaration of one user-defined table trigger
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TriggerInfo</name> <modifier>*</modifier></type><name>tginfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>trigprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tgargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>lentgargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>findx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we needn't check dobj.dump because TriggerInfo wouldn't have been
	 * created in the first place for non-dumpable triggers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>trigprefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP TRIGGER %s "</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"ON %s;\n"</literal></expr></argument>,
					  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgdef</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"%s;\n"</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgdef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgisconstraint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE CONSTRAINT TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Trigger type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"unexpected tgtype value: %d\n"</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>findx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" OR TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON %s\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgisconstraint</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* regclass output is already quoted */</comment>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FROM %s\n    "</literal></expr></argument>,
								  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgconstrrelname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tginfo</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DEFERRABLE INITIALLY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DEFERRED\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"IMMEDIATE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FOR EACH ROW\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"    FOR EACH STATEMENT\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* regproc output is already sufficiently quoted */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE PROCEDURE %s("</literal></expr></argument>,
						  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tgargs</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>PQunescapeBytea</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgargs</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>lentgargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tgargs</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>findx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>findx</name> <operator>&lt;</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>findx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* find the embedded null that terminates this trigger argument */</comment>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>tlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>tlen</name> <operator>&gt;=</operator> <name>tgargs</name> <operator>+</operator> <name>lentgargs</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* hm, not found before end of bytea value... */</comment>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"invalid argument string (%s) for trigger \"%s\" on table \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgargs</name></name></expr></argument>,
						  <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
						  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>tlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tgargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Triggers marked internal only appear here because their 'tgenabled'
		 * flag differs from its parent's.  The trigger is created already, so
		 * remove the CREATE and replace it with an ALTER.  (Clear out the
		 * DROP query too, so that pg_dump --create does not cause errors.)
		 */</comment>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\nALTER %sTABLE %s "</literal></expr></argument>,
						  <argument><expr><ternary><condition><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr> ?</condition><then> <expr><literal type="string">"FOREIGN "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DISABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
			<case>case <expr><literal type="char">'O'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TRIGGER %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\nALTER TABLE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>tgenabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DISABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" TRIGGER %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>trigprefix</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>trigprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>tginfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trigprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpEventTrigger
 *	  write the declaration of one user-defined event trigger
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpEventTrigger</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>EventTriggerInfo</name> <modifier>*</modifier></type><name>evtinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delqry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qevtname</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delqry</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qevtname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE EVENT TRIGGER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtevent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evttags</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n         WHEN TAG IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evttags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\n   EXECUTE PROCEDURE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"();\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtenabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"\nALTER EVENT TRIGGER %s "</literal></expr></argument>,
						  <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtenabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DISABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ENABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>, <argument><expr><literal type="string">"DROP EVENT TRIGGER %s;\n"</literal></expr></argument>,
					  <argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dopt</name><operator>-&gt;</operator><name>binary_upgrade</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>include_yb_metadata</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>binary_upgrade_extension_member</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtowner</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delqry</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><literal type="string">"EVENT TRIGGER"</literal></expr></argument>, <argument><expr><name>qevtname</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>evtowner</name></name></expr></argument>,
					<argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>evtinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qevtname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dumpRule
 *		Dump a rule
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpRule</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>RuleInfo</name> <modifier>*</modifier></type><name>rinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>ruletable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_view</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>delcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>ruleprefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qtabname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* Skip if not to be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>||</operator> <name><name>dopt</name><operator>-&gt;</operator><name>dataOnly</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it is an ON SELECT rule that is created implicitly by CREATE VIEW,
	 * we do not want to dump it as a separate object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>separate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's an ON SELECT rule, we want to print it as a view definition,
	 * instead of a rule.
	 */</comment>
	<expr_stmt><expr><name>is_view</name> <operator>=</operator> <operator>(</operator><name><name>rinfo</name><operator>-&gt;</operator><name>ev_type</name></name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>is_instead</name></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>delcmd</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ruleprefix</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qtabname</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_view</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need OR REPLACE here because we'll be replacing a dummy view.
		 * Otherwise this should look largely like the regular view dump code.
		 */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>reloptions</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"\n  WITH %s CHECK OPTION"</literal></expr></argument>,
							  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>checkoption</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* In the rule case, just print pg_get_ruledef's result verbatim */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT pg_catalog.pg_get_ruledef('%u'::pg_catalog.oid)"</literal></expr></argument>,
						  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"query to get rule \"%s\" for table \"%s\" failed: wrong number of rows returned\n"</literal></expr></argument>,
					  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Add the command to alter the rules replication firing semantics if it
	 * differs from the default.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ev_enabled</name></name> <operator>!=</operator> <literal type="char">'O'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s "</literal></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>ev_enabled</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'A'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ENABLE ALWAYS RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"ENABLE REPLICA RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"DISABLE RULE %s;\n"</literal></expr></argument>,
								  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_view</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can't DROP a view's ON SELECT rule.  Instead, use CREATE OR
		 * REPLACE VIEW to replace the rule with something with minimal
		 * dependencies.
		 */</comment>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW %s"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>createDummyViewAsClause</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">" AS\n%s;\n"</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"DROP RULE %s "</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>, <argument><expr><literal type="string">"ON %s;\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tbinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>ruleprefix</name></expr></argument>, <argument><expr><literal type="string">"RULE %s ON"</literal></expr></argument>,
					  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>,
					 <argument><expr><name>tag</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><literal type="string">"RULE"</literal></expr></argument>, <argument><expr><name>SECTION_POST_DATA</name></expr></argument>,
					 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>delcmd</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Dump rule comments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_COMMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpComment</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>ruleprefix</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>qtabname</name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>,
					<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>delcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>ruleprefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qtabname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getExtensionMembership --- obtain extension membership data
 *
 * We need to identify objects that are extension members as soon as they're
 * loaded, so that we can correctly determine whether they need to be dumped.
 * Generally speaking, extension member objects will get marked as *not* to
 * be dumped, as they will be recreated by the single CREATE EXTENSION
 * command.  However, in binary upgrade mode we still need to dump the members
 * individually.
 */</comment>
<function><type><name>void</name></type>
<name>getExtensionMembership</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name></type> <name><name>extinfo</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>nextmembers</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionMemberId</name> <modifier>*</modifier></type><name>extmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if no extensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>numExtensions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* refclassid constraint is redundant but may speed the search */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						 <literal type="string">"classid, objid, refobjid "</literal>
						 <literal type="string">"FROM pg_depend "</literal>
						 <literal type="string">"WHERE refclassid = 'pg_extension'::regclass "</literal>
						 <literal type="string">"AND deptype = 'e' "</literal>
						 <literal type="string">"ORDER BY 3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extmembers</name> <operator>=</operator> <operator>(</operator><name>ExtensionMemberId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionMemberId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Accumulate data into extmembers[].
	 *
	 * Since we ordered the SELECT by referenced ID, we can expect that
	 * multiple entries for the same extension will appear together; this
	 * saves on searches.
	 */</comment>
	<expr_stmt><expr><name>ext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>extId</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extId</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>ext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>extId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>findExtensionByOid</name><argument_list>(<argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"could not find referenced extension %u\n"</literal></expr></argument>, <argument><expr><name>extId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>extmembers</name><index>[<expr><name>nextmembers</name></expr>]</index></name><operator>.</operator><name>catId</name> <operator>=</operator> <name>objId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>extmembers</name><index>[<expr><name>nextmembers</name></expr>]</index></name><operator>.</operator><name>ext</name> <operator>=</operator> <name>ext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextmembers</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember the data for use later */</comment>
	<expr_stmt><expr><call><name>setExtensionMembership</name><argument_list>(<argument><expr><name>extmembers</name></expr></argument>, <argument><expr><name>nextmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * processExtensionTables --- deal with extension configuration tables
 *
 * There are two parts to this process:
 *
 * 1. Identify and create dump records for extension configuration tables.
 *
 *	  Extensions can mark tables as "configuration", which means that the user
 *	  is able and expected to modify those tables after the extension has been
 *	  loaded.  For these tables, we dump out only the data- the structure is
 *	  expected to be handled at CREATE EXTENSION time, including any indexes or
 *	  foreign keys, which brings us to-
 *
 * 2. Record FK dependencies between configuration tables.
 *
 *	  Due to the FKs being created at CREATE EXTENSION time and therefore before
 *	  the data is loaded, we have to work out what the best order for reloading
 *	  the data is, to avoid FK violations when the tables are restored.  This is
 *	  not perfect- we can't handle circular dependencies and if any exist they
 *	  will cause an invalid dump to be produced (though at least all of the data
 *	  is included for a user to manually restore).  This is currently documented
 *	  but perhaps we can provide a better solution in the future.
 */</comment>
<function><type><name>void</name></type>
<name>processExtensionTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>ExtensionInfo</name></type> <name><name>extinfo</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>numExtensions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_conrelid</name></decl>,
				<decl><type ref="prev"/><name>i_confrelid</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if no extensions */</comment>
	<if_stmt><if>if <condition>(<expr><name>numExtensions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify extension configuration tables and create TableDataInfo
	 * objects for them, ensuring their data will be dumped even though the
	 * tables themselves won't be.
	 *
	 * Note that we create TableDataInfo objects even in schemaOnly mode, ie,
	 * user data in a configuration table is treated like schema data. This
	 * seems appropriate since system data in a config table would get
	 * reloaded by CREATE EXTENSION.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numExtensions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>curext</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>extinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extconfig</name> <init>= <expr><name><name>curext</name><operator>-&gt;</operator><name>extconfig</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extcondition</name> <init>= <expr><name><name>curext</name><operator>-&gt;</operator><name>extcondition</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>extconfigarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>extconditionarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nconfigitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nconditionitems</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>parsePGArray</name><argument_list>(<argument><expr><name>extconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extconfigarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigitems</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>parsePGArray</name><argument_list>(<argument><expr><name>extcondition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extconditionarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconditionitems</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>nconfigitems</name> <operator>==</operator> <name>nconditionitems</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nconfigitems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>configtbl</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>configtbloid</name> <init>= <expr><call><name>atooid</name><argument_list>(<argument><expr><name><name>extconfigarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>dumpobj</name> <init>=
				<expr><name><name>curext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>configtbl</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>configtbl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Tables of not-to-be-dumped extensions shouldn't be dumped
				 * unless the table or its schema is explicitly included
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>curext</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator> <name>DUMP_COMPONENT_DEFINITION</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* check table explicitly requested */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>table_include_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_include_oids</name></expr></argument>,
											   <argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* check table's schema explicitly requested */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>configtbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>&amp;</operator>
						<name>DUMP_COMPONENT_DATA</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* check table excluded by an exclusion switch */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>table_exclude_oids</name><operator>.</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_exclude_oids</name></expr></argument>,
										   <argument><expr><name>configtbloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* check schema excluded by an exclusion switch */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>simple_oid_list_member</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema_exclude_oids</name></expr></argument>,
										   <argument><expr><name><name>configtbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dumpobj</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>dumpobj</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Note: config tables are dumped without OIDs regardless
					 * of the --oids setting.  This is because row filtering
					 * conditions aren't compatible with dumping OIDs.
					 */</comment>
					<expr_stmt><expr><call><name>makeTableDataInfo</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>configtbl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>configtbl</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>extconditionarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>configtbl</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>filtercond</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>extconditionarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>extconfigarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extconfigarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>extconditionarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extconditionarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now that all the TableInfoData objects have been created for all the
	 * extensions, check their FK dependencies and register them to try and
	 * dump the data out in an order that they can be restored in.
	 *
	 * Note that this is not a problem for user tables as their FKs are
	 * recreated after the data has been loaded.
	 */</comment>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printfPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT conrelid, confrelid "</literal>
					  <literal type="string">"FROM pg_constraint "</literal>
					  <literal type="string">"JOIN pg_depend ON (objid = confrelid) "</literal>
					  <literal type="string">"WHERE contype = 'f' "</literal>
					  <literal type="string">"AND refclassid = 'pg_extension'::regclass "</literal>
					  <literal type="string">"AND classid = 'pg_class'::regclass;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_conrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"conrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_confrelid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"confrelid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now get the dependencies and register them */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>conrelid</name></decl>,
					<decl><type ref="prev"/><name>confrelid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>reftable</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>contable</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_conrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>confrelid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_confrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>contable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reftable</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>confrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>reftable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>reftable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name>contable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>contable</name><operator>-&gt;</operator><name>dataObj</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make referencing TABLE_DATA object depend on the referenced table's
		 * TABLE_DATA object.
		 */</comment>
		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>contable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
							<argument><expr><name><name>reftable</name><operator>-&gt;</operator><name>dataObj</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getDependencies --- obtain available dependency data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntups</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i_classid</name></decl>,
				<decl><type ref="prev"/><name>i_objid</name></decl>,
				<decl><type ref="prev"/><name>i_refclassid</name></decl>,
				<decl><type ref="prev"/><name>i_refobjid</name></decl>,
				<decl><type ref="prev"/><name>i_deptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>refdobj</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading dependency data\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PIN dependencies aren't interesting, and EXTENSION dependencies were
	 * already processed by getExtensionMembership.
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal>
						 <literal type="string">"classid, objid, refclassid, refobjid, deptype "</literal>
						 <literal type="string">"FROM pg_depend "</literal>
						 <literal type="string">"WHERE deptype != 'p' AND deptype != 'e' "</literal>
						 <literal type="string">"ORDER BY 1,2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQuery</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>PGRES_TUPLES_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ntups</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i_classid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"classid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_objid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"objid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refclassid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refclassid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_refobjid</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"refobjid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i_deptype</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"deptype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we ordered the SELECT by referencing ID, we can expect that
	 * multiple entries for the same object will appear together; this saves
	 * on searches.
	 */</comment>
	<expr_stmt><expr><name>dobj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>objId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CatalogId</name></type>	<name>refobjId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>deptype</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refclassid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_refobjid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>deptype</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i_deptype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>tableoid</name></name> <operator>||</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name><name>objId</name><operator>.</operator><name>oid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>objId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Failure to find objects mentioned in pg_depend is not unexpected,
		 * since for example we don't collect info about TOAST tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no referencing object %u %u\n"</literal></expr></argument>,
					<argument><expr><name><name>objId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>objId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>refdobj</name> <operator>=</operator> <call><name>findObjectByCatalogId</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>refdobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
			<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"no referenced object %u %u\n"</literal></expr></argument>,
					<argument><expr><name><name>refobjId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>refobjId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Ordinarily, table rowtypes have implicit dependencies on their
		 * tables.  However, for a composite type the implicit dependency goes
		 * the other way in pg_depend; which is the right thing for DROP but
		 * it doesn't produce the dependency ordering we need. So in that one
		 * case, we reverse the direction of the dependency.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>==</operator> <literal type="char">'i'</literal> <operator>&amp;&amp;</operator>
			<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
			<name><name>refdobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>refdobj</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* normal case */</comment>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>refdobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * createBoundaryObjects - create dummy DumpableObjects to represent
 * dump section boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier></type>
<name>createBoundaryObjects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobjs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dobjs</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>objType</name> <operator>=</operator> <name>DO_PRE_DATA_BOUNDARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>catId</name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>dobjs</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"PRE-DATA BOUNDARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>objType</name> <operator>=</operator> <name>DO_POST_DATA_BOUNDARY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>catId</name> <operator>=</operator> <name>nilCatalogId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><name>dobjs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobjs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"POST-DATA BOUNDARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dobjs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * addBoundaryDependencies - add dependencies as needed to enforce the dump
 * section boundaries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addBoundaryDependencies</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dobjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
						<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>preDataBound</name> <init>= <expr><name>boundaryObjs</name> <operator>+</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>postDataBound</name> <init>= <expr><name>boundaryObjs</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name> <init>= <expr><name><name>dobjs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The classification of object types here must match the SECTION_xxx
		 * values assigned during subsequent ArchiveEntry calls!
		 */</comment>
		<switch>switch <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DO_NAMESPACE</name></expr>:</case>
			<case>case <expr><name>DO_EXTENSION</name></expr>:</case>
			<case>case <expr><name>DO_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_SHELL_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_FUNC</name></expr>:</case>
			<case>case <expr><name>DO_AGG</name></expr>:</case>
			<case>case <expr><name>DO_OPERATOR</name></expr>:</case>
			<case>case <expr><name>DO_ACCESS_METHOD</name></expr>:</case>
			<case>case <expr><name>DO_OPCLASS</name></expr>:</case>
			<case>case <expr><name>DO_OPFAMILY</name></expr>:</case>
			<case>case <expr><name>DO_COLLATION</name></expr>:</case>
			<case>case <expr><name>DO_CONVERSION</name></expr>:</case>
			<case>case <expr><name>DO_TABLE</name></expr>:</case>
			<case>case <expr><name>DO_TABLEGROUP</name></expr>:</case>
			<case>case <expr><name>DO_ATTRDEF</name></expr>:</case>
			<case>case <expr><name>DO_PROCLANG</name></expr>:</case>
			<case>case <expr><name>DO_CAST</name></expr>:</case>
			<case>case <expr><name>DO_DUMMY_TYPE</name></expr>:</case>
			<case>case <expr><name>DO_TSPARSER</name></expr>:</case>
			<case>case <expr><name>DO_TSDICT</name></expr>:</case>
			<case>case <expr><name>DO_TSTEMPLATE</name></expr>:</case>
			<case>case <expr><name>DO_TSCONFIG</name></expr>:</case>
			<case>case <expr><name>DO_FDW</name></expr>:</case>
			<case>case <expr><name>DO_FOREIGN_SERVER</name></expr>:</case>
			<case>case <expr><name>DO_TRANSFORM</name></expr>:</case>
			<case>case <expr><name>DO_BLOB</name></expr>:</case>
				<comment type="block">/* Pre-data objects: must come before the pre-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>preDataBound</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_TABLE_DATA</name></expr>:</case>
			<case>case <expr><name>DO_SEQUENCE_SET</name></expr>:</case>
			<case>case <expr><name>DO_BLOB_DATA</name></expr>:</case>
				<comment type="block">/* Data objects: must come between the boundaries */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>preDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>postDataBound</name></expr></argument>, <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_INDEX</name></expr>:</case>
			<case>case <expr><name>DO_INDEX_ATTACH</name></expr>:</case>
			<case>case <expr><name>DO_STATSEXT</name></expr>:</case>
			<case>case <expr><name>DO_REFRESH_MATVIEW</name></expr>:</case>
			<case>case <expr><name>DO_TRIGGER</name></expr>:</case>
			<case>case <expr><name>DO_EVENT_TRIGGER</name></expr>:</case>
			<case>case <expr><name>DO_DEFAULT_ACL</name></expr>:</case>
			<case>case <expr><name>DO_POLICY</name></expr>:</case>
			<case>case <expr><name>DO_PUBLICATION</name></expr>:</case>
			<case>case <expr><name>DO_PUBLICATION_REL</name></expr>:</case>
			<case>case <expr><name>DO_SUBSCRIPTION</name></expr>:</case>
				<comment type="block">/* Post-data objects: must come after the post-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_RULE</name></expr>:</case>
				<comment type="block">/* Rules are post-data, but only if dumped separately */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_CONSTRAINT</name></expr>:</case>
			<case>case <expr><name>DO_FK_CONSTRAINT</name></expr>:</case>
				<comment type="block">/* Constraints are post-data, but only if dumped separately */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>dobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>postDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DO_PRE_DATA_BOUNDARY</name></expr>:</case>
				<comment type="block">/* nothing to do */</comment>
				<break>break;</break>
			<case>case <expr><name>DO_POST_DATA_BOUNDARY</name></expr>:</case>
				<comment type="block">/* must come after the pre-data boundary */</comment>
				<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>dobj</name></expr></argument>, <argument><expr><name><name>preDataBound</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * BuildArchiveDependencies - create dependency data for archive TOC entries
 *
 * The raw dependency data obtained by getDependencies() is not terribly
 * useful in an archive dump, because in many cases there are dependency
 * chains linking through objects that don't appear explicitly in the dump.
 * For example, a view will depend on its _RETURN rule while the _RETURN rule
 * will depend on other objects --- but the rule will not appear as a separate
 * object in the dump.  We need to adjust the view's dependencies to include
 * whatever the rule depends on that is included in the dump.
 *
 * Just to make things more complicated, there are also "special" dependencies
 * such as the dependency of a TABLE DATA item on its TABLE, which we must
 * not rearrange because pg_restore knows that TABLE DATA only depends on
 * its table.  In these cases we must leave the dependencies strictly as-is
 * even if they refer to not-to-be-dumped objects.
 *
 * To handle this, the convention is that "special" dependencies are created
 * during ArchiveEntry calls, and an archive TOC item that has any such
 * entries will not be touched here.  Otherwise, we recursively search the
 * DumpableObject data structures to build the correct dependencies for each
 * archive TOC item.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BuildArchiveDependencies</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name> <init>= <expr><operator>(</operator><name>ArchiveHandle</name> <operator>*</operator><operator>)</operator> <name>fout</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TocEntry</name>   <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

	<comment type="block">/* Scan all TOC entries in the archive */</comment>
	<for>for <control>(<init><expr><name>te</name> <operator>=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>te</name> <operator>!=</operator> <name><name>AH</name><operator>-&gt;</operator><name>toc</name></name></expr>;</condition> <incr><expr><name>te</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DumpId</name>	   <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nDeps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>allocDeps</name></decl>;</decl_stmt>

		<comment type="block">/* No need to process entries that will not be dumped */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>reqs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Ignore entries that already have "special" dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Otherwise, look up the item's original DumpableObject, if any */</comment>
		<expr_stmt><expr><name>dobj</name> <operator>=</operator> <call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* No work if it has no dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Set up work array */</comment>
		<expr_stmt><expr><name>allocDeps</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>allocDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nDeps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Recursively find all dumpable dependencies */</comment>
		<expr_stmt><expr><call><name>findDumpableDependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>dobj</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>dependencies</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nDeps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>allocDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* And save 'em ... */</comment>
		<if_stmt><if>if <condition>(<expr><name>nDeps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>,
												 <argument><expr><name>nDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>dependencies</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <name>nDeps</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Recursive search subroutine for BuildArchiveDependencies */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findDumpableDependencies</name><parameter_list>(<parameter><decl><type><name>ArchiveHandle</name> <modifier>*</modifier></type><name>AH</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>,
						 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier><modifier>*</modifier></type><name>dependencies</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nDeps</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>allocDeps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ignore section boundary objects: if we search through them, we'll
	 * report lots of bogus dependencies.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_PRE_DATA_BOUNDARY</name> <operator>||</operator>
		<name><name>dobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_POST_DATA_BOUNDARY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpId</name></type>		<name>depid</name> <init>= <expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TocIDRequired</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>depid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Object will be dumped, so just reference it as a dependency */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nDeps</name> <operator>&gt;=</operator> <operator>*</operator><name>allocDeps</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>allocDeps</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>dependencies</name></expr></argument>,
													  <argument><expr><operator>*</operator><name>allocDeps</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>dependencies</name><operator>)</operator><index>[<expr><operator>*</operator><name>nDeps</name></expr>]</index> <operator>=</operator> <name>depid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>nDeps</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Object will not be dumped, so recursively consider its deps. We
			 * rely on the assumption that sortDumpableObjects already broke
			 * any dependency loops, else we might recurse infinitely.
			 */</comment>
			<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>otherdobj</name> <init>= <expr><call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name>depid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>otherdobj</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>findDumpableDependencies</name><argument_list>(<argument><expr><name>AH</name></expr></argument>, <argument><expr><name>otherdobj</name></expr></argument>,
										 <argument><expr><name>dependencies</name></expr></argument>, <argument><expr><name>nDeps</name></expr></argument>, <argument><expr><name>allocDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * getFormattedTypeName - retrieve a nicely-formatted type name for the
 * given type OID.
 *
 * This does not guarantee to schema-qualify the output, so it should not
 * be used to create the target object name for CREATE or ALTER commands.
 *
 * TODO: there might be some value in caching the results.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getFormattedTypeName</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>OidOptions</name></type> <name>opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsOpaque</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><name>g_opaque_type</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsAny</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"'any'"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsStar</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>zeroAsNone</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.format_type('%u'::pg_catalog.oid, NULL)"</literal></expr></argument>,
					  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* result of format_type is already quoted */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a column list clause for the given relation.
 *
 * Special case: if there are no undropped columns in the relation, return
 * "", not an invalid "()" column list.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fmtCopyColumnList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableInfo</name> <modifier>*</modifier></type><name>ti</name></decl></parameter>, <parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numatts</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>numatts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>attnames</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>attnames</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>attisdropped</name> <init>= <expr><name><name>ti</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needComma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attisdropped</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>attnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needComma</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no undropped columns */</comment>

	<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if a reloptions array is nonempty.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>nonemptyReloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Don't want to print it if it's just "{}" */</comment>
	<return>return <expr><operator>(</operator><name>reloptions</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbAppendReloptions2</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline_before</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1_prefix</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2_prefix</name></decl></parameter>,
				   <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YbAppendReloptions3</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>newline_before</name></expr></argument>,
						<argument><expr><name>reloptions1</name></expr></argument>, <argument><expr><name>reloptions1_prefix</name></expr></argument>,
						<argument><expr><name>reloptions2</name></expr></argument>, <argument><expr><name>reloptions2_prefix</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbAppendReloptions3</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline_before</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions1_prefix</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions2_prefix</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions3_prefix</name></decl></parameter>,
					<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>addwith</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>addcomma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>with</name> <init>= <expr><ternary><condition><expr><name>newline_before</name></expr> ?</condition><then> <expr><literal type="string">"\nWITH ("</literal></expr> </then><else>: <expr><literal type="string">" WITH ("</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name>reloptions1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>reloptions1</name></expr></argument>, <argument><expr><name>reloptions1_prefix</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addwith</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>addcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name>reloptions2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addwith</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addcomma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>reloptions2</name></expr></argument>, <argument><expr><name>reloptions2_prefix</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addwith</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>addcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>nonemptyReloptions</name><argument_list>(<argument><expr><name>reloptions3</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addwith</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addcomma</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBufferStr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendReloptionsArrayAH</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>reloptions3</name></expr></argument>, <argument><expr><name>reloptions3_prefix</name></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addwith</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>addcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addwith</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Format a reloptions array and append it to the given buffer.
 *
 * "prefix" is prepended to the option names; typically it's "" or "toast.".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendReloptionsArrayAH</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>appendReloptionsArray</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>fout</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>,
								<argument><expr><name><name>fout</name><operator>-&gt;</operator><name>std_strings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not parse reloptions array\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load the YB table properties from the YB server.
 * The table is identified by the Relation OID.
 *
 * properties - this struct, if allocated, will be filled by the function.
 * reloptions_buf - will contain a stringified array of artificial YB-specific
 * 					reloptions, will be '{}' if properties are not allocated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getYbTablePropertiesAndReloptions</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>YbTableProperties</name></type> <name>properties</name></decl></parameter>,
								  <parameter><decl><type><name>PQExpBuffer</name></type> <name>reloptions_buf</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>properties</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Retrieve the table properties from the YB server. */</comment>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
						  <argument><expr><literal type="string">"SELECT * FROM yb_table_properties(%u)"</literal></expr></argument>,
						  <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>PGresult</name><modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type>	<name>i_num_tablets</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"num_tablets"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>i_num_hash_key_columns</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"num_hash_key_columns"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>i_is_colocated</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"is_colocated"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>i_tablegroup_oid</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"tablegroup_oid"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>i_colocation_id</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"colocation_id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i_colocation_id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"cannot create a dump with YSQL metadata included, "</literal>
								<literal type="string">"please run YSQL upgrade first.\n"</literal>
								<literal type="string">"DETAILS: yb_table_properties system function definition "</literal>
								<literal type="string">"is out of date.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>properties</name><operator>-&gt;</operator><name>num_tablets</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_num_tablets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>properties</name><operator>-&gt;</operator><name>num_hash_key_columns</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_num_hash_key_columns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>properties</name><operator>-&gt;</operator><name>is_colocated</name></name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_is_colocated</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>properties</name><operator>-&gt;</operator><name>tablegroup_oid</name></name> <operator>=</operator>
			<ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tablegroup_oid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_tablegroup_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>properties</name><operator>-&gt;</operator><name>colocation_id</name></name> <operator>=</operator>
			<ternary><condition><expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_colocation_id</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>atooid</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_colocation_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>properties</name><operator>-&gt;</operator><name>is_colocated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>properties</name><operator>-&gt;</operator><name>colocation_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"colocation ID is not defined for a colocated table \"%s\"\n"</literal></expr></argument>,
						  <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Construct the reloptions array for Yugabyte reloptions. If YB is
	 * disabled, then the array will be empty ('{}').
	 */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>reloptions_buf</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>properties</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For colocated tables, we need to set the new table to have the same
		 * colocation_id since we use it as a prefix in our DocKeys.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>properties</name><operator>-&gt;</operator><name>is_colocated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>reloptions_buf</name></expr></argument>, <argument><expr><literal type="string">"colocation_id=%u"</literal></expr></argument>, <argument><expr><name><name>properties</name><operator>-&gt;</operator><name>colocation_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Note: We don't need to handle non-colocated tables in colocated
		 * databases since they will already have 'colocated=false' in their
		 * table reloptions.
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>reloptions_buf</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Is the Database colocated on the YB server.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isDatabaseColocated</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Retrieve the database property from the YB server. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT yb_is_database_colocated()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PGresult</name><modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>is_colocated</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>is_colocated</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Load the YB range-partitioned table SPLIT AT Clause from the YB server.
 * The table is identified by the Relation OID.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getYbSplitClause</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Retrieve the range split SPLIT AT clause from the YB server. */</comment>
	<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					  <argument><expr><literal type="string">"SELECT * FROM yb_get_range_split_clause(%u)"</literal></expr></argument>,
					  <argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PGresult</name><modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>ExecuteSqlQueryForSingleRow</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i_range_split_clause</name> <init>= <expr><call><name>PQfnumber</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"range_split_clause"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>range_split_clause</name> <init>= <expr><call><name>pg_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_range_split_clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>range_split_clause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update pg_extension catalog to record correct configuration relations' OID.
 * This function is called after sortDumpableObjects() functions to ensure all
 * configuration relations has been created before we update pg_extension
 * catalog.
 * Add a TOC entry for each extension containing configuration relations. Use
 * SECTION_POST_DATA as the section parameter value to respect established
 * sorted ordering before this function call.
 * Since all TOCs created in this funciton are added to the end, we can ensure
 * that all of their dependencies: configuration relations have been created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybDumpUpdatePgExtensionCatalog</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type>	   <name>update_query</name> <init>= <expr><call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		 <modifier>*</modifier><modifier>*</modifier></type><name>extconfigarray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			   <name>nconfigitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			   <name>tbloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableInfo</name>	  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>yb_dumpable_extensions_with_config_relations</name> <operator>&amp;&amp;</operator>
		   <name>yb_num_dumpable_extensions_with_config_relations</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>yb_num_dumpable_extensions_with_config_relations</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>extinfo</name> <operator>=</operator> <name><name>yb_dumpable_extensions_with_config_relations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><literal type="string">"-- YB: ensure extconfig field for "</literal>
						  <literal type="string">"extension: %s in pg_extension catalog is correct\n"</literal></expr></argument>,
						  <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>,
						  <argument><expr><literal type="string">"UPDATE pg_extension SET extconfig = ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Shouldn't happen. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parsePGArray</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>extconfig</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extconfigarray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigitems</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"error parsing OIDs of configuration relations "</literal>
						  <literal type="string">"of extension with OID %u\n"</literal></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nconfigitems</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tbloid</name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name><name>extconfigarray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tblinfo</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"configuration relation with OID %u of extension with OID %u "</literal>
							  <literal type="string">"not found\n"</literal></expr></argument>, <argument><expr><name><name>tblinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><call><name>fmtQualifiedDumpable</name><argument_list>(<argument><expr><name>tblinfo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><literal type="string">"::regclass::oid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>,
						  <argument><expr><literal type="string">"]::oid[] WHERE extname = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringLiteralAH</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><call><name>fmtId</name><argument_list>(<argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add a TOC entry to UPDATE pg_extension catalog. */</comment>
		<expr_stmt><expr><call><name>ArchiveEntry</name><argument_list>(<argument><expr><name>fout</name></expr></argument>,
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name></name></expr></argument>, <comment type="block">/* catalog ID */</comment>
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>, <comment type="block">/* dump ID */</comment>
					 <argument><expr><name><name>extinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <comment type="block">/* Name */</comment>
					 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Namespace */</comment>
					 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Tablespace */</comment>
					 <argument><expr><literal type="string">""</literal></expr></argument>, <comment type="block">/* Owner */</comment>
					 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* with oids */</comment>
					 <argument><expr><literal type="string">"EXTENSION"</literal></expr></argument>, <comment type="block">/* Desc */</comment>
					 <argument><expr><name>SECTION_POST_DATA</name></expr></argument>, <comment type="block">/* Section */</comment>
					 <argument><expr><name><name>update_query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <comment type="block">/* Create */</comment>
					 <argument><expr><literal type="string">""</literal></expr></argument>, <comment type="block">/* Del */</comment>
					 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Copy */</comment>
					 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Deps */</comment>
					 <argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* # Deps */</comment>
					 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* Dumper */</comment>
					 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Dumper Arg */</comment>

		<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>extconfigarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>extconfigarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>update_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
