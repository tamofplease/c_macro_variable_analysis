<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/pg_dump/common.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * common.c
 *	Catalog routines used by pg_dump; long ago these were shared
 *	by another dump tool, but not anymore.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/bin/pg_dump/common.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_archiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_dump.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fe_utils/string_utils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Variables for mapping DumpId to DumpableObject
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>dumpIdMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>allocedDumpIds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpId</name></type> <name>lastDumpId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Variables for mapping CatalogId to DumpableObject
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>catalogIdMapValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>catalogIdMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numCatalogIds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These variables are static to avoid the notational cruft of having to pass
 * them into findTableByOid() and friends.  For each of these arrays, we build
 * a sorted-by-OID index array immediately after the objects are fetched,
 * and then we use binary search in findTableByOid() and friends.  (qsort'ing
 * the object arrays themselves would be simpler, but it doesn't work because
 * pg_dump.c may have already established pointers between items.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>tblinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>typinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>funinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>oprinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>collinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>nspinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>extinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>tblgrpinfoindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numTables</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numTablegroups</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numTypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numFuncs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numOperators</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numCollations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numNamespaces</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numExtensions</name></decl>;</decl_stmt>

<comment type="block">/* This is an array of object identities, not actual DumpableObjects */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExtensionMemberId</name> <modifier>*</modifier></type><name>extmembers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numextmembers</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flagInhTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tbinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>,
			  <parameter><decl><type><name>InhInfo</name> <modifier>*</modifier></type><name>inhinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numInherits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flagInhIndexes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flagInhAttrs</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>buildIndexArray</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>objArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
				<parameter><decl><type><name>Size</name></type> <name>objSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DOCatalogIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ExtensionMemberIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findParentsByOid</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
				 <parameter><decl><type><name>InhInfo</name> <modifier>*</modifier></type><name>inhinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numInherits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>strInArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndxInfo</name> <modifier>*</modifier></type><name>findIndexByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>idxinfoindex</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>numIndexes</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * getSchemaData
 *	  Collect information about all potentially dumpable objects
 */</comment>
<function><type><name>TableInfo</name> <modifier>*</modifier></type>
<name>getSchemaData</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numTablesPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tblinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>typinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>funinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oprinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CollInfo</name>   <modifier>*</modifier></type><name>collinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NamespaceInfo</name> <modifier>*</modifier></type><name>nspinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionInfo</name> <modifier>*</modifier></type><name>extinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InhInfo</name>    <modifier>*</modifier></type><name>inhinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TablegroupInfo</name> <modifier>*</modifier></type><name>tblgrpinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAggregates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numInherits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numRules</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numProcLangs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCasts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTransforms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAccessMethods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numOpclasses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numOpfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numConversions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTSParsers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTSTemplates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTSDicts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numTSConfigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numForeignDataWrappers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numForeignServers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numDefaultACLs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numEventTriggers</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must read extensions and extension membership info first, because
	 * extension membership needs to be consultable during decisions about
	 * whether other objects are to be dumped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading extensions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>extinfo</name> <operator>=</operator> <call><name>getExtensions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numExtensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>extinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>extinfo</name></expr></argument>, <argument><expr><name>numExtensions</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"identifying extension members\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getExtensionMembership</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>extinfo</name></expr></argument>, <argument><expr><name>numExtensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading schemas\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nspinfo</name> <operator>=</operator> <call><name>getNamespaces</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numNamespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>nspinfo</name></expr></argument>, <argument><expr><name>numNamespaces</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NamespaceInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * getTables should be done as soon as possible, so as to minimize the
	 * window between starting our transaction and acquiring per-table locks.
	 * However, we have to do getNamespaces first because the tables get
	 * linked to their containing namespaces during getTables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined tables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tblinfo</name> <operator>=</operator> <call><name>getTables</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tblinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do this after we've built tblinfoindex */</comment>
	<expr_stmt><expr><call><name>getOwnedSeqs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>funinfo</name> <operator>=</operator> <call><name>getFuncs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>funinfo</name></expr></argument>, <argument><expr><name>numFuncs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FuncInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this must be after getTables and getFuncs */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined types\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typinfo</name> <operator>=</operator> <call><name>getTypes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>typinfo</name></expr></argument>, <argument><expr><name>numTypes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TypeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this must be after getFuncs, too */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading procedural languages\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getProcLangs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numProcLangs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined aggregate functions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getAggregates</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numAggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined operators\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>oprinfo</name> <operator>=</operator> <call><name>getOperators</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>oprinfo</name></expr></argument>, <argument><expr><name>numOperators</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OprInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined access methods\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getAccessMethods</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numAccessMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined tablegroups\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tblgrpinfo</name> <operator>=</operator> <call><name>getTablegroups</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTablegroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tblgrpinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>tblgrpinfo</name></expr></argument>, <argument><expr><name>numTablegroups</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TablegroupInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined operator classes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getOpclasses</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numOpclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined operator families\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getOpfamilies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numOpfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined text search parsers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTSParsers</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTSParsers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined text search templates\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTSTemplates</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTSTemplates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined text search dictionaries\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTSDictionaries</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTSDicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined text search configurations\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTSConfigurations</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTSConfigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined foreign-data wrappers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getForeignDataWrappers</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numForeignDataWrappers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined foreign servers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getForeignServers</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numForeignServers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading default privileges\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getDefaultACLs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numDefaultACLs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined collations\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>collinfo</name> <operator>=</operator> <call><name>getCollations</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collinfoindex</name> <operator>=</operator> <call><name>buildIndexArray</name><argument_list>(<argument><expr><name>collinfo</name></expr></argument>, <argument><expr><name>numCollations</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CollInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading user-defined conversions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getConversions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numConversions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading type casts\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getCasts</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numCasts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading transforms\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTransforms</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numTransforms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading table inheritance information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>inhinfo</name> <operator>=</operator> <call><name>getInherits</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numInherits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading event triggers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getEventTriggers</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numEventTriggers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify extension configuration tables that should be dumped */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"finding extension tables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>processExtensionTables</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>extinfo</name></expr></argument>, <argument><expr><name>numExtensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Link tables to parents, mark parents of target tables interesting */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"finding inheritance relationships\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>flagInhTables</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>, <argument><expr><name>inhinfo</name></expr></argument>, <argument><expr><name>numInherits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading column info for interesting tables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTableAttrs</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"flagging inherited columns in subtables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>flagInhAttrs</name><argument_list>(<argument><expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading indexes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getIndexes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"flagging indexes in partitioned tables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>flagInhIndexes</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading extended statistics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getExtendedStatistics</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading constraints\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getConstraints</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading triggers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getTriggers</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading rewrite rules\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getRules</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numRules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading policies\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getPolicies</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading publications\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getPublications</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading publication membership\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getPublicationTables</name><argument_list>(<argument><expr><name>fout</name></expr></argument>, <argument><expr><name>tblinfo</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>g_verbose</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"reading subscriptions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>getSubscriptions</name><argument_list>(<argument><expr><name>fout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>numTablesPtr</name> <operator>=</operator> <name>numTables</name></expr>;</expr_stmt>
	<return>return <expr><name>tblinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* flagInhTables -
 *	 Fill in parent link fields of tables for which we need that information,
 *	 and mark parents of target tables as interesting
 *
 * Note that only direct ancestors of targets are marked interesting.
 * This is sufficient; we don't much care whether they inherited their
 * attributes or not.
 *
 * modifies tblinfo
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flagInhTables</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>,
			  <parameter><decl><type><name>InhInfo</name> <modifier>*</modifier></type><name>inhinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numInherits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name> <init>= <expr><name><name>fout</name><operator>-&gt;</operator><name>dopt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>find_parents</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>mark_parents</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Some kinds never have parents */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
			<name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
			<name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Normally, we don't bother computing anything for non-target tables,
		 * but if load-via-partition-root is specified, we gather information
		 * on every partition in the system so that getRootTableInfo can trace
		 * from any given to leaf partition all the way up to the root.  (We
		 * don't need to mark them as interesting for getTableAttrs, though.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>mark_parents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dopt</name><operator>-&gt;</operator><name>load_via_partition_root</name></name> <operator>||</operator>
				<operator>!</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ispartition</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>find_parents</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If needed, find all the immediate parent tables. */</comment>
		<if_stmt><if>if <condition>(<expr><name>find_parents</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>findParentsByOid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>inhinfo</name></expr></argument>, <argument><expr><name>numInherits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If needed, mark the parents as interesting for getTableAttrs and
		 * getIndexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>mark_parents</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name> <init>= <expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numParents</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name> <init>= <expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parents</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>parents</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>interesting</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * flagInhIndexes -
 *	 Create AttachIndexInfo objects for partitioned indexes, and add
 *	 appropriate dependency links.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flagInhIndexes</name><parameter_list>(<parameter><decl><type><name>Archive</name> <modifier>*</modifier></type><name>fout</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name></type> <name><name>tblinfo</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>parentIndexArray</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parentIndexArray</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>pg_malloc0</name><argument_list>(<argument><expr><call><name>getMaxDumpId</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parenttbl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexAttachInfo</name> <modifier>*</modifier></type><name>attachinfo</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ispartition</name> <operator>||</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numParents</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numParents</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parenttbl</name> <operator>=</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need access to each parent table's index list, but there is no
		 * index to cover them outside of this function.  To avoid having to
		 * sort every parent table's indexes each time we come across each of
		 * its partitions, create an indexed array for each parent the first
		 * time it is required.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parentIndexArray</name><index>[<expr><name><name>parenttbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parentIndexArray</name><index>[<expr><name><name>parenttbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>]</index></name> <operator>=</operator>
				<call><name>buildIndexArray</name><argument_list>(<argument><expr><name><name>parenttbl</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>,
								<argument><expr><name><name>parenttbl</name><operator>-&gt;</operator><name>numIndexes</name></name></expr></argument>,
								<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndxInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attachinfo</name> <operator>=</operator> <operator>(</operator><name>IndexAttachInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>pg_malloc0</name><argument_list>(<argument><expr><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numIndexes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexAttachInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numIndexes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndxInfo</name>   <modifier>*</modifier></type><name>parentidx</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>parentidx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>parentidx</name> <operator>=</operator> <call><name>findIndexByOid</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>parentidx</name></name></expr></argument>,
									   <argument><expr><name><name>parentIndexArray</name><index>[<expr><name><name>parenttbl</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>parenttbl</name><operator>-&gt;</operator><name>numIndexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>parentidx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_INDEX_ATTACH</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indextable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>parentIdx</name> <operator>=</operator> <name>parentidx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>partitionIdx</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We must state the DO_INDEX_ATTACH object's dependencies
			 * explicitly, since it will not match anything in pg_depend.
			 *
			 * Give it dependencies on both the partition index and the parent
			 * index, so that it will not be executed till both of those
			 * exist.  (There's no need to care what order those are created
			 * in.)
			 *
			 * In addition, give it dependencies on the indexes' underlying
			 * tables.  This does nothing of great value so far as serial
			 * restore ordering goes, but it ensures that a parallel restore
			 * will not try to run the ATTACH concurrently with other
			 * operations on those tables.
			 */</comment>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>, <argument><expr><name><name>parentidx</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>,
								<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indextable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attachinfo</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>dobj</name></expr></argument>,
								<argument><expr><name><name>parentidx</name><operator>-&gt;</operator><name>indextable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>parentIndexArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name><name>parentIndexArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pg_free</name><argument_list>(<argument><expr><name>parentIndexArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* flagInhAttrs -
 *	 for each dumpable table in tblinfo, flag its inherited attributes
 *
 * What we need to do here is detect child columns that inherit NOT NULL
 * bits from their parents (so that we needn't specify that again for the
 * child) and child columns that have DEFAULT NULL when their parents had
 * some non-null default.  In the latter case, we make up a dummy AttrDefInfo
 * object so that we'll correctly emit the necessary DEFAULT NULL clause;
 * otherwise the backend will apply an inherited default to the column.
 *
 * modifies tblinfo
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flagInhAttrs</name><parameter_list>(<parameter><decl><type><name>DumpOptions</name> <modifier>*</modifier></type><name>dopt</name></decl></parameter>, <parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>tblinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numTables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>tbinfo</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>tblinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TableInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>

		<comment type="block">/* Some kinds never have parents */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
			<name><name>tbinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Don't bother computing anything for non-target tables, either */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numParents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numParents</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parents</name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* nothing to see here, move along */</comment>

		<comment type="block">/* For each column, search for matching column names in parent(s) */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>numatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>foundNotNull</name></decl>;</decl_stmt>	<comment type="block">/* Attr was NOT NULL in a parent */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>foundDefault</name></decl>;</decl_stmt>	<comment type="block">/* Found a default in a parent */</comment>

			<comment type="block">/* no point in examining dropped columns */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attisdropped</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>foundNotNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>foundDefault</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>numParents</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>parents</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>inhAttrInd</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>inhAttrInd</name> <operator>=</operator> <call><name>strInArray</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>attnames</name></name></expr></argument>,
										<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>numatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>inhAttrInd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>foundNotNull</name> <operator>|=</operator> <name><name>parent</name><operator>-&gt;</operator><name>notnull</name><index>[<expr><name>inhAttrInd</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>foundDefault</name> <operator>|=</operator> <operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>inhAttrInd</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Remember if we found inherited NOT NULL */</comment>
			<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>inhNotNull</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>foundNotNull</name></expr>;</expr_stmt>

			<comment type="block">/* Manufacture a DEFAULT NULL clause if necessary */</comment>
			<if_stmt><if>if <condition>(<expr><name>foundDefault</name> <operator>&amp;&amp;</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>attrDef</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>attrDef</name> <operator>=</operator> <operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrDefInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>objType</name></name> <operator>=</operator> <name>DO_ATTRDEF</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>tableoid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AssignDumpId</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>adtable</name></name> <operator>=</operator> <name>tbinfo</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>adnum</name></name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>adef_expr</name></name> <operator>=</operator> <call><name>pg_strdup</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Will column be dumped explicitly? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>shouldPrintColumn</name><argument_list>(<argument><expr><name>dopt</name></expr></argument>, <argument><expr><name>tbinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>separate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<comment type="block">/* No dependency needed: NULL cannot have dependencies */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* column will be suppressed, print default separately */</comment>
					<expr_stmt><expr><name><name>attrDef</name><operator>-&gt;</operator><name>separate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* ensure it comes out after the table */</comment>
					<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attrDef</name><operator>-&gt;</operator><name>dobj</name></name></expr></argument>,
										<argument><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name><name>tbinfo</name><operator>-&gt;</operator><name>attrdefs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>attrDef</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AssignDumpId
 *		Given a newly-created dumpable object, assign a dump ID,
 *		and enter the object into the lookup table.
 *
 * The caller is expected to have filled in objType and catId,
 * but not any of the other standard fields of a DumpableObject.
 */</comment>
<function><type><name>void</name></type>
<name>AssignDumpId</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>=</operator> <operator>++</operator><name>lastDumpId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* must be set later */</comment>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>namespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* may be set later */</comment>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>=</operator> <name>DUMP_COMPONENT_ALL</name></expr>;</expr_stmt>	<comment type="block">/* default assumption */</comment>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>ext_member</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* default assumption */</comment>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name> <operator>&gt;=</operator> <name>allocedDumpIds</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newAlloc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>allocedDumpIds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newAlloc</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dumpIdMap</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>pg_malloc</name><argument_list>(<argument><expr><name>newAlloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newAlloc</name> <operator>=</operator> <name>allocedDumpIds</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dumpIdMap</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>pg_realloc</name><argument_list>(<argument><expr><name>dumpIdMap</name></expr></argument>, <argument><expr><name>newAlloc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dumpIdMap</name> <operator>+</operator> <name>allocedDumpIds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>newAlloc</name> <operator>-</operator> <name>allocedDumpIds</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>allocedDumpIds</name> <operator>=</operator> <name>newAlloc</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>dumpIdMap</name><index>[<expr><name><name>dobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>=</operator> <name>dobj</name></expr>;</expr_stmt>

	<comment type="block">/* mark catalogIdMap invalid, but don't rebuild it yet */</comment>
	<expr_stmt><expr><name>catalogIdMapValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a DumpId that's not tied to a DumpableObject.
 *
 * This is used when creating a "fixed" ArchiveEntry that doesn't need to
 * participate in the sorting logic.
 */</comment>
<function><type><name>DumpId</name></type>
<name>createDumpId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>lastDumpId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the largest DumpId so far assigned
 */</comment>
<function><type><name>DumpId</name></type>
<name>getMaxDumpId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>lastDumpId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a DumpableObject by dump ID
 *
 * Returns NULL for invalid ID
 */</comment>
<function><type><name>DumpableObject</name> <modifier>*</modifier></type>
<name>findObjectByDumpId</name><parameter_list>(<parameter><decl><type><name>DumpId</name></type> <name>dumpId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dumpId</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>dumpId</name> <operator>&gt;=</operator> <name>allocedDumpIds</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* out of range? */</comment>
	<return>return <expr><name><name>dumpIdMap</name><index>[<expr><name>dumpId</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a DumpableObject by catalog ID
 *
 * Returns NULL for unknown ID
 *
 * We use binary search in a sorted list that is built on first call.
 * If AssignDumpId() and findObjectByCatalogId() calls were freely intermixed,
 * the code would work, but possibly be very slow.  In the current usage
 * pattern that does not happen, indeed we build the list at most twice.
 */</comment>
<function><type><name>DumpableObject</name> <modifier>*</modifier></type>
<name>findObjectByCatalogId</name><parameter_list>(<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>catalogIdMapValid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>catalogIdMap</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>catalogIdMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>getDumpableObjects</name><argument_list>(<argument><expr><operator>&amp;</operator><name>catalogIdMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numCatalogIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>numCatalogIds</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>catalogIdMap</name></expr></argument>, <argument><expr><name>numCatalogIds</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>DOCatalogIdCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>catalogIdMapValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could use bsearch() here, but the notational cruft of calling
	 * bsearch is nearly as bad as doing it ourselves; and the generalized
	 * bsearch function is noticeably slower as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numCatalogIds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>catalogIdMap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <name>catalogIdMap</name> <operator>+</operator> <operator>(</operator><name>numCatalogIds</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>middle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>difference</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<comment type="block">/* comparison must match DOCatalogIdCompare, below */</comment>
		<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>middle</name><operator>)</operator><operator>-&gt;</operator><name><name>catId</name><operator>.</operator><name>oid</name></name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>middle</name><operator>)</operator><operator>-&gt;</operator><name><name>catId</name><operator>.</operator><name>tableoid</name></name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>*</operator><name>middle</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>difference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find a DumpableObject by OID, in a pre-sorted array of one type of object
 *
 * Returns NULL for unknown OID
 */</comment>
<function><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier></type>
<name>findObjectByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is the same as findObjectByCatalogId except we assume we need not
	 * look at table OID because the objects are all the same type.
	 *
	 * We could use bsearch() here, but the notational cruft of calling
	 * bsearch is nearly as bad as doing it ourselves; and the generalized
	 * bsearch function is noticeably slower as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>indexArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <name>indexArray</name> <operator>+</operator> <operator>(</operator><name>numObjs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>middle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>difference</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>middle</name><operator>)</operator><operator>-&gt;</operator><name><name>catId</name><operator>.</operator><name>oid</name></name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>*</operator><name>middle</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>difference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an index array of DumpableObject pointers, sorted by OID
 */</comment>
<function><type><specifier>static</specifier> <name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>buildIndexArray</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>objArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>objSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptrs</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numObjs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ptrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>objArray</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>objSize</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* We can use DOCatalogIdCompare to sort since its first key is OID */</comment>
	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ptrs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>DOCatalogIdCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ptrs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for pointers to DumpableObjects
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>DOCatalogIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>obj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DumpableObject</name> <modifier>*</modifier></type><name>obj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmpval</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compare OID first since it's usually unique, whereas there will only be
	 * a few distinct values of tableoid.
	 */</comment>
	<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an array of pointers to all known dumpable objects
 *
 * This simply creates a modifiable copy of the internal map.
 */</comment>
<function><type><name>void</name></type>
<name>getDumpableObjects</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>numObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>objs</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>pg_malloc</name><argument_list>(<argument><expr><name>allocedDumpIds</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>allocedDumpIds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dumpIdMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>objs</name><operator>)</operator><index>[<expr><name>j</name><operator>++</operator></expr>]</index> <operator>=</operator> <name><name>dumpIdMap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>numObjs</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a dependency link to a DumpableObject
 *
 * Note: duplicate dependencies are currently not eliminated
 */</comment>
<function><type><name>void</name></type>
<name>addObjectDependency</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>refId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>&gt;=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator>
				<call><name>pg_malloc</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator>
				<call><name>pg_realloc</name><argument_list>(<argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>,
						   <argument><expr><name><name>dobj</name><operator>-&gt;</operator><name>allocDeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>refId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove a dependency link from a DumpableObject
 *
 * If there are multiple links, all are removed
 */</comment>
<function><type><name>void</name></type>
<name>removeObjectDependency</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>dobj</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>refId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>refId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>dobj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>dobj</name><operator>-&gt;</operator><name>nDeps</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * findTableByOid
 *	  finds the entry (in tblinfo) of the table with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>TableInfo</name> <modifier>*</modifier></type>
<name>findTableByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>tblinfoindex</name></expr></argument>, <argument><expr><name>numTables</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findTypeByOid
 *	  finds the entry (in typinfo) of the type with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>TypeInfo</name> <modifier>*</modifier></type>
<name>findTypeByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>typinfoindex</name></expr></argument>, <argument><expr><name>numTypes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findFuncByOid
 *	  finds the entry (in funinfo) of the function with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>FuncInfo</name> <modifier>*</modifier></type>
<name>findFuncByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>FuncInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>funinfoindex</name></expr></argument>, <argument><expr><name>numFuncs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findOprByOid
 *	  finds the entry (in oprinfo) of the operator with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>OprInfo</name> <modifier>*</modifier></type>
<name>findOprByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>OprInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oprinfoindex</name></expr></argument>, <argument><expr><name>numOperators</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findCollationByOid
 *	  finds the entry (in collinfo) of the collation with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>CollInfo</name> <modifier>*</modifier></type>
<name>findCollationByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>CollInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>collinfoindex</name></expr></argument>, <argument><expr><name>numCollations</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findNamespaceByOid
 *	  finds the entry (in nspinfo) of the namespace with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>NamespaceInfo</name> <modifier>*</modifier></type>
<name>findNamespaceByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>NamespaceInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>nspinfoindex</name></expr></argument>, <argument><expr><name>numNamespaces</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findExtensionByOid
 *	  finds the entry (in extinfo) of the extension with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>ExtensionInfo</name> <modifier>*</modifier></type>
<name>findExtensionByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>ExtensionInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>extinfoindex</name></expr></argument>, <argument><expr><name>numExtensions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findTablegroupByOid
 *	  finds the entry (in tblgrpinfo) of the tablegroup with the given oid
 *	  returns NULL if not found
 */</comment>
<function><type><name>TablegroupInfo</name> <modifier>*</modifier></type>
<name>findTablegroupByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>TablegroupInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>tblgrpinfoindex</name></expr></argument>, <argument><expr><name>numTablegroups</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findIndexByOid
 *		find the entry of the index with the given oid
 *
 * This one's signature is different from the previous ones because we lack a
 * global array of all indexes, so caller must pass their array as argument.
 */</comment>
<function><type><specifier>static</specifier> <name>IndxInfo</name> <modifier>*</modifier></type>
<name>findIndexByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>idxinfoindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numIndexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <call><name>findObjectByOid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>idxinfoindex</name></expr></argument>, <argument><expr><name>numIndexes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setExtensionMembership
 *	  accept and save data about which objects belong to extensions
 */</comment>
<function><type><name>void</name></type>
<name>setExtensionMembership</name><parameter_list>(<parameter><decl><type><name>ExtensionMemberId</name> <modifier>*</modifier></type><name>extmems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nextmems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Sort array in preparation for binary searches */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextmems</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>extmems</name></expr></argument>, <argument><expr><name>nextmems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExtensionMemberId</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>ExtensionMemberIdCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* And save */</comment>
	<expr_stmt><expr><name>extmembers</name> <operator>=</operator> <name>extmems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numextmembers</name> <operator>=</operator> <name>nextmems</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findOwningExtension
 *	  return owning extension for specified catalog ID, or NULL if none
 */</comment>
<function><type><name>ExtensionInfo</name> <modifier>*</modifier></type>
<name>findOwningExtension</name><parameter_list>(<parameter><decl><type><name>CatalogId</name></type> <name>catalogId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExtensionMemberId</name> <modifier>*</modifier></type><name>low</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensionMemberId</name> <modifier>*</modifier></type><name>high</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We could use bsearch() here, but the notational cruft of calling
	 * bsearch is nearly as bad as doing it ourselves; and the generalized
	 * bsearch function is noticeably slower as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numextmembers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>extmembers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <name>extmembers</name> <operator>+</operator> <operator>(</operator><name>numextmembers</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExtensionMemberId</name> <modifier>*</modifier></type><name>middle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>difference</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<comment type="block">/* comparison must match ExtensionMemberIdCompare, below */</comment>
		<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>middle</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>middle</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>catalogId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>middle</name><operator>-&gt;</operator><name>ext</name></name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>difference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for ExtensionMemberIds
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ExtensionMemberIdCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensionMemberId</name> <modifier>*</modifier></type><name>obj1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ExtensionMemberId</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensionMemberId</name> <modifier>*</modifier></type><name>obj2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ExtensionMemberId</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmpval</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compare OID first since it's usually unique, whereas there will only be
	 * a few distinct values of tableoid.
	 */</comment>
	<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>oidcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>tableoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * findParentsByOid
 *	  find a table's parents in tblinfo[]
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findParentsByOid</name><parameter_list>(<parameter><decl><type><name>TableInfo</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
				 <parameter><decl><type><name>InhInfo</name> <modifier>*</modifier></type><name>inhinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numInherits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParents</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numParents</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numInherits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhrelid</name> <operator>==</operator> <name>oid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numParents</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>numParents</name></name> <operator>=</operator> <name>numParents</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numParents</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>parents</name></name> <operator>=</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>pg_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numParents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numInherits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhrelid</name> <operator>==</operator> <name>oid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>findTableByOid</name><argument_list>(<argument><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"failed sanity check, parent OID %u of table \"%s\" (OID %u) not found\n"</literal></expr></argument>,
							  <argument><expr><name><name>inhinfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>inhparent</name></expr></argument>,
							  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							  <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>parents</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>parents</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parseOidArray
 *	  parse a string of numbers delimited by spaces into a character array
 *
 * Note: actually this is used for both Oids and potentially-signed
 * attribute numbers.  This should cause no trouble, but we could split
 * the function into two functions with different argument types if it does.
 */</comment>

<function><type><name>void</name></type>
<name>parseOidArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arraysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>argNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>temp</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>argNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>argNum</name> <operator>&gt;=</operator> <name>arraysize</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not parse numeric array \"%s\": too many numbers\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>temp</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>array</name><index>[<expr><name>argNum</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>s</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>||</operator>
				<name>j</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"could not parse numeric array \"%s\": invalid character in number\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>exit_nicely</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>temp</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><name>argNum</name> <operator>&lt;</operator> <name>arraysize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>array</name><index>[<expr><name>argNum</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * strInArray:
 *	  takes in a string and a string array and the number of elements in the
 * string array.
 *	  returns the index if the string is somewhere in the array, -1 otherwise
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>strInArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arr_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arr_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
</unit>
