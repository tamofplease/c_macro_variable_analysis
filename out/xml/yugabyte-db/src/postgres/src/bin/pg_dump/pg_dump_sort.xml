<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/bin/pg_dump/pg_dump_sort.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_dump_sort.c
 *	  Sort the items of a dump into a safe order for dumping
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/bin/pg_dump/pg_dump_sort.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_archiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_backup_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_dump.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class_d.h"</cpp:file></cpp:include>

<comment type="block">/* translator: this is a module name */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modulename</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sorter"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Sort priority for database object types.
 * Objects are sorted by type, and within a type by name.
 *
 * Because materialized views can potentially reference system views,
 * DO_REFRESH_MATVIEW should always be the last thing on the list.
 *
 * On the other hand, casts are intentionally sorted earlier than you might
 * expect; logically they should come after functions, since they usually
 * depend on those.  This works around the backend's habit of recording
 * views that use casts as dependent on the cast's underlying function.
 * We initially sort casts first, and then any functions used by casts
 * will be hoisted above the casts, and in turn views that those functions
 * depend on will be hoisted above the functions.  But views not used that
 * way won't be hoisted.
 *
 * NOTE: object-type priorities must match the section assignments made in
 * pg_dump.c; that is, PRE_DATA objects must sort before DO_PRE_DATA_BOUNDARY,
 * POST_DATA objects must sort after DO_POST_DATA_BOUNDARY, and DATA objects
 * must sort between them.
 *
 * Note: sortDataAndIndexObjectsBySize wants to have all DO_TABLE_DATA and
 * DO_INDEX objects in contiguous chunks, so do not reuse the values for those
 * for other object types.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>dbObjectTypePriority</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="number">1</literal></expr>,							<comment type="block">/* DO_NAMESPACE */</comment>
	<expr><literal type="number">4</literal></expr>,							<comment type="block">/* DO_EXTENSION */</comment>
	<expr><literal type="number">5</literal></expr>,							<comment type="block">/* DO_TYPE */</comment>
	<expr><literal type="number">5</literal></expr>,							<comment type="block">/* DO_SHELL_TYPE */</comment>
	<expr><literal type="number">7</literal></expr>,							<comment type="block">/* DO_FUNC */</comment>
	<expr><literal type="number">8</literal></expr>,							<comment type="block">/* DO_AGG */</comment>
	<expr><literal type="number">9</literal></expr>,							<comment type="block">/* DO_OPERATOR */</comment>
	<expr><literal type="number">9</literal></expr>,							<comment type="block">/* DO_ACCESS_METHOD */</comment>
	<expr><literal type="number">10</literal></expr>,							<comment type="block">/* DO_OPCLASS */</comment>
	<expr><literal type="number">10</literal></expr>,							<comment type="block">/* DO_OPFAMILY */</comment>
	<expr><literal type="number">3</literal></expr>,							<comment type="block">/* DO_COLLATION */</comment>
	<expr><literal type="number">11</literal></expr>,							<comment type="block">/* DO_CONVERSION */</comment>
	<expr><literal type="number">19</literal></expr>,							<comment type="block">/* DO_TABLE */</comment>
	<expr><literal type="number">21</literal></expr>,							<comment type="block">/* DO_ATTRDEF */</comment>
	<expr><literal type="number">29</literal></expr>,							<comment type="block">/* DO_INDEX */</comment>
	<expr><literal type="number">30</literal></expr>,							<comment type="block">/* DO_INDEX_ATTACH */</comment>
	<expr><literal type="number">31</literal></expr>,							<comment type="block">/* DO_STATSEXT */</comment>
	<expr><literal type="number">32</literal></expr>,							<comment type="block">/* DO_RULE */</comment>
	<expr><literal type="number">33</literal></expr>,							<comment type="block">/* DO_TRIGGER */</comment>
	<expr><literal type="number">28</literal></expr>,							<comment type="block">/* DO_CONSTRAINT */</comment>
	<expr><literal type="number">34</literal></expr>,							<comment type="block">/* DO_FK_CONSTRAINT */</comment>
	<expr><literal type="number">2</literal></expr>,							<comment type="block">/* DO_PROCLANG */</comment>
	<expr><literal type="number">6</literal></expr>,							<comment type="block">/* DO_CAST */</comment>
	<expr><literal type="number">24</literal></expr>,							<comment type="block">/* DO_TABLE_DATA */</comment>
	<expr><literal type="number">25</literal></expr>,							<comment type="block">/* DO_SEQUENCE_SET */</comment>
	<expr><literal type="number">20</literal></expr>,							<comment type="block">/* DO_DUMMY_TYPE */</comment>
	<expr><literal type="number">12</literal></expr>,							<comment type="block">/* DO_TSPARSER */</comment>
	<expr><literal type="number">14</literal></expr>,							<comment type="block">/* DO_TSDICT */</comment>
	<expr><literal type="number">13</literal></expr>,							<comment type="block">/* DO_TSTEMPLATE */</comment>
	<expr><literal type="number">15</literal></expr>,							<comment type="block">/* DO_TSCONFIG */</comment>
	<expr><literal type="number">16</literal></expr>,							<comment type="block">/* DO_FDW */</comment>
	<expr><literal type="number">17</literal></expr>,							<comment type="block">/* DO_FOREIGN_SERVER */</comment>
	<expr><literal type="number">34</literal></expr>,							<comment type="block">/* DO_DEFAULT_ACL */</comment>
	<expr><literal type="number">3</literal></expr>,							<comment type="block">/* DO_TRANSFORM */</comment>
	<expr><literal type="number">22</literal></expr>,							<comment type="block">/* DO_BLOB */</comment>
	<expr><literal type="number">26</literal></expr>,							<comment type="block">/* DO_BLOB_DATA */</comment>
	<expr><literal type="number">23</literal></expr>,							<comment type="block">/* DO_PRE_DATA_BOUNDARY */</comment>
	<expr><literal type="number">27</literal></expr>,							<comment type="block">/* DO_POST_DATA_BOUNDARY */</comment>
	<expr><literal type="number">35</literal></expr>,							<comment type="block">/* DO_EVENT_TRIGGER */</comment>
	<expr><literal type="number">40</literal></expr>,							<comment type="block">/* DO_REFRESH_MATVIEW */</comment>
	<expr><literal type="number">36</literal></expr>,							<comment type="block">/* DO_POLICY */</comment>
	<expr><literal type="number">37</literal></expr>,							<comment type="block">/* DO_PUBLICATION */</comment>
	<expr><literal type="number">38</literal></expr>,							<comment type="block">/* DO_PUBLICATION_REL */</comment>
	<expr><literal type="number">39</literal></expr>,							<comment type="block">/* DO_SUBSCRIPTION */</comment>
	<expr><literal type="number">18</literal></expr>,							<comment type="block">/* DO_TABLEGROUP */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>DumpId</name></type> <name>preDataBoundId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DumpId</name></type> <name>postDataBoundId</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DOTypeNameCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TopoSort</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
		 <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordering</name></decl></parameter>,
		 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nOrdering</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addHeapElement</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>heapLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>removeHeapElement</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>heapLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>findDependencyLoops</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nObjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>totObjs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>findLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
		 <parameter><decl><type><name>DumpId</name></type> <name>startPoint</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>,
		 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier></type><name>searchFailed</name></decl></parameter>,
		 <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>workspace</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repairDependencyLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>loop</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nLoop</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>describeDumpableObject</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>DOSizeCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>findFirstEqualType</name><parameter_list>(<parameter><decl><type><name>DumpableObjectType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>objs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>findFirstDifferentType</name><parameter_list>(<parameter><decl><type><name>DumpableObjectType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>objs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	<return>return <expr><name>numObjs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When we do a parallel dump, we want to start with the largest items first.
 *
 * Say we have the objects in this order:
 * ....DDDDD....III....
 *
 * with D = Table data, I = Index, . = other object
 *
 * This sorting function now takes each of the D or I blocks and sorts them
 * according to their size.
 */</comment>
<function><type><name>void</name></type>
<name>sortDataAndIndexObjectsBySize</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>startIdx</name></decl>,
				<decl><type ref="prev"/><name>endIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>startPtr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>startIdx</name> <operator>=</operator> <call><name>findFirstEqualType</name><argument_list>(<argument><expr><name>DO_TABLE_DATA</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>endIdx</name> <operator>=</operator> <call><name>findFirstDifferentType</name><argument_list>(<argument><expr><name>DO_TABLE_DATA</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startPtr</name> <operator>=</operator> <name>objs</name> <operator>+</operator> <name>startIdx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>startPtr</name></expr></argument>, <argument><expr><name>endIdx</name> <operator>-</operator> <name>startIdx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>DOSizeCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>startIdx</name> <operator>=</operator> <call><name>findFirstEqualType</name><argument_list>(<argument><expr><name>DO_INDEX</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>startIdx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>endIdx</name> <operator>=</operator> <call><name>findFirstDifferentType</name><argument_list>(<argument><expr><name>DO_INDEX</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><name>startIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>startPtr</name> <operator>=</operator> <name>objs</name> <operator>+</operator> <name>startIdx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>startPtr</name></expr></argument>, <argument><expr><name>endIdx</name> <operator>-</operator> <name>startIdx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>DOSizeCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>DOSizeCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>obj1_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>obj2_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obj1_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>obj1</name><operator>)</operator><operator>-&gt;</operator><name><name>tdtable</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obj1_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name>obj1</name><operator>)</operator><operator>-&gt;</operator><name>relpages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>obj2</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE_DATA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obj2_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>TableDataInfo</name> <operator>*</operator><operator>)</operator> <name>obj2</name><operator>)</operator><operator>-&gt;</operator><name><name>tdtable</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obj2</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>obj2_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name>obj2</name><operator>)</operator><operator>-&gt;</operator><name>relpages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we want to see the biggest item go first */</comment>
	<if_stmt><if>if <condition>(<expr><name>obj1_size</name> <operator>&gt;</operator> <name>obj2_size</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>obj2_size</name> <operator>&gt;</operator> <name>obj1_size</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort the given objects into a type/name-based ordering
 *
 * Normally this is just the starting point for the dependency-based
 * ordering.
 */</comment>
<function><type><name>void</name></type>
<name>sortDumpableObjectsByTypeName</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>DOTypeNameCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>DOTypeNameCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>DumpableObject</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmpval</name></decl>;</decl_stmt>

	<comment type="block">/* Sort by type's priority */</comment>
	<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name><name>dbObjectTypePriority</name><index>[<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name></expr>]</index></name> <operator>-</operator>
		<name><name>dbObjectTypePriority</name><index>[<expr><name><name>obj2</name><operator>-&gt;</operator><name>objType</name></name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sort by namespace.  Typically, all objects of the same priority would
	 * either have or not have a namespace link, but there are exceptions.
	 * Sort NULL namespace after non-NULL in such cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>obj2</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
							<argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>obj2</name><operator>-&gt;</operator><name>namespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Sort by name */</comment>
	<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* To have a stable sort order, break ties for some object types */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_FUNC</name> <operator>||</operator> <name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_AGG</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>fobj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>FuncInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncInfo</name>   <modifier>*</modifier></type><name>fobj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>FuncInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <name><name>fobj1</name><operator>-&gt;</operator><name>nargs</name></name> <operator>-</operator> <name><name>fobj2</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fobj1</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>argtype1</name> <init>= <expr><call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>fobj1</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>argtype2</name> <init>= <expr><call><name>findTypeByOid</name><argument_list>(<argument><expr><name><name>fobj2</name><operator>-&gt;</operator><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>argtype1</name> <operator>&amp;&amp;</operator> <name>argtype2</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>argtype1</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name> <operator>&amp;&amp;</operator> <name><name>argtype2</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argtype1</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
									<argument><expr><name><name>argtype2</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>namespace</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argtype1</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>argtype2</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_OPERATOR</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oobj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>OprInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OprInfo</name>    <modifier>*</modifier></type><name>oobj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>OprInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* oprkind is 'l', 'r', or 'b'; this sorts prefix, postfix, infix */</comment>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <operator>(</operator><name><name>oobj2</name><operator>-&gt;</operator><name>oprkind</name></name> <operator>-</operator> <name><name>oobj1</name><operator>-&gt;</operator><name>oprkind</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>obj1</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_ATTRDEF</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>adobj1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrDefInfo</name> <modifier>*</modifier></type><name>adobj2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <operator>(</operator><name><name>adobj1</name><operator>-&gt;</operator><name>adnum</name></name> <operator>-</operator> <name><name>adobj2</name><operator>-&gt;</operator><name>adnum</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cmpval</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Usually shouldn't get here, but if we do, sort by OID */</comment>
	<return>return <expr><call><name>oidcmp</name><argument_list>(<argument><expr><name><name>obj1</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>obj2</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sort the given objects into a safe dump order using dependency
 * information (to the extent we have it available).
 *
 * The DumpIds of the PRE_DATA_BOUNDARY and POST_DATA_BOUNDARY objects are
 * passed in separately, in case we need them during dependency loop repair.
 */</comment>
<function><type><name>void</name></type>
<name>sortDumpableObjects</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
					<parameter><decl><type><name>DumpId</name></type> <name>preBoundaryId</name></decl></parameter>, <parameter><decl><type><name>DumpId</name></type> <name>postBoundaryId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordering</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nOrdering</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* can't happen anymore ... */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Saving the boundary IDs in static variables is a bit grotty, but seems
	 * better than adding them to parameter lists of subsidiary functions.
	 */</comment>
	<expr_stmt><expr><name>preDataBoundId</name> <operator>=</operator> <name>preBoundaryId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>postDataBoundId</name> <operator>=</operator> <name>postBoundaryId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ordering</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numObjs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>!</operator><call><name>TopoSort</name><argument_list>(<argument><expr><name>objs</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>, <argument><expr><name>ordering</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nOrdering</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>findDependencyLoops</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>, <argument><expr><name>nOrdering</name></expr></argument>, <argument><expr><name>numObjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>objs</name></expr></argument>, <argument><expr><name>ordering</name></expr></argument>, <argument><expr><name>numObjs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TopoSort -- topological sort of a dump list
 *
 * Generate a re-ordering of the dump list that satisfies all the dependency
 * constraints shown in the dump list.  (Each such constraint is a fact of a
 * partial ordering.)  Minimize rearrangement of the list not needed to
 * achieve the partial ordering.
 *
 * The input is the list of numObjs objects in objs[].  This list is not
 * modified.
 *
 * Returns true if able to build an ordering that satisfies all the
 * constraints, false if not (there are contradictory constraints).
 *
 * On success (true result), ordering[] is filled with a sorted array of
 * DumpableObject pointers, of length equal to the input list length.
 *
 * On failure (false result), ordering[] is filled with an unsorted array of
 * DumpableObject pointers of length *nOrdering, listing the objects that
 * prevented the sort from being completed.  In general, these objects either
 * participate directly in a dependency cycle, or are depended on by objects
 * that are in a cycle.  (The latter objects are not actually problematic,
 * but it takes further analysis to identify which are which.)
 *
 * The caller is responsible for allocating sufficient space at *ordering.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TopoSort</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>numObjs</name></decl></parameter>,
		 <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordering</name></decl></parameter>, <comment type="block">/* output argument */</comment>
		 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nOrdering</name></decl></parameter>)</parameter_list>		<comment type="block">/* output argument */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>DumpId</name></type>		<name>maxDumpId</name> <init>= <expr><call><name>getMaxDumpId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>pendingHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>beforeConstraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>idMap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>heapLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is basically the same algorithm shown for topological sorting in
	 * Knuth's Volume 1.  However, we would like to minimize unnecessary
	 * rearrangement of the input ordering; that is, when we have a choice of
	 * which item to output next, we always want to take the one highest in
	 * the original list.  Therefore, instead of maintaining an unordered
	 * linked list of items-ready-to-output as Knuth does, we maintain a heap
	 * of their item numbers, which we can use as a priority queue.  This
	 * turns the algorithm from O(N) to O(N log N) because each insertion or
	 * removal of a heap item takes O(log N) time.  However, that's still
	 * plenty fast enough for this application.
	 */</comment>

	<expr_stmt><expr><operator>*</operator><name>nOrdering</name> <operator>=</operator> <name>numObjs</name></expr>;</expr_stmt>		<comment type="block">/* for success return */</comment>

	<comment type="block">/* Eliminate the null case */</comment>
	<if_stmt><if>if <condition>(<expr><name>numObjs</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create workspace for the above-described heap */</comment>
	<expr_stmt><expr><name>pendingHeap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>numObjs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the constraints, and for each item in the input, generate a count
	 * of the number of constraints that say it must be before something else.
	 * The count for the item with dumpId j is stored in beforeConstraints[j].
	 * We also make a map showing the input-order index of the item with
	 * dumpId j.
	 */</comment>
	<expr_stmt><expr><name>beforeConstraints</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>maxDumpId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>beforeConstraints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>maxDumpId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idMap</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>maxDumpId</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>objs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>&gt;</operator> <name>maxDumpId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"invalid dumpId %d\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>idMap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>obj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>k</name> <operator>&gt;</operator> <name>maxDumpId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"invalid dependency %d\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>beforeConstraints</name><index>[<expr><name>k</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now initialize the heap of items-ready-to-output by filling it with the
	 * indexes of items that already have beforeConstraints[id] == 0.
	 *
	 * The essential property of a heap is heap[(j-1)/2] &gt;= heap[j] for each j
	 * in the range 1..heapLength-1 (note we are using 0-based subscripts
	 * here, while the discussion in Knuth assumes 1-based subscripts). So, if
	 * we simply enter the indexes into pendingHeap[] in decreasing order, we
	 * a-fortiori have the heap invariant satisfied at completion of this
	 * loop, and don't need to do any sift-up comparisons.
	 */</comment>
	<expr_stmt><expr><name>heapLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numObjs</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>beforeConstraints</name><index>[<expr><name><name>objs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pendingHeap</name><index>[<expr><name>heapLength</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*--------------------
	 * Now emit objects, working backwards in the output list.  At each step,
	 * we use the priority heap to select the last item that has no remaining
	 * before-constraints.  We remove that item from the heap, output it to
	 * ordering[], and decrease the beforeConstraints count of each of the
	 * items it was constrained against.  Whenever an item's beforeConstraints
	 * count is thereby decreased to zero, we insert it into the priority heap
	 * to show that it is a candidate to output.  We are done when the heap
	 * becomes empty; if we have output every element then we succeeded,
	 * otherwise we failed.
	 * i = number of ordering[] entries left to output
	 * j = objs[] index of item we are outputting
	 * k = temp for scanning constraint list for item j
	 *--------------------
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>numObjs</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>heapLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Select object to output by removing largest heap member */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>removeHeapElement</name><argument_list>(<argument><expr><name>pendingHeap</name></expr></argument>, <argument><expr><name>heapLength</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>objs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Output candidate to ordering[] */</comment>
		<expr_stmt><expr><name><name>ordering</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

		<comment type="block">/* Update beforeConstraints counts of its predecessors */</comment>
		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>obj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>id</name> <init>= <expr><name><name>obj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>--</operator><name><name>beforeConstraints</name><index>[<expr><name>id</name></expr>]</index></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>addHeapElement</name><argument_list>(<argument><expr><name><name>idMap</name><index>[<expr><name>id</name></expr>]</index></name></expr></argument>, <argument><expr><name>pendingHeap</name></expr></argument>, <argument><expr><name>heapLength</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we failed, report the objects that couldn't be output; these are the
	 * ones with beforeConstraints[] still nonzero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>maxDumpId</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>beforeConstraints</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ordering</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>objs</name><index>[<expr><name><name>idMap</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><operator>*</operator><name>nOrdering</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Done */</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pendingHeap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>beforeConstraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>idMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an item to a heap (priority queue)
 *
 * heapLength is the current heap size; caller is responsible for increasing
 * its value after the call.  There must be sufficient storage at *heap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addHeapElement</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>heapLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sift-up the new entry, per Knuth 5.2.3 exercise 16. Note that Knuth is
	 * using 1-based array indexes, not 0-based.
	 */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <name>heapLength</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><operator>(</operator><name>j</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;=</operator> <name><name>heap</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>heap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the largest item present in a heap (priority queue)
 *
 * heapLength is the current heap size; caller is responsible for decreasing
 * its value after the call.
 *
 * We remove and return heap[0], which is always the largest element of
 * the heap, and then "sift up" to maintain the heap invariant.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>removeHeapElement</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>heapLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name> <init>= <expr><name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>--</operator><name>heapLength</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>heap</name><index>[<expr><name>heapLength</name></expr>]</index></name></expr>;</expr_stmt>		<comment type="block">/* value that must be reinserted */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>						<comment type="block">/* i is where the "hole" is */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>heapLength</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>heapLength</name> <operator>&amp;&amp;</operator>
			<name><name>heap</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <name><name>heap</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <name><name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>heap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findDependencyLoops - identify loops in TopoSort's failure output,
 *		and pass each such loop to repairDependencyLoop() for action
 *
 * In general there may be many loops in the set of objects returned by
 * TopoSort; for speed we should try to repair as many loops as we can
 * before trying TopoSort again.  We can safely repair loops that are
 * disjoint (have no members in common); if we find overlapping loops
 * then we repair only the first one found, because the action taken to
 * repair the first might have repaired the other as well.  (If not,
 * we'll fix it on the next go-round.)
 *
 * objs[] lists the objects TopoSort couldn't sort
 * nObjs is the number of such objects
 * totObjs is the total number of objects in the universe
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>findDependencyLoops</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>objs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nObjs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>totObjs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We use three data structures here:
	 *
	 * processed[] is a bool array indexed by dump ID, marking the objects
	 * already processed during this invocation of findDependencyLoops().
	 *
	 * searchFailed[] is another array indexed by dump ID.  searchFailed[j] is
	 * set to dump ID k if we have proven that there is no dependency path
	 * leading from object j back to start point k.  This allows us to skip
	 * useless searching when there are multiple dependency paths from k to j,
	 * which is a common situation.  We could use a simple bool array for
	 * this, but then we'd need to re-zero it for each start point, resulting
	 * in O(N^2) zeroing work.  Using the start point's dump ID as the "true"
	 * value lets us skip clearing the array before we consider the next start
	 * point.
	 *
	 * workspace[] is an array of DumpableObject pointers, in which we try to
	 * build lists of objects constituting loops.  We make workspace[] large
	 * enough to hold all the objects in TopoSort's output, which is huge
	 * overkill in most cases but could theoretically be necessary if there is
	 * a single dependency chain linking all the objects.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>processed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpId</name>	   <modifier>*</modifier></type><name>searchFailed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fixedloop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>processed</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>getMaxDumpId</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>searchFailed</name> <operator>=</operator> <operator>(</operator><name>DumpId</name> <operator>*</operator><operator>)</operator> <call><name>pg_malloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>getMaxDumpId</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>workspace</name> <operator>=</operator> <operator>(</operator><name>DumpableObject</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pg_malloc</name><argument_list>(<argument><expr><name>totObjs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpableObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fixedloop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nObjs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name><name>objs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>looplen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>looplen</name> <operator>=</operator> <call><name>findLoop</name><argument_list>(<argument><expr><name>obj</name></expr></argument>,
						   <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>,
						   <argument><expr><name>processed</name></expr></argument>,
						   <argument><expr><name>searchFailed</name></expr></argument>,
						   <argument><expr><name>workspace</name></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>looplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a loop, repair it */</comment>
			<expr_stmt><expr><call><name>repairDependencyLoop</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>looplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fixedloop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Mark loop members as processed */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>looplen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>processed</name><index>[<expr><name><name>workspace</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * There's no loop starting at this object, but mark it processed
			 * anyway.  This is not necessary for correctness, but saves later
			 * invocations of findLoop() from uselessly chasing references to
			 * such an object.
			 */</comment>
			<expr_stmt><expr><name><name>processed</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We'd better have fixed at least one loop */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fixedloop</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>exit_horribly</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"could not identify dependency loop\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>searchFailed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively search for a circular dependency loop that doesn't include
 * any already-processed objects.
 *
 *	obj: object we are examining now
 *	startPoint: dumpId of starting object for the hoped-for circular loop
 *	processed[]: flag array marking already-processed objects
 *	searchFailed[]: flag array marking already-unsuccessfully-visited objects
 *	workspace[]: work array in which we are building list of loop members
 *	depth: number of valid entries in workspace[] at call
 *
 * On success, the length of the loop is returned, and workspace[] is filled
 * with pointers to the members of the loop.  On failure, we return 0.
 *
 * Note: it is possible that the given starting object is a member of more
 * than one cycle; if so, we will find an arbitrary one of the cycles.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>findLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
		 <parameter><decl><type><name>DumpId</name></type> <name>startPoint</name></decl></parameter>,
		 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>processed</name></decl></parameter>,
		 <parameter><decl><type><name>DumpId</name> <modifier>*</modifier></type><name>searchFailed</name></decl></parameter>,
		 <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>workspace</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject if obj is already processed.  This test prevents us from finding
	 * loops that overlap previously-processed loops.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>processed</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we've already proven there is no path from this object back to the
	 * startPoint, forget it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>searchFailed</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>==</operator> <name>startPoint</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reject if obj is already present in workspace.  This test prevents us
	 * from going into infinite recursion if we are given a startPoint object
	 * that links to a cycle it's not a member of, and it guarantees that we
	 * can't overflow the allocated size of workspace[].
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>depth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workspace</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>obj</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Okay, tentatively add obj to workspace
	 */</comment>
	<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if we've found a loop back to the desired startPoint; if so, done
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>obj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>startPoint</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>depth</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Recurse down each outgoing branch
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>obj</name><operator>-&gt;</operator><name>nDeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>nextobj</name> <init>= <expr><call><name>findObjectByDumpId</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newDepth</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextobj</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore dependencies on undumped objects */</comment>
		<expr_stmt><expr><name>newDepth</name> <operator>=</operator> <call><name>findLoop</name><argument_list>(<argument><expr><name>nextobj</name></expr></argument>,
							<argument><expr><name>startPoint</name></expr></argument>,
							<argument><expr><name>processed</name></expr></argument>,
							<argument><expr><name>searchFailed</name></expr></argument>,
							<argument><expr><name>workspace</name></expr></argument>,
							<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>newDepth</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Remember there is no path from here back to startPoint
	 */</comment>
	<expr_stmt><expr><name><name>searchFailed</name><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr>]</index></name> <operator>=</operator> <name>startPoint</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A user-defined datatype will have a dependency loop with each of its
 * I/O functions (since those have the datatype as input or output).
 * Similarly, a range type will have a loop with its canonicalize function,
 * if any.  Break the loop by making the function depend on the associated
 * shell type, instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairTypeFuncLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>typeobj</name></decl></parameter>, <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>funcobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeInfo</name>   <modifier>*</modifier></type><name>typeInfo</name> <init>= <expr><operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name>typeobj</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* remove function's dependency on type */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>funcobj</name></expr></argument>, <argument><expr><name><name>typeobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add function's dependency on shell type, instead */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typeInfo</name><operator>-&gt;</operator><name>shellType</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>funcobj</name></expr></argument>, <argument><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>shellType</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark shell type (always including the definition, as we need the
		 * shell type defined to identify the function fully) as to be dumped
		 * if any such function is
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>funcobj</name><operator>-&gt;</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typeInfo</name><operator>-&gt;</operator><name>shellType</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>dump</name></name> <operator>=</operator> <name><name>funcobj</name><operator>-&gt;</operator><name>dump</name></name> <operator>|</operator>
				<name>DUMP_COMPONENT_DEFINITION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Because we force a view to depend on its ON SELECT rule, while there
 * will be an implicit dependency in the other direction, we need to break
 * the loop.  If there are no other objects in the loop then we can remove
 * the implicit dependency and leave the ON SELECT rule non-separate.
 * This applies to matviews, as well.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairViewRuleLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>viewobj</name></decl></parameter>,
				   <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>ruleobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove rule's dependency on view */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>ruleobj</name></expr></argument>, <argument><expr><name><name>viewobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* flags on the two objects are already set correctly for this case */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * However, if there are other objects in the loop, we must break the loop
 * by making the ON SELECT rule a separately-dumped object.
 *
 * Because findLoop() finds shorter cycles before longer ones, it's likely
 * that we will have previously fired repairViewRuleLoop() and removed the
 * rule's dependency on the view.  Put it back to ensure the rule won't be
 * emitted before the view.
 *
 * Note: this approach does *not* work for matviews, at the moment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairViewRuleMultiLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>viewobj</name></decl></parameter>,
						<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>ruleobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>viewinfo</name> <init>= <expr><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>viewobj</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleInfo</name>   <modifier>*</modifier></type><name>ruleinfo</name> <init>= <expr><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name>ruleobj</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* remove view's dependency on rule */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>viewobj</name></expr></argument>, <argument><expr><name><name>ruleobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mark view to be printed with a dummy definition */</comment>
	<expr_stmt><expr><name><name>viewinfo</name><operator>-&gt;</operator><name>dummy_view</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* mark rule as needing its own dump */</comment>
	<expr_stmt><expr><name><name>ruleinfo</name><operator>-&gt;</operator><name>separate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* put back rule's dependency on view */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>ruleobj</name></expr></argument>, <argument><expr><name><name>viewobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* now that rule is separate, it must be post-data */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>ruleobj</name></expr></argument>, <argument><expr><name>postDataBoundId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If a matview is involved in a multi-object loop, we can't currently fix
 * that by splitting off the rule.  As a stopgap, we try to fix it by
 * dropping the constraint that the matview be dumped in the pre-data section.
 * This is sufficient to handle cases where a matview depends on some unique
 * index, as can happen if it has a GROUP BY for example.
 *
 * Note that the "next object" is not necessarily the matview itself;
 * it could be the matview's rowtype, for example.  We may come through here
 * several times while removing all the pre-data linkages.  In particular,
 * if there are other matviews that depend on the one with the circularity
 * problem, we'll come through here for each such matview and mark them all
 * as postponed.  (This works because all MVs have pre-data dependencies
 * to begin with, so each of them will get visited.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairMatViewBoundaryMultiLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>boundaryobj</name></decl></parameter>,
							   <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>nextobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove boundary's dependency on object after it in loop */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>boundaryobj</name></expr></argument>, <argument><expr><name><name>nextobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if that object is a matview, mark it as postponed into post-data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nextobj</name><operator>-&gt;</operator><name>objType</name></name> <operator>==</operator> <name>DO_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableInfo</name>  <modifier>*</modifier></type><name>nextinfo</name> <init>= <expr><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name>nextobj</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>nextinfo</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nextinfo</name><operator>-&gt;</operator><name>postponed_def</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Because we make tables depend on their CHECK constraints, while there
 * will be an automatic dependency in the other direction, we need to break
 * the loop.  If there are no other objects in the loop then we can remove
 * the automatic dependency and leave the CHECK constraint non-separate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairTableConstraintLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>tableobj</name></decl></parameter>,
						  <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>constraintobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove constraint's dependency on table */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name><name>tableobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * However, if there are other objects in the loop, we must break the loop
 * by making the CHECK constraint a separately-dumped object.
 *
 * Because findLoop() finds shorter cycles before longer ones, it's likely
 * that we will have previously fired repairTableConstraintLoop() and
 * removed the constraint's dependency on the table.  Put it back to ensure
 * the constraint won't be emitted before the table...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairTableConstraintMultiLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>tableobj</name></decl></parameter>,
							   <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>constraintobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove table's dependency on constraint */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>, <argument><expr><name><name>constraintobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mark constraint as needing its own dump */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>constraintobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* put back constraint's dependency on table */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name><name>tableobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* now that constraint is separate, it must be post-data */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name>postDataBoundId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attribute defaults behave exactly the same as CHECK constraints...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairTableAttrDefLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>tableobj</name></decl></parameter>,
					   <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>attrdefobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove attrdef's dependency on table */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>attrdefobj</name></expr></argument>, <argument><expr><name><name>tableobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairTableAttrDefMultiLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>tableobj</name></decl></parameter>,
							<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>attrdefobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove table's dependency on attrdef */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>tableobj</name></expr></argument>, <argument><expr><name><name>attrdefobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mark attrdef as needing its own dump */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>attrdefobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* put back attrdef's dependency on table */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>attrdefobj</name></expr></argument>, <argument><expr><name><name>tableobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CHECK constraints on domains work just like those on tables ...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairDomainConstraintLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>domainobj</name></decl></parameter>,
						   <parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>constraintobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove constraint's dependency on domain */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name><name>domainobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairDomainConstraintMultiLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>domainobj</name></decl></parameter>,
								<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>constraintobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove domain's dependency on constraint */</comment>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>domainobj</name></expr></argument>, <argument><expr><name><name>constraintobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* mark constraint as needing its own dump */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name>constraintobj</name><operator>)</operator><operator>-&gt;</operator><name>separate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* put back constraint's dependency on domain */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name><name>domainobj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* now that constraint is separate, it must be post-data */</comment>
	<expr_stmt><expr><call><name>addObjectDependency</name><argument_list>(<argument><expr><name>constraintobj</name></expr></argument>, <argument><expr><name>postDataBoundId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairIndexLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>partedindex</name></decl></parameter>,
				<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>partindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name>partedindex</name></expr></argument>, <argument><expr><name><name>partindex</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fix a dependency loop, or die trying ...
 *
 * This routine is mainly concerned with reducing the multiple ways that
 * a loop might appear to common cases, which it passes off to the
 * "fixer" routines above.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repairDependencyLoop</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>loop</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>nLoop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Datatype and one of its I/O or canonicalize functions */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_FUNC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTypeFuncLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_FUNC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTypeFuncLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* View (including matview) and its ON SELECT rule */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_RULE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		 <operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>is_instead</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ruletable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairViewRuleLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_RULE</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		 <operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>is_instead</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ruletable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairViewRuleLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Indirect loop involving view (but not matview) and ON SELECT rule */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_RULE</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ev_type</name> <operator>==</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>is_instead</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>RuleInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>ruletable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>repairViewRuleMultiLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Indirect loop involving matview and data boundary */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_PRE_DATA_BOUNDARY</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>nextobj</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>nextobj</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>j</name> <operator>&lt;</operator> <name>nLoop</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>loop</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>repairMatViewBoundaryMultiLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>nextobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Table and CHECK constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTableConstraintLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTableConstraintLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Indirect loop involving table and CHECK constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>repairTableConstraintMultiLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Table and attribute default */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_ATTRDEF</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>adtable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTableAttrDefLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_ATTRDEF</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>adtable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairTableAttrDefLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* index on partitioned table and corresponding index on partition */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_INDEX</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>parentidx</name> <operator>==</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>catId</name><operator>.</operator><name>oid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>repairIndexLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>IndxInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>parentidx</name> <operator>==</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name><name>catId</name><operator>.</operator><name>oid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>repairIndexLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Indirect loop involving table and attribute default */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_ATTRDEF</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>adtable</name> <operator>==</operator> <operator>(</operator><name>TableInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>repairTableAttrDefMultiLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Domain and CHECK constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>condomain</name> <operator>==</operator> <operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairDomainConstraintLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>condomain</name> <operator>==</operator> <operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>repairDomainConstraintLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Indirect loop involving domain and CHECK constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_TYPE</name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>==</operator> <name>DO_CONSTRAINT</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <literal type="char">'c'</literal> <operator>&amp;&amp;</operator>
						<operator>(</operator><operator>(</operator><name>ConstraintInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>condomain</name> <operator>==</operator> <operator>(</operator><name>TypeInfo</name> <operator>*</operator><operator>)</operator> <name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>repairDomainConstraintMultiLoop</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If all the objects are TABLE_DATA items, what we must have is a
	 * circular set of foreign key constraints (or a single self-referential
	 * table).  Print an appropriate complaint and break the loop arbitrarily.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>objType</name> <operator>!=</operator> <name>DO_TABLE_DATA</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nLoop</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"NOTICE: there are circular foreign-key constraints on this table:\n"</literal></expr></argument>,
								 <argument><expr><literal type="string">"NOTICE: there are circular foreign-key constraints among these tables:\n"</literal></expr></argument>,
								 <argument><expr><name>nLoop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"  %s\n"</literal></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"You might not be able to restore the dump without using --disable-triggers or temporarily dropping the constraints.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Consider using a full dump instead of a --data-only dump to avoid this problem.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* must be a self-dependency */</comment>
			<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we can't find a principled way to break the loop, complain and break
	 * it in an arbitrary fashion.
	 */</comment>
	<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"WARNING: could not resolve dependency loop among these items:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nLoop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>describeDumpableObject</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_msg</name><argument_list>(<argument><expr><name>modulename</name></expr></argument>, <argument><expr><literal type="string">"  %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nLoop</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* must be a self-dependency */</comment>
		<expr_stmt><expr><call><name>removeObjectDependency</name><argument_list>(<argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>loop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dumpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Describe a dumpable object usefully for errors
 *
 * This should probably go somewhere else...
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>describeDumpableObject</name><parameter_list>(<parameter><decl><type><name>DumpableObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>objType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DO_NAMESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"SCHEMA %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_EXTENSION</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"EXTENSION %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TYPE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_SHELL_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"SHELL TYPE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_FUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"FUNCTION %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_AGG</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"AGGREGATE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_OPERATOR</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"OPERATOR %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_ACCESS_METHOD</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"ACCESS METHOD %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_OPCLASS</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"OPERATOR CLASS %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_OPFAMILY</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"OPERATOR FAMILY %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_COLLATION</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"COLLATION %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_CONVERSION</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"CONVERSION %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TABLE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					<argument><expr><literal type="string">"TABLEGROUP %s  (ID %d OID %u)"</literal></expr></argument>,
					<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_ATTRDEF</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"ATTRDEF %s.%s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>adtable</name><operator>-&gt;</operator><name>dobj</name><operator>.</operator><name>name</name></name></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>adtable</name><operator>-&gt;</operator><name>attnames</name><index>[<expr><operator>(</operator><operator>(</operator><name>AttrDefInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name>adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"INDEX %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_INDEX_ATTACH</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"INDEX ATTACH %s  (ID %d)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_STATSEXT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"STATISTICS %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_REFRESH_MATVIEW</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"REFRESH MATERIALIZED VIEW %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_RULE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"RULE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TRIGGER %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"EVENT TRIGGER %s (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"CONSTRAINT %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_FK_CONSTRAINT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"FK CONSTRAINT %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_PROCLANG</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"PROCEDURAL LANGUAGE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_CAST</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"CAST %u to %u  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>CastInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name>castsource</name></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>CastInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name>casttarget</name></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TRANSFORM %u lang %u  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>TransformInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name>trftype</name></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator><name>TransformInfo</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name>trflang</name></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TABLE_DATA</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TABLE DATA %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_SEQUENCE_SET</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"SEQUENCE SET %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_DUMMY_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"DUMMY TYPE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TSPARSER</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TEXT SEARCH PARSER %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TSDICT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TEXT SEARCH DICTIONARY %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TSTEMPLATE</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TEXT SEARCH TEMPLATE %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_TSCONFIG</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"TEXT SEARCH CONFIGURATION %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_FDW</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"FOREIGN DATA WRAPPER %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"FOREIGN SERVER %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_DEFAULT_ACL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"DEFAULT ACL %s  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_BLOB</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"BLOB  (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_BLOB_DATA</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"BLOB DATA  (ID %d)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_POLICY</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"POLICY (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_PUBLICATION</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"PUBLICATION (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_PUBLICATION_REL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"PUBLICATION TABLE (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_SUBSCRIPTION</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"SUBSCRIPTION (ID %d OID %u)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_PRE_DATA_BOUNDARY</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"PRE-DATA BOUNDARY  (ID %d)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><name>DO_POST_DATA_BOUNDARY</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
					 <argument><expr><literal type="string">"POST-DATA BOUNDARY  (ID %d)"</literal></expr></argument>,
					 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>
	<comment type="block">/* shouldn't get here */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
			 <argument><expr><literal type="string">"object type %d  (ID %d OID %u)"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>obj</name><operator>-&gt;</operator><name>objType</name></name></expr></argument>,
			 <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>dumpId</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>catId</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
