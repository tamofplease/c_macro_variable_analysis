<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/partitioning/partbounds.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partbounds.c
 *		Support routines for manipulating partition bounds
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		  src/backend/partitioning/partbounds.c
 *
 *-------------------------------------------------------------------------
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partprune.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hashutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_partition_bound_num_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
					   <parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>,
					   <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
						 <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
						 <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * get_qual_from_partbound
 *		Given a parser node for partition bound, return the list of executable
 *		expressions as partition constraint
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_qual_from_partbound</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>my_qual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_hash</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>my_qual</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Are two partition bound collections logically equal?
 *
 * Used in the keep logic of relcache.c (ie, in RelationClearRelation()).
 * This is also useful when b1 and b2 are bound collections of two separate
 * relations, respectively, because PartitionBoundInfo is a canonical
 * representation of partition bounds.
 */</comment>
<function><type><name>bool</name></type>
<name>partition_bounds_equal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>parttyplen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>parttypbyval</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b1</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>null_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>null_index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>default_index</name></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>default_index</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name> <init>= <expr><call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If two hash partitioned tables have different greatest moduli,
		 * their partition schemes don't match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>greatest_modulus</name> <operator>!=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We arrange the partitions in the ascending order of their moduli
		 * and remainders.  Also every modulus is factor of next larger
		 * modulus.  Therefore we can safely store index of a given partition
		 * in indexes array at remainder of that partition.  Also entries at
		 * (remainder + N * modulus) positions in indexes array are all same
		 * for (modulus, remainder) specification for any partition.  Thus
		 * datums array from both the given bounds are same, if and only if
		 * their indexes array will be same.  So, it suffices to compare
		 * indexes array.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

		<comment type="block">/*
		 * Nonetheless make sure that the bounds are indeed same when the
		 * indexes match.  Hash partition bound stores modulus and remainder
		 * at b1-&gt;datums[i][0] and b1-&gt;datums[i][1] position respectively.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
					<name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>b1</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* For range partitions, the bounds might not be finite. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* The different kinds of bound all differ from each other */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Non-finite bounds are equal without further
					 * examination.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Compare the actual values. Note that it would be both
				 * incorrect and unsafe to invoke the comparison operator
				 * derived from the partitioning specification here.  It would
				 * be incorrect because we want the relcache entry to be
				 * updated for ANY change to the partition bounds, not just
				 * those that the partitioning operator thinks are
				 * significant.  It would be unsafe because we might reach
				 * this code in the context of an aborted transaction, and an
				 * arbitrary partitioning operator might not be safe in that
				 * context.  datumIsEqual() should be simple enough to be
				 * safe.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* There are ndatums+1 indexes in case of range partitions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>b1</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
			<name><name>b1</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b2</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a copy of given PartitionBoundInfo structure. The data types of bounds
 * are described by given partition key specification.
 */</comment>
<function><type><name>PartitionBoundInfo</name></type>
<name>partition_bounds_copy</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>src</name></decl></parameter>,
					  <parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfo</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partnatts</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <call><name>get_partition_bound_num_indexes</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* List partitioned tables have only a single partition key. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>||</operator> <name>partnatts</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
														 <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>partnatts</name> <operator>*</operator>
															   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For a corresponding to hash partition, datums array will have two
		 * elements - modulus and remainder.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hash_part</name> <init>= <expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><ternary><condition><expr><name>hash_part</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><name>partnatts</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>byval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>hash_part</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>typlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt> <comment type="block">/* Always int4 */</comment>
				<expr_stmt><expr><name>byval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* int4 is pass-by-value */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>byval</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name><name>dest</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>byval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>indexes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>default_index</name></name></expr>;</expr_stmt>

	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_new_partition_bound
 *
 * Checks if the new partition's bound overlaps any of the existing partitions
 * of parent.  Also performs additional checks as necessary per strategy.
 */</comment>
<function><type><name>void</name></type>
<name>check_new_partition_bound</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						  <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>partdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>partdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>with</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>overlap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The default partition bound never conflicts with any other
		 * partition's; if that's what we're attaching, the only possible
		 * problem is that one already exists, so check for that and we're
		 * done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>boundinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Default partition already exists, error out. */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" conflicts with existing default partition \"%s\""</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Datum</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>datums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>valid_modulus</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>prev_modulus</name></decl>,	<comment type="block">/* Previous largest modulus */</comment>
								<decl><type ref="prev"/><name>next_modulus</name></decl>;</decl_stmt>	<comment type="block">/* Next largest modulus */</comment>

					<comment type="block">/*
					 * Check rule that every modulus must be a factor of the
					 * next larger modulus.  For example, if you have a bunch
					 * of partitions that all have modulus 5, you can add a
					 * new partition with modulus 10 or a new partition with
					 * modulus 15, but you cannot add both a partition with
					 * modulus 10 and a partition with modulus 15, because 10
					 * is not a factor of 15.
					 *
					 * Get the greatest (modulus, remainder) pair contained in
					 * boundinfo-&gt;datums that is less than or equal to the
					 * (spec-&gt;modulus, spec-&gt;remainder) pair.
					 */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_hash_bsearch</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>,
													<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>prev_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>%</operator> <name>prev_modulus</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>valid_modulus</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>ndatums</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>next_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>valid_modulus</name> <operator>=</operator> <operator>(</operator><name>next_modulus</name> <operator>%</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every hash partition modulus must be a factor of the next larger modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>greatest_modulus</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Normally, the lowest remainder that could conflict with
					 * the new partition is equal to the remainder specified
					 * for the new partition, but when the new partition has a
					 * modulus higher than any used so far, we need to adjust.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>greatest_modulus</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name>remainder</name> <operator>%</operator> <name>greatest_modulus</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Check every potentially-conflicting remainder. */</comment>
					<do>do
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
					</block_content>}</block> while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>;</do>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
						   <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_list_bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
															<argument><expr><name>boundinfo</name></expr></argument>,
															<argument><expr><name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * First check if the resulting range would be empty with
				 * specified lower and upper bounds
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
										 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>,
										 <argument><expr><name><name>lower</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty range bound specified for partition \"%s\""</literal></expr></argument>,
									<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Specified lower bound %s is greater than or equal to upper bound %s."</literal></expr></argument>,
									   <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partdesc</name><operator>-&gt;</operator><name>nparts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>equal</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>boundinfo</name> <operator>&amp;&amp;</operator>
						   <name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name> <operator>&amp;&amp;</operator>
						   <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>partition_bound_has_default</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Test whether the new lower bound (which is treated
					 * inclusively as part of the new partition) lies inside
					 * an existing partition, or in a gap.
					 *
					 * If it's inside an existing partition, the bound at
					 * offset + 1 will be the upper bound of that partition,
					 * and its index will be &gt;= 0.
					 *
					 * If it's in a gap, the bound at offset + 1 will be the
					 * lower bound of the next partition, and its index will
					 * be -1. This is also true if there is no next partition,
					 * since the index array is initialised with an extra -1
					 * at the end.
					 */</comment>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>partition_range_bsearch</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
													 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
													 <argument><expr><name>boundinfo</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Check that the new partition will fit in the gap.
						 * For it to fit, the new upper bound must be less
						 * than or equal to the lower bound of the next
						 * partition, if there is one.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>is_lower</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>datums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>kind</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
							<expr_stmt><expr><name>is_lower</name> <operator>=</operator> <operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

							<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
														  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>,
														  <argument><expr><name>datums</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
														  <argument><expr><name>is_lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * The new partition overlaps with the
								 * existing partition between offset + 1 and
								 * offset + 2.
								 */</comment>
								<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * The new partition overlaps with the existing
						 * partition between offset and offset + 1.
						 */</comment>
						<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>with</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>overlap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>with</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition \"%s\" would overlap partition \"%s\""</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>partdesc</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name>with</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_default_partition_contents
 *
 * This function checks if there exists a row in the default partition that
 * would properly belong to the new partition being added.  If it finds one,
 * it throws an error.
 */</comment>
<function><type><name>void</name></type>
<name>check_default_partition_contents</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>default_rel</name></decl></parameter>,
								 <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>new_spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>def_part_constraints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>all_parts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>new_part_constraints</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>new_spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name><operator>)</operator></expr>
		?</condition><then> <expr><call><name>get_qual_for_list</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>new_spec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>def_part_constraints</name> <operator>=</operator>
		<call><name>get_proposed_default_constraint</name><argument_list>(<argument><expr><name>new_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the existing constraints on the default partition imply that it will
	 * not contain any row that would belong to the new partition, we can
	 * avoid scanning the default partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>, <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the default partition and its subpartitions, and check for rows
	 * that do not satisfy the revised partition constraints.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>default_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>all_parts</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>all_parts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>part_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>part_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>partition_constraint</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>partqualstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupslot</name></decl>;</decl_stmt>

		<comment type="block">/* Lock already taken above. */</comment>
		<if_stmt><if>if <condition>(<expr><name>part_relid</name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>part_relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the partition constraints on default partition child imply
			 * that it will not contain any row that would belong to the new
			 * partition, we can avoid scanning the child table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PartConstraintImpliedByRelConstraint</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>,
													 <argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" is implied by existing constraints"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>part_rel</name> <operator>=</operator> <name>default_rel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Only RELKIND_RELATION relations (i.e. leaf partitions) need to be
		 * scanned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>part_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipped scanning foreign table \"%s\" which is a partition of default partition \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>def_part_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partition_constraint</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>map_partition_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>constr</name></expr></argument>,
									<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build expression execution states for partition check quals */</comment>
		<expr_stmt><expr><name>partqualstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>partition_constraint</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to per-tuple memory context and reset it for each tuple
		 * produced, so we don't leak memory.
		 */</comment>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupslot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>tupslot</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheck</name><argument_list>(<argument><expr><name>partqualstate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHECK_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"updated partition constraint for default partition \"%s\" would be violated by some row"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>default_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>part_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* keep the lock until commit */</comment>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_hash_partition_greatest_modulus
 *
 * Returns the greatest modulus of the hash partition bound. The greatest
 * modulus will be at the end of the datums array because hash partitions are
 * arranged in the ascending order of their moduli and remainders.
 */</comment>
<function><type><name>int</name></type>
<name>get_hash_partition_greatest_modulus</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bound</name> <operator>&amp;&amp;</operator> <name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name></name> <operator>&amp;&amp;</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_one_partition_rbound
 *
 * Return a PartitionRangeBound given a list of PartitionRangeDatum elements
 * and a flag telling whether the bound is lower or not.  Made into a function
 * because there are multiple sites that want to use this facility.
 */</comment>
<function><type><name>PartitionRangeBound</name> <modifier>*</modifier></type>
<name>make_one_partition_rbound</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datums</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lower</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>datums</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bound</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
													  <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>datums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>datum</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* What's contained in this range datum? */</comment>
		<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>datum</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound datum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>bound</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>bound</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_cmp
 *
 * Return for two range bounds whether the 1st one (specified in datums1,
 * kind1, and lower1) is &lt;, =, or &gt; the bound specified in *b2.
 *
 * partnatts, partsupfunc and partcollation give the number of attributes in the
 * bounds to be compared, comparison function to be used and the collations of
 * attributes, respectively.
 *
 * Note that if the values of the two range bounds compare equal, then we take
 * into account whether they are upper or lower bounds, and an upper bound is
 * considered to be smaller than a lower bound. This is important to the way
 * that RelationBuildPartitionDesc() builds the PartitionBoundInfoData
 * structure, which only stores the upper bound of a common boundary between
 * two contiguous partitions.
 */</comment>
<function><type><name>int32</name></type>
<name>partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datums1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind1</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>lower1</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* placate compiler */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datums2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>datums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>kind2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>kind</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lower2</name> <init>= <expr><name><name>b2</name><operator>-&gt;</operator><name>lower</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * First, handle cases where the column is unbounded, which should not
		 * invoke the comparison procedure, and should not consider any later
		 * columns. Note that the PartitionRangeDatumKind enum elements
		 * compare the same way as the values they represent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>kind2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>kind1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

			<comment type="block">/*
			 * The column bounds are both MINVALUE or both MAXVALUE. No later
			 * columns should be considered, but we still need to compare
			 * whether they are upper or lower bounds.
			 */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>datums1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>datums2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the comparison is anything other than equal, we're done. If they
	 * compare equal though, we still have to consider whether the boundaries
	 * are inclusive or exclusive.  Exclusive one is considered smaller of the
	 * two.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lower1</name> <operator>!=</operator> <name>lower2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <ternary><condition><expr><name>lower1</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_rbound_datum_cmp
 *
 * Return whether range bound (specified in rb_datums, rb_kind, and rb_lower)
 * is &lt;, =, or &gt; partition key of tuple (tuple_datums)
 *
 * n_tuple_datums, partsupfunc and partcollation give number of attributes in
 * the bounds to be compared, comparison function to be used and the collations
 * of attributes resp.
 *
 */</comment>
<function><type><name>int32</name></type>
<name>partition_rbound_datum_cmp</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>rb_datums</name></decl></parameter>, <parameter><decl><type><name>PartitionRangeDatumKind</name> <modifier>*</modifier></type><name>rb_kind</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>tuple_datums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_tuple_datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_tuple_datums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rb_kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>rb_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>tuple_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>cmpval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hbound_cmp
 *
 * Compares modulus first, then remainder if modulus is equal.
 */</comment>
<function><type><name>int32</name></type>
<name>partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>modulus1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modulus2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&lt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>&gt;</operator> <name>modulus2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>modulus1</name> <operator>==</operator> <name>modulus2</name> <operator>&amp;&amp;</operator> <name>remainder1</name> <operator>!=</operator> <name>remainder2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>remainder1</name> <operator>&gt;</operator> <name>remainder2</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_list_bsearch
 *		Returns the index of the greatest bound datum that is less than equal
 * 		to the given value or -1 if all of the bound datums are greater
 *
 * *is_equal is set to true if the bound datum at the returned index is equal
 * to the input value.
 */</comment>
<function><type><name>int</name></type>
<name>partition_list_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
					   <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given range bound or -1 if all of the range bounds are
 *		greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input range bound
 */</comment>
<function><type><name>int</name></type>
<name>partition_range_bsearch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
						<parameter><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>probe</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>,
									  <argument><expr><name>partcollation</name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
									  <argument><expr><operator>(</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>mid</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,
									  <argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_range_bsearch
 *		Returns the index of the greatest range bound that is less than or
 *		equal to the given tuple or -1 if all of the range bounds are greater
 *
 * *is_equal is set to true if the range bound at the returned index is equal
 * to the input tuple.
 */</comment>
<function><type><name>int</name></type>
<name>partition_range_datum_bsearch</name><parameter_list>(<parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>,
							  <parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_rbound_datum_cmp</name><argument_list>(<argument><expr><name>partsupfunc</name></expr></argument>,
											<argument><expr><name>partcollation</name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>,
											<argument><expr><name>values</name></expr></argument>,
											<argument><expr><name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>is_equal</name> <operator>=</operator> <operator>(</operator><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_equal</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * partition_hash_bsearch
 *		Returns the index of the greatest (modulus, remainder) pair that is
 *		less than or equal to the given (modulus, remainder) pair or -1 if
 *		all of them are greater
 */</comment>
<function><type><name>int</name></type>
<name>partition_hash_bsearch</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>modulus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>remainder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lo</name></decl>,
				<decl><type ref="prev"/><name>hi</name></decl>,
				<decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>hi</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>cmpval</name></decl>,
					<decl><type ref="prev"/><name>bound_modulus</name></decl>,
					<decl><type ref="prev"/><name>bound_remainder</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_modulus</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bound_remainder</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>mid</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name>bound_modulus</name></expr></argument>, <argument><expr><name>bound_remainder</name></expr></argument>,
									  <argument><expr><name>modulus</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmpval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>lo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_bound_num_indexes
 *
 * Returns the number of the entries in the partition bound indexes array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_partition_bound_num_indexes</name><parameter_list>(<parameter><decl><type><name>PartitionBoundInfo</name></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>

			<comment type="block">/*
			 * The number of the entries in the indexes array is same as the
			 * greatest modulus.
			 */</comment>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <call><name>get_hash_partition_greatest_modulus</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<comment type="block">/* Range partitioned table has an extra index. */</comment>
			<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <name><name>bound</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bound</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>num_indexes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_operator
 *
 * Return oid of the operator of the given strategy for the given partition
 * key column.  It is assumed that the partitioning key is of the same type as
 * the chosen partitioning opclass, or at least binary-compatible.  In the
 * latter case, *need_relabel is set to true if the opclass is not of a
 * polymorphic type (indicating a RelabelType node needed on top), otherwise
 * false.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_partition_operator</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_relabel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the operator in the partitioning opfamily using the opclass'
	 * declared input type as both left- and righttype.
	 */</comment>
	<expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in partition opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>,
			 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the partition key column is not of the same type as the operator
	 * class and not polymorphic, tell caller to wrap the non-Const expression
	 * in a RelabelType.  This matches what parse_coerce.c does.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>need_relabel</name> <operator>=</operator> <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>col</name></expr>]</index></name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name> <operator>&amp;&amp;</operator>
					 <name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name> <operator>!=</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>col</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>operoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_partition_op_expr
 *		Returns an Expr for the given partition key column with arg1 and
 *		arg2 as its leftop and rightop, respectively
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>make_partition_op_expr</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
					   <parameter><decl><type><name>uint16</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_relabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the correct btree operator for this partitioning column */</comment>
	<expr_stmt><expr><name>operoid</name> <operator>=</operator> <call><name>get_partition_operator</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keynum</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need_relabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Chosen operator may be such that the non-Const operand needs to be
	 * coerced, so apply the same; see the comment in
	 * get_partition_operator().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>need_relabel</name> <operator>||</operator>
		 <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>,
										<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Generate the actual expression */</comment>
	<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elems</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>elems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>keynum</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrexpr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saopexpr</name></decl>;</decl_stmt>

					<comment type="block">/* Construct an ArrayExpr for the right-hand inputs */</comment>
					<expr_stmt><expr><name>arrexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator>
						<call><name>get_array_type</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>array_collid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>elems</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>arrexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<comment type="block">/* Build leftop = ANY (rightop) */</comment>
					<expr_stmt><expr><name>saopexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name>operoid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>useOr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arrexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>saopexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>saopexpr</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>elems</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>,
								   <decl><type ref="prev"><modifier>*</modifier></type><name>elemop</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>elemop</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>,
											   <argument><expr><name>BOOLOID</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>,
											   <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>,
											   <argument><expr><name>InvalidOid</name></expr></argument>,
											   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>elemops</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elemops</name></expr></argument>, <argument><expr><name>elemop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>elemops</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>elemops</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operoid</name></expr></argument>,
								   <argument><expr><name>BOOLOID</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid partitioning strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_hash
 *
 * Returns a CHECK constraint expression to use as a hash partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * The partition constraint for a hash partition is always a call to the
 * built-in function satisfies_hash_partition().
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_hash</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>relidConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>modulusConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>remainderConst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Fixed arguments. */</comment>
	<expr_stmt><expr><name>relidConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									<argument><expr><name>InvalidOid</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>modulusConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>InvalidOid</name></expr></argument>,
									  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
									  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>remainderConst</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>relidConst</name></expr></argument>, <argument><expr><name>modulusConst</name></expr></argument>, <argument><expr><name>remainderConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add an argument for each key column. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<comment type="block">/* Left operand */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>keyCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_SATISFIES_HASH_PARTITION</name></expr></argument>,
						 <argument><expr><name>BOOLOID</name></expr></argument>,
						 <argument><expr><name>args</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_list
 *
 * Returns an implicit-AND list of expressions to use as a list partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * The function returns NIL for a default partition when it's the only
 * partition since in that case there is no constraint.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_list</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>opexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>list_has_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only single-column list partitioning is supported, so we are worried
	 * only about the partition key with index 0.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct Var or expression representing the partition column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For default list partition, collect datums for all the partitions. The
	 * default partition constraint should check that the partition key is
	 * equal to none of those.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>boundinfo</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>boundinfo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>partition_bound_accepts_nulls</name><argument_list>(<argument><expr><name>boundinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If default is the only partition, there need not be any partition
		 * constraint on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ndatums</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>list_has_null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Construct Const from known-not-null datum.  We must be careful
			 * to copy the value, because our result has to be able to outlive
			 * the relcache entry we're copying from.
			 */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							<argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><operator>*</operator><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* isnull */</comment>
							<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Create list of Consts for the allowed values, excluding any nulls.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>list_has_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>elems</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Generate the operator expression from the non-null partition
		 * values.
		 */</comment>
		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
										<argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If there are no partition values, we don't need an operator
		 * expression.
		 */</comment>
		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list_has_null</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Gin up a "col IS NOT NULL" test that will be AND'd with the main
		 * expression.  This might seem redundant, but the partition routing
		 * machinery needs it.
		 */</comment>
		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>opexpr</name></expr> ?</condition><then> <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Gin up a "col IS NULL" test that will be OR'd with the main
		 * expression.
		 */</comment>
		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>opexpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>or</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>or</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>, <argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note that, in general, applying NOT to a constraint expression doesn't
	 * necessarily invert the set of rows it accepts, because NOT (NULL) is
	 * NULL.  However, the partition constraints we construct here never
	 * evaluate to NULL, so applying NOT works as intended.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_qual_for_range
 *
 * Returns an implicit-AND list of expressions to use as a range partition's
 * constraint, given the parent relation and partition bound structure.
 *
 * For a multi-column range partition key, say (a, b, c), with (al, bl, cl)
 * as the lower bound tuple and (au, bu, cu) as the upper bound tuple, we
 * generate an expression tree of the following form:
 *
 *	(a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *		AND
 *	(a &gt; al OR (a = al AND b &gt; bl) OR (a = al AND b = bl AND c &gt;= cl))
 *		AND
 *	(a &lt; au OR (a = au AND b &lt; bu) OR (a = au AND b = bu AND c &lt; cu))
 *
 * It is often the case that a prefix of lower and upper bound tuples contains
 * the same values, for example, (al = au), in which case, we will emit an
 * expression tree of the following form:
 *
 *	(a IS NOT NULL) and (b IS NOT NULL) and (c IS NOT NULL)
 *		AND
 *	(a = al)
 *		AND
 *	(b &gt; bl OR (b = bl AND c &gt;= cl))
 *		AND
 *	(b &lt; bu) OR (b = bu AND c &lt; cu))
 *
 * If a bound datum is either MINVALUE or MAXVALUE, these expressions are
 * simplified using the fact that any value is greater than MINVALUE and less
 * than MAXVALUE. So, for example, if cu = MAXVALUE, c &lt; cu is automatically
 * true, and we need not emit any expression for it, and the last line becomes
 *
 *	(b &lt; bu) OR (b = bu), which is simplified to (b &lt;= bu)
 *
 * In most common cases with only one partition column, say a, the following
 * expression tree will be generated: a IS NOT NULL AND a &gt;= al AND a &lt; au
 *
 * For default partition, it returns the negation of the constraints of all
 * the other partitions.
 *
 * External callers should pass for_default as false; we set it to true only
 * when recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_qual_for_range</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>for_default</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>cell2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>partexprs_item_saved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>udatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>lower_val</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lower_or_arms</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_or_arms</name></decl>,
				<decl><type ref="prev"/><name>current_or_arm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lower_or_start_datum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_start_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_next_lower_arm</name></decl>,
				<decl><type ref="prev"/><name>need_next_upper_arm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>or_expr_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>pdesc</name> <init>= <expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>inhoids</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>oids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nparts</name> <init>= <expr><name><name>pdesc</name><operator>-&gt;</operator><name>nparts</name></name></expr></init></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>inhrelid</name> <init>= <expr><name><name>inhoids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bspec</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null relpartbound for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>bspec</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator>
				<call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected PartitionBoundSpec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bspec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>part_qual</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>part_qual</name> <operator>=</operator> <call><name>get_qual_for_range</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bspec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * AND the constraints of the partition and add to
				 * or_expr_args
				 */</comment>
				<expr_stmt><expr><name>or_expr_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									   ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>part_qual</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									   </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>part_qual</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>or_expr_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>other_parts_constr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Combine the constraints obtained for non-default partitions
			 * using OR.  As requested, each of the OR's args doesn't include
			 * the NOT NULL test for partition keys (which is to avoid its
			 * useless repetition).  Add the same now.
			 */</comment>
			<expr_stmt><expr><name>other_parts_constr</name> <operator>=</operator>
				<call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>,
							 <argument><expr><call><name>lappend</name><argument_list>(<argument><expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>or_expr_args</name></expr></argument>,
													<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>or_expr_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Finally, the default partition contains everything *NOT*
			 * contained in the non-default partitions.
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>other_parts_constr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it is the recursive call for default, we skip the get_range_nulltest
	 * to avoid accumulating the NullTest on the same keys for each partition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>for_default</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Iterate over the key columns and check if the corresponding lower and
	 * upper datums are equal using the btree equality operator for the
	 * column's type.  If equal, we emit single keyCol = common_value
	 * expression.  Starting from the first column for which the corresponding
	 * lower and upper bound datums are not equal, we generate OR expressions
	 * as shown in the function's header comment.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>	<comment type="block">/* placate compiler */</comment>
	<macro><name>forboth</name><argument_list>(<argument>cell1</argument>, <argument>spec-&gt;lowerdatums</argument>, <argument>cell2</argument>, <argument>spec-&gt;upperdatums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>test_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>test_exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>test_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since get_range_key_properties() modifies partexprs_item, and we
		 * might need to start over from the previous expression in the later
		 * part of this function, save away the current value.
		 */</comment>
		<expr_stmt><expr><name>partexprs_item_saved</name> <operator>=</operator> <name>partexprs_item</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If either value is NULL, the corresponding partition bound is
		 * either MINVALUE or MAXVALUE, and we treat them as unequal, because
		 * even if they're the same, there is no common value to equate the
		 * key column with.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>upper_val</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Create the test expression */</comment>
		<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_expr</name> <operator>=</operator> <call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>test_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_exprstate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>test_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>test_result</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>test_exprstate</name></expr></argument>,
												<argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If not equal, go generate the OR expressions */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The bounds for the last key column can't be equal, because such a
		 * range partition would never be allowed to be defined (it would have
		 * an empty range otherwise).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid range bound specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Equal, so generate keyCol = lower_val expression */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
												<argument><expr><name>keyCol</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* First pair of lower_val and upper_val that are not equal. */</comment>
	<expr_stmt><expr><name>lower_or_start_datum</name> <operator>=</operator> <name>cell1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_or_start_datum</name> <operator>=</operator> <name>cell2</name></expr>;</expr_stmt>

	<comment type="block">/* OR will have as many arms as there are key columns left. */</comment>
	<expr_stmt><expr><name>num_or_arms</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_or_arm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <name>upper_or_arms</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>need_next_upper_arm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>current_or_arm</name> <operator>&lt;</operator> <name>num_or_arms</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>lower_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>upper_or_arm_args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Restart scan of columns from the i'th one */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <name>partexprs_item_saved</name></expr>;</expr_stmt>

		<macro><name>for_both_cell</name><argument_list>(<argument>cell1</argument>, <argument>lower_or_start_datum</argument>, <argument>cell2</argument>, <argument>upper_or_start_datum</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>udatum_next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ldatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
									   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>udatum</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>udatum_next</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>,
									   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_range_key_properties</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>ldatum</name></expr></argument>, <argument><expr><name>udatum</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>partexprs_item</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>keyCol</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>lower_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <name>lower_val</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>strategy</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For the non-last columns of this arm, use the EQ operator.
				 * For the last column of this arm, use GT, unless this is the
				 * last column of the whole bound check, or the next bound
				 * datum is MINVALUE, in which case use GE.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator>
						 <operator>(</operator><name>ldatum_next</name> <operator>&amp;&amp;</operator>
						  <name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>lower_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>,
											<argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
																   <argument><expr><name>strategy</name></expr></argument>,
																   <argument><expr><name>keyCol</name></expr></argument>,
																   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lower_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>need_next_upper_arm</name> <operator>&amp;&amp;</operator> <name>upper_val</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint16</name></type>		<name>strategy</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * For the non-last columns of this arm, use the EQ operator.
				 * For the last column of this arm, use LT, unless the next
				 * bound datum is MAXVALUE, in which case use LE.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name>current_or_arm</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>udatum_next</name> <operator>&amp;&amp;</operator>
						 <name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>strategy</name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><name>upper_or_arm_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>,
											<argument><expr><call><name>make_partition_op_expr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
																   <argument><expr><name>strategy</name></expr></argument>,
																   <argument><expr><name>keyCol</name></expr></argument>,
																   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>upper_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Did we generate enough of OR's arguments?  First arm considers
			 * the first of the remaining columns, second arm considers first
			 * two of the remaining columns, and so on.
			 */</comment>
			<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&gt;</operator> <name>current_or_arm</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We must not emit any more arms if the new column that will
				 * be considered is unbounded, or this one was.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lower_val</name> <operator>||</operator> <operator>!</operator><name>ldatum_next</name> <operator>||</operator>
					<name><name>ldatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_next_lower_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>upper_val</name> <operator>||</operator> <operator>!</operator><name>udatum_next</name> <operator>||</operator>
					<name><name>udatum_next</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_next_upper_arm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>lower_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>,
									<argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									</then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>upper_or_arm_args</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper_or_arms</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>,
									<argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
									?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arm_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
									</then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arm_args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If no work to do in the next iteration, break away. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_next_lower_arm</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_next_upper_arm</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>++</operator><name>current_or_arm</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Generate the OR expressions for each of lower and upper bounds (if
	 * required), and append to the list of implicitly ANDed list of
	 * expressions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lower_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
						 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>lower_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
						 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>lower_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>upper_or_arms</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>
						 ?</condition><then> <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>upper_or_arms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
						 </then><else>: <expr><call><name>linitial</name><argument_list>(<argument><expr><name>upper_or_arms</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * As noted above, for non-default, we return list with constant TRUE. If
	 * the result is NIL during the recursive call for default, it implies
	 * this is the only other partition which can hold every value of the key
	 * except NULL. Hence we return the NullTest result skipped earlier.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>for_default</name></expr>
			?</condition><then> <expr><call><name>get_range_nulltest</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>
			</then><else>: <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_key_properties
 *		Returns range partition key information for a given column
 *
 * This is a subroutine for get_qual_for_range, and its API is pretty
 * specialized to that caller.
 *
 * Constructs an Expr for the key column (returned in *keyCol) and Consts
 * for the lower and upper range limits (returned in *lower_val and
 * *upper_val).  For MINVALUE/MAXVALUE limits, NULL is returned instead of
 * a Const.  All of these structures are freshly palloc'd.
 *
 * *partexprs_item points to the cell containing the next expression in
 * the key-&gt;partexprs list, or NULL.  It may be advanced upon return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_range_key_properties</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keynum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name></decl></parameter>,
						 <parameter><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>udatum</name></decl></parameter>,
						 <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>partexprs_item</name></decl></parameter>,
						 <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyCol</name></decl></parameter>,
						 <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>lower_val</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>upper_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Get partition key expression for this column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>keynum</name></expr>]</index></name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><operator>*</operator><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Get appropriate Const nodes for the bounds */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ldatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lower_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>udatum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>udatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>upper_val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_range_nulltest
 *
 * A non-default range partition table does not currently allow partition
 * keys to be null, so emit an IS NOT NULL expression for each key column.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_range_nulltest</name><parameter_list>(<parameter><decl><type><name>PartitionKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nulltest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>keyCol</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>keyCol</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>nulltest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>keyCol</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulltest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nulltest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_partition_hash_value
 *
 * Compute the hash value for given partition key values.
 */</comment>
<function><type><name>uint64</name></type>
<name>compute_partition_hash_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partnatts</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>partsupfunc</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Nulls are just ignored */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Compute hash for each datum value by calling respective
			 * datatype-specific hash functions of each partition key
			 * attribute.
			 */</comment>
			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rowHash</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * satisfies_hash_partition
 *
 * This is an SQL-callable function for use in hash partition constraints.
 * The first three arguments are the parent table OID, modulus, and remainder.
 * The remaining arguments are the value of the partitioning columns (or
 * expressions); these are hashed and the results are combined into a single
 * hash value by calling hash_combine64.
 *
 * Returns true if remainder produced when this computed single hash value is
 * divided by the given modulus is equal to given remainder, otherwise false.
 *
 * See get_qual_for_hash() for usage.
 */</comment>
<function><type><name>Datum</name></type>
<name>satisfies_hash_partition</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct <name>ColumnsHashData</name>
	<block>{
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>variadic_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>variadic_typlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>variadic_typbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>variadic_typalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name><name>partsupfunc</name><index>[<expr><name>PARTITION_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	}</block></struct></type> <name>ColumnsHashData</name>;</typedef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>HASH_PARTITION_SEED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnsHashData</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>rowHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Return null if the parent OID, modulus, or remainder is NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parentId</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>modulus</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>remainder</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check modulus and remainder. */</comment>
	<if_stmt><if>if <condition>(<expr><name>modulus</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modulus for hash partition must be a positive integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be a non-negative integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainder</name> <operator>&gt;=</operator> <name>modulus</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be less than modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Cache hash function information.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>parentId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<comment type="block">/* Open parent relation and fetch partition key info */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reject parent table that is not hash-partitioned. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			<name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a hash partitioned table"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain if wrong number of column values */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>!=</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* allocate space for our cache */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

			<comment type="block">/* check argument types and save fmgr_infos */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>argtype</name> <operator>!=</operator> <name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* allocate space for our cache -- just one FmgrInfo in this case */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
									   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ColumnsHashData</name></expr></argument>, <argument><expr><name>partsupfunc</name></expr></argument>)</argument_list></call> <operator>+</operator>
									   <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ColumnsHashData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>parentId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check argument types */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %d of the partition key has type \"%s\", but supplied value is of type \"%s\""</literal></expr></argument>,
									<argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						   <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Hold lock until commit */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name> <init>= <expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For a non-variadic call, neither the number of arguments nor their
		 * types can change across calls, so avoid the expense of rechecking
		 * here.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<comment type="block">/* keys start from fourth argument of function. */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>argno</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>argno</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>variadic_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>variadic_array</name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_type</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typlen</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typbyval</name></name></expr></argument>,
						  <argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>variadic_typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* complain if wrong number of column values */</comment>
		<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>!=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of partitioning columns (%d) does not match number of partition keys provided (%d)"</literal></expr></argument>,
							<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>hash</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>datum</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Form a single 64-bit hash value */</comment>
			<expr_stmt><expr><name>rowHash</name> <operator>=</operator> <call><name>hash_combine64</name><argument_list>(<argument><expr><name>rowHash</name></expr></argument>, <argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>rowHash</name> <operator>%</operator> <name>modulus</name> <operator>==</operator> <name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
