<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/libpq/auth.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * auth.c
 *	  Routines to handle network authentication
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/libpq/auth.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/scram-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/crypt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/scram.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/backend_random.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>


<comment type="block">/*----------------------------------------------------------------
 * Global authentication functions
 *----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendAuthRequest</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>AuthRequest</name></type> <name>areq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extradata</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>extralen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>auth_failed</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recv_password_packet</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*----------------------------------------------------------------
 * Password-based authentication methods (password, md5, and scram-sha-256)
 *----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckPasswordAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckPWChallengeAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckMD5Auth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shadow_pass</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckSCRAMAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shadow_pass</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckYbTserverKeyAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*----------------------------------------------------------------
 * Ident authentication
 *----------------------------------------------------------------
 */</comment>
<comment type="block">/* Max size of username ident server can return */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_USERNAME_MAX</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/* Standard TCP port number for Ident service.  Assigned by IANA */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_PORT</name></cpp:macro> <cpp:value>113</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ident_inet</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>auth_peer</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*----------------------------------------------------------------
 * PAM authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PAM_PAM_APPL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pam/pam_appl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SECURITY_PAM_APPL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;security/pam_appl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSQL_PAM_SERVICE</name></cpp:macro> <cpp:value>"postgresql"</cpp:value></cpp:define>	<comment type="block">/* Service name passed to PAM */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckPAMAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pam_passwd_conv_proc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pam_message</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>,
					 <parameter><decl><type><name><name>struct</name> <name>pam_response</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>resp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>appdata_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pam_conv</name></name></type> <name>pam_passw_conv</name> <init>= <expr><block>{
	<expr><operator>&amp;</operator><name>pam_passwd_conv_proc</name></expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pam_passwd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Workaround for Solaris 2.6
										 * brokenness */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Port</name> <modifier>*</modifier></type><name>pam_port_cludge</name></decl>;</decl_stmt>	<comment type="block">/* Workaround for passing "Port *port" into
								 * pam_passwd_conv_proc */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PAM */</comment>


<comment type="block">/*----------------------------------------------------------------
 * BSD authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bsd_auth.h&gt;</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckBSDAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_BSD_AUTH */</comment>


<comment type="block">/*----------------------------------------------------------------
 * LDAP authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/* We use a deprecated function to keep the codepath the same as win32. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_DEPRECATED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ldap.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winldap.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Correct header from the Platform SDK */</comment>
<typedef>typedef
<function_decl><type><name>ULONG</name></type>		(<modifier>*</modifier><name>__ldap_start_tls_sA</name>) <parameter_list>(
									<parameter><decl><type><name>IN</name> <name>PLDAP</name></type> <name>ExternalHandle</name></decl></parameter>,
									<parameter><decl><type><name>OUT</name> <name>PULONG</name></type> <name>ServerReturnValue</name></decl></parameter>,
									<parameter><decl><type><name>OUT</name> <name>LDAPMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>,
									<parameter><decl><type><name>IN</name> <name>PLDAPControlA</name> <modifier>*</modifier></type> <name>ServerControls</name></decl></parameter>,
									<parameter><decl><type><name>IN</name> <name>PLDAPControlA</name> <modifier>*</modifier></type> <name>ClientControls</name></decl></parameter>
)</parameter_list>;</function_decl></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckLDAPAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>get_ldap_password</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>ldapbindpasswd</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* LDAP_OPT_DIAGNOSTIC_MESSAGE is the newer spelling */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LDAP_OPT_DIAGNOSTIC_MESSAGE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_OPT_DIAGNOSTIC_MESSAGE</name></cpp:macro> <cpp:value>LDAP_OPT_ERROR_STRING</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LDAP */</comment>

<comment type="block">/*----------------------------------------------------------------
 * Cert authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckCertAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*----------------------------------------------------------------
 * Kerberos and GSSAPI GUCs
 *----------------------------------------------------------------
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pg_krb_server_keyfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>pg_krb_caseins_users</name></decl>;</decl_stmt>


<comment type="block">/*----------------------------------------------------------------
 * GSSAPI Authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GSSAPI_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gssapi.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gssapi/gssapi.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_GSS_recvauth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS */</comment>


<comment type="block">/*----------------------------------------------------------------
 * SSPI Authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
<typedef>typedef <function_decl><type><name>SECURITY_STATUS</name></type>
			(<name>WINAPI</name> <modifier>*</modifier> <name>QUERY_SECURITY_CONTEXT_TOKEN_FN</name>) <parameter_list>(
														<parameter><decl><type><name>PCtxtHandle</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pg_SSPI_recvauth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pg_SSPI_make_upn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accountname</name></decl></parameter>,
				 <parameter><decl><type><name>size_t</name></type> <name>accountnamesize</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>domainname</name></decl></parameter>,
				 <parameter><decl><type><name>size_t</name></type> <name>domainnamesize</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>update_accountname</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*----------------------------------------------------------------
 * RADIUS Authentication
 *----------------------------------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CheckRADIUSAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>PerformRadiusTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>secret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passwd</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Maximum accepted size of GSS and SSPI authentication tokens.
 *
 * Kerberos tickets are usually quite small, but the TGTs issued by Windows
 * domain controllers include an authorization field known as the Privilege
 * Attribute Certificate (PAC), which contains the user's Windows permissions
 * (group memberships etc.). The PAC is copied into all tickets obtained on
 * the basis of this TGT (even those issued by Unix realms which the Windows
 * realm trusts), and can be several kB in size. The maximum token size
 * accepted by Windows systems is determined by the MaxAuthToken Windows
 * registry setting. Microsoft recommends that it is not set higher than
 * 65535 bytes, so that seems like a reasonable limit for us as well.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_MAX_AUTH_TOKEN_LENGTH</name></cpp:macro>	<cpp:value>65535</cpp:value></cpp:define>

<comment type="block">/*
 * Maximum accepted size of SASL messages.
 *
 * The messages that the server or libpq generate are much smaller than this,
 * but have some headroom.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_MAX_SASL_MESSAGE_LENGTH</name></cpp:macro>	<cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/*----------------------------------------------------------------
 * Global authentication functions
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This hook allows plugins to get control following client authentication,
 * but before the user has been informed about the results.  It could be used
 * to record login events, insert a delay after failed authentication, etc.
 */</comment>
<decl_stmt><decl><type><name>ClientAuthentication_hook_type</name></type> <name>ClientAuthentication_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Tell the user the authentication failed, but not (much about) why.
 *
 * There is a tradeoff here between security concerns and making life
 * unnecessarily difficult for legitimate users.  We would not, for example,
 * want to report the password we were expecting to receive...
 * But it seems useful to report the username and authorization method
 * in use, and these are items that must be presumed known to an attacker
 * anyway.
 * Note that many sorts of failure report additional information in the
 * postmaster log, which we hope is only readable by good guys.  In
 * particular, if logdetail isn't NULL, we send that string to the log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>auth_failed</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cdetail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errcode_return</name> <init>= <expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we failed due to EOF from client, just quit; there's no point in
	 * trying to send a message to the client, and not much point in logging
	 * the failure in the postmaster log.  (Logging the failure might be
	 * desirable, were it not for the fact that libpq closes the connection
	 * unceremoniously if challenged for a password when it hasn't got one to
	 * send.  We'll get a useless log entry for every psql connection under
	 * password auth, even if it's perfectly successful, if we log STATUS_EOF
	 * events.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_EOF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>uaReject</name></expr>:</case>
		<case>case <expr><name>uaImplicitReject</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"authentication failed for user \"%s\": host rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaTrust</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"\"trust\" authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaIdent</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ident authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaPeer</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Peer authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaPassword</name></expr>:</case>
		<case>case <expr><name>uaMD5</name></expr>:</case>
		<case>case <expr><name>uaSCRAM</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"password authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We use it to indicate if a .pgpass password failed. */</comment>
			<expr_stmt><expr><name>errcode_return</name> <operator>=</operator> <name>ERRCODE_INVALID_PASSWORD</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaYbTserverKey</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"tserver key authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errcode_return</name> <operator>=</operator> <name>ERRCODE_INVALID_PASSWORD</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaGSS</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GSSAPI authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaSSPI</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"SSPI authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaPAM</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PAM authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaBSD</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"BSD authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaLDAP</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"LDAP authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaCert</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"certificate authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaRADIUS</name></expr>:</case>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"RADIUS authentication failed for user \"%s\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"authentication failed for user \"%s\": invalid authentication method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line_to_print</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>maskedline</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>line_to_print</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>line_to_print</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>rawline</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cdetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Connection matched pg_hba.conf line %d: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>, <argument><expr><name>line_to_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logdetail</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>logdetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s\n%s"</literal></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>, <argument><expr><name>cdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>logdetail</name> <operator>=</operator> <name>cdetail</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>errcode_return</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <ternary><condition><expr><name>logdetail</name></expr> ?</condition><then> <expr><call><name>errdetail_log</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* doesn't return */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Client authentication starts here.  If there is an error, this
 * function does not return and the backend process is terminated.
 */</comment>
<function><type><name>void</name></type>
<name>ClientAuthentication</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>STATUS_ERROR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>logdetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the authentication method to use for this frontend/database
	 * combination.  Note: we do not parse the file at this point; this has
	 * already been done elsewhere.  hba.c dropped an error message into the
	 * server logfile if parsing the hba config file failed.
	 */</comment>
	<expr_stmt><expr><call><name>hba_getauthmethod</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is the first point where we have access to the hba record for the
	 * current connection, so perform any verifications based on the hba
	 * options field that should be done *before* the authentication here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>clientcert</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we haven't loaded a root certificate store, fail */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>secure_loaded_verify_locations</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"client certificates can only be checked if a root certificate store is available"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we loaded a root certificate store, and if a certificate is
		 * present on the client, then it has been verified against our root
		 * certificate store, and the connection would have been aborted
		 * already if it didn't verify ok.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>peer_cert_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection requires a valid client certificate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now proceed to do the actual authentication check
	 */</comment>
	<switch>switch <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>uaReject</name></expr>:</case>

			<comment type="block">/*
			 * An explicit "reject" entry in pg_hba.conf.  This report exposes
			 * the fact that there's an explicit reject entry, which is
			 * perhaps not so desirable from a security standpoint; but the
			 * message for an implicit reject could confuse the DBA a lot when
			 * the true situation is a match to an explicit reject.  And we
			 * don't want to change the message for an implicit reject.  As
			 * noted below, the additional information shown here doesn't
			 * expose anything not known to an attacker.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>hostinfo</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
								   <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hba.conf rejects replication connection for host \"%s\", user \"%s\", %s"</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hba.conf rejects replication connection for host \"%s\", user \"%s\""</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hba.conf rejects connection for host \"%s\", user \"%s\", database \"%s\", %s"</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_hba.conf rejects connection for host \"%s\", user \"%s\", database \"%s\""</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>uaImplicitReject</name></expr>:</case>

			<comment type="block">/*
			 * No matching entry, so tell the user we fell through.
			 *
			 * NOTE: the extra info reported here is not a security breach,
			 * because all that info is known at the frontend and must be
			 * assumed known to bad guys.  We're merely helping out the less
			 * clueful good guys.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>hostinfo</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
								   <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME_LOOKUP_DETAIL</name><parameter_list>(<parameter><type><name>port</name></type></parameter>)</parameter_list></cpp:macro> \
				<cpp:value>(port-&gt;remote_hostname ? \
				 (port-&gt;remote_hostname_resolv == +1 ? \
				  errdetail_log("Client IP address resolved to \"%s\", forward lookup matches.", \
								port-&gt;remote_hostname) : \
				  port-&gt;remote_hostname_resolv == 0 ? \
				  errdetail_log("Client IP address resolved to \"%s\", forward lookup not checked.", \
								port-&gt;remote_hostname) : \
				  port-&gt;remote_hostname_resolv == -1 ? \
				  errdetail_log("Client IP address resolved to \"%s\", forward lookup does not match.", \
								port-&gt;remote_hostname) : \
				  port-&gt;remote_hostname_resolv == -2 ? \
				  errdetail_log("Could not translate client host name \"%s\" to IP address: %s.", \
								port-&gt;remote_hostname, \
								gai_strerror(port-&gt;remote_hostname_errcode)) : \
				  0) \
				 : (port-&gt;remote_hostname_resolv == -2 ? \
					errdetail_log("Could not resolve client IP address to a host name: %s.", \
								  gai_strerror(port-&gt;remote_hostname_errcode)) : \
					0))</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no pg_hba.conf entry for replication connection from host \"%s\", user \"%s\", %s"</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>HOSTNAME_LOOKUP_DETAIL</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no pg_hba.conf entry for replication connection from host \"%s\", user \"%s\""</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>HOSTNAME_LOOKUP_DETAIL</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no pg_hba.conf entry for host \"%s\", user \"%s\", database \"%s\", %s"</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"SSL off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>HOSTNAME_LOOKUP_DETAIL</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no pg_hba.conf entry for host \"%s\", user \"%s\", database \"%s\""</literal></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
									<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>HOSTNAME_LOOKUP_DETAIL</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>uaGSS</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_GSS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pg_GSS_recvauth</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>

		<case>case <expr><name>uaSSPI</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
			<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_SSPI</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pg_SSPI_recvauth</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>

		<case>case <expr><name>uaPeer</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>auth_peer</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>

		<case>case <expr><name>uaIdent</name></expr>:</case>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ident_inet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>uaMD5</name></expr>:</case>
		<case>case <expr><name>uaSCRAM</name></expr>:</case>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckPWChallengeAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>uaPassword</name></expr>:</case>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckPasswordAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>uaYbTserverKey</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckYbTserverKeyAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>

		<case>case <expr><name>uaPAM</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckPAMAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PAM */</comment>
			<break>break;</break>

		<case>case <expr><name>uaBSD</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckBSDAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_BSD_AUTH */</comment>
			<break>break;</break>

		<case>case <expr><name>uaLDAP</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckLDAPAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>

		<case>case <expr><name>uaCert</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckCertAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>uaRADIUS</name></expr>:</case>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>CheckRADIUSAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>uaTrust</name></expr>:</case>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>ClientAuthentication_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ClientAuthentication_hook</name>) <argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>auth_failed</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Send an authentication request packet to the frontend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendAuthRequest</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>AuthRequest</name></type> <name>areq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extradata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extralen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'R'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>areq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>extralen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>extradata</name></expr></argument>, <argument><expr><name>extralen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush message so client will see it, except for AUTH_REQ_OK and
	 * AUTH_REQ_SASL_FIN, which need not be sent until we are ready for
	 * queries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>areq</name> <operator>!=</operator> <name>AUTH_REQ_OK</name> <operator>&amp;&amp;</operator> <name>areq</name> <operator>!=</operator> <name>AUTH_REQ_SASL_FIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect password response packet from frontend.
 *
 * Returns NULL if couldn't get password, else palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>recv_password_packet</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>proto</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Expect 'p' message type */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>mtype</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the client just disconnects without offering a password,
			 * don't make a log entry.  This is legal per protocol spec and in
			 * fact commonly done by psql, so complaining just clutters the
			 * log.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected password response, got message type %d"</literal></expr></argument>,
								<argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* EOF or bad message type */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* For pre-3.0 clients, avoid log entry if they just disconnect */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_peekbyte</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* EOF */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* receive password */</comment>
	<block>{<block_content>
		<comment type="block">/* EOF - pq_getmessage already logged a suitable message */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Apply sanity check: password packet length should agree with length of
	 * contained string.  Note it is safe to use strlen here because
	 * StringInfo is guaranteed to have an appended '\0'.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid password packet size"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow an empty password. Libpq treats an empty password the same
	 * as no password at all, and won't even try to authenticate. But other
	 * clients might, so allowing it would be confusing.
	 *
	 * Note that this only catches an empty password sent by the client in
	 * plaintext. There's also a check in CREATE/ALTER USER that prevents an
	 * empty string from being stored as a user's password in the first place.
	 * We rely on that for MD5 and SCRAM authentication, but we still need
	 * this check here, to prevent an empty password from being used with
	 * authentication methods that check the password against an external
	 * system, like PAM, LDAP and RADIUS.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PASSWORD</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"empty password returned by client"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Do not echo password to logs, for security. */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"received password packet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the received string.  Note we do not attempt to do any
	 * character-set conversion on it; since we don't yet know the client's
	 * encoding, there wouldn't be much point.
	 */</comment>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------------
 * Password-based authentication mechanisms
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Plaintext password authentication.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckPasswordAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shadow_pass</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* client wouldn't send password */</comment>

	<expr_stmt><expr><name>shadow_pass</name> <operator>=</operator> <call><name>get_role_password</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shadow_pass</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>plain_crypt_verify</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>shadow_pass</name></expr></argument>, <argument><expr><name>passwd</name></expr></argument>,
									<argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shadow_pass</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>shadow_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MD5 and SCRAM authentication.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckPWChallengeAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>auth_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shadow_pass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PasswordType</name></type> <name>pwtype</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaSCRAM</name> <operator>||</operator>
		   <name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaMD5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First look up the user's password. */</comment>
	<expr_stmt><expr><name>shadow_pass</name> <operator>=</operator> <call><name>get_role_password</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the user does not exist, or has no password or it's expired, we
	 * still go through the motions of authentication, to avoid revealing to
	 * the client that the user didn't exist.  If 'md5' is allowed, we choose
	 * whether to use 'md5' or 'scram-sha-256' authentication based on current
	 * password_encryption setting.  The idea is that most genuine users
	 * probably have a password of that type, and if we pretend that this user
	 * had a password of that type, too, it "blends in" best.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shadow_pass</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pwtype</name> <operator>=</operator> <name>Password_encryption</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pwtype</name> <operator>=</operator> <call><name>get_password_type</name><argument_list>(<argument><expr><name>shadow_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If 'md5' authentication is allowed, decide whether to perform 'md5' or
	 * 'scram-sha-256' authentication based on the type of password the user
	 * has.  If it's an MD5 hash, we must do MD5 authentication, and if it's a
	 * SCRAM verifier, we must do SCRAM authentication.
	 *
	 * If MD5 authentication is not allowed, always use SCRAM.  If the user
	 * had an MD5 password, CheckSCRAMAuth() will fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaMD5</name> <operator>&amp;&amp;</operator> <name>pwtype</name> <operator>==</operator> <name>PASSWORD_TYPE_MD5</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>auth_result</name> <operator>=</operator> <call><name>CheckMD5Auth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>shadow_pass</name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>auth_result</name> <operator>=</operator> <call><name>CheckSCRAMAuth</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>shadow_pass</name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shadow_pass</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>shadow_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If get_role_password() returned error, return error, even if the
	 * authentication succeeded.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shadow_pass</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>auth_result</name> <operator>!=</operator> <name>STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>auth_result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckMD5Auth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shadow_pass</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>md5Salt</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* Password salt */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Db_user_namespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MD5 authentication is not supported when \"db_user_namespace\" is enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* include the salt to use for computing the response */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_backend_random</name><argument_list>(<argument><expr><name>md5Salt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate random MD5 salt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_MD5</name></expr></argument>, <argument><expr><name>md5Salt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* client wouldn't send password */</comment>

	<if_stmt><if>if <condition>(<expr><name>shadow_pass</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>md5_crypt_verify</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>shadow_pass</name></expr></argument>, <argument><expr><name>passwd</name></expr></argument>,
								  <argument><expr><name>md5Salt</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckSCRAMAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>shadow_pass</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>sasl_mechs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>scram_opaq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>output</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outputlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>input</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inputlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>initial</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SASL auth is not supported for protocol versions before 3, because it
	 * relies on the overall message length word to determine the SASL payload
	 * size in AuthenticationSASLContinue and PasswordMessage messages.  (We
	 * used to have a hard rule that protocol messages must be parsable
	 * without relying on the length word, but we hardly care about older
	 * protocol version anymore.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SASL authentication is not supported in protocol version 2"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Send the SASL authentication request to user.  It includes the list of
	 * authentication mechanisms that are supported.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sasl_mechs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_be_scram_get_mechanisms</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sasl_mechs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Put another '\0' to mark that list is finished. */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sasl_mechs</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_SASL</name></expr></argument>, <argument><expr><name><name>sasl_mechs</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>sasl_mechs</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sasl_mechs</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through SASL message exchange.  This exchange can consist of
	 * multiple messages sent in both directions.  First message is always
	 * from the client.  All messages from client to server are password
	 * packets (type 'p').
	 */</comment>
	<expr_stmt><expr><name>initial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only log error if client didn't disconnect. */</comment>
			<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <name>EOF</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected SASL response, got message type %d"</literal></expr></argument>,
								<argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the actual SASL message */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>PG_MAX_SASL_MESSAGE_LENGTH</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* EOF - pq_getmessage already logged error */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Processing received SASL response of length %d"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The first SASLInitialResponse message is different from the others.
		 * It indicates which SASL mechanism the client selected, and contains
		 * an optional Initial Client Response payload.  The subsequent
		 * SASLResponse messages contain just the SASL payload.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>initial</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>selected_mech</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>selected_mech</name> <operator>=</operator> <call><name>pq_getmsgrawstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Initialize the status tracker for message exchanges.
			 *
			 * If the user doesn't exist, or doesn't have a valid password, or
			 * it's expired, we still go through the motions of SASL
			 * authentication, but tell the authentication method that the
			 * authentication is "doomed". That is, it's going to fail, no
			 * matter what.
			 *
			 * This is because we don't want to reveal to an attacker what
			 * usernames are valid, nor which users have a valid password.
			 */</comment>
			<expr_stmt><expr><name>scram_opaq</name> <operator>=</operator> <call><name>pg_be_scram_init</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>selected_mech</name></expr></argument>, <argument><expr><name>shadow_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>inputlen</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>inputlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>input</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>input</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>inputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>initial</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>inputlen</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>input</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The StringInfo guarantees that there's a \0 byte after the
		 * response.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>input</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>input</name><index>[<expr><name>inputlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we pass 'logdetail' as NULL when doing a mock authentication,
		 * because we should already have a better error message in that case
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_be_scram_exchange</name><argument_list>(<argument><expr><name>scram_opaq</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>inputlen</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputlen</name></expr></argument>,
									  <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* input buffer no longer used */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>output</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Negotiation generated data to be sent to the client.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"sending SASL challenge of length %u"</literal></expr></argument>, <argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>SASL_EXCHANGE_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_SASL_FIN</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_SASL_CONT</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>outputlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>result</name> <operator>==</operator> <name>SASL_EXCHANGE_CONTINUE</name></expr>)</condition>;</do>

	<comment type="block">/* Oops, Something bad happened */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>SASL_EXCHANGE_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Yugabyte internal tserver to postgres key authentication.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckYbTserverKeyAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>logdetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type>	<name>client_key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if>		<comment type="block">/* client wouldn't send password */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Convert client-supplied password string to uint64 key */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>client_key</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>passwd</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"auth key must be uint64"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>auth_key</name></decl>;</decl_stmt>
	<return>return <expr><ternary><condition><expr><call><name>yb_get_role_password</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auth_key</name></expr></argument>)</argument_list></call></expr>
		?</condition><then> <expr><call><name>yb_plain_key_verify</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>auth_key</name></expr></argument>, <argument><expr><name>client_key</name></expr></argument>, <argument><expr><name>logdetail</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><name>STATUS_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------------
 * GSSAPI authentication system
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
 * MIT Kerberos GSSAPI DLL doesn't properly export the symbols for MingW
 * that contain the OIDs required. Redefine here, values copied
 * from src/athena/auth/krb5/src/lib/gssapi/generic/gssapi_generic.c
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>gss_OID_desc</name></type> <name>GSS_C_NT_USER_NAME_desc</name> <init>=
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <literal type="string">"\x2a\x86\x48\x86\xf7\x12\x01\x02\x01\x02"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>GSS_DLLIMP</name> <name>gss_OID</name></type> <name>GSS_C_NT_USER_NAME</name> <init>= <expr><operator>&amp;</operator><name>GSS_C_NT_USER_NAME_desc</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Generate an error for GSSAPI authentication.  The caller should apply
 * _() to errmsg to make it translatable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_GSS_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>severity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>, <parameter><decl><type><name>OM_uint32</name></type> <name>maj_stat</name></decl></parameter>, <parameter><decl><type><name>OM_uint32</name></type> <name>min_stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>gmsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>lmin_s</name></decl>,
				<decl><type ref="prev"/><name>msg_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msg_major</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>msg_minor</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Fetch major status message */</comment>
	<expr_stmt><expr><name>msg_ctx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gss_display_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><name>maj_stat</name></expr></argument>, <argument><expr><name>GSS_C_GSS_CODE</name></expr></argument>,
					   <argument><expr><name>GSS_C_NO_OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>msg_major</name></expr></argument>, <argument><expr><name><name>gmsg</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg_major</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>msg_ctx</name></expr>)</condition><block type="pseudo"><block_content>

		<comment type="block">/*
		 * More than one message available. XXX: Should we loop and read all
		 * messages? (same below)
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"incomplete GSS error report"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch mechanism minor status message */</comment>
	<expr_stmt><expr><name>msg_ctx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gss_display_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><name>min_stat</name></expr></argument>, <argument><expr><name>GSS_C_MECH_CODE</name></expr></argument>,
					   <argument><expr><name>GSS_C_NO_OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>msg_minor</name></expr></argument>, <argument><expr><name><name>gmsg</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg_minor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>msg_ctx</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"incomplete GSS minor error report"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * errmsg_internal, since translation of the first part must be done
	 * before calling this function anyway.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>severity</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>msg_major</name></expr></argument>, <argument><expr><name>msg_minor</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_GSS_recvauth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>maj_stat</name></decl>,
				<decl><type ref="prev"/><name>min_stat</name></decl>,
				<decl><type ref="prev"/><name>lmin_s</name></decl>,
				<decl><type ref="prev"/><name>gflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>gbuf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GSS auth is not supported for protocol versions before 3, because it
	 * relies on the overall message length word to determine the GSS payload
	 * size in AuthenticationGSSContinue and PasswordMessage messages. (This
	 * is, in fact, a design error in our GSS support, because protocol
	 * messages are supposed to be parsable without relying on the length
	 * word; but it's not worth changing it now.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GSSAPI is not supported in protocol version 2"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pg_krb_server_keyfile</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pg_krb_server_keyfile</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set default Kerberos keytab file for the Krb5 mechanism.
		 *
		 * setenv("KRB5_KTNAME", pg_krb_server_keyfile, 0); except setenv()
		 * not always available.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"KRB5_KTNAME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>kt_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pg_krb_server_keyfile</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">14</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>kt_path</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>kt_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kt_path</name> <operator>||</operator>
				<call><name>snprintf</name><argument_list>(<argument><expr><name>kt_path</name></expr></argument>, <argument><expr><name>kt_len</name></expr></argument>, <argument><expr><literal type="string">"KRB5_KTNAME=%s"</literal></expr></argument>,
						 <argument><expr><name>pg_krb_server_keyfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>kt_len</name> <operator>-</operator> <literal type="number">2</literal> <operator>||</operator>
				<call><name>putenv</name><argument_list>(<argument><expr><name>kt_path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We accept any service principal that's present in our keytab. This
	 * increases interoperability between kerberos implementations that see
	 * for example case sensitivity differently, while not really opening up
	 * any vector of attack.
	 */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name> <operator>=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize sequence with an empty context
	 */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name> <operator>=</operator> <name>GSS_C_NO_CONTEXT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through GSSAPI message exchange. This exchange can consist of
	 * multiple messages sent in both directions. First message is always from
	 * the client. All messages from client to server are password packets
	 * (type 'p').
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only log error if client didn't disconnect. */</comment>
			<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected GSS response, got message type %d"</literal></expr></argument>,
								<argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the actual GSS token */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>PG_MAX_AUTH_TOKEN_LENGTH</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* EOF - pq_getmessage already logged error */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Map to GSSAPI style buffer */</comment>
		<expr_stmt><expr><name><name>gbuf</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gbuf</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Processing received GSS token of length %u"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>gbuf</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>maj_stat</name> <operator>=</operator> <call><name>gss_accept_sec_context</name><argument_list>(
										  <argument><expr><operator>&amp;</operator><name>min_stat</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,
										  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>gbuf</name></expr></argument>,
										  <argument><expr><name>GSS_C_NO_CHANNEL_BINDINGS</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>gflags</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* gbuf no longer used */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"gss_accept_sec_context major: %d, "</literal>
			 <literal type="string">"minor: %d, outlen: %u, outflags: %x"</literal></expr></argument>,
			 <argument><expr><name>maj_stat</name></expr></argument>, <argument><expr><name>min_stat</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name></expr></argument>, <argument><expr><name>gflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Negotiation generated data to be sent to the client.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"sending GSS response token of length %u"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_GSS_CONT</name></expr></argument>,
							<argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>maj_stat</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name> <operator>&amp;&amp;</operator> <name>maj_stat</name> <operator>!=</operator> <name>GSS_S_CONTINUE_NEEDED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gss_delete_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>GSS_C_NO_BUFFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"accepting GSS security context failed"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>maj_stat</name></expr></argument>, <argument><expr><name>min_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>maj_stat</name> <operator>==</operator> <name>GSS_S_CONTINUE_NEEDED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"GSS continue needed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block> while <condition>(<expr><name>maj_stat</name> <operator>==</operator> <name>GSS_S_CONTINUE_NEEDED</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name> <operator>!=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Release service principal credentials
		 */</comment>
		<expr_stmt><expr><call><name>gss_release_cred</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GSS_S_COMPLETE indicates that authentication is now complete.
	 *
	 * Get the name of the user that authenticated, and compare it to the pg
	 * username that was specified for the connection.
	 */</comment>
	<expr_stmt><expr><name>maj_stat</name> <operator>=</operator> <call><name>gss_display_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_stat</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>maj_stat</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_GSS_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"retrieving GSS user name failed"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>maj_stat</name></expr></argument>, <argument><expr><name>min_stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Split the username at the realm separator
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>gbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>gbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we are not going to include the realm in the username that is
		 * passed to the ident map, destructively modify it here to remove the
		 * realm. Then advance past the separator to check the realm.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>include_realm</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Match the realm part of the name first
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pg_krb_caseins_users</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* GSS realm does not match */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
					 <argument><expr><literal type="string">"GSSAPI realm (%s) and configured realm (%s) don't match"</literal></expr></argument>,
					 <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			 <argument><expr><literal type="string">"GSSAPI did not return realm but realm matching was requested"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>gbuf</name><operator>.</operator><name>value</name></name></expr></argument>,
						<argument><expr><name>pg_krb_caseins_users</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmin_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS */</comment>


<comment type="block">/*----------------------------------------------------------------
 * SSPI authentication system
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>

<comment type="block">/*
 * Generate an error for SSPI authentication.  The caller should apply
 * _() to errmsg to make it translatable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_SSPI_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>severity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>, <parameter><decl><type><name>SECURITY_STATUS</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sysmsg</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_IGNORE_INSERTS</name> <operator>|</operator>
					  <name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><name>sysmsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>severity</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"SSPI error %x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>severity</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s (%x)"</literal></expr></argument>, <argument><expr><name>sysmsg</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SSPI_recvauth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>mtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SECURITY_STATUS</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CredHandle</name></type>	<name>sspicred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CtxtHandle</name> <modifier>*</modifier></type><name>sspictx</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				<decl><type ref="prev"/><name>newctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeStamp</name></type>	<name>expiry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ULONG</name></type>		<name>contextattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBufferDesc</name></type> <name>inbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBufferDesc</name></type> <name>outbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBuffer</name></type>	<name><name>OutBuffers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SecBuffer</name></type>	<name><name>InBuffers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HANDLE</name></type>		<name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TOKEN_USER</name> <modifier>*</modifier></type><name>tokenuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>retlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>accountname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>domainname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>accountnamesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>accountname</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>domainnamesize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SID_NAME_USE</name></type> <name>accountnameuse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HMODULE</name></type>		<name>secur32</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>QUERY_SECURITY_CONTEXT_TOKEN_FN</name></type> <name>_QuerySecurityContextToken</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * SSPI auth is not supported for protocol versions before 3, because it
	 * relies on the overall message length word to determine the SSPI payload
	 * size in AuthenticationGSSContinue and PasswordMessage messages. (This
	 * is, in fact, a design error in our SSPI support, because protocol
	 * messages are supposed to be parsable without relying on the length
	 * word; but it's not worth changing it now.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SSPI is not supported in protocol version 2"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Acquire a handle to the server credentials.
	 */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>AcquireCredentialsHandle</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><literal type="string">"negotiate"</literal></expr></argument>,
								 <argument><expr><name>SECPKG_CRED_INBOUND</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sspicred</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>expiry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEC_E_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_SSPI_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not acquire SSPI credentials"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop through SSPI message exchange. This exchange can consist of
	 * multiple messages sent in both directions. First message is always from
	 * the client. All messages from client to server are password packets
	 * (type 'p').
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mtype</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only log error if client didn't disconnect. */</comment>
			<if_stmt><if>if <condition>(<expr><name>mtype</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected SSPI response, got message type %d"</literal></expr></argument>,
								<argument><expr><name>mtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the actual SSPI token */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>PG_MAX_AUTH_TOKEN_LENGTH</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* EOF - pq_getmessage already logged error */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Map to SSPI style buffer */</comment>
		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>ulVersion</name></name> <operator>=</operator> <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inbuf</name><operator>.</operator><name>pBuffers</name></name> <operator>=</operator> <name>InBuffers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>InBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>BufferType</name> <operator>=</operator> <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>

		<comment type="block">/* Prepare output buffer */</comment>
		<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>BufferType</name> <operator>=</operator> <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>OutBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name></name> <operator>=</operator> <name>OutBuffers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>outbuf</name><operator>.</operator><name>ulVersion</name></name> <operator>=</operator> <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>


		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Processing received SSPI token of length %u"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>AcceptSecurityContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sspicred</name></expr></argument>,
								  <argument><expr><name>sspictx</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>inbuf</name></expr></argument>,
								  <argument><expr><name>ASC_REQ_ALLOCATE_MEMORY</name></expr></argument>,
								  <argument><expr><name>SECURITY_NETWORK_DREP</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>newctx</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>outbuf</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>contextattr</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* input buffer no longer used */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>outbuf</name><operator>.</operator><name>cBuffers</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Negotiation generated data to be sent to the client.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"sending SSPI response token of length %u"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cbBuffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_GSS_CONT</name></expr></argument>,
							<argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>outbuf</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FreeContextBuffer</name><argument_list>(<argument><expr><name><name>outbuf</name><operator>.</operator><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEC_E_OK</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>SEC_I_CONTINUE_NEEDED</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>sspictx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DeleteSecurityContext</name><argument_list>(<argument><expr><name>sspictx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sspictx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>FreeCredentialsHandle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sspicred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_SSPI_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						  <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not accept SSPI security context"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Overwrite the current context with the one we just received. If
		 * sspictx is NULL it was the first loop and we need to allocate a
		 * buffer for it. On subsequent runs, we can just overwrite the buffer
		 * contents since the size does not change.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sspictx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sspictx</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CtxtHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sspictx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sspictx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CtxtHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>SEC_I_CONTINUE_NEEDED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"SSPI continue needed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block> while <condition>(<expr><name>r</name> <operator>==</operator> <name>SEC_I_CONTINUE_NEEDED</name></expr>)</condition>;</do>


	<comment type="block">/*
	 * Release service principal credentials
	 */</comment>
	<expr_stmt><expr><call><name>FreeCredentialsHandle</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sspicred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * SEC_E_OK indicates that authentication is now complete.
	 *
	 * Get the name of the user that authenticated, and compare it to the pg
	 * username that was specified for the connection.
	 *
	 * MingW is missing the export for QuerySecurityContextToken in the
	 * secur32 library, so we have to load it dynamically.
	 */</comment>

	<expr_stmt><expr><name>secur32</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"SECUR32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>secur32</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not load secur32.dll: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>_QuerySecurityContextToken</name> <operator>=</operator> <operator>(</operator><name>QUERY_SECURITY_CONTEXT_TOKEN_FN</name><operator>)</operator>
		<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>secur32</name></expr></argument>, <argument><expr><literal type="string">"QuerySecurityContextToken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>_QuerySecurityContextToken</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>secur32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not locate QuerySecurityContextToken in secur32.dll: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>_QuerySecurityContextToken</name><operator>)</operator> <operator>(</operator><name>sspictx</name><operator>,</operator> <operator>&amp;</operator><name>token</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEC_E_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>secur32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_SSPI_error</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					  <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"could not get token from SSPI security context"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>secur32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No longer need the security context, everything from here on uses the
	 * token instead.
	 */</comment>
	<expr_stmt><expr><call><name>DeleteSecurityContext</name><argument_list>(<argument><expr><name>sspictx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sspictx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TokenUser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>retlen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">122</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not get token information buffer size: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tokenuser</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>retlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tokenuser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetTokenInformation</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>TokenUser</name></expr></argument>, <argument><expr><name>tokenuser</name></expr></argument>, <argument><expr><name>retlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not get token information: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LookupAccountSid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>tokenuser</name><operator>-&gt;</operator><name>User</name><operator>.</operator><name>Sid</name></name></expr></argument>, <argument><expr><name>accountname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>accountnamesize</name></expr></argument>,
						  <argument><expr><name>domainname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>domainnamesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>accountnameuse</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"could not look up account SID: error code %lu"</literal></expr></argument>,
								 <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tokenuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>compat_realm</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><call><name>pg_SSPI_make_upn</name><argument_list>(<argument><expr><name>accountname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>accountname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											  <argument><expr><name>domainname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
											  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>upn_username</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Error already reported from pg_SSPI_make_upn */</comment>
			<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compare realm/domain if requested. In SSPI, always compare case
	 * insensitive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>, <argument><expr><name>domainname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				 <argument><expr><literal type="string">"SSPI domain (%s) and configured domain (%s) don't match"</literal></expr></argument>,
				 <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have the username (without domain/realm) in accountname, compare to
	 * the supplied value. In SSPI, always compare case insensitive.
	 *
	 * If set to include realm, append it in &lt;username&gt;@&lt;realm&gt; format.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>include_realm</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namebuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>namebuf</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s@%s"</literal></expr></argument>, <argument><expr><name>accountname</name></expr></argument>, <argument><expr><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>retval</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>accountname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Replaces the domainname with the Kerberos realm name,
 * and optionally the accountname with the Kerberos user name.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_SSPI_make_upn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accountname</name></decl></parameter>,
				 <parameter><decl><type><name>size_t</name></type> <name>accountnamesize</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>domainname</name></decl></parameter>,
				 <parameter><decl><type><name>size_t</name></type> <name>domainnamesize</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>update_accountname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>samname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>upname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ULONG</name></type>		<name>upnamesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>upnamerealmsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BOOLEAN</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build SAM name (DOMAIN\user), then translate to UPN
	 * (user@kerberos.realm). The realm name is returned in lower case, but
	 * that is fine because in SSPI auth, string comparisons are always
	 * case-insensitive.
	 */</comment>

	<expr_stmt><expr><name>samname</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s\\%s"</literal></expr></argument>, <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>accountname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>TranslateName</name><argument_list>(<argument><expr><name>samname</name></expr></argument>, <argument><expr><name>NameSamCompatible</name></expr></argument>, <argument><expr><name>NameUserPrincipal</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upnamesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>res</name> <operator>&amp;&amp;</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ERROR_INSUFFICIENT_BUFFER</name><operator>)</operator>
		<operator>||</operator> <name>upnamesize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>samname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ROLE_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* upnamesize includes the terminating NUL. */</comment>
	<expr_stmt><expr><name>upname</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>upnamesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>TranslateName</name><argument_list>(<argument><expr><name>samname</name></expr></argument>, <argument><expr><name>NameSamCompatible</name></expr></argument>, <argument><expr><name>NameUserPrincipal</name></expr></argument>,
						<argument><expr><name>upname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upnamesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>samname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>upname</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name> <operator>||</operator> <name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>upname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ROLE_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Length of realm name after the '@', including the NUL. */</comment>
	<expr_stmt><expr><name>upnamerealmsize</name> <operator>=</operator> <name>upnamesize</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>upname</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Replace domainname with realm name. */</comment>
	<if_stmt><if>if <condition>(<expr><name>upnamerealmsize</name> <operator>&gt;</operator> <name>domainnamesize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>upname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ROLE_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"realm name too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Length is now safe. */</comment>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Replace account name as well (in case UPN != SAM)? */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_accountname</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>-</operator> <name>upname</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name>accountnamesize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>upname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ROLE_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"translated account name too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>accountname</name></expr></argument>, <argument><expr><name>upname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>upname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_SSPI */</comment>



<comment type="block">/*----------------------------------------------------------------
 * Ident authentication system
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	Parse the string "*ident_response" as a response from a query to an Ident
 *	server.  If it's a normal response indicating a user name, return true
 *	and store the user name at *ident_user. If it's anything else,
 *	return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>interpret_ident_response</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident_response</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ident_user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cursor</name> <init>= <expr><name>ident_response</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Cursor into *ident_response */</comment>

	<comment type="block">/*
	 * Ident's response, in the telnet tradition, should end in crlf (\r\n).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident_response</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ident_response</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident_response</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip port field */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We're positioned to colon before response type field */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>response_type</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>		<comment type="block">/* Index into *response_type */</comment>

			<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt>			<comment type="block">/* Go over colon */</comment>
			<while>while <condition>(<expr><call><name>pg_isblank</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip blanks */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_isblank</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>response_type</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>response_type</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name><name>response_type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>pg_isblank</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip blanks */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>response_type</name></expr></argument>, <argument><expr><literal type="string">"USERID"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * It's a USERID response.  Good.  "cursor" should be pointing
				 * to the colon that precedes the operating system type.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* Go over colon */</comment>
					<comment type="block">/* Skip over operating system field. */</comment>
					<while>while <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>	<comment type="block">/* Index into *ident_user */</comment>

						<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* Go over colon */</comment>
						<while>while <condition>(<expr><call><name>pg_isblank</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>	<comment type="block">/* skip blanks */</comment>
						<comment type="block">/* Rest of line is user name.  Copy it over. */</comment>
						<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<while>while <condition>(<expr><operator>*</operator><name>cursor</name> <operator>!=</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>IDENT_USERNAME_MAX</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>ident_user</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cursor</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
						<expr_stmt><expr><name><name>ident_user</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Talk to the ident server on host "remote_ip_addr" and find out who
 *	owns the tcp connection from his port "remote_port" to port
 *	"local_port_addr" on host "local_ip_addr".  Return the user name the
 *	ident server gives as "*ident_user".
 *
 *	IP addresses and port numbers are in network byte order.
 *
 *	But iff we're unable to get the information from ident, return false.
 *
 *	XXX: Using WaitLatchOrSocket() and doing a CHECK_FOR_INTERRUPTS() if the
 *	latch was set would improve the responsiveness to timeouts/cancellations.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ident_inet</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>SockAddr</name></type> <name>remote_addr</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>SockAddr</name></type> <name>local_addr</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ident_user</name><index>[<expr><name>IDENT_USERNAME_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgsocket</name></type>	<name>sock_fd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt> <comment type="block">/* for talking to Ident server */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>				<comment type="block">/* Return code from a locally called function */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ident_return</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_addr_s</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>local_addr_s</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>local_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ident_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ident_query</name><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ident_response</name><index>[<expr><literal type="number">80</literal> <operator>+</operator> <name>IDENT_USERNAME_MAX</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>ident_serv</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>la</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				<decl><type ref="prev"/><name>hints</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Might look a little weird to first convert it to text and then back to
	 * sockaddr, but it's protocol independent.
	 */</comment>
	<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>remote_addr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>remote_addr</name><operator>.</operator><name>salen</name></name></expr></argument>,
					   <argument><expr><name>remote_addr_s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_addr_s</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>remote_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_addr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>local_addr</name><operator>.</operator><name>salen</name></name></expr></argument>,
					   <argument><expr><name>local_addr_s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_addr_s</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>local_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_port</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					   <argument><expr><name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ident_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ident_port</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>IDENT_PORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name><name>remote_addr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>remote_addr_s</name></expr></argument>, <argument><expr><name>ident_port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ident_serv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>||</operator> <operator>!</operator><name>ident_serv</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we don't expect this to happen */</comment>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name><name>local_addr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>local_addr_s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>la</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>||</operator> <operator>!</operator><name>la</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we don't expect this to happen */</comment>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sock_fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>ident_serv</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>ident_serv</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>,
					 <argument><expr><name><name>ident_serv</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sock_fd</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create socket for Ident connection: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Bind to the address which the client originally contacted, otherwise
	 * the ident server won't be able to match up the right connection. This
	 * is necessary if the PostgreSQL server is running on an IP alias.
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>bind</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name><name>la</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>la</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bind to local address \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>local_addr_s</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>connect</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name><name>ident_serv</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
				 <argument><expr><name><name>ident_serv</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to Ident server at address \"%s\", port %s: %m"</literal></expr></argument>,
						<argument><expr><name>remote_addr_s</name></expr></argument>, <argument><expr><name>ident_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The query we send to the Ident server */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ident_query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ident_query</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s,%s\r\n"</literal></expr></argument>,
			 <argument><expr><name>remote_port</name></expr></argument>, <argument><expr><name>local_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop in case send is interrupted */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name>ident_query</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident_query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send query to Ident server at address \"%s\", port %s: %m"</literal></expr></argument>,
						<argument><expr><name>remote_addr_s</name></expr></argument>, <argument><expr><name>ident_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>, <argument><expr><name>ident_response</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ident_response</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive response from Ident server at address \"%s\", port %s: %m"</literal></expr></argument>,
						<argument><expr><name>remote_addr_s</name></expr></argument>, <argument><expr><name>ident_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<goto>goto <name>ident_inet_done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ident_response</name><index>[<expr><name>rc</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ident_return</name> <operator>=</operator> <call><name>interpret_ident_response</name><argument_list>(<argument><expr><name>ident_response</name></expr></argument>, <argument><expr><name>ident_user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ident_return</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalidly formatted response from Ident server: \"%s\""</literal></expr></argument>,
						<argument><expr><name>ident_response</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>ident_inet_done</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>sock_fd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ident_serv</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>remote_addr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>ident_serv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>la</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>local_addr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>la</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ident_return</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Success! Check the usermap */</comment>
		<return>return <expr><call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>ident_user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Ask kernel about the credentials of the connecting process,
 *	determine the symbolic name of the corresponding user, and check
 *	if valid per the usermap.
 *
 *	Iff authorized, return STATUS_OK, otherwise return STATUS_ERROR.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>auth_peer</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>ident_user</name><index>[<expr><name>IDENT_USERNAME_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uid_t</name></type>		<name>uid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gid_t</name></type>		<name>gid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>getpeereid</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Provide special error message if getpeereid is a stub */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"peer authentication is not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get peer credentials: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* clear errno before call */</comment>
	<expr_stmt><expr><name>pw</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><name>uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pw</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not look up local user ID %ld: %s"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>uid</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"user does not exist"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>ident_user</name></expr></argument>, <argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>, <argument><expr><name>IDENT_USERNAME_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>ident_user</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>


<comment type="block">/*----------------------------------------------------------------
 * PAM authentication system
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>

<comment type="block">/*
 * PAM conversation function
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pam_passwd_conv_proc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pam_message</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>,
					 <parameter><decl><type><name><name>struct</name> <name>pam_response</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>resp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>appdata_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pam_response</name></name> <modifier>*</modifier></type><name>reply</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>appdata_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>passwd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>appdata_ptr</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Workaround for Solaris 2.6 where the PAM library is broken and does
		 * not pass appdata_ptr to the conversation routine
		 */</comment>
		<expr_stmt><expr><name>passwd</name> <operator>=</operator> <name>pam_passwd</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>resp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>				<comment type="block">/* in case of error exit */</comment>

	<if_stmt><if>if <condition>(<expr><name>num_msg</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>num_msg</name> <operator>&gt;</operator> <name>PAM_MAX_NUM_MSG</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PAM_CONV_ERR</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Explicitly not using palloc here - PAM will free this memory in
	 * pam_end()
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>reply</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num_msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pam_response</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>PAM_CONV_ERR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_msg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>msg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>msg_style</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PAM_PROMPT_ECHO_OFF</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Password wasn't passed to PAM the first time around -
					 * let's go ask the client to send a password, which we
					 * then stuff into PAM.
					 */</comment>
					<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>pam_port_cludge</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>pam_port_cludge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Client didn't want to send password.  We
						 * intentionally do not log anything about this.
						 */</comment>
						<goto>goto <name>fail</name>;</goto>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp_retcode</name> <operator>=</operator> <name>PAM_SUCCESS</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PAM_ERROR_MSG</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error from underlying PAM layer: %s"</literal></expr></argument>,
								<argument><expr><name><name>msg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* FALL THROUGH */</comment>
			<case>case <expr><name>PAM_TEXT_INFO</name></expr>:</case>
				<comment type="block">/* we don't bother to log TEXT_INFO messages */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp_retcode</name> <operator>=</operator> <name>PAM_SUCCESS</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unsupported PAM conversation %d/\"%s\""</literal></expr></argument>,
					 <argument><expr><name><name>msg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>msg_style</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>msg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>msg</name></expr> ?</condition><then> <expr><name><name>msg</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>msg</name></expr> </then><else>: <expr><literal type="string">"(none)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>fail</name>;</goto>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>resp</name> <operator>=</operator> <name>reply</name></expr>;</expr_stmt>
	<return>return <expr><name>PAM_SUCCESS</name></expr>;</return>

<label><name>fail</name>:</label>
	<comment type="block">/* free up whatever we allocated */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_msg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>reply</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>resp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>PAM_CONV_ERR</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check authentication against PAM.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckPAMAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>password</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pam_handle_t</name> <modifier>*</modifier></type><name>pamh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can't entirely rely on PAM to pass through appdata --- it appears
	 * not to work on at least Solaris 2.6.  So use these ugly static
	 * variables instead.
	 */</comment>
	<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>password</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pam_port_cludge</name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the application data portion of the conversation struct.  This is
	 * later used inside the PAM conversation to pass the password to the
	 * authentication module.
	 */</comment>
	<expr_stmt><expr><name><name>pam_passw_conv</name><operator>.</operator><name>appdata_ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>password</name></expr>;</expr_stmt> <comment type="block">/* from password above,
													 * not allocated */</comment>

	<comment type="block">/* Optionally, one can set the service name in pg_hba.conf */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>pamservice</name></name> <operator>&amp;&amp;</operator> <name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>pamservice</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_start</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>pamservice</name></name></expr></argument>, <argument><expr><literal type="string">"pgsql@"</literal></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>pam_passw_conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pamh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_start</name><argument_list>(<argument><expr><name>PGSQL_PAM_SERVICE</name></expr></argument>, <argument><expr><literal type="string">"pgsql@"</literal></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>pam_passw_conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pamh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create PAM authenticator: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* Unset pam_passwd */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_set_item</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>PAM_USER</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pam_set_item(PAM_USER) failed: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* Unset pam_passwd */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>conntype</name></name> <operator>!=</operator> <name>ctLocal</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>hostinfo</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>pam_use_hostname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
									<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"pg_getnameinfo_all() failed: %s"</literal></expr></argument>,
									 <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_set_item</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>PAM_RHOST</name></expr></argument>, <argument><expr><name>hostinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pam_set_item(PAM_RHOST) failed: %s"</literal></expr></argument>,
							<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_set_item</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>PAM_CONV</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pam_passw_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pam_set_item(PAM_CONV) failed: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* Unset pam_passwd */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_authenticate</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pam_authenticate failed: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* Unset pam_passwd */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_acct_mgmt</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pam_acct_mgmt failed: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* Unset pam_passwd */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>pam_end</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>PAM_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not release PAM authenticator: %s"</literal></expr></argument>,
						<argument><expr><call><name>pam_strerror</name><argument_list>(<argument><expr><name>pamh</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pam_passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* Unset pam_passwd */</comment>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name>retval</name> <operator>==</operator> <name>PAM_SUCCESS</name></expr> ?</condition><then> <expr><name>STATUS_OK</name></expr> </then><else>: <expr><name>STATUS_ERROR</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PAM */</comment>


<comment type="block">/*----------------------------------------------------------------
 * BSD authentication system
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckBSDAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>

	<comment type="block">/* Send regular password request to client, and get the response */</comment>
	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ask the BSD auth system to verify password.  Note that auth_userokay
	 * will overwrite the password string with zeroes, but it's just a
	 * temporary string so we don't care.
	 */</comment>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>auth_userokay</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"auth-postgresql"</literal></expr></argument>, <argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_BSD_AUTH */</comment>


<comment type="block">/*----------------------------------------------------------------
 * LDAP authentication system
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>errdetail_for_ldap</name><parameter_list>(<parameter><decl><type><name>LDAP</name> <modifier>*</modifier></type><name>ldap</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize a connection to the LDAP server, including setting up
 * TLS if requested.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>InitializeLDAPConnection</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>LDAP</name> <modifier>*</modifier><modifier>*</modifier></type><name>ldap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scheme</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ldapversion</name> <init>= <expr><name>LDAP_VERSION3</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scheme</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapscheme</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scheme</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>scheme</name> <operator>=</operator> <literal type="string">"ldap"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"ldaps"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ldap</name> <operator>=</operator> <call><name>ldap_sslinit</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ldap</name> <operator>=</operator> <call><name>ldap_init</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ldap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not initialize LDAP: error code %d"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>LdapGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LDAP_INITIALIZE</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostnames</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>uris</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We have a space-separated list of hostnames.  Convert it
		 * to a space-separated list of URIs.
		 */</comment>
		<do>do
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hostname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>hostname_size</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new_uris</name></decl>;</decl_stmt>

			<comment type="block">/* Find the leading hostname. */</comment>
			<expr_stmt><expr><name>hostname_size</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>hostnames</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hostname</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>hostnames</name></expr></argument>, <argument><expr><name>hostname_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Append a URI for this hostname. */</comment>
			<expr_stmt><expr><name>new_uris</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s://%s:%d"</literal></expr></argument>,
								<argument><expr><ternary><condition><expr><name>uris</name></expr> ?</condition><then> <expr><name>uris</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><name>uris</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><name>scheme</name></expr></argument>,
								<argument><expr><name>hostname</name></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>uris</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>uris</name> <operator>=</operator> <name>new_uris</name></expr>;</expr_stmt>

			<comment type="block">/* Step over this hostname and any spaces. */</comment>
			<expr_stmt><expr><name>hostnames</name> <operator>+=</operator> <name>hostname_size</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>hostnames</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>hostnames</name></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block> while <condition>(<expr><operator>*</operator><name>hostnames</name></expr>)</condition>;</do>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldap_initialize</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not initialize LDAP: %s"</literal></expr></argument>,
							<argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"ldaps"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ldaps not supported with this LDAP library"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ldap</name> <operator>=</operator> <call><name>ldap_init</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ldap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not initialize LDAP: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>ldap_set_option</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>, <argument><expr><name>LDAP_OPT_PROTOCOL_VERSION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ldapversion</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set LDAP protocol version: %s"</literal></expr></argument>,
						<argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldaptls</name></name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>ldap_start_tls_s</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><specifier>static</specifier> <name>__ldap_start_tls_sA</name></type> <name>_ldap_start_tls_sA</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>_ldap_start_tls_sA</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Need to load this function dynamically because it does not
			 * exist on Windows 2000, and causes a load error for the whole
			 * exe if referenced.
			 */</comment>
			<decl_stmt><decl><type><name>HANDLE</name></type>		<name>ldaphandle</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ldaphandle</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"WLDAP32.DLL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ldaphandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * should never happen since we import other files from
				 * wldap32, but check anyway
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not load wldap32.dll"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>_ldap_start_tls_sA</name> <operator>=</operator> <operator>(</operator><name>__ldap_start_tls_sA</name><operator>)</operator> <call><name>GetProcAddress</name><argument_list>(<argument><expr><name>ldaphandle</name></expr></argument>, <argument><expr><literal type="string">"ldap_start_tls_sA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>_ldap_start_tls_sA</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not load function _ldap_start_tls_sA in wldap32.dll"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"LDAP over SSL is not supported on this platform."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Leak LDAP handle on purpose, because we need the library to
			 * stay open. This is ok because it will only ever be leaked once
			 * per process and is automatically cleaned up on process exit.
			 */</comment>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>_ldap_start_tls_sA</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start LDAP TLS session: %s"</literal></expr></argument>,
							<argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><operator>*</operator><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Placeholders recognized by FormatSearchFilter.  For now just one. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LPH_USERNAME</name></cpp:macro> <cpp:value>"$username"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LPH_USERNAME_LEN</name></cpp:macro> <cpp:value>(sizeof(LPH_USERNAME) - 1)</cpp:value></cpp:define>

<comment type="block">/* Not all LDAP implementations define this. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LDAP_NO_ATTRS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAP_NO_ATTRS</name></cpp:macro> <cpp:value>"1.1"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Not all LDAP implementations define this. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LDAPS_PORT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LDAPS_PORT</name></cpp:macro> <cpp:value>636</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Return a newly allocated C string copied from "pattern" with all
 * occurrences of the placeholder "$username" replaced with "user_name".
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>FormatSearchFilter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>output</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>pattern</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>LPH_USERNAME</name></expr></argument>, <argument><expr><name>LPH_USERNAME_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pattern</name> <operator>+=</operator> <name>LPH_USERNAME_LEN</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>*</operator><name>pattern</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name><name>output</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform LDAP authentication
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckLDAPAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LDAP</name>	   <modifier>*</modifier></type><name>ldap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fulluser</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name> <operator>||</operator> <name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LDAP server not specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapscheme</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapscheme</name></name></expr></argument>, <argument><expr><literal type="string">"ldaps"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>=</operator> <name>LDAPS_PORT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>=</operator> <name>LDAP_PORT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* client wouldn't send password */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>InitializeLDAPConnection</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ldap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Error message already sent */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbasedn</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First perform an LDAP search to find the DN for the user we are
		 * trying to log in as.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filter</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LDAPMessage</name> <modifier>*</modifier></type><name>search_message</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LDAPMessage</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>attributes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>LDAP_NO_ATTRS</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Disallow any characters that we would otherwise need to escape,
		 * since they aren't really reasonable in a username anyway. Allowing
		 * them would make it possible to inject any kind of custom filters in
		 * the LDAP filter.
		 */</comment>
		<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr>;</init> <condition><expr><operator>*</operator><name>c</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator>
				<operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator>
				<operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
				<operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator>
				<operator>*</operator><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid character in user name for LDAP authentication"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Bind with a pre-defined username/password (if available) for
		 * searching. If none is specified, this turns into an anonymous bind.
		 */</comment>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>hba_password</name> <init>= <expr><call><name>get_ldap_password</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldap_simple_bind_s</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr> ?</condition><then> <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							   <argument><expr><name>hba_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hba_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not perform initial LDAP bind for ldapbinddn \"%s\" on server \"%s\": %s"</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr> ?</condition><then> <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>,
							<argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Build a custom filter or a single attribute filter? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filter</name> <operator>=</operator> <call><name>FormatSearchFilter</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filter</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%s=%s)"</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>filter</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(uid=%s)"</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>search_message</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldap_search_s</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>,
						  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapbasedn</name></name></expr></argument>,
						  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapscope</name></name></expr></argument>,
						  <argument><expr><name>filter</name></expr></argument>,
						  <argument><expr><name>attributes</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not search LDAP for filter \"%s\" on server \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>search_message</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>ldap_count_entries</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LDAP user \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"LDAP search for filter \"%s\" on server \"%s\" returned no entries."</literal></expr></argument>,
								   <argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LDAP user \"%s\" is not unique"</literal></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"LDAP search for filter \"%s\" on server \"%s\" returned %d entry."</literal></expr></argument>,
										  <argument><expr><literal type="string">"LDAP search for filter \"%s\" on server \"%s\" returned %d entries."</literal></expr></argument>,
										  <argument><expr><name>count</name></expr></argument>,
										  <argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ldap_first_entry</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn</name> <operator>=</operator> <call><name>ldap_get_dn</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>error</name></decl>;</decl_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ldap_get_option</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>LDAP_OPT_ERROR_NUMBER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not get dn for the first entry matching \"%s\" on server \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>,
							<argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>fulluser</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_memfree</name><argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_msgfree</name><argument_list>(<argument><expr><name>search_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Unbind and disconnect from the LDAP server */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldap_unbind_s</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unbind after searching for user \"%s\" on server \"%s\""</literal></expr></argument>,
							<argument><expr><name>fulluser</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fulluser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Need to re-initialize the LDAP connection, so that we can bind to
		 * it with a different username.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>InitializeLDAPConnection</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ldap</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_ERROR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fulluser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Error message already sent */</comment>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fulluser</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapprefix</name></name></expr> ?</condition><then> <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapprefix</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsuffix</name></name></expr> ?</condition><then> <expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapsuffix</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ldap_simple_bind_s</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>fulluser</name></expr></argument>, <argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LDAP login failed for user \"%s\" on server \"%s\": %s"</literal></expr></argument>,
						<argument><expr><name>fulluser</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_for_ldap</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fulluser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ldap_unbind</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fulluser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a detail error message text to the current error if one can be
 * constructed from the LDAP 'diagnostic message'.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetail_for_ldap</name><parameter_list>(<parameter><decl><type><name>LDAP</name> <modifier>*</modifier></type><name>ldap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ldap_get_option</name><argument_list>(<argument><expr><name>ldap</name></expr></argument>, <argument><expr><name>LDAP_OPT_DIAGNOSTIC_MESSAGE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>LDAP_SUCCESS</name> <operator>&amp;&amp;</operator> <name>message</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"LDAP diagnostics: %s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ldap_memfree</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_ldap_password</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>ldapbindpasswd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Return password stored in YSQL_LDAP_BIND_PWD_ENV env var */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>ldapbindpasswd</name></expr></argument>, <argument><expr><literal type="string">"YSQL_LDAP_BIND_PWD_ENV"</literal></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"YSQL_LDAP_BIND_PWD_ENV"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"YSQL_LDAP_BIND_PWD_ENV"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected env variable YSQL_LDAP_BIND_PWD_ENV to be defined, got NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Return password as defined in hba.conf */</comment>
	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>ldapbindpasswd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_LDAP */</comment>


<comment type="block">/*----------------------------------------------------------------
 * SSL client certificate authentication
 *----------------------------------------------------------------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckCertAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we have received a username in the certificate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>peer_cn</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>peer_cn</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"certificate authentication failed for user \"%s\": client certificate contains no user name"</literal></expr></argument>,
						<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Just pass the certificate CN to the usermap check */</comment>
	<return>return <expr><call><name>check_usermap</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>peer_cn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*----------------------------------------------------------------
 * RADIUS authentication
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * RADIUS authentication is described in RFC2865 (and several others).
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_VECTOR_LENGTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_HEADER_LENGTH</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_MAX_PASSWORD_LENGTH</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<comment type="block">/* Maximum size of a RADIUS packet we will create or accept */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_BUFFER_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint8</name></type>		<name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>data</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>radius_attribute</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint8</name></type>		<name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>vector</name><index>[<expr><name>RADIUS_VECTOR_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* this is a bit longer than strictly necessary: */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pad</name><index>[<expr><name>RADIUS_BUFFER_SIZE</name> <operator>-</operator> <name>RADIUS_VECTOR_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>radius_packet</name>;</typedef>

<comment type="block">/* RADIUS packet types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_ACCESS_REQUEST</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_ACCESS_ACCEPT</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_ACCESS_REJECT</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* RADIUS attributes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_USER_NAME</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_PASSWORD</name></cpp:macro>			<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_SERVICE_TYPE</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_NAS_IDENTIFIER</name></cpp:macro>	<cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* RADIUS service types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_AUTHENTICATE_ONLY</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* Seconds to wait - XXX: should be in a config variable! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_TIMEOUT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>radius_add_attribute</name><parameter_list>(<parameter><decl><type><name>radius_packet</name> <modifier>*</modifier></type><name>packet</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>radius_attribute</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>packet</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>RADIUS_BUFFER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * With remotely realistic data, this can never happen. But catch it
		 * just to make sure we don't overrun a buffer. We'll just skip adding
		 * the broken attribute, which will in the end cause authentication to
		 * fail.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			 <argument><expr><literal type="string">"Adding attribute code %d with length %d to radius packet would create oversize packet, ignoring"</literal></expr></argument>,
			 <argument><expr><name>type</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>attr</name> <operator>=</operator> <operator>(</operator><name>radius_attribute</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>packet</name> <operator>+</operator> <name><name>packet</name><operator>-&gt;</operator><name>length</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attribute</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>		<comment type="block">/* total size includes type and length */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>length</name></name> <operator>+=</operator> <name><name>attr</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckRADIUSAuth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>server</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>secrets</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>radiusports</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>identifiers</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure struct alignment is correct */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>radius_packet</name></expr></argument>, <argument><expr><name>vector</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify parameters */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS server not specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS secret not specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send regular password request to client, and get the response */</comment>
	<expr_stmt><expr><call><name>sendAuthRequest</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>AUTH_REQ_PASSWORD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>recv_password_packet</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>passwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* client wouldn't send password */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>RADIUS_MAX_PASSWORD_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS authentication does not support passwords longer than %d characters"</literal></expr></argument>, <argument><expr><name>RADIUS_MAX_PASSWORD_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Loop over and try each server in order.
	 */</comment>
	<expr_stmt><expr><name>secrets</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>radiusports</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiusports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>identifiers</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiusidentifiers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>server</argument>, <argument>port-&gt;hba-&gt;radiusservers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><call><name>PerformRadiusTransaction</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>secrets</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><ternary><condition><expr><name>radiusports</name></expr> ?</condition><then> <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>radiusports</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
												   <argument><expr><ternary><condition><expr><name>identifiers</name></expr> ?</condition><then> <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
												   <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
												   <argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*------
		 * STATUS_OK = Login OK
		 * STATUS_ERROR = Login not OK, but try next server
		 * STATUS_EOF = Login not OK, and don't try next server
		 *------
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_OK</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>STATUS_EOF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * secret, port and identifiers either have length 0 (use default),
		 * length 1 (use the same everywhere) or the same length as servers.
		 * So if the length is &gt;1, we advance one step. In other cases, we
		 * don't and will then reuse the correct value.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>secrets</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>secrets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiusports</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>radiusports</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>radiusports</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name><operator>-&gt;</operator><name>radiusidentifiers</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>identifiers</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>identifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No servers left to try, so give up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>PerformRadiusTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>secret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>identifier</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passwd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>radius_packet</name></type> <name>radius_send_pack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>radius_packet</name></type> <name>radius_recv_pack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>radius_packet</name> <modifier>*</modifier></type><name>packet</name> <init>= <expr><operator>&amp;</operator><name>radius_send_pack</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>radius_packet</name> <modifier>*</modifier></type><name>receivepacket</name> <init>= <expr><operator>&amp;</operator><name>radius_recv_pack</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>radius_buffer</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>radius_send_pack</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>receive_buffer</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>radius_recv_pack</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>service</name> <init>= <expr><call><name>pg_hton32</name><argument_list>(<argument><expr><name>RADIUS_AUTHENTICATE_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>cryptvector</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encryptedpasswordlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name><name>encryptedpassword</name><index>[<expr><name>RADIUS_MAX_PASSWORD_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>md5trailer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>packetlength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgsocket</name></type>	<name>sock</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name></type> <name>localaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name></type> <name>remoteaddr</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name></type> <name>localaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name></type> <name>remoteaddr</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>serveraddrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>addrsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>fdset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>endtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<comment type="block">/* Assign default values */</comment>
	<if_stmt><if>if <condition>(<expr><name>portstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>portstr</name> <operator>=</operator> <literal type="string">"1812"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>identifier</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>identifier</name> <operator>=</operator> <literal type="string">"postgresql"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>portstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>server</name></expr></argument>, <argument><expr><name>portstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>||</operator> <operator>!</operator><name>serveraddrs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate RADIUS server name \"%s\" to address: %s"</literal></expr></argument>,
						<argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>serveraddrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* XXX: add support for multiple returned addresses? */</comment>

	<comment type="block">/* Construct RADIUS packet */</comment>
	<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>RADIUS_ACCESS_REQUEST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>RADIUS_HEADER_LENGTH</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_backend_random</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>packet</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name>RADIUS_VECTOR_LENGTH</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not generate random encryption vector"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>packet</name><operator>-&gt;</operator><name>vector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>radius_add_attribute</name><argument_list>(<argument><expr><name>packet</name></expr></argument>, <argument><expr><name>RADIUS_SERVICE_TYPE</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>service</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>radius_add_attribute</name><argument_list>(<argument><expr><name>packet</name></expr></argument>, <argument><expr><name>RADIUS_USER_NAME</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>user_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>user_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>radius_add_attribute</name><argument_list>(<argument><expr><name>packet</name></expr></argument>, <argument><expr><name>RADIUS_NAS_IDENTIFIER</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>identifier</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * RADIUS password attributes are calculated as: e[0] = p[0] XOR
	 * MD5(secret + Request Authenticator) for the first group of 16 octets,
	 * and then: e[i] = p[i] XOR MD5(secret + e[i-1]) for the following ones
	 * (if necessary)
	 */</comment>
	<expr_stmt><expr><name>encryptedpasswordlen</name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>RADIUS_VECTOR_LENGTH</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>RADIUS_VECTOR_LENGTH</name><operator>)</operator> <operator>*</operator> <name>RADIUS_VECTOR_LENGTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cryptvector</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>RADIUS_VECTOR_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>, <argument><expr><name>secret</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* for the first iteration, we use the Request Authenticator vector */</comment>
	<expr_stmt><expr><name>md5trailer</name> <operator>=</operator> <name><name>packet</name><operator>-&gt;</operator><name>vector</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>encryptedpasswordlen</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>RADIUS_VECTOR_LENGTH</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>md5trailer</name></expr></argument>, <argument><expr><name>RADIUS_VECTOR_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * .. and for subsequent iterations the result of the previous XOR
		 * (calculated below)
		 */</comment>
		<expr_stmt><expr><name>md5trailer</name> <operator>=</operator> <name>encryptedpassword</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_binary</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>RADIUS_VECTOR_LENGTH</name></expr></argument>, <argument><expr><name>encryptedpassword</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not perform MD5 encryption of password"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>+</operator> <name>RADIUS_VECTOR_LENGTH</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>encryptedpassword</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>passwd</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^</operator> <name><name>encryptedpassword</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>encryptedpassword</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal> <operator>^</operator> <name><name>encryptedpassword</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>radius_add_attribute</name><argument_list>(<argument><expr><name>packet</name></expr></argument>, <argument><expr><name>RADIUS_PASSWORD</name></expr></argument>, <argument><expr><name>encryptedpassword</name></expr></argument>, <argument><expr><name>encryptedpasswordlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Length needs to be in network order on the wire */</comment>
	<expr_stmt><expr><name>packetlength</name> <operator>=</operator> <name><name>packet</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>packet</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><name><name>packet</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>serveraddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ai_family</name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create RADIUS socket: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localaddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
	<expr_stmt><expr><name><name>localaddr</name><operator>.</operator><name>sin6_family</name></name> <operator>=</operator> <name><name>serveraddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ai_family</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localaddr</name><operator>.</operator><name>sin6_addr</name></name> <operator>=</operator> <name>in6addr_any</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>localaddr</name><operator>.</operator><name>sin6_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>localaddr</name><operator>.</operator><name>sin_family</name></name> <operator>=</operator> <name><name>serveraddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ai_family</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localaddr</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <name>INADDR_ANY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localaddr</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bind local RADIUS socket: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sendto</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>radius_buffer</name></expr></argument>, <argument><expr><name>packetlength</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><name><name>serveraddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ai_addr</name></expr></argument>, <argument><expr><name><name>serveraddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ai_addrlen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send RADIUS packet: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Don't need the server address anymore */</comment>
	<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>serveraddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out at what time we should time out. We can't just use a single
	 * call to select() with a timeout, since somebody can be sending invalid
	 * packets to our port thus causing us to retry in a loop and never time
	 * out.
	 *
	 * XXX: Using WaitLatchOrSocket() and doing a CHECK_FOR_INTERRUPTS() if
	 * the latch was set would improve the responsiveness to
	 * timeouts/cancellations.
	 */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endtime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>endtime</name><operator>.</operator><name>tv_sec</name></name> <operator>+=</operator> <name>RADIUS_TIMEOUT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>timeoutval</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>timeoutval</name> <operator>=</operator> <operator>(</operator><name><name>endtime</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000000</literal> <operator>+</operator> <name><name>endtime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000000</literal> <operator>+</operator> <name><name>now</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>timeoutval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timeout waiting for RADIUS response from %s"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>timeoutval</name> <operator>/</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name>timeoutval</name> <operator>%</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Anything else is an actual error */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not check status on RADIUS socket: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timeout waiting for RADIUS response from %s"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Attempt to read the response packet, and verify the contents.
		 *
		 * Any packet that's not actually a RADIUS packet, or otherwise does
		 * not validate as an explicit reject, is just ignored and we retry
		 * for another packet (until we reach the timeout). This is to avoid
		 * the possibility to denial-of-service the login by flooding the
		 * server with invalid packets on the port that we're expecting the
		 * RADIUS response on.
		 */</comment>

		<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>remoteaddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>packetlength</name> <operator>=</operator> <call><name>recvfrom</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>receive_buffer</name></expr></argument>, <argument><expr><name>RADIUS_BUFFER_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remoteaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>packetlength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read RADIUS response: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>remoteaddr</name><operator>.</operator><name>sin6_port</name></name> <operator>!=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name><name>remoteaddr</name><operator>.</operator><name>sin_port</name></name> <operator>!=</operator> <call><name>pg_hton16</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s was sent from incorrect port: %d"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>pg_ntoh16</name><argument_list>(<argument><expr><name><name>remoteaddr</name><operator>.</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s was sent from incorrect port: %d"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>pg_ntoh16</name><argument_list>(<argument><expr><name><name>remoteaddr</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>packetlength</name> <operator>&lt;</operator> <name>RADIUS_HEADER_LENGTH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s too short: %d"</literal></expr></argument>, <argument><expr><name>server</name></expr></argument>, <argument><expr><name>packetlength</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>packetlength</name> <operator>!=</operator> <call><name>pg_ntoh16</name><argument_list>(<argument><expr><name><name>receivepacket</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s has corrupt length: %d (actual length %d)"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>, <argument><expr><call><name>pg_ntoh16</name><argument_list>(<argument><expr><name><name>receivepacket</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>packetlength</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>packet</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name><name>receivepacket</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s is to a different request: %d (should be %d)"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>, <argument><expr><name><name>receivepacket</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>packet</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Verify the response authenticator, which is calculated as
		 * MD5(Code+ID+Length+RequestAuthenticator+Attributes+Secret)
		 */</comment>
		<expr_stmt><expr><name>cryptvector</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>packetlength</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>, <argument><expr><name>receivepacket</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* code+id+length */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>packet</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name>RADIUS_VECTOR_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request
																		 * authenticator, from
																		 * original packet */</comment>
		<if_stmt><if>if <condition>(<expr><name>packetlength</name> <operator>&gt;</operator> <name>RADIUS_HEADER_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* there may be no
													 * attributes at all */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name> <operator>+</operator> <name>RADIUS_HEADER_LENGTH</name></expr></argument>, <argument><expr><name>receive_buffer</name> <operator>+</operator> <name>RADIUS_HEADER_LENGTH</name></expr></argument>, <argument><expr><name>packetlength</name> <operator>-</operator> <name>RADIUS_HEADER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cryptvector</name> <operator>+</operator> <name>packetlength</name></expr></argument>, <argument><expr><name>secret</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_md5_binary</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>,
						   <argument><expr><name>packetlength</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>secret</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>encryptedpassword</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not perform MD5 encryption of received packet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cryptvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>receivepacket</name><operator>-&gt;</operator><name>vector</name></name></expr></argument>, <argument><expr><name>encryptedpassword</name></expr></argument>, <argument><expr><name>RADIUS_VECTOR_LENGTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s has incorrect MD5 signature"</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>receivepacket</name><operator>-&gt;</operator><name>code</name></name> <operator>==</operator> <name>RADIUS_ACCESS_ACCEPT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_OK</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>receivepacket</name><operator>-&gt;</operator><name>code</name></name> <operator>==</operator> <name>RADIUS_ACCESS_REJECT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_EOF</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RADIUS response from %s has invalid code (%d) for user \"%s\""</literal></expr></argument>,
							<argument><expr><name>server</name></expr></argument>, <argument><expr><name><name>receivepacket</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>user_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>							<comment type="block">/* while (true) */</comment>
</block_content>}</block></function>
</unit>
