<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/libpq/hba.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hba.c
 *	  Routines to handle host based authentication (that's the scheme
 *	  wherein you authenticate a user by seeing what IP address the system
 *	  says he comes from and choosing authentication method based on it).
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/libpq/hba.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/ifaddr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex/regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winldap.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ldap.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TOKEN</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_LINE</name></cpp:macro>	<cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* callback data for check_network_callback */</comment>
<typedef>typedef <type><struct>struct <name>check_network_data</name>
<block>{
	<decl_stmt><decl><type><name>IPCompareMethod</name></type> <name>method</name></decl>;</decl_stmt>		<comment type="block">/* test method */</comment>
	<decl_stmt><decl><type><name>SockAddr</name>   <modifier>*</modifier></type><name>raddr</name></decl>;</decl_stmt>			<comment type="block">/* client's actual address */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>			<comment type="block">/* set to true if match */</comment>
}</block></struct></type> <name>check_network_data</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>token_is_keyword</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(!t-&gt;quoted &amp;&amp; strcmp(t-&gt;string, k) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>token_matches</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(strcmp(t-&gt;string, k) == 0)</cpp:value></cpp:define>

<comment type="block">/*
 * A single string token lexed from a config file, together with whether
 * the token had been quoted.
 */</comment>
<typedef>typedef <type><struct>struct <name>HbaToken</name>
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>quoted</name></decl>;</decl_stmt>
}</block></struct></type> <name>HbaToken</name>;</typedef>

<comment type="block">/*
 * TokenizedLine represents one line lexed from a config file.
 * Each item in the "fields" list is a sub-list of HbaTokens.
 * We don't emit a TokenizedLine for empty or all-comment lines,
 * so "fields" is never NIL (nor are any of its sub-lists).
 * Exception: if an error occurs during tokenization, we might
 * have fields == NIL, in which case err_msg != NULL.
 */</comment>
<typedef>typedef <type><struct>struct <name>TokenizedLine</name>
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fields</name></decl>;</decl_stmt>			<comment type="block">/* List of lists of HbaTokens */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_num</name></decl>;</decl_stmt>		<comment type="block">/* Line number */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>raw_line</name></decl>;</decl_stmt>		<comment type="block">/* Raw line text */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_msg</name></decl>;</decl_stmt>		<comment type="block">/* Error message if any */</comment>
}</block></struct></type> <name>TokenizedLine</name>;</typedef>

<comment type="block">/*
 * pre-parsed content of HBA config file: list of HbaLine structs.
 * parsed_hba_context is the memory context where it lives.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>parsed_hba_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>parsed_hba_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The following character array contains the additional hardcoded HBA config
 * lines that are set internally.  These lines take priority over user defined
 * config lines.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>HardcodedHbaLines</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"local all postgres yb-tserver-key"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * pre-parsed content of ident mapping file: list of IdentLine structs.
 * parsed_ident_context is the memory context where it lives.
 *
 * NOTE: the IdentLine structs can contain pre-compiled regular expressions
 * that live outside the memory context. Before destroying or resetting the
 * memory context, they need to be explicitly free'd.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>parsed_ident_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>parsed_ident_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The following character array represents the names of the authentication
 * methods that are supported by PostgreSQL.
 *
 * Note: keep this in sync with the UserAuth enum in hba.h.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>UserAuthName</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"reject"</literal></expr>,
	<expr><literal type="string">"implicit reject"</literal></expr>,			<comment type="block">/* Not a user-visible option */</comment>
	<expr><literal type="string">"trust"</literal></expr>,
	<expr><literal type="string">"ident"</literal></expr>,
	<expr><literal type="string">"password"</literal></expr>,
	<expr><literal type="string">"md5"</literal></expr>,
	<expr><literal type="string">"scram-sha-256"</literal></expr>,
	<expr><literal type="string">"yb-tserver-key"</literal></expr>,			<comment type="block">/* For internal tserver-postgres connection */</comment>
	<expr><literal type="string">"gss"</literal></expr>,
	<expr><literal type="string">"sspi"</literal></expr>,
	<expr><literal type="string">"pam"</literal></expr>,
	<expr><literal type="string">"bsd"</literal></expr>,
	<expr><literal type="string">"ldap"</literal></expr>,
	<expr><literal type="string">"cert"</literal></expr>,
	<expr><literal type="string">"radius"</literal></expr>,
	<expr><literal type="string">"peer"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>tokenize_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tok_lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tokenize_hardcoded</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tok_lines_all</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TokenizedLine</name> <modifier>*</modifier></type><name>tokenize_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>line_number</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawline</name></decl></parameter>,
									<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>tokenize_inc_file</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tokens</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>outer_filename</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inc_filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_hba_auth_opt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hbaline</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>verify_option_list_length</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optionname</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>masters</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mastername</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>gethba_options</name><parameter_list>(<parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hba</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_hba_line</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hba</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_hba_view</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * isblank() exists in the ISO C99 spec, but it's not very portable yet,
 * so provide our own version.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_isblank</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Grab one token out of the string pointed to by *lineptr.
 *
 * Tokens are strings of non-blank
 * characters bounded by blank characters, commas, beginning of line, and
 * end of line. Blank means space or tab. Tokens can be delimited by
 * double quotes (this allows the inclusion of blanks, but not newlines).
 * Comments (started by an unquoted '#') are skipped.
 *
 * The token, if any, is returned at *buf (a buffer of size bufsz), and
 * *lineptr is advanced past the token.
 *
 * Also, we set *initial_quote to indicate whether there was quoting before
 * the first character.  (We use that to prevent "@x" from being treated
 * as a file inclusion request.  Note that @"x" should be so treated;
 * we want to allow that to support embedded spaces in file paths.)
 *
 * We set *terminating_comma to indicate whether the token is terminated by a
 * comma (which is not returned).
 *
 * In event of an error, log a message at ereport level elevel, and also
 * set *err_msg to a string describing the error.  Currently the only
 * possible error is token too long for buf.
 *
 * If successful: store null-terminated token at *buf and return true.
 * If no more tokens on line: set *buf = '\0' and return false.
 * If error: fill buf with truncated or misformatted token and return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>next_token</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lineptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>initial_quote</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>terminating_comma</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_buf</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>end_buf</name> <init>= <expr><name>buf</name> <operator>+</operator> <operator>(</operator><name>bufsz</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_quote</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>end_buf</name> <operator>&gt;</operator> <name>start_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>initial_quote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>terminating_comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Move over any whitespace and commas preceding the next token */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>++</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_isblank</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">','</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></while>

	<comment type="block">/*
	 * Build a token in buf of next characters up to EOL, unquoted comma, or
	 * unquoted whitespace.
	 */</comment>
	<while>while <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>!</operator><call><name>pg_isblank</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>in_quote</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* skip comments to EOL */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_quote</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>++</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<empty_stmt>;</empty_stmt></block_content></block></while>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>&gt;=</operator> <name>end_buf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"authentication file token too long, skipping: \"%s\""</literal></expr></argument>,
							<argument><expr><name>start_buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"authentication file token too long"</literal></expr>;</expr_stmt>
			<comment type="block">/* Discard remainder of line */</comment>
			<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>++</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<empty_stmt>;</empty_stmt></block_content></block></while>
			<comment type="block">/* Un-eat the '\0', in case we're called again */</comment>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we do not pass back a terminating comma in the token */</comment>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_quote</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>terminating_comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>was_quote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Literal double-quote is two double-quotes */</comment>
		<if_stmt><if>if <condition>(<expr><name>in_quote</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>was_quote</name> <operator>=</operator> <operator>!</operator><name>was_quote</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>was_quote</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>saw_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>start_buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>initial_quote</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Un-eat the char right after the token (critical in case it is '\0',
	 * else next call will read past end of string).
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>lineptr</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>saw_quote</name> <operator>||</operator> <name>buf</name> <operator>&gt;</operator> <name>start_buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a palloc'd HbaToken struct, copying the given string.
 */</comment>
<function><type><specifier>static</specifier> <name>HbaToken</name> <modifier>*</modifier></type>
<name>make_hba_token</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quoted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>hbatoken</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>toklen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we copy string into same palloc block as the struct */</comment>
	<expr_stmt><expr><name>hbatoken</name> <operator>=</operator> <operator>(</operator><name>HbaToken</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HbaToken</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hbatoken</name><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>hbatoken</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HbaToken</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hbatoken</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <name>quoted</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hbatoken</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hbatoken</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy a HbaToken struct into freshly palloc'd memory.
 */</comment>
<function><type><specifier>static</specifier> <name>HbaToken</name> <modifier>*</modifier></type>
<name>copy_hba_token</name><parameter_list>(<parameter><decl><type><name>HbaToken</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>make_hba_token</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>quoted</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Tokenize one HBA field from a line, handling file inclusion and comma lists.
 *
 * filename: current file's pathname (needed to resolve relative pathnames)
 * *lineptr: current line pointer, which will be advanced past field
 *
 * In event of an error, log a message at ereport level elevel, and also
 * set *err_msg to a string describing the error.  Note that the result
 * may be non-NIL anyway, so *err_msg must be tested to determine whether
 * there was an error.
 *
 * The result is a List of HbaToken structs, one for each token in the field,
 * or NIL if we reached EOL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>next_field_expand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lineptr</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAX_TOKEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>trailing_comma</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>initial_quote</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tokens</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>next_token</name><argument_list>(<argument><expr><name>lineptr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>initial_quote</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trailing_comma</name></expr></argument>,
						<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Is this referencing a file? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>initial_quote</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>tokenize_inc_file</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name>make_hba_token</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>initial_quote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>trailing_comma</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>err_msg</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>;</do>

	<return>return <expr><name>tokens</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tokenize_inc_file
 *		Expand a file included from another file into an hba "field"
 *
 * Opens and tokenises a file included from another HBA config file with @,
 * and returns all values found therein as a flat list of HbaTokens.  If a
 * @-token is found, recursively expand it.  The newly read tokens are
 * appended to "tokens" (so that foo,bar,@baz does what you expect).
 * All new tokens are allocated in caller's memory context.
 *
 * In event of an error, log a message at ereport level elevel, and also
 * set *err_msg to a string describing the error.  Note that the result
 * may be non-NIL anyway, so *err_msg must be tested to determine whether
 * there was an error.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>tokenize_inc_file</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tokens</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>outer_filename</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inc_filename</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
				  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inc_fullname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>inc_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inc_lines</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inc_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>linecxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_absolute_path</name><argument_list>(<argument><expr><name>inc_filename</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* absolute path is taken as-is */</comment>
		<expr_stmt><expr><name>inc_fullname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>inc_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* relative path is relative to dir of calling file */</comment>
		<expr_stmt><expr><name>inc_fullname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outer_filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
									   <call><name>strlen</name><argument_list>(<argument><expr><name>inc_filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><name>outer_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>join_path_components</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><name>inc_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>inc_file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inc_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open secondary authentication file \"@%s\" as \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>inc_filename</name></expr></argument>, <argument><expr><name>inc_fullname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"could not open secondary authentication file \"@%s\" as \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name>inc_filename</name></expr></argument>, <argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>tokens</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* There is possible recursion here if the file contains @ */</comment>
	<expr_stmt><expr><name>linecxt</name> <operator>=</operator> <call><name>tokenize_file</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>, <argument><expr><name>inc_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inc_lines</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>inc_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>inc_fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy all tokens found in the file and append to the tokens list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>inc_line</argument>, <argument>inc_lines</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name> <init>= <expr><operator>(</operator><name>TokenizedLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>inc_line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inc_field</name></decl>;</decl_stmt>

		<comment type="block">/* If any line has an error, propagate that up to caller */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>inc_field</argument>, <argument>tok_line-&gt;fields</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inc_tokens</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>inc_field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inc_token</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>inc_token</argument>, <argument>inc_tokens</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>inc_token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name>copy_hba_token</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tokens</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Tokenize the given file.
 *
 * The output is a list of TokenizedLine structs; see struct definition above.
 *
 * filename: the absolute path to the target file
 * file: the already-opened target file
 * tok_lines: receives output list
 * elevel: message logging level
 *
 * Errors are reported by logging messages at ereport level elevel and by
 * adding TokenizedLine structs containing non-null err_msg fields to the
 * output list.
 *
 * Return value is a memory context which contains all memory allocated by
 * this function (it's a child of caller's context).
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>tokenize_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tok_lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_number</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>linecxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>linecxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><literal type="string">"tokenize_file"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>tok_lines</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>rawline</name><index>[<expr><name>MAX_LINE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fgets</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* normal EOF */</comment>
			<comment type="block">/* I/O error! */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %s"</literal></expr></argument>,
							   <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rawline</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MAX_LINE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Line too long! */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"authentication file line too long"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_number</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>err_msg</name> <operator>=</operator> <literal type="string">"authentication file line too long"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tok_line</name> <operator>=</operator> <call><name>tokenize_line</name><argument_list>(<argument><expr><name>filename</name></expr></argument>,
								 <argument><expr><name>elevel</name></expr></argument>,
								 <argument><expr><name>line_number</name></expr></argument>,
								 <argument><expr><name>rawline</name></expr></argument>,
								 <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tok_line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tok_lines</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tok_lines</name></expr></argument>, <argument><expr><name>tok_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>line_number</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>linecxt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Tokenize the hardcoded configuration lines.
 *
 * The output is a list of TokenizedLine structs; see struct definition above.
 *
 * tok_lines: receives output list
 * elevel: message logging level
 *
 * Errors are reported by logging messages at ereport level elevel and by
 * adding TokenizedLine structs containing non-null err_msg fields to the
 * output list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tokenize_hardcoded</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>tok_lines</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_number</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>tok_lines</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HardcodedHbaLines</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>err_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tok_line</name> <operator>=</operator> <call><name>tokenize_line</name><argument_list>(<argument><expr><literal type="string">"(hardcoded: no filename)"</literal></expr></argument> <comment type="block">/* filename */</comment>,
								 <argument><expr><name>elevel</name></expr></argument>,
								 <argument><expr><name>line_number</name></expr></argument>,
								 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>HardcodedHbaLines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tok_line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>tok_lines</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>tok_lines</name></expr></argument>, <argument><expr><name>tok_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>line_number</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Tokenize the given line.
 *
 * The output is a TokenizedLine struct.
 *
 * filename: the absolute path to the target file
 * elevel: message logging level
 * line_number: line in the target file
 * rawline: the input line (strip trailing line breaks)
 * err_msg: error message (inherit it, set it, or leave it null)
 *
 * Errors are reported by logging messages at ereport level elevel and by
 * putting a non-null err_msg in the TokenizedLine struct.
 *
 * Return value is a palloc'd tokenized line.
 */</comment>
<function><type><specifier>static</specifier> <name>TokenizedLine</name> <modifier>*</modifier></type>
<name>tokenize_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>line_number</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawline</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lineptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_line</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rawline</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><name>ERRCODE_INTERNAL_ERROR</name><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"line is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Strip trailing linebreak from rawline */</comment>
	<expr_stmt><expr><name>lineptr</name> <operator>=</operator> <name>rawline</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lineptr</name> <operator>&gt;=</operator> <name>rawline</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>lineptr</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>lineptr</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lineptr</name><operator>--</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Parse fields */</comment>
	<expr_stmt><expr><name>lineptr</name> <operator>=</operator> <name>rawline</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>lineptr</name> <operator>&amp;&amp;</operator> <name>err_msg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>current_field</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_field</name> <operator>=</operator> <call><name>next_field_expand</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineptr</name></expr></argument>,
										  <argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* add field to line, unless we are at EOL or comment start */</comment>
		<if_stmt><if>if <condition>(<expr><name>current_field</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>current_line</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>current_line</name></expr></argument>, <argument><expr><name>current_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Reached EOL; emit line unless it's boring */</comment>
	<if_stmt><if>if <condition>(<expr><name>current_line</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>err_msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tok_line</name> <operator>=</operator> <operator>(</operator><name>TokenizedLine</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TokenizedLine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok_line</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <name>current_line</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok_line</name><operator>-&gt;</operator><name>line_num</name></name> <operator>=</operator> <name>line_number</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok_line</name><operator>-&gt;</operator><name>raw_line</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>rawline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name> <operator>=</operator> <name>err_msg</name></expr>;</expr_stmt>
		<return>return <expr><name>tok_line</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Does user belong to role?
 *
 * userid is the OID of the role given as the attempted login identifier.
 * We check to see if it is a member of the specified role name.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_member</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* if user not exist, say "no" */</comment>

	<expr_stmt><expr><name>roleid</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* if target role not exist, say "no" */</comment>

	<comment type="block">/*
	 * See if user is directly or indirectly a member of role. For this
	 * purpose, a superuser is not considered to be automatically a member of
	 * the role, so group auth only applies to explicit membership.
	 */</comment>
	<return>return <expr><call><name>is_member_of_role_nosuper</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check HbaToken list for a match to role, allowing group names.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>role</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tokens</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>tokens</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tok</name><operator>-&gt;</operator><name>quoted</name></name> <operator>&amp;&amp;</operator> <name><name>tok</name><operator>-&gt;</operator><name>string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_member</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>string</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_matches</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see if db/role combination matches HbaToken list.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_db</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>role</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tokens</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>tokens</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>am_walsender</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_db_walsender</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * physical replication walsender connections can only match
			 * replication keyword
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"sameuser"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"samegroup"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"samerole"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_member</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>			<comment type="block">/* never match this if not walsender */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>token_matches</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ipv4eq</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ipv6eq</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>sin6_addr</name><operator>.</operator><name>s6_addr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>sin6_addr</name><operator>.</operator><name>s6_addr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_IPV6 */</comment>

<comment type="block">/*
 * Check whether host name matches pattern.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hostname_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>actual_hostname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>		<comment type="block">/* suffix match */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>hlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>actual_hostname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hlen</name> <operator>&lt;</operator> <name>plen</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>actual_hostname</name> <operator>+</operator> <operator>(</operator><name>hlen</name> <operator>-</operator> <name>plen</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>actual_hostname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see if a connecting IP matches a given host name.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_hostname</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>gai</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Quick out if remote host name already known bad */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_resolv</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Lookup remote host name if not already done */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>remote_hostname</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_hostname</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
								 <argument><expr><name>remote_hostname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_hostname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><name>NI_NAMEREQD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remember failure; don't complain in the postmaster log yet */</comment>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_resolv</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_errcode</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>remote_hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now see if remote host name matches this pg_hba line */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hostname_match</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we already verified the forward lookup, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_resolv</name></name> <operator>==</operator> <operator>+</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Lookup IP from host name and check against original IP */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember failure; don't complain in the postmaster log yet */</comment>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_resolv</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_errcode</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>gai</name> <operator>=</operator> <name>gai_result</name></expr>;</init> <condition><expr><name>gai</name></expr>;</condition> <incr><expr><name>gai</name> <operator>=</operator> <name><name>gai</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>gai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>gai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ipv4eq</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <name><name>gai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
						   <argument><expr><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
			<if type="elseif">else if <condition>(<expr><name><name>gai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ipv6eq</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <name><name>gai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
						   <argument><expr><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>gai_result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"pg_hba.conf host name \"%s\" rejected because address resolution did not return a match with IP address of client"</literal></expr></argument>,
			 <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>remote_hostname_resolv</name></name> <operator>=</operator> <ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see if a connecting IP matches the given address and netmask.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_ip</name><parameter_list>(<parameter><decl><type><name>SockAddr</name> <modifier>*</modifier></type><name>raddr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>raddr</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name><name>addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>&amp;&amp;</operator>
		<call><name>pg_range_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>raddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
						  <argument><expr><operator>(</operator>struct <name>sockaddr_storage</name> <operator>*</operator><operator>)</operator> <name>addr</name></expr></argument>,
						  <argument><expr><operator>(</operator>struct <name>sockaddr_storage</name> <operator>*</operator><operator>)</operator> <name>mask</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_foreach_ifaddr callback: does client addr match this machine interface?
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_network_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>netmask</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_network_data</name> <modifier>*</modifier></type><name>cn</name> <init>= <expr><operator>(</operator><name>check_network_data</name> <operator>*</operator><operator>)</operator> <name>cb_data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>mask</name></decl>;</decl_stmt>

	<comment type="block">/* Already found a match? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>result</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>method</name></name> <operator>==</operator> <name>ipCmpSameHost</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make an all-ones netmask of appropriate length for family */</comment>
		<expr_stmt><expr><call><name>pg_sockaddr_cidr_mask</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>sa_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>check_ip</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Use the netmask of the interface itself */</comment>
		<expr_stmt><expr><name><name>cn</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>check_ip</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>netmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Use pg_foreach_ifaddr to check a samehost or samenet match
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_same_host_or_net</name><parameter_list>(<parameter><decl><type><name>SockAddr</name> <modifier>*</modifier></type><name>raddr</name></decl></parameter>, <parameter><decl><type><name>IPCompareMethod</name></type> <name>method</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>check_network_data</name></type> <name>cn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cn</name><operator>.</operator><name>method</name></name> <operator>=</operator> <name>method</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cn</name><operator>.</operator><name>raddr</name></name> <operator>=</operator> <name>raddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cn</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_foreach_ifaddr</name><argument_list>(<argument><expr><name>check_network_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"error enumerating network interfaces: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>cn</name><operator>.</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Macros used to check and report on invalid configuration options.
 * On error: log a message at level elevel, set *err_msg, and exit the function.
 * These macros are not as general-purpose as they look, because they know
 * what the calling function's error-exit value is.
 *
 * INVALID_AUTH_OPTION = reports when an option is specified for a method where it's
 *						 not supported.
 * REQUIRE_AUTH_OPTION = same as INVALID_AUTH_OPTION, except it also checks if the
 *						 method is actually the one specified. Used as a shortcut when
 *						 the option is only valid for one authentication method.
 * MANDATORY_AUTH_ARG  = check if a required option is set for an authentication method,
 *						 reporting error if it's not.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_AUTH_OPTION</name><parameter_list>(<parameter><type><name>optname</name></type></parameter>, <parameter><type><name>validmethods</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	ereport(elevel, \
			(errcode(ERRCODE_CONFIG_FILE_ERROR), \
			 <comment type="block">/* translator: the second %s is a list of auth methods */</comment> \
			 errmsg("authentication option \"%s\" is only valid for authentication methods %s", \
					optname, _(validmethods)), \
			 errcontext("line %d of configuration file \"%s\"", \
					line_num, HbaFileName))); \
	*err_msg = psprintf("authentication option \"%s\" is only valid for authentication methods %s", \
						optname, validmethods); \
	return false; \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE_AUTH_OPTION</name><parameter_list>(<parameter><type><name>methodval</name></type></parameter>, <parameter><type><name>optname</name></type></parameter>, <parameter><type><name>validmethods</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (hbaline-&gt;auth_method != methodval) \
		INVALID_AUTH_OPTION(optname, validmethods); \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MANDATORY_AUTH_ARG</name><parameter_list>(<parameter><type><name>argvar</name></type></parameter>, <parameter><type><name>argname</name></type></parameter>, <parameter><type><name>authname</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (argvar == NULL) { \
		ereport(elevel, \
				(errcode(ERRCODE_CONFIG_FILE_ERROR), \
				 errmsg("authentication method \"%s\" requires argument \"%s\" to be set", \
						authname, argname), \
				 errcontext("line %d of configuration file \"%s\"", \
						line_num, HbaFileName))); \
		*err_msg = psprintf("authentication method \"%s\" requires argument \"%s\" to be set", \
							authname, argname); \
		return NULL; \
	} \
} while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * Macros for handling pg_ident problems.
 * Much as above, but currently the message level is hardwired as LOG
 * and there is no provision for an err_msg string.
 *
 * IDENT_FIELD_ABSENT:
 * Log a message and exit the function if the given ident field ListCell is
 * not populated.
 *
 * IDENT_MULTI_VALUE:
 * Log a message and exit the function if the given ident token List has more
 * than one element.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_FIELD_ABSENT</name><parameter_list>(<parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (!field) { \
		ereport(LOG, \
				(errcode(ERRCODE_CONFIG_FILE_ERROR), \
				 errmsg("missing entry in file \"%s\" at end of line %d", \
						IdentFileName, line_num))); \
		return NULL; \
	} \
} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_MULTI_VALUE</name><parameter_list>(<parameter><type><name>tokens</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (tokens-&gt;length &gt; 1) { \
		ereport(LOG, \
				(errcode(ERRCODE_CONFIG_FILE_ERROR), \
				 errmsg("multiple values in ident field"), \
				 errcontext("line %d of configuration file \"%s\"", \
							line_num, IdentFileName))); \
		return NULL; \
	} \
} while (0)</cpp:value></cpp:define>


<comment type="block">/*
 * Parse one tokenised line from the hba config file and store the result in a
 * HbaLine structure.
 *
 * If parsing fails, log a message at ereport level elevel, store an error
 * string in tok_line-&gt;err_msg, and return NULL.  (Some non-error conditions
 * can also result in such messages.)
 *
 * Note: this function leaks memory when an error occurs.  Caller is expected
 * to have set a memory context that will be reset if this function returns
 * NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>HbaLine</name> <modifier>*</modifier></type>
<name>parse_hba_line</name><parameter_list>(<parameter><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_num</name> <init>= <expr><name><name>tok_line</name><operator>-&gt;</operator><name>line_num</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name> <init>= <expr><operator>&amp;</operator><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cidr_slash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>unsupauth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tokens</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tokencell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaLine</name>    <modifier>*</modifier></type><name>parsedline</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parsedline</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HbaLine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name>line_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>rawline</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>raw_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the record type. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>fields</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tokens</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple values specified for connection type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify exactly one connection type per line."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"multiple values specified for connection type"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"local"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>=</operator> <name>ctLocal</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local connections are not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"local connections are not supported by this build"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"hostssl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"hostnossl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>

		<if_stmt><if>if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>string</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition>	<comment type="block">/* "hostssl" */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>=</operator> <name>ctHostSSL</name></expr>;</expr_stmt>
			<comment type="block">/* Log a warning if SSL support is not active */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableSSL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostssl record cannot match because SSL is disabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set ssl = on in postgresql.conf."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"hostssl record cannot match because SSL is disabled"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostssl record cannot match because SSL is not supported by this build"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Compile with --with-openssl to use SSL connections."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"hostssl record cannot match because SSL is not supported by this build"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>token</name><operator>-&gt;</operator><name>string</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition>	<comment type="block">/* "hostnossl" */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>=</operator> <name>ctHostNoSSL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* "host" */</comment>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>=</operator> <name>ctHost</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>							<comment type="block">/* record type */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid connection type \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid connection type \"%s\""</literal></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Get the databases. */</comment>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>field</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-line before database specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"end-of-line before database specification"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>databases</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>tokencell</argument>, <argument>tokens</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>databases</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>databases</name></name></expr></argument>,
										<argument><expr><call><name>copy_hba_token</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>tokencell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Get the roles. */</comment>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>field</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-line before role specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"end-of-line before role specification"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>roles</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>tokencell</argument>, <argument>tokens</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>roles</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>,
									<argument><expr><call><name>copy_hba_token</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>tokencell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>!=</operator> <name>ctLocal</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Read the IP address field. (with or without CIDR netmask) */</comment>
		<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>field</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-line before IP address specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"end-of-line before IP address specification"</literal></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tokens</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple values specified for host address"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify one address range per line."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"multiple values specified for host address"</literal></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ip_cmp_method</name></name> <operator>=</operator> <name>ipCmpAll</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"samehost"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Any IP on this host is allowed to connect */</comment>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ip_cmp_method</name></name> <operator>=</operator> <name>ipCmpSameHost</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>token_is_keyword</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"samenet"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Any IP on the host's subnets is allowed to connect */</comment>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ip_cmp_method</name></name> <operator>=</operator> <name>ipCmpSameNet</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* IP and netmask are specified */</comment>
			<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ip_cmp_method</name></name> <operator>=</operator> <name>ipCmpMask</name></expr>;</expr_stmt>

			<comment type="block">/* need a modifiable copy of token */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check if it has a CIDR suffix and if so isolate it */</comment>
			<expr_stmt><expr><name>cidr_slash</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cidr_slash</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cidr_slash</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Get the IP address either way */</comment>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addrlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_canonname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>gai_result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parsedline</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>gai_result</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
					   <argument><expr><name><name>gai_result</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EAI_NONAME</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>hostname</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid IP address \"%s\": %s"</literal></expr></argument>,
								<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid IP address \"%s\": %s"</literal></expr></argument>,
									<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>gai_result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get the netmask */</comment>
			<if_stmt><if>if <condition>(<expr><name>cidr_slash</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>hostname</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying both host name and CIDR mask is invalid: \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"specifying both host name and CIDR mask is invalid: \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>pg_sockaddr_cidr_mask</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parsedline</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>, <argument><expr><name>cidr_slash</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										  <argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid CIDR mask in address \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid CIDR mask in address \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>parsedline</name><operator>-&gt;</operator><name>hostname</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Read the mask field. */</comment>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>field</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-line before netmask specification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify an address range in CIDR notation, or provide a separate netmask."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"end-of-line before netmask specification"</literal></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tokens</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple values specified for netmask"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"multiple values specified for netmask"</literal></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>gai_result</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid IP mask \"%s\": %s"</literal></expr></argument>,
									<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid IP mask \"%s\": %s"</literal></expr></argument>,
										<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>gai_result</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parsedline</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>, <argument><expr><name><name>gai_result</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
					   <argument><expr><name><name>gai_result</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>!=</operator> <name><name>parsedline</name><operator>-&gt;</operator><name>mask</name><operator>.</operator><name>ss_family</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"IP address and mask do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
										<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"IP address and mask do not match"</literal></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>							<comment type="block">/* != ctLocal */</comment>

	<comment type="block">/* Get the authentication method */</comment>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>field</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end-of-line before authentication method"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"end-of-line before authentication method"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tokens</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple values specified for authentication type"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Specify exactly one authentication type per line."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"multiple values specified for authentication type"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"trust"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaTrust</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"ident"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaIdent</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"peer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaPeer</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaPassword</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"gss"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaGSS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"gss"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"sspi"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_SSPI</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaSSPI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"sspi"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaReject</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"md5"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Db_user_namespace</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MD5 authentication is not supported when \"db_user_namespace\" is enabled"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"MD5 authentication is not supported when \"db_user_namespace\" is enabled"</literal></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaMD5</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"scram-sha-256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaSCRAM</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"yb-tserver-key"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaYbTserverKey</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"pam"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PAM</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaPAM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"pam"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"bsd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSD_AUTH</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaBSD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"bsd"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaLDAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"ldap"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"cert"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaCert</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>unsupauth</name> <operator>=</operator> <literal type="string">"cert"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaRADIUS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid authentication method \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid authentication method \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>unsupauth</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid authentication method \"%s\": not supported by this build"</literal></expr></argument>,
						<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid authentication method \"%s\": not supported by this build"</literal></expr></argument>,
							<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX: When using ident on local connections, change it to peer, for
	 * backwards compatibility.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>==</operator> <name>ctLocal</name> <operator>&amp;&amp;</operator>
		<name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaIdent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaPeer</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Invalid authentication combinations */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>==</operator> <name>ctLocal</name> <operator>&amp;&amp;</operator>
		<name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaGSS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"gssapi authentication is not supported on local sockets"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"gssapi authentication is not supported on local sockets"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>!=</operator> <name>ctLocal</name> <operator>&amp;&amp;</operator>
		<name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaPeer</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"peer authentication is only supported on local sockets"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"peer authentication is only supported on local sockets"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * SSPI authentication can never be enabled on ctLocal connections,
	 * because it's only supported on Windows, where ctLocal isn't supported.
	 */</comment>


	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>!=</operator> <name>ctHostSSL</name> <operator>&amp;&amp;</operator>
		<name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaCert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cert authentication is only supported on hostssl connections"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"cert authentication is only supported on hostssl connections"</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For GSS and SSPI, set the default value of include_realm to true.
	 * Having include_realm set to false is dangerous in multi-realm
	 * situations and is generally considered bad practice.  We keep the
	 * capability around for backwards compatibility, but we might want to
	 * remove it at some point in the future.  Users who still need to strip
	 * the realm off would be better served by using an appropriate regex in a
	 * pg_ident.conf mapping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaGSS</name> <operator>||</operator>
		<name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaSSPI</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>include_realm</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For SSPI, include_realm defaults to the SAM-compatible domain (aka
	 * NetBIOS name) and user names instead of the Kerberos principal name for
	 * compatibility.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaSSPI</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>compat_realm</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>upn_username</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Parse remaining arguments */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>tokencell</argument>, <argument>tokens</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tokencell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Got something that's not a name=value pair.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"authentication option not in name=value format: %s"</literal></expr></argument>, <argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"authentication option not in name=value format: %s"</literal></expr></argument>,
									<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>val</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>		<comment type="block">/* str now holds "name", val holds "value" */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_hba_auth_opt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>parsedline</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* parse_hba_auth_opt already logged the error message */</comment>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Check if the selected authentication method has any mandatory arguments
	 * that are not set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaLDAP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MANDATORY_AUTH_ARG</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>, <argument><expr><literal type="string">"ldapserver"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * LDAP can operate in two modes: either with a direct bind, using
		 * ldapprefix and ldapsuffix, or using a search+bind, using
		 * ldapbasedn, ldapbinddn, ldapbindpasswd and one of
		 * ldapsearchattribute or ldapsearchfilter.  Disallow mixing these
		 * parameters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapprefix</name></name> <operator>||</operator> <name><name>parsedline</name><operator>-&gt;</operator><name>ldapsuffix</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapbasedn</name></name> <operator>||</operator>
				<name><name>parsedline</name><operator>-&gt;</operator><name>ldapbinddn</name></name> <operator>||</operator>
				<name><name>parsedline</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name> <operator>||</operator>
				<name><name>parsedline</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name> <operator>||</operator>
				<name><name>parsedline</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use ldapbasedn, ldapbinddn, ldapbindpasswd, ldapsearchattribute, ldapsearchfilter, or ldapurl together with ldapprefix"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"cannot use ldapbasedn, ldapbinddn, ldapbindpasswd, ldapsearchattribute, ldapsearchfilter, or ldapurl together with ldapprefix"</literal></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>parsedline</name><operator>-&gt;</operator><name>ldapbasedn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"authentication method \"ldap\" requires argument \"ldapbasedn\", \"ldapprefix\", or \"ldapsuffix\" to be set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"authentication method \"ldap\" requires argument \"ldapbasedn\", \"ldapprefix\", or \"ldapsuffix\" to be set"</literal></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * When using search+bind, you can either use a simple attribute
		 * (defaulting to "uid") or a fully custom search filter.  You can't
		 * do both.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name> <operator>&amp;&amp;</operator> <name><name>parsedline</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use ldapsearchattribute together with ldapsearchfilter"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"cannot use ldapsearchattribute together with ldapsearchfilter"</literal></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaRADIUS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MANDATORY_AUTH_ARG</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>, <argument><expr><literal type="string">"radiusservers"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MANDATORY_AUTH_ARG</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>, <argument><expr><literal type="string">"radiussecrets"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"list of RADIUS servers cannot be empty"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"list of RADIUS secrets cannot be empty"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Verify length of option lists - each can be 0 (except for secrets,
		 * but that's already checked above), 1 (use the same value
		 * everywhere) or the same as the number of servers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_option_list_length</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiussecrets</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS secrets"</literal></expr></argument>,
									   <argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS servers"</literal></expr></argument>,
									   <argument><expr><name>line_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_option_list_length</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusports</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS ports"</literal></expr></argument>,
									   <argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS servers"</literal></expr></argument>,
									   <argument><expr><name>line_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>verify_option_list_length</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusidentifiers</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS identifiers"</literal></expr></argument>,
									   <argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>radiusservers</name></name></expr></argument>,
									   <argument><expr><literal type="string">"RADIUS servers"</literal></expr></argument>,
									   <argument><expr><name>line_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Enforce any parameters implied by other settings.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaCert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>clientcert</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We manually mask ldapbindpasswd field of the the rawline
		 * by creating a duplicate modified version of it and storing
		 * that in the maskedline field
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passkey</name> <init>= <expr><literal type="string">"ldapbindpasswd="</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pass_replacement_string</name> <init>= <expr><literal type="string">"ldapbindpasswd=***"</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>passfield</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>rawline</name></name></expr></argument>, <argument><expr><name>passkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>passfield</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Caching various string lengths
		 */</comment>		
		<decl_stmt><decl><type><name>size_t</name></type> <name>total_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>rawline</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>prefix_len</name> <init>= <expr><name>passfield</name> <operator>-</operator> <name><name>parsedline</name><operator>-&gt;</operator><name>rawline</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>passkey_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>passkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>passwd_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>pass_replacement_string_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pass_replacement_string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>maskedlinelength</name> <init>= <expr><name>total_len</name> <operator>-</operator> <name>passkey_len</name> <operator>-</operator> <name>passwd_len</name>
									<operator>+</operator> <name>pass_replacement_string_len</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maskedlinelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type> <name>copy_size</name> <init>= <expr><name>prefix_len</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name></name> <operator>+</operator> <name>head</name></expr></argument>, <argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>rawline</name></name></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>head</name> <operator>+=</operator> <name>copy_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>copy_size</name> <operator>=</operator> <name>pass_replacement_string_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name></name> <operator>+</operator> <name>head</name></expr></argument>, 
				<argument><expr><name>pass_replacement_string</name></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>head</name> <operator>+=</operator> <name>copy_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>copy_size</name> <operator>=</operator> <name>total_len</name> <operator>-</operator> <name>prefix_len</name> <operator>-</operator> <name>passkey_len</name>
					<operator>-</operator> <name>passwd_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name></name> <operator>+</operator> <name>head</name></expr></argument>, 
				<argument><expr><name>passfield</name> <operator>+</operator> <name>passkey_len</name>
				<operator>+</operator> <name>passwd_len</name></expr></argument>, <argument><expr><name>copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>head</name> <operator>+=</operator> <name>copy_size</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>maskedline</name><index>[<expr><name>maskedlinelength</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>parsedline</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>verify_option_list_length</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optionname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>masters</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mastername</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>masters</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the number of %s (%d) must be 1 or the same as the number of %s (%d)"</literal></expr></argument>,
					<argument><expr><name>optionname</name></expr></argument>,
					<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>mastername</name></expr></argument>,
					<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>masters</name></expr></argument>)</argument_list></call></expr></argument>
					)</argument_list></call><operator>,</operator>
			 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
						<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse one name-value pair as an authentication option into the given
 * HbaLine.  Return true if we successfully parse the option, false if we
 * encounter an error.  In the event of an error, also log a message at
 * ereport level elevel, and store a message string into *err_msg.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_hba_auth_opt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hbaline</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_num</name> <init>= <expr><name><name>hbaline</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_LDAP</name></cpp:ifdef>
	<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapscope</name></name> <operator>=</operator> <name>LDAP_SCOPE_SUBTREE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaIdent</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaPeer</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaGSS</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaSSPI</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaCert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVALID_AUTH_OPTION</name><argument_list>(<argument><expr><literal type="string">"map"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"ident, peer, gssapi, sspi, and cert"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>usermap</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"clientcert"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>conntype</name></name> <operator>!=</operator> <name>ctHostSSL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clientcert can only be configured for \"hostssl\" rows"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"clientcert can only be configured for \"hostssl\" rows"</literal></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>clientcert</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaCert</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clientcert can not be set to 0 when using \"cert\" authentication"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"clientcert can not be set to 0 when using \"cert\" authentication"</literal></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>clientcert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pamservice"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaPAM</name></expr></argument>, <argument><expr><literal type="string">"pamservice"</literal></expr></argument>, <argument><expr><literal type="string">"pam"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>pamservice</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pam_use_hostname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaPAM</name></expr></argument>, <argument><expr><literal type="string">"pam_use_hostname"</literal></expr></argument>, <argument><expr><literal type="string">"pam"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>pam_use_hostname</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>pam_use_hostname</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapurl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LDAP_API_FEATURE_X_OPENLDAP</name></cpp:ifdef>
		<decl_stmt><decl><type><name>LDAPURLDesc</name> <modifier>*</modifier></type><name>urldata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapurl"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LDAP_API_FEATURE_X_OPENLDAP</name></cpp:ifdef>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>ldap_url_parse</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>urldata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>LDAP_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse LDAP URL \"%s\": %s"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"could not parse LDAP URL \"%s\": %s"</literal></expr></argument>,
								<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ldap_err2string</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr></argument>, <argument><expr><literal type="string">"ldaps"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported LDAP URL scheme: %s"</literal></expr></argument>, <argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"unsupported LDAP URL scheme: %s"</literal></expr></argument>,
								<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ldap_free_urldesc</name><argument_list>(<argument><expr><name>urldata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapscheme</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_host</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapserver</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>=</operator> <name><name>urldata</name><operator>-&gt;</operator><name>lud_port</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_dn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapbasedn</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_dn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_attrs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_attrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* only use first one */</comment>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapscope</name></name> <operator>=</operator> <name><name>urldata</name><operator>-&gt;</operator><name>lud_scope</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_filter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>urldata</name><operator>-&gt;</operator><name>lud_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ldap_free_urldesc</name><argument_list>(<argument><expr><name>urldata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not OpenLDAP */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LDAP URLs not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <literal type="string">"LDAP URLs not supported on this platform"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not OpenLDAP */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldaptls"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldaptls"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldaptls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldaptls</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapscheme"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapscheme"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"ldaps"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid ldapscheme value: \"%s\""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapscheme</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapserver"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapserver"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapserver</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapport"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapport"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapport</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP port number: \"%s\""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid LDAP port number: \"%s\""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapbinddn"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapbinddn"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapbinddn</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapbindpasswd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapbindpasswd"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapsearchattribute"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapsearchattribute"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapsearchfilter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapsearchfilter"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapbasedn"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapbasedn"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapbasedn</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapprefix"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapprefix"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapprefix</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ldapsuffix"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaLDAP</name></expr></argument>, <argument><expr><literal type="string">"ldapsuffix"</literal></expr></argument>, <argument><expr><literal type="string">"ldap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>ldapsuffix</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"krb_realm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaGSS</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaSSPI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVALID_AUTH_OPTION</name><argument_list>(<argument><expr><literal type="string">"krb_realm"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"gssapi and sspi"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>krb_realm</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"include_realm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaGSS</name> <operator>&amp;&amp;</operator>
			<name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaSSPI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVALID_AUTH_OPTION</name><argument_list>(<argument><expr><literal type="string">"include_realm"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"gssapi and sspi"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>include_realm</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>include_realm</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"compat_realm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaSSPI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVALID_AUTH_OPTION</name><argument_list>(<argument><expr><literal type="string">"compat_realm"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sspi"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>compat_realm</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>compat_realm</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"upn_username"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hbaline</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>!=</operator> <name>uaSSPI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>INVALID_AUTH_OPTION</name><argument_list>(<argument><expr><literal type="string">"upn_username"</literal></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"sspi"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>upn_username</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>upn_username</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"radiusservers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>gai_result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsed_servers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dupval</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaRADIUS</name></expr></argument>, <argument><expr><literal type="string">"radiusservers"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>dupval</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_servers</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* syntax error in list */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse RADIUS server list \"%s\""</literal></expr></argument>,
							<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* For each entry in the list, translate it */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parsed_servers</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>gai_result</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate RADIUS server name \"%s\" to address: %s"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>gai_result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>parsed_servers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>gai_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* All entries are OK, so store them */</comment>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusservers</name></name> <operator>=</operator> <name>parsed_servers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusservers_s</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"radiusports"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsed_ports</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dupval</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaRADIUS</name></expr></argument>, <argument><expr><literal type="string">"radiusports"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>dupval</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_ports</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse RADIUS port list \"%s\""</literal></expr></argument>,
							<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"invalid RADIUS port number: \"%s\""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parsed_ports</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid RADIUS port number: \"%s\""</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
									<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusports</name></name> <operator>=</operator> <name>parsed_ports</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusports_s</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"radiussecrets"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsed_secrets</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dupval</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaRADIUS</name></expr></argument>, <argument><expr><literal type="string">"radiussecrets"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>dupval</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_secrets</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* syntax error in list */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse RADIUS secret list \"%s\""</literal></expr></argument>,
							<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiussecrets</name></name> <operator>=</operator> <name>parsed_secrets</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiussecrets_s</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"radiusidentifiers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parsed_identifiers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dupval</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>REQUIRE_AUTH_OPTION</name><argument_list>(<argument><expr><name>uaRADIUS</name></expr></argument>, <argument><expr><literal type="string">"radiusidentifiers"</literal></expr></argument>, <argument><expr><literal type="string">"radius"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>dupval</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_identifiers</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* syntax error in list */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse RADIUS identifiers list \"%s\""</literal></expr></argument>,
							<argument><expr><name>val</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
								<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusidentifiers</name></name> <operator>=</operator> <name>parsed_identifiers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hbaline</name><operator>-&gt;</operator><name>radiusidentifiers_s</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized authentication option name: \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"line %d of configuration file \"%s\""</literal></expr></argument>,
							<argument><expr><name>line_num</name></expr></argument>, <argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>err_msg</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"unrecognized authentication option name: \"%s\""</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Scan the pre-parsed hba file, looking for a match to the port's connection
 *	request.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_hba</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaLine</name>    <modifier>*</modifier></type><name>hba</name></decl>;</decl_stmt>

	<comment type="block">/* Get the target role's OID.  Note we do not error out for bad role. */</comment>
	<expr_stmt><expr><name>roleid</name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>line</argument>, <argument>parsed_hba_lines</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>hba</name> <operator>=</operator> <operator>(</operator><name>HbaLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check connection type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>conntype</name></name> <operator>==</operator> <name>ctLocal</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Check SSL state */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Connection is SSL, match both "host" and "hostssl" */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>conntype</name></name> <operator>==</operator> <name>ctHostNoSSL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Connection is not SSL, match both "host" and "hostnossl" */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>conntype</name></name> <operator>==</operator> <name>ctHostSSL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Check IP address */</comment>
			<switch>switch <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ip_cmp_method</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>ipCmpMask</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>hostname</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_hostname</name><argument_list>(<argument><expr><name>port</name></expr></argument>,
											<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_ip</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>,
									  <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>hba</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,
									  <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>hba</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>
				<case>case <expr><name>ipCmpAll</name></expr>:</case>
					<break>break;</break>
				<case>case <expr><name>ipCmpSameHost</name></expr>:</case>
				<case>case <expr><name>ipCmpSameNet</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_same_host_or_net</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name></name></expr></argument>,
												<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ip_cmp_method</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* shouldn't get here, but deem it no-match if so */</comment>
					<continue>continue;</continue>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>						<comment type="block">/* != ctLocal */</comment>

		<comment type="block">/* Check database and role */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_db</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
					  <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>databases</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_role</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Found a record that matched! */</comment>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name></name> <operator>=</operator> <name>hba</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also persist whether the auth method is yb-tserver-key because this
		 * information gets lost upon deleting the memory context for auth.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaYbTserverKey</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>yb_is_tserver_auth_method</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block>

	<comment type="block">/* If no matching entry was found, then implicitly reject. */</comment>
	<expr_stmt><expr><name>hba</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HbaLine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>=</operator> <name>uaImplicitReject</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>hba</name></name> <operator>=</operator> <name>hba</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the config file and create a List of HbaLine records for the contents.
 *
 * The configuration is read into a temporary list, and if any parse error
 * occurs the old list is kept in place and false is returned.  Only if the
 * whole file parses OK is the list replaced, and the function returns true.
 *
 * On a false result, caller will take care of reporting a FATAL error in case
 * this is the initial startup.  If it happens on reload, we just keep running
 * with the old data.
 */</comment>
<function><type><name>bool</name></type>
<name>load_hba</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hba_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_parsed_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>linecxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>hbacxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>linecxt</name> <operator>=</operator> <call><name>tokenize_file</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hba_lines</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add hardcoded hba config lines in front of user-defined ones. */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hba_lines_hardcoded</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tokenize_hardcoded</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hba_lines_hardcoded</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hba_lines</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>hba_lines_hardcoded</name></expr></argument>, <argument><expr><name>hba_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now parse all the lines */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hbacxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>,
								   <argument><expr><literal type="string">"hba parser context"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>hbacxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>line</argument>, <argument>hba_lines</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name> <init>= <expr><operator>(</operator><name>TokenizedLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HbaLine</name>    <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>

		<comment type="block">/* don't parse lines that already have errors */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newline</name> <operator>=</operator> <call><name>parse_hba_line</name><argument_list>(<argument><expr><name>tok_line</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Parse error; remember there's trouble */</comment>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Keep parsing the rest of the file so we can report errors on
			 * more than the first line.  Error has already been logged, no
			 * need for more chatter here.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_parsed_lines</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_parsed_lines</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * A valid HBA file must have at least one entry; else there's no way to
	 * connect to the postmaster.  But only complain about this if we didn't
	 * already have parsing errors.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ok</name> <operator>&amp;&amp;</operator> <name>new_parsed_lines</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"configuration file \"%s\" contains no entries"</literal></expr></argument>,
						<argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free tokenizer memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* File contained one or more errors, so bail out */</comment>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>hbacxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Loaded new file successfully, replace the one we use */</comment>
	<if_stmt><if>if <condition>(<expr><name>parsed_hba_context</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>parsed_hba_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>parsed_hba_context</name> <operator>=</operator> <name>hbacxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parsed_hba_lines</name> <operator>=</operator> <name>new_parsed_lines</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This macro specifies the maximum number of authentication options
 * that are possible with any given authentication method that is supported.
 * Currently LDAP supports 11, and there are 3 that are not dependent on
 * the auth method here.  It may not actually be possible to set all of them
 * at the same time, but we'll set the macro value high enough to be
 * conservative and avoid warnings from static analysis tools.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HBA_OPTIONS</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>

<comment type="block">/*
 * Create a text array listing the options specified in the HBA line.
 * Return NULL if no options are specified.
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayType</name> <modifier>*</modifier></type>
<name>gethba_options</name><parameter_list>(<parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hba</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>noptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>options</name><index>[<expr><name>MAX_HBA_OPTIONS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>noptions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaGSS</name> <operator>||</operator> <name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaSSPI</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>include_realm</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"include_realm=true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"krb_realm=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>krb_realm</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"map=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>clientcert</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"clientcert=true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>pamservice</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
			<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"pamservice=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>pamservice</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaLDAP</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapserver=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapserver</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapport=%d"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapport</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldaptls</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"ldaptls=true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapprefix</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapprefix=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapprefix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsuffix</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapsuffix=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsuffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbasedn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapbasedn=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbasedn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapbinddn=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbinddn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapbindpasswd=%s"</literal></expr></argument>,
											 <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapbindpasswd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapsearchattribute=%s"</literal></expr></argument>,
											 <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsearchattribute</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapsearchfilter=%s"</literal></expr></argument>,
											 <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapsearchfilter</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ldapscope</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"ldapscope=%d"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>ldapscope</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name> <operator>==</operator> <name>uaRADIUS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>radiusservers_s</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"radiusservers=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>radiusservers_s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>radiussecrets_s</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"radiussecrets=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>radiussecrets_s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>radiusidentifiers_s</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"radiusidentifiers=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>radiusidentifiers_s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>radiusports_s</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>options</name><index>[<expr><name>noptions</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"radiusports=%s"</literal></expr></argument>, <argument><expr><name><name>hba</name><operator>-&gt;</operator><name>radiusports_s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If you add more options, consider increasing MAX_HBA_OPTIONS. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>noptions</name> <operator>&lt;=</operator> <name>MAX_HBA_OPTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>noptions</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>construct_array</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>noptions</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Number of columns in pg_hba_file_rules view */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PG_HBA_FILE_RULES_ATTS</name></cpp:macro>	 <cpp:value>9</cpp:value></cpp:define>

<comment type="block">/*
 * fill_hba_line: build one row of pg_hba_file_rules view, add it to tuplestore
 *
 * tuple_store: where to store data
 * tupdesc: tuple descriptor for the view
 * lineno: pg_hba.conf line number (must always be valid)
 * hba: parsed line data (can be NULL, in which case err_msg should be set)
 * err_msg: error message (NULL if none)
 *
 * Note: leaks memory, but we don't care since this is run in a short-lived
 * memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_hba_line</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>HbaLine</name> <modifier>*</modifier></type><name>hba</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_PG_HBA_FILE_RULES_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_PG_HBA_FILE_RULES_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addrstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>maskstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name>NUM_PG_HBA_FILE_RULES_ATTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* line_number */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hba</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* type */</comment>
		<comment type="block">/* Avoid a default: case so compiler will warn about missing cases */</comment>
		<expr_stmt><expr><name>typestr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>conntype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ctLocal</name></expr>:</case>
				<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"local"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ctHost</name></expr>:</case>
				<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ctHostSSL</name></expr>:</case>
				<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"hostssl"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ctHostNoSSL</name></expr>:</case>
				<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"hostnossl"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>typestr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* database */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>databases</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Flatten HbaToken list to string list.  It might seem that we
			 * should re-quote any quoted tokens, but that has been rejected
			 * on the grounds that it makes it harder to compare the array
			 * elements to other system catalogs.  That makes entries like
			 * "all" or "samerole" formally ambiguous ... but users who name
			 * databases/roles that way are inflicting their own pain.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hba-&gt;databases</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>tok</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>strlist_to_textarray</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* user */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>roles</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Flatten HbaToken list to string list; see comment above */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>roles</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hba-&gt;roles</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>tok</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>roles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>roles</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>strlist_to_textarray</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* address and netmask */</comment>
		<comment type="block">/* Avoid a default: case so compiler will warn about missing cases */</comment>
		<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <name>maskstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>ip_cmp_method</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ipCmpMask</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>hba</name><operator>-&gt;</operator><name>hostname</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <name><name>hba</name><operator>-&gt;</operator><name>hostname</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hba</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>clean_ipv6_addr</name><argument_list>(<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hba</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>clean_ipv6_addr</name><argument_list>(<argument><expr><name><name>hba</name><operator>-&gt;</operator><name>mask</name><operator>.</operator><name>ss_family</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>maskstr</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>ipCmpAll</name></expr>:</case>
				<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <literal type="string">"all"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ipCmpSameHost</name></expr>:</case>
				<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <literal type="string">"samehost"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ipCmpSameNet</name></expr>:</case>
				<expr_stmt><expr><name>addrstr</name> <operator>=</operator> <literal type="string">"samenet"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>addrstr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>addrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>maskstr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>maskstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Make sure UserAuthName[] tracks additions to the UserAuth enum
		 */</comment>
		<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>UserAuthName</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>USER_AUTH_LAST</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						 <argument><expr><literal type="string">"UserAuthName[] must match the UserAuth enum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* auth_method */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>UserAuthName</name><index>[<expr><name><name>hba</name><operator>-&gt;</operator><name>auth_method</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* options */</comment>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>gethba_options</name><argument_list>(<argument><expr><name>hba</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>options</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no parsing result, so set relevant fields to nulls */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>NUM_PG_HBA_FILE_RULES_ATTS</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* error */</comment>
	<if_stmt><if>if <condition>(<expr><name>err_msg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>NUM_PG_HBA_FILE_RULES_ATTS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>NUM_PG_HBA_FILE_RULES_ATTS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the pg_hba.conf file and fill the tuplestore with view records.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fill_hba_view</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hba_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>linecxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>hbacxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the unlikely event that we can't open pg_hba.conf, we throw an
	 * error, rather than trying to report it via some sort of view entry.
	 * (Most other error conditions should result in a message in a view
	 * entry.)
	 */</comment>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open configuration file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>linecxt</name> <operator>=</operator> <call><name>tokenize_file</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hba_lines</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now parse all the lines */</comment>
	<expr_stmt><expr><name>hbacxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><literal type="string">"hba parser context"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>hbacxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>line</argument>, <argument>hba_lines</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name> <init>= <expr><operator>(</operator><name>TokenizedLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HbaLine</name>    <modifier>*</modifier></type><name>hbaline</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* don't parse lines that already have errors */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hbaline</name> <operator>=</operator> <call><name>parse_hba_line</name><argument_list>(<argument><expr><name>tok_line</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fill_hba_line</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>line_num</name></name></expr></argument>,
					  <argument><expr><name>hbaline</name></expr></argument>, <argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Free tokenizer memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Free parse_hba_line memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>hbacxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL-accessible SRF to return all the entries in the pg_hba.conf file.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_hba_file_rules</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must use the Materialize mode to be safe against HBA file changes
	 * while the cursor is open. It's also more efficient than having to look
	 * up our current position in the parsed list every time.
	 */</comment>
	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<comment type="block">/* Check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsi</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build tuplestore to hold the result rows */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple_store</name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tuple_store</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill the tuplestore */</comment>
	<expr_stmt><expr><call><name>fill_hba_view</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Parse one tokenised line from the ident config file and store the result in
 * an IdentLine structure.
 *
 * If parsing fails, log a message and return NULL.
 *
 * If ident_user is a regular expression (ie. begins with a slash), it is
 * compiled and stored in IdentLine structure.
 *
 * Note: this function leaks memory when an error occurs.  Caller is expected
 * to have set a memory context that will be reset if this function returns
 * NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>IdentLine</name> <modifier>*</modifier></type>
<name>parse_ident_line</name><parameter_list>(<parameter><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_num</name> <init>= <expr><name><name>tok_line</name><operator>-&gt;</operator><name>line_num</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tokens</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HbaToken</name>   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IdentLine</name>  <modifier>*</modifier></type><name>parsedline</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>fields</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tok_line</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>parsedline</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IdentLine</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>linenumber</name></name> <operator>=</operator> <name>line_num</name></expr>;</expr_stmt>

	<comment type="block">/* Get the map token (must exist) */</comment>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IDENT_MULTI_VALUE</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>usermap</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the ident user token */</comment>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IDENT_FIELD_ABSENT</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IDENT_MULTI_VALUE</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the PG rolename token */</comment>
	<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IDENT_FIELD_ABSENT</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tokens</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IDENT_MULTI_VALUE</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parsedline</name><operator>-&gt;</operator><name>pg_role</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>token</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When system username starts with a slash, treat it as a regular
		 * expression. Pre-compile it.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wstr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>wstr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><name>wstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parsedline</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><name>wstr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>REG_ADVANCED</name></expr></argument>, <argument><expr><name>C_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>errstr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parsedline</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid regular expression \"%s\": %s"</literal></expr></argument>,
							<argument><expr><name><name>parsedline</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>parsedline</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Process one line from the parsed ident config lines.
 *
 *	Compare input parsed ident line to the needed map, pg_role and ident_user.
 *	*found_p and *error_p are set according to our results.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_ident_usermap</name><parameter_list>(<parameter><decl><type><name>IdentLine</name> <modifier>*</modifier></type><name>identLine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usermap_name</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_role</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident_user</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found_p</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>error_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>found_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>error_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>usermap</name></name></expr></argument>, <argument><expr><name>usermap_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Line does not match the map name we're looking for, so just abort */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Match? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>identLine</name><operator>-&gt;</operator><name>ident_user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When system username starts with a slash, treat it as a regular
		 * expression. In this case, we process the system username as a
		 * regular expression that returns exactly one match. This is replaced
		 * for \1 in the database username string, if present.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>regmatch_t</name></type>	<name><name>matches</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wstr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ofs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>regexp_pgrole</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>wstr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ident_user</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><name>ident_user</name></expr></argument>, <argument><expr><name>wstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident_user</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pg_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>identLine</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><name>wstr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>matches</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>errstr</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>REG_NOMATCH</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* REG_NOMATCH is not an error, everything else is */</comment>
				<expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>identLine</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular expression match for \"%s\" failed: %s"</literal></expr></argument>,
								<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>error_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>wstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ofs</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>, <argument><expr><literal type="string">"\\1"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>

			<comment type="block">/* substitution of the first argument requested */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular expression \"%s\" has no subexpressions as requested by backreference in \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>ident_user</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>error_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * length: original length minus length of \1 plus length of match
			 * plus null terminator
			 */</comment>
			<expr_stmt><expr><name>regexp_pgrole</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>-</operator> <name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_so</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ofs</name> <operator>-</operator> <name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>regexp_pgrole</name></expr></argument>, <argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>regexp_pgrole</name> <operator>+</operator> <name>offset</name></expr></argument>,
				   <argument><expr><name>ident_user</name> <operator>+</operator> <name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></argument>,
				   <argument><expr><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>-</operator> <name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>regexp_pgrole</name></expr></argument>, <argument><expr><name>ofs</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no substitution, so copy the match */</comment>
			<expr_stmt><expr><name>regexp_pgrole</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * now check if the username actually matched what the user is trying
		 * to connect as
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>case_insensitive</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>regexp_pgrole</name></expr></argument>, <argument><expr><name>pg_role</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>regexp_pgrole</name></expr></argument>, <argument><expr><name>pg_role</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>regexp_pgrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not regular expression, so make complete match */</comment>
		<if_stmt><if>if <condition>(<expr><name>case_insensitive</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>, <argument><expr><name>pg_role</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>ident_user</name></name></expr></argument>, <argument><expr><name>ident_user</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>pg_role</name></name></expr></argument>, <argument><expr><name>pg_role</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>identLine</name><operator>-&gt;</operator><name>ident_user</name></name></expr></argument>, <argument><expr><name>ident_user</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>found_p</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	Scan the (pre-parsed) ident usermap file line by line, looking for a match
 *
 *	See if the user with ident username "auth_user" is allowed to act
 *	as Postgres user "pg_role" according to usermap "usermap_name".
 *
 *	Special case: Usermap NULL, equivalent to what was previously called
 *	"sameuser" or "samerole", means don't look in the usermap file.
 *	That's an implied map wherein "pg_role" must be identical to
 *	"auth_user" in order to be authorized.
 *
 *	Iff authorized, return STATUS_OK, otherwise return STATUS_ERROR.
 */</comment>
<function><type><name>int</name></type>
<name>check_usermap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>usermap_name</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_role</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auth_user</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_entry</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>usermap_name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>usermap_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>case_insensitive</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>pg_role</name></expr></argument>, <argument><expr><name>auth_user</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pg_role</name></expr></argument>, <argument><expr><name>auth_user</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"provided user name (%s) and authenticated user name (%s) do not match"</literal></expr></argument>,
						<argument><expr><name>pg_role</name></expr></argument>, <argument><expr><name>auth_user</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>line_cell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>line_cell</argument>, <argument>parsed_ident_lines</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>check_ident_usermap</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>line_cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>usermap_name</name></expr></argument>,
								<argument><expr><name>pg_role</name></expr></argument>, <argument><expr><name>auth_user</name></expr></argument>, <argument><expr><name>case_insensitive</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found_entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_entry</name> <operator>||</operator> <name>error</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_entry</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>error</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no match in usermap \"%s\" for user \"%s\" authenticated as \"%s\""</literal></expr></argument>,
						<argument><expr><name>usermap_name</name></expr></argument>, <argument><expr><name>pg_role</name></expr></argument>, <argument><expr><name>auth_user</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><name>found_entry</name></expr> ?</condition><then> <expr><name>STATUS_OK</name></expr> </then><else>: <expr><name>STATUS_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Read the ident config file and create a List of IdentLine records for
 * the contents.
 *
 * This works the same as load_hba(), but for the user config file.
 */</comment>
<function><type><name>bool</name></type>
<name>load_ident</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ident_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>line_cell</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>parsed_line_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_parsed_lines</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>linecxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ident_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IdentLine</name>  <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>IdentFileName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not fatal ... we just won't do any special ident maps */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open usermap file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>IdentFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>linecxt</name> <operator>=</operator> <call><name>tokenize_file</name><argument_list>(<argument><expr><name>IdentFileName</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ident_lines</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now parse all the lines */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ident_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>PostmasterContext</name></expr></argument>,
										  <argument><expr><literal type="string">"ident parser context"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ident_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>line_cell</argument>, <argument>ident_lines</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TokenizedLine</name> <modifier>*</modifier></type><name>tok_line</name> <init>= <expr><operator>(</operator><name>TokenizedLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>line_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* don't parse lines that already have errors */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tok_line</name><operator>-&gt;</operator><name>err_msg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newline</name> <operator>=</operator> <call><name>parse_ident_line</name><argument_list>(<argument><expr><name>tok_line</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Parse error; remember there's trouble */</comment>
			<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Keep parsing the rest of the file so we can report errors on
			 * more than the first line.  Error has already been logged, no
			 * need for more chatter here.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_parsed_lines</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_parsed_lines</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Free tokenizer memory */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>linecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * File contained one or more errors, so bail out, first being careful
		 * to clean up whatever we allocated.  Most stuff will go away via
		 * MemoryContextDelete, but we have to clean up regexes explicitly.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>parsed_line_cell</argument>, <argument>new_parsed_lines</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>newline</name> <operator>=</operator> <operator>(</operator><name>IdentLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parsed_line_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>newline</name><operator>-&gt;</operator><name>ident_user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newline</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>ident_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Loaded new file successfully, replace the one we use */</comment>
	<if_stmt><if>if <condition>(<expr><name>parsed_ident_lines</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>parsed_line_cell</argument>, <argument>parsed_ident_lines</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>newline</name> <operator>=</operator> <operator>(</operator><name>IdentLine</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parsed_line_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>newline</name><operator>-&gt;</operator><name>ident_user</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newline</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parsed_ident_context</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>parsed_ident_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>parsed_ident_context</name> <operator>=</operator> <name>ident_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parsed_ident_lines</name> <operator>=</operator> <name>new_parsed_lines</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 *	Determine what authentication method should be used when accessing database
 *	"database" from frontend "raddr", user "user".  Return the method and
 *	an optional argument (stored in fields of *port), and STATUS_OK.
 *
 *	If the file does not contain any entry matching the request, we return
 *	method = uaImplicitReject.
 */</comment>
<function><type><name>void</name></type>
<name>hba_getauthmethod</name><parameter_list>(<parameter><decl><type><name>hbaPort</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_hba</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
