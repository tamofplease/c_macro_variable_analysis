<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/statistics/dependencies.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * dependencies.c
 *	  POSTGRES functional dependencies
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/statistics/dependencies.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/extended_stats_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Internal state for DependencyGenerator of dependencies. Dependencies are similar to
 * k-permutations of n elements, except that the order does not matter for the
 * first (k-1) elements. That is, (a,b=&gt;c) and (b,a=&gt;c) are equivalent.
 */</comment>
<typedef>typedef <type><struct>struct <name>DependencyGeneratorData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>				<comment type="block">/* size of the dependency */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>				<comment type="block">/* number of possible attributes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current</name></decl>;</decl_stmt>		<comment type="block">/* next dependency to return (index) */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>ndependencies</name></decl>;</decl_stmt>	<comment type="block">/* number of dependencies generated */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>	<comment type="block">/* array of pre-generated dependencies	*/</comment>
}</block></struct></type> <name>DependencyGeneratorData</name>;</typedef>

<typedef>typedef <type><name>DependencyGeneratorData</name> <modifier>*</modifier></type><name>DependencyGenerator</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_dependencies_recurse</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>generate_dependencies</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DependencyGenerator</name></type> <name>DependencyGenerator_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DependencyGenerator_free</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>DependencyGenerator_next</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>dependency_degree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>,
				  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>, <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dependency_is_fully_matched</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>,
							<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dependency_implies_attribute</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>,
							 <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dependency_is_compatible_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>,
								<parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MVDependency</name> <modifier>*</modifier></type><name>find_strongest_dependency</name><parameter_list>(<parameter><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
						  <parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl></parameter>,
						  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_dependencies_recurse</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
							  <parameter><decl><type><name>AttrNumber</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The generator handles the first (k-1) elements differently from the
	 * last element.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The first (k-1) values have to be in ascending order, which we
		 * generate recursively.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>current</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>generate_dependencies_recurse</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * the last element is the implied value, which does not respect the
		 * ascending order. We just need to check that the value is not in the
		 * first (k-1) elements.
		 */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>current</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>index</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>current</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>i</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If the value is not found in the first part of the dependency,
			 * we're done.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>,
															  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name><operator>)</operator></expr>]</index></name></expr></argument>,
					   <argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* generate all dependencies (k-permutations of n elements) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generate_dependencies</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>generate_dependencies_recurse</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initialize the DependencyGenerator of variations, and prebuild the variations
 *
 * This pre-builds all the variations. We could also generate them in
 * DependencyGenerator_next(), but this seems simpler.
 */</comment>
<function><type><specifier>static</specifier> <name>DependencyGenerator</name></type>
<name>DependencyGenerator_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>&gt;=</operator> <name>k</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate the DependencyGenerator state */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>DependencyGenerator</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DependencyGeneratorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

	<comment type="block">/* now actually pre-generate all the variations */</comment>
	<expr_stmt><expr><call><name>generate_dependencies</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* free the DependencyGenerator state */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DependencyGenerator_free</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dependencies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/* generate next combination */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type>
<name>DependencyGenerator_next</name><parameter_list>(<parameter><decl><type><name>DependencyGenerator</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>current</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>ndependencies</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>dependencies</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * validates functional dependency on the data
 *
 * An actual work horse of detecting functional dependencies. Given a variation
 * of k attributes, it checks that the first (k-1) are sufficient to determine
 * the last one.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>dependency_degree</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>,
				  <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvalues</name> <init>= <expr><name>numrows</name> <operator>*</operator> <name>k</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiSortSupport</name></type> <name>mss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>

	<comment type="block">/* counters valid within a group */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>group_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_violations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* total number of rows supporting (consistent with) the dependency */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>n_supporting_rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure we have at least two input attributes. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort info for all attributes columns */</comment>
	<expr_stmt><expr><name>mss</name> <operator>=</operator> <call><name>multi_sort_init</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* data for the sort */</comment>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>SortItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numrows</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fix the pointers to values/isnull */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>values</name> <operator>=</operator> <operator>&amp;</operator><name><name>values</name><index>[<expr><name>i</name> <operator>*</operator> <name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <operator>&amp;</operator><name><name>isnull</name><index>[<expr><name>i</name> <operator>*</operator> <name>k</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Transform the bms into an array, to make accessing i-th member easier.
	 */</comment>
	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Verify the dependency (a,b,...)-&gt;z, using a rather simple algorithm:
	 *
	 * (a) sort the data lexicographically
	 *
	 * (b) split the data into groups by first (k-1) columns
	 *
	 * (c) for each group count different values in the last column
	 */</comment>

	<comment type="block">/* prepare the sort function for the first dimension, and SortItem array */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>colstat</name> <init>= <expr><name><name>stats</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_LT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for ordering operator for type %u"</literal></expr></argument>,
				 <argument><expr><name><name>colstat</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* prepare the sort function for this dimension */</comment>
		<expr_stmt><expr><call><name>multi_sort_add_dimension</name><argument_list>(<argument><expr><name>mss</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>lt_opr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* accumulate all the data for both columns into an array and sort it */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>heap_getattr</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>,
							 <argument><expr><name><name>stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* sort the items so that we can detect the groups */</comment>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>items</name></expr></argument>, <argument><expr><name>numrows</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>multi_sort_compare</name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk through the sorted array, split it into rows according to the
	 * first (k-1) columns. If there's a single value in the last column, we
	 * count the group as 'supporting' the functional dependency. Otherwise we
	 * count it as contradicting.
	 */</comment>

	<comment type="block">/* start with the first row forming a group */</comment>
	<expr_stmt><expr><name>group_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* loop 1 beyond the end of the array so that we count the final group */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numrows</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if the group ended, which may be either because we processed
		 * all the items (i==numrows), or because the i-th item is not equal
		 * to the preceding one.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>numrows</name> <operator>||</operator>
			<call><name>multi_sort_compare_dims</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>k</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If no violations were found in the group then track the rows of
			 * the group as supporting the functional dependency.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>n_violations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>n_supporting_rows</name> <operator>+=</operator> <name>group_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Reset counters for the new group */</comment>
			<expr_stmt><expr><name>n_violations</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>group_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<comment type="block">/* first columns match, but the last one does not (so contradicting) */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>multi_sort_compare_dim</name><argument_list>(<argument><expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>mss</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>n_violations</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>group_size</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute the 'degree of validity' as (supporting/total). */</comment>
	<return>return <expr><operator>(</operator><name>n_supporting_rows</name> <operator>*</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>numrows</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * detects functional dependencies between groups of columns
 *
 * Generates all possible subsets of columns (variations) and computes
 * the degree of validity for each one. For example when creating statistics
 * on three columns (a,b,c) there are 9 possible dependencies
 *
 *	   two columns			  three columns
 *	   -----------			  -------------
 *	   (a) -&gt; b				  (a,b) -&gt; c
 *	   (a) -&gt; c				  (a,c) -&gt; b
 *	   (b) -&gt; a				  (b,c) -&gt; a
 *	   (b) -&gt; c
 *	   (c) -&gt; a
 *	   (c) -&gt; b
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_build</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numrows</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attrs</name></decl></parameter>,
						   <parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier><modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>

	<comment type="block">/* result */</comment>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform the bms into an array, to make accessing i-th member easier.
	 */</comment>
	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attnums</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numattrs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll try build functional dependencies starting from the smallest ones
	 * covering just 2 columns, to the largest ones, covering all columns
	 * included in the statistics object.  We start from the smallest ones
	 * because we want to be able to skip already implied ones.
	 */</comment>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dependency</name></decl>;</decl_stmt> <comment type="block">/* array with k elements */</comment>

		<comment type="block">/* prepare a DependencyGenerator of variation */</comment>
		<decl_stmt><decl><type><name>DependencyGenerator</name></type> <name>DependencyGenerator</name> <init>= <expr><call><name>DependencyGenerator_init</name><argument_list>(<argument><expr><name>numattrs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* generate all possible variations of k values (out of n) */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>dependency</name> <operator>=</operator> <call><name>DependencyGenerator_next</name><argument_list>(<argument><expr><name>DependencyGenerator</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>degree</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

			<comment type="block">/* compute how valid the dependency seems */</comment>
			<expr_stmt><expr><name>degree</name> <operator>=</operator> <call><name>dependency_degree</name><argument_list>(<argument><expr><name>numrows</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>dependency</name></expr></argument>, <argument><expr><name>stats</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if the dependency seems entirely invalid, don't store it
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>degree</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>MVDependency</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependency</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call>
										 <operator>+</operator> <name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* copy the dependency (and keep the indexes into stxkeys) */</comment>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>degree</name></name> <operator>=</operator> <name>degree</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>attnums</name><index>[<expr><name><name>dependency</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

			<comment type="block">/* initialize the list of dependencies */</comment>
			<if_stmt><if>if <condition>(<expr><name>dependencies</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependencies</name>
					<operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>STATS_DEPS_MAGIC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>STATS_DEPS_TYPE_BASIC</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>,
													   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>, <argument><expr><name>deps</name></expr></argument>)</argument_list></call>
													   <operator>+</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MVDependency</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * we're done with variations of k elements, so free the
		 * DependencyGenerator
		 */</comment>
		<expr_stmt><expr><call><name>DependencyGenerator_free</name><argument_list>(<argument><expr><name>DependencyGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>dependencies</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Serialize list of dependencies into a bytea value.
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>statext_dependencies_serialize</name><parameter_list>(<parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* we need to store ndeps, with a number of attributes for each one */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>VARHDRSZ</name> <operator>+</operator> <name>SizeOfDependencies</name>
		<operator>+</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <name>SizeOfDependency</name></expr>;</expr_stmt>

	<comment type="block">/* and also include space for the actual attribute numbers and degrees */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nattributes</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>output</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the base struct values (magic, type, ndeps) */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* store number of attributes and attribute numbers for each dependency */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>SizeOfDependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <name>SizeOfDependency</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>output</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>output</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reads serialized dependencies into MVDependencies structure.
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_deserialize</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>min_expected_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>SizeOfDependencies</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MVDependencies size %zd (expected at least %zd)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SizeOfDependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* read the MVDependencies header */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <operator>(</operator><name>MVDependencies</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize pointer to the data part (skip the varlena header) */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read the header fields and perform basic sanity checks */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>STATS_DEPS_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependency magic %d (expected %d)"</literal></expr></argument>,
			 <argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>STATS_DEPS_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>STATS_DEPS_TYPE_BASIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependency type %d (expected %d)"</literal></expr></argument>,
			 <argument><expr><name><name>dependencies</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>STATS_DEPS_TYPE_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid zero-length item array in MVDependencies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* what minimum bytea size do we expect for those parameters */</comment>
	<expr_stmt><expr><name>min_expected_size</name> <operator>=</operator> <name>SizeOfDependencies</name> <operator>+</operator>
		<name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <operator>(</operator><name>SizeOfDependency</name> <operator>+</operator>
							   <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>min_expected_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid dependencies size %zd (expected at least %zd)"</literal></expr></argument>,
			 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>min_expected_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* allocate space for the MCV items */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependencies</name></expr></argument>, <argument><expr><name>deps</name></expr></argument>)</argument_list></call>
							<operator>+</operator> <operator>(</operator><name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MVDependency</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>degree</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>k</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

		<comment type="block">/* degree of validity */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>degree</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* number of attributes */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/* is the number of attributes valid? */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>k</name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&lt;=</operator> <name>STATS_MAX_DIMENSIONS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* now that we know the number of attributes, allocate the dependency */</comment>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>MVDependency</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>MVDependency</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call>
									 <operator>+</operator> <operator>(</operator><name>k</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>degree</name></name> <operator>=</operator> <name>degree</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

		<comment type="block">/* copy attribute numbers */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>attributes</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

		<comment type="block">/* still within the bytea */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we should have consumed the whole bytea exactly */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dependencies</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependency_is_fully_matched
 *		checks that a functional dependency is fully matched given clauses on
 *		attributes (assuming the clauses are suitable equality clauses)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dependency_is_fully_matched</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the dependency actually is fully covered by clauses. We have
	 * to translate all attribute numbers, as those are referenced
	 */</comment>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name> <init>= <expr><name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependency_implies_attribute
 *		check that the attnum matches is implied by the functional dependency
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dependency_implies_attribute</name><parameter_list>(<parameter><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * statext_dependencies_load
 *		Load the functional dependencies for the indicated pg_statistic_ext tuple
 */</comment>
<function><type><name>MVDependencies</name> <modifier>*</modifier></type>
<name>statext_dependencies_load</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>mvoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>deps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>deps</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>,
						   <argument><expr><name>Anum_pg_statistic_ext_stxdependencies</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"requested statistic kind \"%c\" is not yet built for statistics object %u"</literal></expr></argument>,
			 <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>, <argument><expr><name>mvoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>statext_dependencies_deserialize</name><argument_list>(<argument><expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>deps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_in		- input routine for type pg_dependencies.
 *
 * pg_dependencies is real enough to be a table column, but it has no operations
 * of its own, and disallows input too
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * pg_node_list stores the data in binary form and parsing text input is
	 * not needed, so disallow this.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_dependencies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies		- output routine for type pg_dependencies.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><call><name>statext_dependencies_deserialize</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" =&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>attributes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"\": %f"</literal></expr></argument>, <argument><expr><name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_recv		- binary input routine for type pg_dependencies.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot accept a value of type %s"</literal></expr></argument>, <argument><expr><literal type="string">"pg_dependencies"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * pg_dependencies_send		- binary output routine for type pg_dependencies.
 *
 * Functional dependencies are serialized in a bytea value (although the type
 * is named differently), so let's just send that.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dependencies_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>byteasend</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependency_is_compatible_clause
 *		Determines if the clause is compatible with functional dependencies
 *
 * Only clauses that have the form of equality to a pseudoconstant, or can be
 * interpreted that way, are currently accepted.  Furthermore the variable
 * part of the clause must be a simple Var belonging to the specified
 * relation, whose attribute number we return in *attnum on success.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dependency_is_compatible_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Pseudoconstants are not interesting (they couldn't contain a Var) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Clauses referencing multiple, or no, varnos are incompatible */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause_relids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's an opclause, check for Var = Const or Const = Var. */</comment>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Only expressions with two arguments are candidates. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Make sure non-selected argument is a pseudoconstant. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_pseudo_constant_clause</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If it's not an "=" operator, just ignore the clause, as it's not
		 * compatible with functional dependencies.
		 *
		 * This uses the function for estimating selectivity, not the operator
		 * directly (a bit awkward, but well ...).
		 *
		 * XXX this is pretty dubious; probably it'd be better to check btree
		 * or hash opclass membership, so as not to be fooled by custom
		 * selectivity functions, and to be more consistent with decisions
		 * elsewhere in the planner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_oprrest</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>F_EQSEL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* OK to proceed with checking "var" */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>not_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * "NOT x" can be interpreted as "x = false", so get the argument and
		 * proceed with seeing if it's a suitable Var.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>get_notclausearg</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * A boolean expression "x" can be interpreted as "x = true", so
		 * proceed with seeing if it's a suitable Var.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We may ignore any RelabelType node above the operand.  (There won't be
	 * more than one, since eval_const_expressions has been applied already.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We only support plain Vars for now */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ensure Var is from the correct relation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We also better ensure the Var is from the current level */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Also ignore system attributes (we don't allow stats on those) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AttrNumberIsForUserDefinedAttr</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_strongest_dependency
 *		find the strongest dependency on the attributes
 *
 * When applying functional dependencies, we start with the strongest
 * dependencies. That is, we select the dependency that:
 *
 * (a) has all attributes covered by equality clauses
 *
 * (b) has the most attributes
 *
 * (c) has the highest degree of validity
 *
 * This guarantees that we eliminate the most redundant conditions first
 * (see the comment in dependencies_clauselist_selectivity).
 */</comment>
<function><type><specifier>static</specifier> <name>MVDependency</name> <modifier>*</modifier></type>
<name>find_strongest_dependency</name><parameter_list>(<parameter><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl></parameter>,
						  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attnums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>strongest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* number of attnums in clauses */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nattnums</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over the MVDependency items and find the strongest one from the
	 * fully-matched dependencies. We do the cheap checks first, before
	 * matching it against the attnums.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dependencies</name><operator>-&gt;</operator><name>ndeps</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name><name>dependencies</name><operator>-&gt;</operator><name>deps</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip dependencies referencing more attributes than available
		 * clauses, as those can't be fully matched.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&gt;</operator> <name>nattnums</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>strongest</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip dependencies on fewer attributes than the strongest. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&lt;</operator> <name><name>strongest</name><operator>-&gt;</operator><name>nattributes</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* also skip weaker dependencies when attribute count matches */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>strongest</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>==</operator> <name><name>dependency</name><operator>-&gt;</operator><name>nattributes</name></name> <operator>&amp;&amp;</operator>
				<name><name>strongest</name><operator>-&gt;</operator><name>degree</name></name> <operator>&gt;</operator> <name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * this dependency is stronger, but we must still check that it's
		 * fully matched to these attnums. We perform this check last as it's
		 * slightly more expensive than the previous checks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>dependency_is_fully_matched</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strongest</name> <operator>=</operator> <name>dependency</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* save new best match */</comment>
	</block_content>}</block></for>

	<return>return <expr><name>strongest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * dependencies_clauselist_selectivity
 *		Return the estimated selectivity of (a subset of) the given clauses
 *		using functional dependency statistics, or 1.0 if no useful functional
 *		dependency statistic exists.
 *
 * 'estimatedclauses' is an output argument that gets a bit set corresponding
 * to the (zero-based) list index of each clause that is included in the
 * estimated selectivity.
 *
 * Given equality clauses on attributes (a,b) we find the strongest dependency
 * between them, i.e. either (a=&gt;b) or (b=&gt;a). Assuming (a=&gt;b) is the selected
 * dependency, we then combine the per-clause selectivities using the formula
 *
 *	   P(a,b) = P(a) * [f + (1-f)*P(b)]
 *
 * where 'f' is the degree of the dependency.
 *
 * With clauses on more than two attributes, the dependencies are applied
 * recursively, starting with the widest/strongest dependencies. For example
 * P(a,b,c) is first split like this:
 *
 *	   P(a,b,c) = P(a,b) * [f + (1-f)*P(c)]
 *
 * assuming (a,b=&gt;c) is the strongest dependency.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>dependencies_clauselist_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
									<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
									<parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
									<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>estimatedclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>clauses_attnums</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>stat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVDependencies</name> <modifier>*</modifier></type><name>dependencies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>list_attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>listidx</name></decl>;</decl_stmt>

	<comment type="block">/* initialize output argument */</comment>
	<expr_stmt><expr><operator>*</operator><name>estimatedclauses</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* check if there's any stats that might be useful for us. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_stats_of_kind</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name></expr></argument>, <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>list_attnums</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
										 <call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pre-process the clauses list to extract the attnums seen in each item.
	 * We need to determine if there's any clauses which will be useful for
	 * dependency selectivity estimations. Along the way we'll record all of
	 * the attnums for each clause in a list which we'll reference later so we
	 * don't need to repeat the same work again. We'll also keep track of all
	 * attnums seen.
	 */</comment>
	<expr_stmt><expr><name>listidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>dependency_is_compatible_clause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>clauses_attnums</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>listidx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's not at least two distinct attnums then reject the whole list
	 * of clauses. We must return 1.0 so the calling function's selectivity is
	 * unaffected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find the best suited statistics object for these attnums */</comment>
	<expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>choose_best_statistics</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name></expr></argument>, <argument><expr><name>clauses_attnums</name></expr></argument>,
								  <argument><expr><name>STATS_EXT_DEPENDENCIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if no matching stats could be found then we've nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stat</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* load the dependency items stored in the statistics object */</comment>
	<expr_stmt><expr><name>dependencies</name> <operator>=</operator> <call><name>statext_dependencies_load</name><argument_list>(<argument><expr><name><name>stat</name><operator>-&gt;</operator><name>statOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply the dependencies recursively, starting with the widest/strongest
	 * ones, and proceeding to the smaller/weaker ones. At the end of each
	 * round we factor in the selectivity of clauses on the implied attribute,
	 * and remove the clauses from the list.
	 */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>s2</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MVDependency</name> <modifier>*</modifier></type><name>dependency</name></decl>;</decl_stmt>

		<comment type="block">/* the widest/strongest dependency, fully matched by clauses */</comment>
		<expr_stmt><expr><name>dependency</name> <operator>=</operator> <call><name>find_strongest_dependency</name><argument_list>(<argument><expr><name>stat</name></expr></argument>, <argument><expr><name>dependencies</name></expr></argument>,
											   <argument><expr><name>clauses_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if no suitable dependency was found, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dependency</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We found an applicable dependency, so find all the clauses on the
		 * implied attribute - with dependency (a,b =&gt; c) we look for clauses
		 * on 'c'.
		 */</comment>
		<expr_stmt><expr><name>listidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>listidx</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * Skip incompatible clauses, and ones we've already estimated on.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name> <operator>==</operator> <name>InvalidAttrNumber</name> <operator>||</operator>
				<call><name>bms_is_member</name><argument_list>(<argument><expr><name>listidx</name></expr></argument>, <argument><expr><operator>*</operator><name>estimatedclauses</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Technically we could find more than one clause for a given
			 * attnum. Since these clauses must be equality clauses, we choose
			 * to only take the selectivity estimate from the final clause in
			 * the list for this attnum. If the attnum happens to be compared
			 * to a different Const in another clause then no rows will match
			 * anyway. If it happens to be compared to the same Const, then
			 * ignoring the additional clause is just the thing to do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>dependency_implies_attribute</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>,
											 <argument><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>clause_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
										<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* mark this one as done, so we don't touch it again. */</comment>
				<expr_stmt><expr><operator>*</operator><name>estimatedclauses</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>estimatedclauses</name></expr></argument>, <argument><expr><name>listidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Mark that we've got and used the dependency on this clause.
				 * We'll want to ignore this when looking for the next
				 * strongest dependency above.
				 */</comment>
				<expr_stmt><expr><name>clauses_attnums</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>clauses_attnums</name></expr></argument>,
												 <argument><expr><name><name>list_attnums</name><index>[<expr><name>listidx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Now factor in the selectivity for all the "implied" clauses into
		 * the final one, using this formula:
		 *
		 * P(a,b) = P(a) * (f + (1-f) * P(b))
		 *
		 * where 'f' is the degree of validity of the dependency.
		 */</comment>
		<expr_stmt><expr><name>s1</name> <operator>*=</operator> <operator>(</operator><name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name><name>dependency</name><operator>-&gt;</operator><name>degree</name></name><operator>)</operator> <operator>*</operator> <name>s2</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dependencies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list_attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>
</unit>
