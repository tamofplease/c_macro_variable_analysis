<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/replication/walsender.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * walsender.c
 *
 * The WAL sender process (walsender) is new as of Postgres 9.0. It takes
 * care of sending XLOG from the primary server to a single recipient.
 * (Note that there can be more than one walsender process concurrently.)
 * It is started by the postmaster when the walreceiver of a standby server
 * connects to the primary server and requests XLOG streaming replication.
 *
 * A walsender is similar to a regular backend, ie. there is a one-to-one
 * relationship between a connection and a walsender process, but instead
 * of processing SQL queries, it understands a small set of special
 * replication-mode commands. The START_REPLICATION command begins streaming
 * WAL to the client. While streaming, the walsender keeps reading XLOG
 * records from the disk and sends them to the standby server over the
 * COPY protocol, until either side ends the replication by exiting COPY
 * mode (or until the connection is closed).
 *
 * Normal termination is by SIGTERM, which instructs the walsender to
 * close the connection and exit(0) at the next convenient moment. Emergency
 * termination is by SIGQUIT; like any backend, the walsender will simply
 * abort and exit on SIGQUIT. A close of the connection and a FATAL error
 * are treated as not a crash but approximately normal termination;
 * the walsender will exit quickly without sending any more XLOG records.
 *
 * If the server is shut down, checkpointer sends us
 * PROCSIG_WALSND_INIT_STOPPING after all regular backends have exited.  If
 * the backend is idle or runs an SQL query this causes the backend to
 * shutdown, if logical replication is in progress all existing WAL records
 * are processed followed by a shutdown.  Otherwise this causes the walsender
 * to switch to the "stopping" state. In this state, the walsender will reject
 * any further replication commands. The checkpointer begins the shutdown
 * checkpoint once all walsenders are confirmed as stopping. When the shutdown
 * checkpoint finishes, the postmaster sends us SIGUSR2. This instructs
 * walsender to send any outstanding WAL, including the shutdown checkpoint
 * record, wait for it to be replicated to the standby, and then exit.
 *
 *
 * Portions Copyright (c) 2010-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/replication/walsender.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/timeline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/replnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/basebackup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/decode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/dest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Maximum data payload in a WAL data message.  Must be &gt;= XLOG_BLCKSZ.
 *
 * We don't have a good idea of what a good value would be; there's some
 * overhead per message in both walsender and walreceiver, but on the other
 * hand sending large batches makes walsender less responsive to signals
 * because signals are checked only between messages.  128kB (with
 * default 8k blocks) seems like a reasonable guess for now.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SEND_SIZE</name></cpp:macro> <cpp:value>(XLOG_BLCKSZ * 16)</cpp:value></cpp:define>

<comment type="block">/* Array of WalSnds in shared memory */</comment>
<decl_stmt><decl><type><name>WalSndCtlData</name> <modifier>*</modifier></type><name>WalSndCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* My slot in the shared memory array */</comment>
<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>MyWalSnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Global state */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_walsender</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Am I a walsender process? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_cascading_walsender</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Am I cascading WAL to another
											 * standby? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_db_walsender</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Connected to a database? */</comment>

<comment type="block">/* User-settable parameters for walsender */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>max_wal_senders</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* the maximum number of concurrent
									 * walsenders */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>wal_sender_timeout</name> <init>= <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* maximum time to send one WAL
											 * data message */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_replication_commands</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * State for WalSndWakeupRequest
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>wake_wal_senders</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These variables are used similarly to openLogFile/SegNo/Off,
 * but for walsender to read the XLOG.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sendFile</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogSegNo</name></type> <name>sendSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>sendOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Timeline ID of the currently open file */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>curFileTimeLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These variables keep track of the state of the timeline we're currently
 * sending. sendTimeLine identifies the timeline. If sendTimeLineIsHistoric,
 * the timeline is not the latest timeline on this server, and the server's
 * history forked off from that timeline at sendTimeLineValidUpto.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>sendTimeLine</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimeLineID</name></type> <name>sendTimeLineNextTLI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>sendTimeLineIsHistoric</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>sendTimeLineValidUpto</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * How far have we sent WAL already? This is also advertised in
 * MyWalSnd-&gt;sentPtr.  (Actually, this is the next WAL location to send.)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>sentPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Buffers for constructing outgoing messages and processing reply messages. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>output_message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>reply_message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfoData</name></type> <name>tmpbuf</name></decl>;</decl_stmt>

<comment type="block">/* Timestamp of last ProcessRepliesIfAny(). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_processing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Timestamp of last ProcessRepliesIfAny() that saw a reply from the
 * standby. Set to 0 if wal_sender_timeout doesn't need to be active.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_reply_timestamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Have we sent a heartbeat message asking for reply, since last reply? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>waiting_for_ping_response</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * While streaming WAL in Copy mode, streamingDoneSending is set to true
 * after we have sent CopyDone. We should not send any more CopyData messages
 * after that. streamingDoneReceiving is set to true when we receive CopyDone
 * from the other end. When both become true, it's time to exit Copy mode.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>streamingDoneSending</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>streamingDoneReceiving</name></decl>;</decl_stmt>

<comment type="block">/* Are we there yet? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>WalSndCaughtUp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flags set by signal handlers for later service in main loop */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGUSR2</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_STOPPING</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This is set while we are streaming. When not set
 * PROCSIG_WALSND_INIT_STOPPING signal will be handled like SIGTERM. When set,
 * the main loop is responsible for checking got_STOPPING and terminating when
 * it's set (after streaming any remaining WAL).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>replication_active</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>logical_decoding_ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>logical_startptr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* A sample associating a WAL location with the time it was written. */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>time</name></decl>;</decl_stmt>
}</block></struct></type> <name>WalTimeSample</name>;</typedef>

<comment type="block">/* The size of our buffer of time samples. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAG_TRACKER_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* A mechanism for tracking replication lag. */</comment>
<struct><specifier>static</specifier> struct
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalTimeSample</name></type> <name><name>buffer</name><index>[<expr><name>LAG_TRACKER_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>write_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>read_heads</name><index>[<expr><name>NUM_SYNC_REP_WAIT_MODE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalTimeSample</name></type> <name><name>last_read</name><index>[<expr><name>NUM_SYNC_REP_WAIT_MODE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>			<decl><name>LagTracker</name></decl>;</struct>

<comment type="block">/* Signal handlers */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndLastCycleHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Prototypes for private functions */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>WalSndSendDataCallback</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndLoop</name><parameter_list>(<parameter><decl><type><name>WalSndSendDataCallback</name></type> <name>send_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitWalSenderSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndShutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogSendPhysical</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogSendLogical</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndDone</name><parameter_list>(<parameter><decl><type><name>WalSndSendDataCallback</name></type> <name>send_data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>GetStandbyFlushRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IdentifySystem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateReplicationSlot</name><parameter_list>(<parameter><decl><type><name>CreateReplicationSlotCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropReplicationSlot</name><parameter_list>(<parameter><decl><type><name>DropReplicationSlotCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartReplication</name><parameter_list>(<parameter><decl><type><name>StartReplicationCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartLogicalReplication</name><parameter_list>(<parameter><decl><type><name>StartReplicationCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessStandbyMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessStandbyReplyMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessStandbyHSFeedbackMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessRepliesIfAny</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndKeepalive</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndKeepaliveIfNecessary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndCheckTimeOut</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>WalSndComputeSleeptime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndPrepareWrite</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndWriteData</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WalSndUpdateProgress</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>WalSndWaitForWal</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LagTrackerWrite</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>local_flush_time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TimeOffset</name></type> <name>LagTrackerRead</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TransactionIdInRecentPast</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>epoch</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>XLogRead</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>startptr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Initialize walsender process before entering the main command loop */</comment>
<function><type><name>void</name></type>
<name>InitWalSender</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>am_cascading_walsender</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a per-walsender data structure in shared memory */</comment>
	<expr_stmt><expr><call><name>InitWalSenderSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up resource owner */</comment>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"walsender top-level resource owner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let postmaster know that we're a WAL sender. Once we've declared us as
	 * a WAL sender process, postmaster will let us outlive the bgwriter and
	 * kill us last in the shutdown sequence, so we get a chance to stream all
	 * remaining WAL at shutdown, including the shutdown checkpoint. Note that
	 * there's no going back, and we mustn't write any WAL records after this.
	 */</comment>
	<expr_stmt><expr><call><name>MarkPostmasterChildWalSender</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_ADVANCE_STATE_MACHINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize empty timestamp buffer for lag tracking. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>LagTracker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LagTracker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up after an error.
 *
 * WAL sender processes don't use transactions like regular backends do.
 * This function does any cleanup required after an error in a WAL sender
 * process, similar to what transaction abort does in a regular backend.
 */</comment>
<function><type><name>void</name></type>
<name>WalSndErrorCleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>replication_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name> <operator>||</operator> <name>got_SIGUSR2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Revert back to startup state */</comment>
	<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle a client's connection abort in an orderly manner.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndShutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Reset whereToSendOutput to prevent ereport from attempting to send any
	 * more messages to the standby.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* keep the compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Handle the IDENTIFY_SYSTEM command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IdentifySystem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>sysid</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xloc</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>logptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reply with a result set with one row, four columns. First col is system
	 * ID, second is timeline ID, third is current xlog location and the
	 * fourth contains the database name if we are connected to one.
	 */</comment>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>am_cascading_walsender</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>am_cascading_walsender</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this also updates ThisTimeLineID */</comment>
		<expr_stmt><expr><name>logptr</name> <operator>=</operator> <call><name>GetStandbyFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>logptr</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xloc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xloc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>logptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>logptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cur</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* syscache access needs a transaction env. */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make dbname live outside TX context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* CommitTransactionCommand switches to TopMemoryContext */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestRemoteSimple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need a tuple descriptor representing four columns */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"systemid"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"timeline"</literal></expr></argument>,
							  <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"xlogpos"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* column 1: system identifier */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* column 2: timeline */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* column 3: wal location */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>xloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* column 4: database name, or NULL if none */</comment>
	<if_stmt><if>if <condition>(<expr><name>dbname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* send it to dest */</comment>
	<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Handle TIMELINE_HISTORY command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendTimeLineHistory</name><parameter_list>(<parameter><decl><type><name>TimeLineHistoryCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>histfname</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>histfilelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reply with a result set with one row, and two columns. The first col is
	 * the name of the history file, 2nd is the contents.
	 */</comment>

	<expr_stmt><expr><call><name>TLHistoryFileName</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TLHistoryFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send a RowDescription message */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* 2 fields */</comment>

	<comment type="block">/* first field */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"filename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* col name */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typlen */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typmod */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* format code */</comment>

	<comment type="block">/* second field */</comment>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"content"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* col name */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typlen */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typmod */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* format code */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send a DataRow message */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* # of columns */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>histfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* col1 len */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>histfname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Determine file length and send it to client */</comment>
	<expr_stmt><expr><name>histfilelen</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>histfilelen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to end of file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to beginning of file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>histfilelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* col2 len */</comment>

	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>histfilelen</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>bytesleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>rbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nread</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>rbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>nread</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle START_REPLICATION command.
 *
 * At the moment, this never returns, but an ereport(ERROR) will take us back
 * to the main loop.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartReplication</name><parameter_list>(<parameter><decl><type><name>StartReplicationCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>FlushPtr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ThisTimeLineID</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"IDENTIFY_SYSTEM has not been run before START_REPLICATION"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We assume here that we're logging enough information in the WAL for
	 * log-shipping, since this is checked in PostmasterMain().
	 *
	 * NOTE: wal_level can only change at shutdown, so in most cases it is
	 * difficult for there to be WAL data that we can still see that was
	 * written at wal_level='minimal'.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReplicationSlotAcquire</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>SlotIsLogical</name><argument_list>(<argument><expr><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use a logical replication slot for physical replication"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Select the timeline. If it was given explicitly by the client, use
	 * that. Otherwise use the timeline of the last replayed record, which is
	 * kept in ThisTimeLineID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_cascading_walsender</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this also updates ThisTimeLineID */</comment>
		<expr_stmt><expr><name>FlushPtr</name> <operator>=</operator> <call><name>GetStandbyFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>FlushPtr</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>switchpoint</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sendTimeLine</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sendTimeLine</name> <operator>==</operator> <name>ThisTimeLineID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendTimeLineValidUpto</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>timeLineHistory</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check that the timeline the client requested exists, and the
			 * requested start location is on that timeline.
			 */</comment>
			<expr_stmt><expr><name>timeLineHistory</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>switchpoint</name> <operator>=</operator> <call><name>tliSwitchPoint</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>, <argument><expr><name>timeLineHistory</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>sendTimeLineNextTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>timeLineHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Found the requested timeline in the history. Check that
			 * requested startpoint is on that timeline in our history.
			 *
			 * This is quite loose on purpose. We only check that we didn't
			 * fork off the requested timeline before the switchpoint. We
			 * don't check that we switched *to* it before the requested
			 * starting point. This is because the client can legitimately
			 * request to start replication from the beginning of the WAL
			 * segment that contains switchpoint, but on the new timeline, so
			 * that it doesn't end up with a partial segment. If you ask for
			 * too old a starting point, you'll get an error later when we
			 * fail to find the requested WAL segment in pg_wal.
			 *
			 * XXX: we could be more strict here and only allow a startpoint
			 * that's older than the switchpoint, if it's still in the same
			 * WAL segment.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>switchpoint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>switchpoint</name> <operator>&lt;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested starting point %X/%X on timeline %u is not in this server's history"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name><operator>)</operator></expr></argument>,
								<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This server's history forked from timeline %u at %X/%X."</literal></expr></argument>,
								   <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>timeline</name></name></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>switchpoint</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
								   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>switchpoint</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>sendTimeLineValidUpto</name> <operator>=</operator> <name>switchpoint</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sendTimeLine</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sendTimeLineValidUpto</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>streamingDoneSending</name> <operator>=</operator> <name>streamingDoneReceiving</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* If there is nothing to stream, don't even enter COPY mode */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sendTimeLineIsHistoric</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name> <operator>&lt;</operator> <name>sendTimeLineValidUpto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When we first start replication the standby will be behind the
		 * primary. For some applications, for example synchronous
		 * replication, it is important to have a clear state for this initial
		 * catchup mode, so we can trigger actions when we change streaming
		 * state later. We may stay in this state for a long time, which is
		 * exactly why we want to be able to monitor whether or not we are
		 * still here.
		 */</comment>
		<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_CATCHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Send a CopyBothResponse message, and start streaming */</comment>
		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'W'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't allow a request to stream from a future point in WAL that
		 * hasn't been flushed to disk in this server yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>FlushPtr</name> <operator>&lt;</operator> <name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested starting point %X/%X is ahead of the WAL flush position of this server %X/%X"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>FlushPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>FlushPtr</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Start streaming from the requested point */</comment>
		<expr_stmt><expr><name>sentPtr</name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name></expr>;</expr_stmt>

		<comment type="block">/* Initialize shared memory status, too */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyWalSnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>sentPtr</name></name> <operator>=</operator> <name>sentPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyWalSnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SyncRepInitConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Main loop of walsender */</comment>
		<expr_stmt><expr><name>replication_active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WalSndLoop</name><argument_list>(<argument><expr><name>XLogSendPhysical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>replication_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>streamingDoneSending</name> <operator>&amp;&amp;</operator> <name>streamingDoneReceiving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy is finished now. Send a single-row result set indicating the next
	 * timeline.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sendTimeLineIsHistoric</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>startpos_str</name><index>[<expr><literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>startpos_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startpos_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>sendTimeLineValidUpto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>sendTimeLineValidUpto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestRemoteSimple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need a tuple descriptor representing two columns. int8 may seem
		 * like a surprising data type for this, but in theory int4 would not
		 * be wide enough for this, as TimeLineID is unsigned.
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"next_tli"</literal></expr></argument>,
								  <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"next_tli_startpos"</literal></expr></argument>,
								  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prepare for projection of tuple */</comment>
		<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>sendTimeLineNextTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>startpos_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* send it to dest */</comment>
		<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send CommandComplete message */</comment>
	<expr_stmt><expr><call><name>pq_puttextmessage</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><literal type="string">"START_STREAMING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * read_page callback for logical decoding contexts, as a walsender process.
 *
 * Inside the walsender we can do better than logical_read_local_xlog_page,
 * which has to do a plain sleep/busy loop, because the walsender's latch gets
 * set every time WAL is flushed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>logical_read_xlog_page</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetPagePtr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reqLen</name></decl></parameter>,
					   <parameter><decl><type><name>XLogRecPtr</name></type> <name>targetRecPtr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cur_page</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name> <modifier>*</modifier></type><name>pageTLI</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flushptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogReadDetermineTimeline</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name> <operator>!=</operator> <name>ThisTimeLineID</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTimeLine</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>currTLI</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTimeLineValidUpto</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>currTLIValidUntil</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTimeLineNextTLI</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>nextTLI</name></name></expr>;</expr_stmt>

	<comment type="block">/* make sure we have enough WAL available */</comment>
	<expr_stmt><expr><name>flushptr</name> <operator>=</operator> <call><name>WalSndWaitForWal</name><argument_list>(<argument><expr><name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fail if not (implies we are going to shut down) */</comment>
	<if_stmt><if>if <condition>(<expr><name>flushptr</name> <operator>&lt;</operator> <name>targetPagePtr</name> <operator>+</operator> <name>reqLen</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetPagePtr</name> <operator>+</operator> <name>XLOG_BLCKSZ</name> <operator>&lt;=</operator> <name>flushptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>XLOG_BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* more than one block available */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>flushptr</name> <operator>-</operator> <name>targetPagePtr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* part of the page available */</comment>

	<comment type="block">/* now actually read the data, we know it's there */</comment>
	<expr_stmt><expr><call><name>XLogRead</name><argument_list>(<argument><expr><name>cur_page</name></expr></argument>, <argument><expr><name>targetPagePtr</name></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process extra options given to CREATE_REPLICATION_SLOT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseCreateReplSlotOptions</name><parameter_list>(<parameter><decl><type><name>CreateReplicationSlotCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reserve_wal</name></decl></parameter>,
						   <parameter><decl><type><name>CRSSnapshotAction</name> <modifier>*</modifier></type><name>snapshot_action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>snapshot_action_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reserve_wal_given</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Parse options */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cmd-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"export_snapshot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>snapshot_action_given</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>REPLICATION_KIND_LOGICAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>snapshot_action_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>snapshot_action</name> <operator>=</operator> <ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>CRS_EXPORT_SNAPSHOT</name></expr> </then><else>:
				<expr><name>CRS_NOEXPORT_SNAPSHOT</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"use_snapshot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>snapshot_action_given</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>REPLICATION_KIND_LOGICAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>snapshot_action_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>snapshot_action</name> <operator>=</operator> <name>CRS_USE_SNAPSHOT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"reserve_wal"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>reserve_wal_given</name> <operator>||</operator> <name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>REPLICATION_KIND_PHYSICAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>reserve_wal_given</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>reserve_wal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Create a new replication slot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateReplicationSlot</name><parameter_list>(<parameter><decl><type><name>CreateReplicationSlotCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>snapshot_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xloc</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>slot_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reserve_wal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CRSSnapshotAction</name></type> <name>snapshot_action</name> <init>= <expr><name>CRS_EXPORT_SNAPSHOT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>parseCreateReplSlotOptions</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reserve_wal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>snapshot_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setup state for XLogReadPage */</comment>
	<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTimeLine</name> <operator>=</operator> <name>ThisTimeLineID</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REPLICATION_KIND_PHYSICAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReplicationSlotCreate</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>temporary</name></name></expr> ?</condition><then> <expr><name>RS_TEMPORARY</name></expr> </then><else>: <expr><name>RS_PERSISTENT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckLogicalDecodingRequirements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initially create persistent slot as ephemeral - that allows us to
		 * nicely handle errors during initialization because it'll get
		 * dropped if this transaction fails. We'll make it persistent at the
		 * end. Temporary slots can be created as temporary from beginning as
		 * they get dropped on error as well.
		 */</comment>
		<expr_stmt><expr><call><name>ReplicationSlotCreate</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><ternary><condition><expr><name><name>cmd</name><operator>-&gt;</operator><name>temporary</name></name></expr> ?</condition><then> <expr><name>RS_TEMPORARY</name></expr> </then><else>: <expr><name>RS_EPHEMERAL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REPLICATION_KIND_LOGICAL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_full_snapshot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Do options check early so that we can bail before calling the
		 * DecodingContextFindStartpoint which can take long time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_action</name> <operator>==</operator> <name>CRS_EXPORT_SNAPSHOT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE_REPLICATION_SLOT ... EXPORT_SNAPSHOT "</literal>
								<literal type="string">"must not be called inside a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>need_full_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>snapshot_action</name> <operator>==</operator> <name>CRS_USE_SNAPSHOT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</literal>
								<literal type="string">"must be called inside a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>XactIsoLevel</name> <operator>!=</operator> <name>XACT_REPEATABLE_READ</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</literal>
								<literal type="string">"must be called in REPEATABLE READ isolation mode transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>FirstSnapshotSet</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</literal>
								<literal type="string">"must be called before any query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE_REPLICATION_SLOT ... USE_SNAPSHOT "</literal>
								<literal type="string">"must not be called in a subtransaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>need_full_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>CreateInitDecodingContext</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>plugin</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>need_full_snapshot</name></expr></argument>,
										<argument><expr><name>logical_read_xlog_page</name></expr></argument>,
										<argument><expr><name>WalSndPrepareWrite</name></expr></argument>, <argument><expr><name>WalSndWriteData</name></expr></argument>,
										<argument><expr><name>WalSndUpdateProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Signal that we don't need the timeout mechanism. We're just
		 * creating the replication slot and don't yet accept feedback
		 * messages or send keepalives. As we possibly need to wait for
		 * further WAL the walsender would otherwise possibly be killed too
		 * soon.
		 */</comment>
		<expr_stmt><expr><name>last_reply_timestamp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* build initial snapshot, might take a while */</comment>
		<expr_stmt><expr><call><name>DecodingContextFindStartpoint</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Export or use the snapshot if we've been asked to do so.
		 *
		 * NB. We will convert the snapbuild.c kind of snapshot to normal
		 * snapshot when doing this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshot_action</name> <operator>==</operator> <name>CRS_EXPORT_SNAPSHOT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot_name</name> <operator>=</operator> <call><name>SnapBuildExportSnapshot</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>snapshot_action</name> <operator>==</operator> <name>CRS_USE_SNAPSHOT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>SnapBuildInitialSnapshot</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>snapshot_builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RestoreTransactionSnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* don't need the decoding context anymore */</comment>
		<expr_stmt><expr><call><name>FreeDecodingContext</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>temporary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReplicationSlotPersist</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REPLICATION_KIND_PHYSICAL</name> <operator>&amp;&amp;</operator> <name>reserve_wal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReplicationSlotReserveWal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write this slot to disk if it's a permanent one. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>temporary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReplicationSlotSave</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xloc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xloc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestRemoteSimple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Need a tuple descriptor representing four columns:
	 * - first field: the slot name
	 * - second field: LSN at which we became consistent
	 * - third field: exported snapshot's name
	 * - fourth field: output plugin
	 *----------
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"slot_name"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"consistent_point"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"snapshot_name"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"output_plugin"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* slot_name */</comment>
	<expr_stmt><expr><name>slot_name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>slot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* consistent wal location */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>xloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* snapshot name, or NULL if none */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshot_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>snapshot_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* plugin, or NULL if none */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>plugin</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>plugin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* send it to dest */</comment>
	<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get rid of a replication slot that is no longer wanted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropReplicationSlot</name><parameter_list>(<parameter><decl><type><name>DropReplicationSlotCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ReplicationSlotDrop</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>cmd</name><operator>-&gt;</operator><name>wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><literal type="string">"DROP_REPLICATION_SLOT"</literal></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load previously initiated logical slot and prepare for sending data (via
 * WalSndLoop).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartLogicalReplication</name><parameter_list>(<parameter><decl><type><name>StartReplicationCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/* make sure that our requirements are still fulfilled */</comment>
	<expr_stmt><expr><call><name>CheckLogicalDecodingRequirements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReplicationSlotAcquire</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>slotname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force a disconnect, so that the decoding code doesn't need to care
	 * about an eventual switch from running in recovery, to running in a
	 * normal environment. Client code is expected to handle reconnects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_cascading_walsender</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walsender process after promotion"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>got_STOPPING</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create our decoding context, making it start at the previously ack'ed
	 * position.
	 *
	 * Do this before sending CopyBoth, so that any errors are reported early.
	 */</comment>
	<expr_stmt><expr><name>logical_decoding_ctx</name> <operator>=</operator>
		<call><name>CreateDecodingContext</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>startpoint</name></name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>logical_read_xlog_page</name></expr></argument>,
							  <argument><expr><name>WalSndPrepareWrite</name></expr></argument>, <argument><expr><name>WalSndWriteData</name></expr></argument>,
							  <argument><expr><name>WalSndUpdateProgress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_CATCHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send a CopyBothResponse message, and start streaming */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'W'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* Start reading WAL from the oldest required WAL. */</comment>
	<expr_stmt><expr><name>logical_startptr</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Report the location after which we'll send out further commits as the
	 * current sentPtr.
	 */</comment>
	<expr_stmt><expr><name>sentPtr</name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>confirmed_flush</name></name></expr>;</expr_stmt>

	<comment type="block">/* Also update the sent position status in shared memory */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyWalSnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>sentPtr</name></name> <operator>=</operator> <name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyWalSnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>replication_active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SyncRepInitConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Main loop of walsender */</comment>
	<expr_stmt><expr><call><name>WalSndLoop</name><argument_list>(<argument><expr><name>XLogSendLogical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeDecodingContext</name><argument_list>(<argument><expr><name>logical_decoding_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReplicationSlotRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>replication_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get out of COPY mode (CommandComplete). */</comment>
	<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><literal type="string">"COPY 0"</literal></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LogicalDecodingContext 'prepare_write' callback.
 *
 * Prepare a write into a StringInfo.
 *
 * Don't do anything lasting in here, it's quite possible that nothing will be done
 * with the data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndPrepareWrite</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* can't have sync rep confused by sending the same LSN several times */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_write</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* dataStart */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* walEnd */</comment>

	<comment type="block">/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendtime */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * LogicalDecodingContext 'write' callback.
 *
 * Actually write out data previously prepared by WalSndPrepareWrite out to
 * the network. Take as long as needed, but process replies from the other
 * side and check timeouts during that.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndWriteData</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>last_write</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

	<comment type="block">/* output previously gathered data in a CopyData packet */</comment>
	<expr_stmt><expr><call><name>pq_putmessage_noblock</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>out</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill the send timestamp last, so that it is taken as late as possible.
	 * This is somewhat ugly, but the protocol is set as it's already used for
	 * several releases by streaming physical replication.
	 */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>out</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>,
		   <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Try to flush pending output to the client */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pq_flush_if_writable</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Try taking fast path unless we get too close to walsender timeout. */</comment>
	<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&lt;</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_reply_timestamp</name></expr></argument>,
										  <argument><expr><name>wal_sender_timeout</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we have pending write here, go to slow path */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wakeEvents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name></decl>;</decl_stmt>

		<comment type="block">/* Check for input from the client */</comment>
		<expr_stmt><expr><call><name>ProcessRepliesIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* die if timeout was reached */</comment>
		<expr_stmt><expr><call><name>WalSndCheckTimeOut</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Send keepalive if the time has come */</comment>
		<expr_stmt><expr><call><name>WalSndKeepaliveIfNecessary</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <call><name>WalSndComputeSleeptime</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>wakeEvents</name> <operator>=</operator> <name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator>
			<name>WL_SOCKET_WRITEABLE</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr>;</expr_stmt>

		<comment type="block">/* Sleep until something happens or we time out */</comment>
		<expr_stmt><expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>wakeEvents</name></expr></argument>,
						  <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>sleeptime</name></expr></argument>,
						  <argument><expr><name>WAIT_EVENT_WAL_SENDER_WRITE_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Emergency bailout if postmaster has died.  This is to avoid the
		 * necessity for manual cleanup of all postmaster children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process any requests or signals received recently */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyncRepInitConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Try to flush pending output to the client */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_flush_if_writable</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* reactivate latch so WalSndLoop knows to continue */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LogicalDecodingContext 'update_progress' callback.
 *
 * Write the current position to the lag tracker (see XLogSendPhysical).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndUpdateProgress</name><parameter_list>(<parameter><decl><type><name>LogicalDecodingContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>sendTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Track lag no more than once per WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS to
	 * avoid flooding the lag tracker when we commit frequently.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</name></cpp:macro>	<cpp:value>1000</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>sendTime</name></expr></argument>, <argument><expr><name>now</name></expr></argument>,
									<argument><expr><name>WALSND_LOGICAL_LAG_TRACK_INTERVAL_MS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LagTrackerWrite</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendTime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait till WAL &lt; loc is flushed to disk so it can be safely sent to client.
 *
 * Returns end LSN of flushed WAL.  Normally this will be &gt;= loc, but
 * if we detect a shutdown request (either from postmaster or client)
 * we will return early, so caller must always check.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>WalSndWaitForWal</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wakeEvents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>RecentFlushPtr</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>


	<comment type="block">/*
	 * Fast path to avoid acquiring the spinlock in case we already know we
	 * have enough WAL available. This is particularly interesting if we're
	 * far behind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>RecentFlushPtr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name> <operator>&amp;&amp;</operator>
		<name>loc</name> <operator>&lt;=</operator> <name>RecentFlushPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RecentFlushPtr</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Get a more recent flush pointer. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>RecentFlushPtr</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>RecentFlushPtr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Emergency bailout if postmaster has died.  This is to avoid the
		 * necessity for manual cleanup of all postmaster children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process any requests or signals received recently */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyncRepInitConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for input from the client */</comment>
		<expr_stmt><expr><call><name>ProcessRepliesIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're shutting down, trigger pending WAL to be written out,
		 * otherwise we'd possibly end up waiting for WAL that never gets
		 * written, because walwriter has shut down already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogBackgroundFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Update our idea of the currently flushed position. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>RecentFlushPtr</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>RecentFlushPtr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If postmaster asked us to stop, don't wait anymore.
		 *
		 * It's important to do this check after the recomputation of
		 * RecentFlushPtr, so we can send all remaining data before shutting
		 * down.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We only send regular messages to the client for full decoded
		 * transactions, but a synchronous replication and walsender shutdown
		 * possibly are waiting for a later location. So we send pings
		 * containing the flush location every now and then.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>flush</name></name> <operator>&lt;</operator> <name>sentPtr</name> <operator>&amp;&amp;</operator>
			<name><name>MyWalSnd</name><operator>-&gt;</operator><name>write</name></name> <operator>&lt;</operator> <name>sentPtr</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>waiting_for_ping_response</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WalSndKeepalive</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>waiting_for_ping_response</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check whether we're done */</comment>
		<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;=</operator> <name>RecentFlushPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Waiting for new WAL. Since we need to wait, we're now caught up. */</comment>
		<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to flush any pending output to the client.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_flush_if_writable</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have received CopyDone from the client, sent CopyDone
		 * ourselves, and the output buffer is empty, it's time to exit
		 * streaming, so fail the current WAL fetch request.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>streamingDoneReceiving</name> <operator>&amp;&amp;</operator> <name>streamingDoneSending</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* die if timeout was reached */</comment>
		<expr_stmt><expr><call><name>WalSndCheckTimeOut</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Send keepalive if the time has come */</comment>
		<expr_stmt><expr><call><name>WalSndKeepaliveIfNecessary</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep until something happens or we time out.  Also wait for the
		 * socket becoming writable, if there's still pending output.
		 * Otherwise we might sit on sendable output data while waiting for
		 * new WAL to be generated.  (But if we have nothing to send, we don't
		 * want to wake on socket-writable.)
		 */</comment>
		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <call><name>WalSndComputeSleeptime</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>wakeEvents</name> <operator>=</operator> <name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator>
			<name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>wakeEvents</name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>wakeEvents</name></expr></argument>,
						  <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>sleeptime</name></expr></argument>,
						  <argument><expr><name>WAIT_EVENT_WAL_SENDER_WAIT_WAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* reactivate latch so WalSndLoop knows to continue */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>RecentFlushPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute an incoming replication command.
 *
 * Returns true if the cmd_string was recognized as WalSender command, false
 * if not.
 */</comment>
<function><type><name>bool</name></type>
<name>exec_replication_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>parse_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cmd_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cmd_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If WAL sender has been told that shutdown is getting close, switch its
	 * status accordingly to handle the next replication commands correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Throw error if in stopping mode.  We need prevent commands that could
	 * generate WAL while the shutdown checkpoint is being written.  To be
	 * safe, we just prohibit all new commands.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute new commands while WAL sender is in stopping mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot until the next
	 * command arrives. Clean up the old stuff if there's anything.
	 */</comment>
	<expr_stmt><expr><call><name>SnapBuildClearExportedSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmd_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"Replication command context"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cmd_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>replication_scanner_init</name><argument_list>(<argument><expr><name>cmd_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>parse_rc</name> <operator>=</operator> <call><name>replication_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parse_rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"replication command parser returned %d"</literal></expr></argument>,
								  <argument><expr><name>parse_rc</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmd_node</name> <operator>=</operator> <name>replication_parse_result</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Log replication command if log_replication_commands is enabled. Even
	 * when it's disabled, log the command with DEBUG1 level for backward
	 * compatibility. Note that SQL commands are not logged here, and will be
	 * logged later if log_statement is enabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cmd_node</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>T_SQLCmd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>log_replication_commands</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received replication command: %s"</literal></expr></argument>, <argument><expr><name>cmd_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * CREATE_REPLICATION_SLOT ... LOGICAL exports a snapshot. If it was
	 * called outside of transaction the snapshot should be cleared here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildClearExportedSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For aborted transactions, don't allow anything except pure SQL, the
	 * exec_simple_query() will handle it correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAbortedTransactionBlockState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>cmd_node</name></expr></argument>, <argument><expr><name>SQLCmd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IN_FAILED_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"current transaction is aborted, "</literal>
						<literal type="string">"commands ignored until end of transaction block"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate buffers that will be used for each outgoing and incoming
	 * message.  We do this just once per command to reduce palloc overhead.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report to pgstat that this process is running */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>cmd_node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IdentifySystemCmd</name></expr>:</case>
			<expr_stmt><expr><call><name>IdentifySystem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_BaseBackupCmd</name></expr>:</case>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"BASE_BACKUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SendBaseBackup</name><argument_list>(<argument><expr><operator>(</operator><name>BaseBackupCmd</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CreateReplicationSlotCmd</name></expr>:</case>
			<expr_stmt><expr><call><name>CreateReplicationSlot</name><argument_list>(<argument><expr><operator>(</operator><name>CreateReplicationSlotCmd</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DropReplicationSlotCmd</name></expr>:</case>
			<expr_stmt><expr><call><name>DropReplicationSlot</name><argument_list>(<argument><expr><operator>(</operator><name>DropReplicationSlotCmd</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_StartReplicationCmd</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StartReplicationCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>StartReplicationCmd</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"START_REPLICATION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REPLICATION_KIND_PHYSICAL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>StartReplication</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>StartLogicalReplication</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_TimeLineHistoryCmd</name></expr>:</case>
			<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"TIMELINE_HISTORY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SendTimeLineHistory</name><argument_list>(<argument><expr><operator>(</operator><name>TimeLineHistoryCmd</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><call><name>CreateDestReceiver</name><argument_list>(<argument><expr><name>DestRemoteSimple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>VariableShowStmt</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>VariableShowStmt</name> <operator>*</operator><operator>)</operator> <name>cmd_node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>GetPGVariable</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SQLCmd</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>MyDatabaseId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute SQL commands in WAL sender for physical replication"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Report to pgstat that this process is now idle */</comment>
			<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Tell the caller that this wasn't a WalSender command. */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized replication command node tag: %u"</literal></expr></argument>,
				 <argument><expr><name><name>cmd_node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* done */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cmd_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send CommandComplete message */</comment>
	<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><literal type="string">"SELECT"</literal></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report to pgstat that this process is now idle */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_IDLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process any incoming messages while streaming. Also checks if the remote
 * end has closed the connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessRepliesIfAny</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>firstchar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>received</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>last_processing</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pq_getbyte_if_available</name><argument_list>(<argument><expr><operator>&amp;</operator><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* unexpected error or EOF */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on standby connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no data available without blocking */</comment>
			<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Read the message contents */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF on standby connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we already received a CopyDone from the frontend, the frontend
		 * should not send us anything until we've closed our end of the COPY.
		 * XXX: In theory, the frontend could already send the next command
		 * before receiving the CopyDone, but libpq doesn't currently allow
		 * that.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>streamingDoneReceiving</name> <operator>&amp;&amp;</operator> <name>firstchar</name> <operator>!=</operator> <literal type="char">'X'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected standby message type \"%c\", after receiving CopyDone"</literal></expr></argument>,
							<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Handle the very limited subset of commands expected in this phase */</comment>
		<switch>switch <condition>(<expr><name>firstchar</name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/*
				 * 'd' means a standby reply wrapped in a CopyData packet.
				 */</comment>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<expr_stmt><expr><call><name>ProcessStandbyMessage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>received</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * CopyDone means the standby requested to finish streaming.
				 * Reply with CopyDone, if we had not sent that already.
				 */</comment>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>streamingDoneSending</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pq_putmessage_noblock</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>streamingDoneSending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>streamingDoneReceiving</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>received</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * 'X' means that the standby is closing down the socket.
				 */</comment>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid standby message type \"%c\""</literal></expr></argument>,
								<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Save the last reply timestamp if we've received at least one reply.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>received</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>last_reply_timestamp</name> <operator>=</operator> <name>last_processing</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>waiting_for_ping_response</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process a status update message received from standby.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessStandbyMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>msgtype</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check message type from the first byte.
	 */</comment>
	<expr_stmt><expr><name>msgtype</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>msgtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'r'</literal></expr>:</case>
			<expr_stmt><expr><call><name>ProcessStandbyReplyMessage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'h'</literal></expr>:</case>
			<expr_stmt><expr><call><name>ProcessStandbyHSFeedbackMessage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected message type \"%c\""</literal></expr></argument>, <argument><expr><name>msgtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Remember that a walreceiver just confirmed receipt of lsn `lsn`.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PhysicalConfirmReceivedLocation</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>MyReplicationSlot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name> <operator>!=</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>restart_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReplicationSlotsComputeRequiredLSN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * One could argue that the slot should be saved to disk now, but that'd
	 * be energy wasted - the worst lost information can do here is give us
	 * wrong information in a statistics view - we'll just potentially be more
	 * conservative in removing files.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Regular reply from standby advising of WAL locations on standby server.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessStandbyReplyMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>writePtr</name></decl>,
				<decl><type ref="prev"/><name>flushPtr</name></decl>,
				<decl><type ref="prev"/><name>applyPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>replyRequested</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>writeLag</name></decl>,
				<decl><type ref="prev"/><name>flushLag</name></decl>,
				<decl><type ref="prev"/><name>applyLag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>clearLagTimes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>now</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>fullyAppliedLastTime</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the caller already consumed the msgtype byte */</comment>
	<expr_stmt><expr><name>writePtr</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flushPtr</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>applyPtr</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendTime; not used ATM */</comment>
	<expr_stmt><expr><name>replyRequested</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"write %X/%X flush %X/%X apply %X/%X%s"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>writePtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>writePtr</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>flushPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>flushPtr</name></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>applyPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>applyPtr</name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name>replyRequested</name></expr> ?</condition><then> <expr><literal type="string">" (reply requested)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See if we can compute the round-trip lag for these positions. */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>writeLag</name> <operator>=</operator> <call><name>LagTrackerRead</name><argument_list>(<argument><expr><name>SYNC_REP_WAIT_WRITE</name></expr></argument>, <argument><expr><name>writePtr</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flushLag</name> <operator>=</operator> <call><name>LagTrackerRead</name><argument_list>(<argument><expr><name>SYNC_REP_WAIT_FLUSH</name></expr></argument>, <argument><expr><name>flushPtr</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>applyLag</name> <operator>=</operator> <call><name>LagTrackerRead</name><argument_list>(<argument><expr><name>SYNC_REP_WAIT_APPLY</name></expr></argument>, <argument><expr><name>applyPtr</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the standby reports that it has fully replayed the WAL in two
	 * consecutive reply messages, then the second such message must result
	 * from wal_receiver_status_interval expiring on the standby.  This is a
	 * convenient time to forget the lag times measured when it last
	 * wrote/flushed/applied a WAL record, to avoid displaying stale lag data
	 * until more WAL traffic arrives.
	 */</comment>
	<expr_stmt><expr><name>clearLagTimes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>applyPtr</name> <operator>==</operator> <name>sentPtr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fullyAppliedLastTime</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>clearLagTimes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fullyAppliedLastTime</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fullyAppliedLastTime</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Send a reply if the standby requested one. */</comment>
	<if_stmt><if>if <condition>(<expr><name>replyRequested</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndKeepalive</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update shared state for this WalSender process based on reply data from
	 * standby.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>writePtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>flush</name></name> <operator>=</operator> <name>flushPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>apply</name></name> <operator>=</operator> <name>applyPtr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>writeLag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>clearLagTimes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>writeLag</name></name> <operator>=</operator> <name>writeLag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>flushLag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>clearLagTimes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>flushLag</name></name> <operator>=</operator> <name>flushLag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>applyLag</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>clearLagTimes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>applyLag</name></name> <operator>=</operator> <name>applyLag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_cascading_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SyncRepReleaseWaiters</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Advance our local xmin horizon when the client confirmed a flush.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>&amp;&amp;</operator> <name>flushPtr</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SlotIsLogical</name><argument_list>(<argument><expr><name>MyReplicationSlot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LogicalConfirmReceivedLocation</name><argument_list>(<argument><expr><name>flushPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PhysicalConfirmReceivedLocation</name><argument_list>(<argument><expr><name>flushPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* compute new replication slot xmin horizon if needed */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PhysicalReplicationSlotNewXmin</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>feedbackXmin</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>feedbackCatalogXmin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>MyReplicationSlot</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For physical replication we don't need the interlock provided by xmin
	 * and effective_xmin since the consequences of a missed increase are
	 * limited to query cancellations, so set both at once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>feedbackXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <name>feedbackXmin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>effective_xmin</name></name> <operator>=</operator> <name>feedbackXmin</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>catalog_xmin</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>catalog_xmin</name></name></expr></argument>, <argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>catalog_xmin</name></name> <operator>=</operator> <name>feedbackCatalogXmin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>effective_catalog_xmin</name></name> <operator>=</operator> <name>feedbackCatalogXmin</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>changed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReplicationSlotMarkDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReplicationSlotsComputeRequiredXmin</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that the provided xmin/epoch are sane, that is, not in the future
 * and not so far back as to be already wrapped around.
 *
 * Epoch of nextXid should be same as standby, or if the counter has
 * wrapped, then one greater than standby.
 *
 * This check doesn't care about whether clog exists for these xids
 * at all.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionIdInRecentPast</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>epoch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nextEpoch</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetNextXidAndEpoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nextXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextEpoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>&lt;=</operator> <name>nextXid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>epoch</name> <operator>!=</operator> <name>nextEpoch</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>epoch</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name>nextEpoch</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nextXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* epoch OK, but it's wrapped around */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hot Standby feedback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessStandbyHSFeedbackMessage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>feedbackXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>feedbackEpoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>feedbackCatalogXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>feedbackCatalogEpoch</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Decipher the reply message. The caller already consumed the msgtype
	 * byte. See XLogWalRcvSendHSFeedback() in walreceiver.c for the creation
	 * of this message.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendTime; not used ATM */</comment>
	<expr_stmt><expr><name>feedbackXmin</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>feedbackEpoch</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>feedbackCatalogXmin</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>feedbackCatalogEpoch</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reply_message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"hot standby feedback xmin %u epoch %u, catalog_xmin %u epoch %u"</literal></expr></argument>,
		 <argument><expr><name>feedbackXmin</name></expr></argument>,
		 <argument><expr><name>feedbackEpoch</name></expr></argument>,
		 <argument><expr><name>feedbackCatalogXmin</name></expr></argument>,
		 <argument><expr><name>feedbackCatalogEpoch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unset WalSender's xmins if the feedback message values are invalid.
	 * This happens when the downstream turned hot_standby_feedback off.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PhysicalReplicationSlotNewXmin</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>, <argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that the provided xmin/epoch are sane, that is, not in the future
	 * and not so far back as to be already wrapped around.  Ignore if not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>TransactionIdInRecentPast</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>, <argument><expr><name>feedbackEpoch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>TransactionIdInRecentPast</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>, <argument><expr><name>feedbackCatalogEpoch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set the WalSender's xmin equal to the standby's requested xmin, so that
	 * the xmin will be taken into account by GetOldestXmin.  This will hold
	 * back the removal of dead rows and thereby prevent the generation of
	 * cleanup conflicts on the standby server.
	 *
	 * There is a small window for a race condition here: although we just
	 * checked that feedbackXmin precedes nextXid, the nextXid could have
	 * gotten advanced between our fetching it and applying the xmin below,
	 * perhaps far enough to make feedbackXmin wrap around.  In that case the
	 * xmin we set here would be "in the future" and have no effect.  No point
	 * in worrying about this since it's too late to save the desired data
	 * anyway.  Assuming that the standby sends us an increasing sequence of
	 * xmins, this could only happen during the first reply cycle, else our
	 * own xmin would prevent nextXid from advancing so far.
	 *
	 * We don't bother taking the ProcArrayLock here.  Setting the xmin field
	 * is assumed atomic, and there's no real need to prevent a concurrent
	 * GetOldestXmin.  (If we're moving our xmin forward, this is obviously
	 * safe, and if we're moving it backwards, well, the data is at risk
	 * already since a VACUUM could have just finished calling GetOldestXmin.)
	 *
	 * If we're using a replication slot we reserve the xmin via that,
	 * otherwise via the walsender's PGXACT entry. We can only track the
	 * catalog xmin separately when using a slot, so we store the least of the
	 * two provided when not using a slot.
	 *
	 * XXX: It might make sense to generalize the ephemeral slot concept and
	 * always use the slot mechanism to handle the feedback xmin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* XXX: persistency configurable? */</comment>
		<expr_stmt><expr><call><name>PhysicalReplicationSlotNewXmin</name><argument_list>(<argument><expr><name>feedbackXmin</name></expr></argument>, <argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>feedbackCatalogXmin</name></expr></argument>, <argument><expr><name>feedbackXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>feedbackCatalogXmin</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>feedbackXmin</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute how long send/receive loops should sleep.
 *
 * If wal_sender_timeout is enabled we want to wake up in time to send
 * keepalives and to abort the connection if wal_sender_timeout has been
 * reached.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>WalSndComputeSleeptime</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 10 s */</comment>

	<if_stmt><if>if <condition>(<expr><name>wal_sender_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>last_reply_timestamp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>wakeup_time</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>sec_to_timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>microsec_to_timeout</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * At the latest stop sleeping once wal_sender_timeout has been
		 * reached.
		 */</comment>
		<expr_stmt><expr><name>wakeup_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_reply_timestamp</name></expr></argument>,
												  <argument><expr><name>wal_sender_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If no ping has been sent yet, wakeup when it's time to do so.
		 * WalSndKeepaliveIfNecessary() wants to send a keepalive once half of
		 * the timeout passed without a response.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>waiting_for_ping_response</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>wakeup_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_reply_timestamp</name></expr></argument>,
													  <argument><expr><name>wal_sender_timeout</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Compute relative time until wakeup. */</comment>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>wakeup_time</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>sec_to_timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsec_to_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <name>sec_to_timeout</name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator>
			<name>microsec_to_timeout</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sleeptime</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether there have been responses by the client within
 * wal_sender_timeout and shutdown if not.  Using last_processing as the
 * reference point avoids counting server-side stalls against the client.
 * However, a long server-side stall can make WalSndKeepaliveIfNecessary()
 * postdate last_processing by more than wal_sender_timeout.  If that happens,
 * the client must reply almost immediately to avoid a timeout.  This rarely
 * affects the default configuration, under which clients spontaneously send a
 * message every standby_message_timeout = wal_sender_timeout/6 = 10s.  We
 * could eliminate that problem by recognizing timeout expiration at
 * wal_sender_timeout/2 after the keepalive.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndCheckTimeOut</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timeout</name></decl>;</decl_stmt>

	<comment type="block">/* don't bail out if we're doing something that doesn't require timeouts */</comment>
	<if_stmt><if>if <condition>(<expr><name>last_reply_timestamp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_reply_timestamp</name></expr></argument>,
										  <argument><expr><name>wal_sender_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>wal_sender_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>last_processing</name> <operator>&gt;=</operator> <name>timeout</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since typically expiration of replication timeout means
		 * communication problem, we don't send the error message to the
		 * standby.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating walsender process due to replication timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Main loop of walsender process that streams the WAL over Copy messages. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndLoop</name><parameter_list>(<parameter><decl><type><name>WalSndSendDataCallback</name></type> <name>send_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Initialize the last reply timestamp. That enables timeout processing
	 * from hereon.
	 */</comment>
	<expr_stmt><expr><name>last_reply_timestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>waiting_for_ping_response</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop until we reach the end of this timeline or the client requests to
	 * stop streaming.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Emergency bailout if postmaster has died.  This is to avoid the
		 * necessity for manual cleanup of all postmaster children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process any requests or signals received recently */</comment>
		<if_stmt><if>if <condition>(<expr><name>ConfigReloadPending</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ConfigReloadPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SyncRepInitConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for input from the client */</comment>
		<expr_stmt><expr><call><name>ProcessRepliesIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have received CopyDone from the client, sent CopyDone
		 * ourselves, and the output buffer is empty, it's time to exit
		 * streaming.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>streamingDoneReceiving</name> <operator>&amp;&amp;</operator> <name>streamingDoneSending</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we don't have any pending data in the output buffer, try to send
		 * some more.  If there is some, we don't bother to call send_data
		 * again until we've flushed it ... but we'd better assume we are not
		 * caught up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>send_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Try to flush pending output to the client */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_flush_if_writable</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If nothing remains to be sent right now ... */</comment>
		<if_stmt><if>if <condition>(<expr><name>WalSndCaughtUp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we're in catchup state, move to streaming.  This is an
			 * important state change for users to know about, since before
			 * this point data loss might occur if the primary dies and we
			 * need to failover to the standby. The state change is also
			 * important for synchronous replication, since commits that
			 * started to wait at that point might wait for some time.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WALSNDSTATE_CATCHUP</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" has now caught up with upstream server"</literal></expr></argument>,
								<argument><expr><name>application_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STREAMING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * When SIGUSR2 arrives, we send any outstanding logs up to the
			 * shutdown checkpoint record (i.e., the latest record), wait for
			 * them to be replicated to the standby, and exit. This may be a
			 * normal termination at shutdown, or a promotion, the walsender
			 * is not sure which.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>got_SIGUSR2</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WalSndDone</name><argument_list>(<argument><expr><name>send_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for replication timeout. */</comment>
		<expr_stmt><expr><call><name>WalSndCheckTimeOut</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Send keepalive if the time has come */</comment>
		<expr_stmt><expr><call><name>WalSndKeepaliveIfNecessary</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't block if not caught up, unless there is unsent data
		 * pending in which case we'd better block until the socket is
		 * write-ready.  This test is only needed for the case where the
		 * send_data callback handled a subset of the available data but then
		 * pq_flush_if_writable flushed it all --- we should immediately try
		 * to send more.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>WalSndCaughtUp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>streamingDoneSending</name><operator>)</operator> <operator>||</operator> <call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type>		<name>sleeptime</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>wakeEvents</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>wakeEvents</name> <operator>=</operator> <name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator>
				<name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Use fresh timestamp, not last_processed, to reduce the chance
			 * of reaching wal_sender_timeout before sending a keepalive.
			 */</comment>
			<expr_stmt><expr><name>sleeptime</name> <operator>=</operator> <call><name>WalSndComputeSleeptime</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>wakeEvents</name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Sleep until something happens or we time out */</comment>
			<expr_stmt><expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>wakeEvents</name></expr></argument>,
							  <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>sleeptime</name></expr></argument>,
							  <argument><expr><name>WAIT_EVENT_WAL_SENDER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize a per-walsender data structure for this walsender process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitWalSenderSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * WalSndCtl should be set up already (we inherit this by fork() or
	 * EXEC_BACKEND mechanism from the postmaster).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>WalSndCtl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyWalSnd</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find a free walsender slot and reserve it. If this fails, we must be
	 * out of WalSnd structures.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Found a free slot. Reserve it for us.
			 */</comment>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>sentPtr</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>flush</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>apply</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>writeLag</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>flushLag</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>applyLag</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WALSNDSTATE_STARTUP</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* don't need the lock anymore */</comment>
			<expr_stmt><expr><name>MyWalSnd</name> <operator>=</operator> <operator>(</operator><name>WalSnd</name> <operator>*</operator><operator>)</operator> <name>walsnd</name></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>MyWalSnd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of requested standby connections "</literal>
						<literal type="string">"exceeds max_wal_senders (currently %d)"</literal></expr></argument>,
						<argument><expr><name>max_wal_senders</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Arrange to clean up at walsender exit */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>WalSndKill</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Destroy the per-walsender data structure for this walsender process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndKill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>walsnd</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyWalSnd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* clear latch while holding the spinlock, so it can safely be read */</comment>
	<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>latch</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* Mark WalSnd struct as no longer being in use. */</comment>
	<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read 'count' bytes from WAL into 'buf', starting at location 'startptr'
 *
 * XXX probably this should be improved to suck data directly from the
 * WAL buffers when possible.
 *
 * Will open, and keep open, one WAL segment stored in the global file
 * descriptor sendFile. This means if XLogRead is used once, there will
 * always be one descriptor left open until the process ends, but never
 * more than one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogRead</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>startptr</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>startoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readbytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* Switch to another logfile segment */</comment>
			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*-------
			 * When reading from a historic timeline, and there is a timeline
			 * switch within this segment, read from the WAL segment belonging
			 * to the new timeline.
			 *
			 * For example, imagine that this server is currently on timeline
			 * 5, and we're streaming timeline 4. The switch from timeline 4
			 * to 5 happened at 0/13002088. In pg_wal, we have these files:
			 *
			 * ...
			 * 000000040000000000000012
			 * 000000040000000000000013
			 * 000000050000000000000013
			 * 000000050000000000000014
			 * ...
			 *
			 * In this situation, when requested to send the WAL from
			 * segment 0x13, on timeline 4, we read the WAL from file
			 * 000000050000000000000013. Archive recovery prefers files from
			 * newer timelines, so if the segment was restored from the
			 * archive on this server, the file belonging to the old timeline,
			 * 000000040000000000000013, might not exist. Their contents are
			 * equal up to the switchpoint, because at a timeline switch, the
			 * used portion of the old segment is copied to the new file.
			 *-------
			 */</comment>
			<expr_stmt><expr><name>curFileTimeLine</name> <operator>=</operator> <name>sendTimeLine</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sendTimeLineIsHistoric</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>endSegNo</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>sendTimeLineValidUpto</name></expr></argument>, <argument><expr><name>endSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sendSegNo</name> <operator>==</operator> <name>endSegNo</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>curFileTimeLine</name> <operator>=</operator> <name>sendTimeLineNextTLI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogFilePath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>curFileTimeLine</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the file is not found, assume it's because the standby
				 * asked for a too old WAL segment that has already been
				 * removed or recycled.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested WAL segment %s has already been removed"</literal></expr></argument>,
									<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>curFileTimeLine</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Need to seek in the file? */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendOff</name> <operator>!=</operator> <name>startoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <name>startoff</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in log segment %s to offset %u: %m"</literal></expr></argument>,
								<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>curFileTimeLine</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>startoff</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sendOff</name> <operator>=</operator> <name>startoff</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* How many bytes are within this segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name>wal_segment_size</name> <operator>-</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>wal_segment_size</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_WAL_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from log segment %s, offset %u, length %lu: %m"</literal></expr></argument>,
							<argument><expr><call><name>XLogFileNameP</name><argument_list>(<argument><expr><name>curFileTimeLine</name></expr></argument>, <argument><expr><name>sendSegNo</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>sendOff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>segbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sendOff</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * After reading into the buffer, check that what we read was valid. We do
	 * this after reading, because even though the segment was present when we
	 * opened it, it might get recycled or removed while we read it. The
	 * read() succeeds in that case, but the data we tried to read might
	 * already have been overwritten with new WAL records.
	 */</comment>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>startptr</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckXLogRemoved</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During recovery, the currently-open WAL file might be replaced with the
	 * file of the same name retrieved from archive. So we always need to
	 * check what we read was valid after reading into the buffer. If it's
	 * invalid, we try to open and read the file again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_cascading_walsender</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>reload</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reload</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>needreload</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>needreload</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>reload</name> <operator>&amp;&amp;</operator> <name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send out the WAL in its normal physical/stored form.
 *
 * Read up to MAX_SEND_SIZE bytes of WAL that's been flushed to disk,
 * but not yet sent to the client, and buffer it in the libpq output
 * buffer.
 *
 * If there is no unsent WAL remaining, WalSndCaughtUp is set to true,
 * otherwise WalSndCaughtUp is set to false.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogSendPhysical</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>SendRqstPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>startptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>

	<comment type="block">/* If requested switch the WAL sender to the stopping state. */</comment>
	<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndSetState</name><argument_list>(<argument><expr><name>WALSNDSTATE_STOPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>streamingDoneSending</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Figure out how far we can safely send the WAL. */</comment>
	<if_stmt><if>if <condition>(<expr><name>sendTimeLineIsHistoric</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Streaming an old timeline that's in this server's history, but is
		 * not the one we're currently inserting or replaying. It can be
		 * streamed up to the point where we switched off that timeline.
		 */</comment>
		<expr_stmt><expr><name>SendRqstPtr</name> <operator>=</operator> <name>sendTimeLineValidUpto</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>am_cascading_walsender</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Streaming the latest timeline on a standby.
		 *
		 * Attempt to send all WAL that has already been replayed, so that we
		 * know it's valid. If we're receiving WAL through streaming
		 * replication, it's also OK to send any WAL that has been received
		 * but not replayed.
		 *
		 * The timeline we're recovering from can change, or we can be
		 * promoted. In either case, the current timeline becomes historic. We
		 * need to detect that so that we don't try to stream past the point
		 * where we switched to another timeline. We check for promotion or
		 * timeline switch after calculating FlushPtr, to avoid a race
		 * condition: if the timeline becomes historic just after we checked
		 * that it was still current, it's still be OK to stream it up to the
		 * FlushPtr that was calculated before it became historic.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>becameHistoric</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>SendRqstPtr</name> <operator>=</operator> <call><name>GetStandbyFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have been promoted. RecoveryInProgress() updated
			 * ThisTimeLineID to the new current timeline.
			 */</comment>
			<expr_stmt><expr><name>am_cascading_walsender</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>becameHistoric</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Still a cascading standby. But is the timeline we're sending
			 * still the one recovery is recovering from? ThisTimeLineID was
			 * updated by the GetStandbyFlushRecPtr() call above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sendTimeLine</name> <operator>!=</operator> <name>ThisTimeLineID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>becameHistoric</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>becameHistoric</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The timeline we were sending has become historic. Read the
			 * timeline history file of the new timeline to see where exactly
			 * we forked off from the timeline we were sending.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>history</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>history</name> <operator>=</operator> <call><name>readTimeLineHistory</name><argument_list>(<argument><expr><name>ThisTimeLineID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendTimeLineValidUpto</name> <operator>=</operator> <call><name>tliSwitchPoint</name><argument_list>(<argument><expr><name>sendTimeLine</name></expr></argument>, <argument><expr><name>history</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sendTimeLineNextTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sendTimeLine</name> <operator>&lt;</operator> <name>sendTimeLineNextTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>history</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sendTimeLineIsHistoric</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>SendRqstPtr</name> <operator>=</operator> <name>sendTimeLineValidUpto</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Streaming the current timeline on a master.
		 *
		 * Attempt to send all data that's already been written out and
		 * fsync'd to disk.  We cannot go further than what's been written out
		 * given the current implementation of XLogRead().  And in any case
		 * it's unsafe to send WAL that is not securely down to disk on the
		 * master: if the master subsequently crashes and restarts, standbys
		 * must not have applied any WAL that got lost on the master.
		 */</comment>
		<expr_stmt><expr><name>SendRqstPtr</name> <operator>=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Record the current system time as an approximation of the time at which
	 * this WAL location was written for the purposes of lag tracking.
	 *
	 * In theory we could make XLogFlush() record a time in shmem whenever WAL
	 * is flushed and we could get that time as well as the LSN when we call
	 * GetFlushRecPtr() above (and likewise for the cascading standby
	 * equivalent), but rather than putting any new code into the hot WAL path
	 * it seems good enough to capture the time here.  We should reach this
	 * after XLogFlush() runs WalSndWakeupProcessRequests(), and although that
	 * may take some time, we read the WAL flush pointer and take the time
	 * very close to together here so that we'll get a later position if it is
	 * still moving.
	 *
	 * Because LagTrackerWriter ignores samples when the LSN hasn't advanced,
	 * this gives us a cheap approximation for the WAL flush time for this
	 * LSN.
	 *
	 * Note that the LSN is not necessarily the LSN for the data contained in
	 * the present message; it's the end of the WAL, which might be further
	 * ahead.  All the lag tracking machinery cares about is finding out when
	 * that arbitrary LSN is eventually reported as written, flushed and
	 * applied, so that it can measure the elapsed time.
	 */</comment>
	<expr_stmt><expr><call><name>LagTrackerWrite</name><argument_list>(<argument><expr><name>SendRqstPtr</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a historic timeline and we've reached the point where we
	 * forked to the next timeline, stop streaming.
	 *
	 * Note: We might already have sent WAL &gt; sendTimeLineValidUpto. The
	 * startup process will normally replay all WAL that has been received
	 * from the master, before promoting, but if the WAL streaming is
	 * terminated at a WAL page boundary, the valid portion of the timeline
	 * might end in the middle of a WAL record. We might've already sent the
	 * first half of that partial WAL record to the cascading standby, so that
	 * sentPtr &gt; sendTimeLineValidUpto. That's OK; the cascading standby can't
	 * replay the partial WAL record either, so it can still follow our
	 * timeline switch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sendTimeLineIsHistoric</name> <operator>&amp;&amp;</operator> <name>sendTimeLineValidUpto</name> <operator>&lt;=</operator> <name>sentPtr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* close the current file. */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendFile</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>sendFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sendFile</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* Send CopyDone */</comment>
		<expr_stmt><expr><call><name>pq_putmessage_noblock</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>streamingDoneSending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"walsender reached end of timeline at %X/%X (sent up to %X/%X)"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>sendTimeLineValidUpto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>sendTimeLineValidUpto</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>sentPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>sentPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do we have any work to do? */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sentPtr</name> <operator>&lt;=</operator> <name>SendRqstPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SendRqstPtr</name> <operator>&lt;=</operator> <name>sentPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Figure out how much to send in one message. If there's no more than
	 * MAX_SEND_SIZE bytes to send, send everything. Otherwise send
	 * MAX_SEND_SIZE bytes, but round back to logfile or page boundary.
	 *
	 * The rounding is not only for performance reasons. Walreceiver relies on
	 * the fact that we never split a WAL record across two messages. Since a
	 * long WAL record is split at page boundary into continuation records,
	 * page boundary is always a safe cut-off point. We also assume that
	 * SendRqstPtr never points to the middle of a WAL record.
	 */</comment>
	<expr_stmt><expr><name>startptr</name> <operator>=</operator> <name>sentPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endptr</name> <operator>+=</operator> <name>MAX_SEND_SIZE</name></expr>;</expr_stmt>

	<comment type="block">/* if we went beyond SendRqstPtr, back off */</comment>
	<if_stmt><if>if <condition>(<expr><name>SendRqstPtr</name> <operator>&lt;=</operator> <name>endptr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>SendRqstPtr</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sendTimeLineIsHistoric</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* round down to page boundary. */</comment>
		<expr_stmt><expr><name>endptr</name> <operator>-=</operator> <operator>(</operator><name>endptr</name> <operator>%</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>endptr</name> <operator>-</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nbytes</name> <operator>&lt;=</operator> <name>MAX_SEND_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK to read and send the slice.
	 */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><name>startptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* dataStart */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><name>SendRqstPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* walEnd */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sendtime, filled in last */</comment>

	<comment type="block">/*
	 * Read the log directly into the output buffer to avoid extra memcpy
	 * calls.
	 */</comment>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>output_message</name><operator>.</operator><name>data</name><index>[<expr><name><name>output_message</name><operator>.</operator><name>len</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>startptr</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>output_message</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>output_message</name><operator>.</operator><name>data</name><index>[<expr><name><name>output_message</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill the send timestamp last, so that it is taken as late as possible.
	 */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmpbuf</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>output_message</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>,
		   <argument><expr><name><name>tmpbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_putmessage_noblock</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>output_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>output_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sentPtr</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt>

	<comment type="block">/* Update shared memory status */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>sentPtr</name></name> <operator>=</operator> <name>sentPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Report progress of XLOG streaming in PS display */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>activitymsg</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>activitymsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"streaming %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>sentPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>sentPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>activitymsg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stream out logically decoded data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>XLogSendLogical</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecord</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't know whether we've caught up yet. We'll set WalSndCaughtUp to
	 * true in WalSndWaitForWal, if we're actually waiting. We also set to
	 * true if XLogReadRecord() had to stop reading but WalSndWaitForWal
	 * didn't wait - i.e. when we're shutting down.
	 */</comment>
	<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>XLogReadRecord</name><argument_list>(<argument><expr><name><name>logical_decoding_ctx</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>, <argument><expr><name>logical_startptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>logical_startptr</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<comment type="block">/* xlog record was invalid */</comment>
	<if_stmt><if>if <condition>(<expr><name>errm</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX: Note that logical decoding cannot be used while in recovery */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flushPtr</name> <init>= <expr><call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note the lack of any call to LagTrackerWrite() which is handled by
		 * WalSndUpdateProgress which is called by output plugin through
		 * logical decoding write api.
		 */</comment>
		<expr_stmt><expr><call><name>LogicalDecodingProcessRecord</name><argument_list>(<argument><expr><name>logical_decoding_ctx</name></expr></argument>, <argument><expr><name><name>logical_decoding_ctx</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sentPtr</name> <operator>=</operator> <name><name>logical_decoding_ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have sent a record that is at or beyond the flushed point, we
		 * have caught up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sentPtr</name> <operator>&gt;=</operator> <name>flushPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the record we just wanted read is at or beyond the flushed
		 * point, then we're caught up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>logical_decoding_ctx</name><operator>-&gt;</operator><name>reader</name><operator>-&gt;</operator><name>EndRecPtr</name></name> <operator>&gt;=</operator> <call><name>GetFlushRecPtr</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>WalSndCaughtUp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Have WalSndLoop() terminate the connection in an orderly
			 * manner, after writing out all the pending data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>got_STOPPING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update shared memory status */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>sentPtr</name></name> <operator>=</operator> <name>sentPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown if the sender is caught up.
 *
 * NB: This should only be called when the shutdown signal has been received
 * from postmaster.
 *
 * Note that if we determine that there's still more data to send, this
 * function will return control to the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndDone</name><parameter_list>(<parameter><decl><type><name>WalSndSendDataCallback</name></type> <name>send_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>replicatedPtr</name></decl>;</decl_stmt>

	<comment type="block">/* ... let's just be real sure we're caught up ... */</comment>
	<expr_stmt><expr><call><name>send_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To figure out whether all WAL has successfully been replicated, check
	 * flush location if valid, write otherwise. Tools like pg_receivewal will
	 * usually (unless in synchronous mode) return an invalid flush location.
	 */</comment>
	<expr_stmt><expr><name>replicatedPtr</name> <operator>=</operator> <ternary><condition><expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>flush</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
		<expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>write</name></name></expr> </then><else>: <expr><name><name>MyWalSnd</name><operator>-&gt;</operator><name>flush</name></name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>WalSndCaughtUp</name> <operator>&amp;&amp;</operator> <name>sentPtr</name> <operator>==</operator> <name>replicatedPtr</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pq_is_send_pending</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Inform the standby that XLOG streaming is done */</comment>
		<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><literal type="string">"COPY 0"</literal></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>waiting_for_ping_response</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WalSndKeepalive</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>waiting_for_ping_response</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the latest point in WAL that has been safely flushed to disk, and
 * can be sent to the standby. This should only be called when in recovery,
 * ie. we're streaming to a cascaded standby.
 *
 * As a side-effect, ThisTimeLineID is updated to the TLI of the last
 * replayed WAL record.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>GetStandbyFlushRecPtr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>replayPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>replayTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>receivePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>receiveTLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can safely send what's already been replayed. Also, if walreceiver
	 * is streaming WAL from the same timeline, we can send anything that it
	 * has streamed, but hasn't been replayed yet.
	 */</comment>

	<expr_stmt><expr><name>receivePtr</name> <operator>=</operator> <call><name>GetWalRcvWriteRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replayPtr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replayTLI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ThisTimeLineID</name> <operator>=</operator> <name>replayTLI</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>replayPtr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>receiveTLI</name> <operator>==</operator> <name>ThisTimeLineID</name> <operator>&amp;&amp;</operator> <name>receivePtr</name> <operator>&gt;</operator> <name>replayPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>receivePtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Request walsenders to reload the currently-open WAL file
 */</comment>
<function><type><name>void</name></type>
<name>WalSndRqstFileReload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>needreload</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Handle PROCSIG_WALSND_INIT_STOPPING signal.
 */</comment>
<function><type><name>void</name></type>
<name>HandleWalSndInitStopping</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>am_walsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If replication has not yet started, die like with SIGTERM. If
	 * replication is active, only set a flag and wake up the main loop. It
	 * will send any outstanding WAL, wait for it to be replicated to the
	 * standby, and then exit gracefully.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replication_active</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>got_STOPPING</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SIGUSR2: set flag to do a last cycle and shut down afterwards. The WAL
 * sender should already have been switched to WALSNDSTATE_STOPPING at
 * this point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndLastCycleHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Set up signal handlers */</comment>
<function><type><name>void</name></type>
<name>WalSndSignals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Set up signal handlers */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>PostgresSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config
												 * file */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* query cancel */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* request shutdown */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* hard crash time */</comment>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* establishes SIGALRM handler */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>WalSndLastCycleHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request a last cycle and
												 * shutdown */</comment>

	<comment type="block">/* Reset some signals that are accepted by postmaster but not here */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Report shared-memory space needed by WalSndShmemInit */</comment>
<function><type><name>Size</name></type>
<name>WalSndShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WalSndCtlData</name></expr></argument>, <argument><expr><name>walsnds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_wal_senders</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WalSnd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate and initialize walsender-related shared memory */</comment>
<function><type><name>void</name></type>
<name>WalSndShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>WalSndCtl</name> <operator>=</operator> <operator>(</operator><name>WalSndCtlData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Wal Sender Ctl"</literal></expr></argument>, <argument><expr><call><name>WalSndShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, so initialize */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>WalSndCtl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>WalSndShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SYNC_REP_WAIT_MODE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>SyncRepQueue</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wake up all walsenders
 *
 * This will be called inside critical sections, so throwing an error is not
 * advisable.
 */</comment>
<function><type><name>void</name></type>
<name>WalSndWakeup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Latch</name>	   <modifier>*</modifier></type><name>latch</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get latch pointer with spinlock held, for the unlikely case that
		 * pointer reads aren't atomic (as they're 8 bytes).
		 */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>latch</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>latch</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>latch</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Signal all walsenders to move to stopping state.
 *
 * This will trigger walsenders to move to a state where no further WAL can be
 * generated. See this file's header for details.
 */</comment>
<function><type><name>void</name></type>
<name>WalSndInitStopping</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SendProcSignal</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>PROCSIG_WALSND_INIT_STOPPING</name></expr></argument>, <argument><expr><name>InvalidBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Wait that all the WAL senders have quit or reached the stopping state. This
 * is used by the checkpointer to control when the shutdown checkpoint can
 * safely be performed.
 */</comment>
<function><type><name>void</name></type>
<name>WalSndWaitStopping</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>all_stopped</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>WALSNDSTATE_STOPPING</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>all_stopped</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* safe to leave if confirmation is done for all WAL senders */</comment>
		<if_stmt><if>if <condition>(<expr><name>all_stopped</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* wait for 10 msec */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Set state for current walsender (only called in walsender) */</comment>
<function><type><name>void</name></type>
<name>WalSndSetState</name><parameter_list>(<parameter><decl><type><name>WalSndState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><name>MyWalSnd</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>am_walsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>walsnd</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a string constant representing the state. This is used
 * in system views, and should *not* be translated.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>WalSndGetStateString</name><parameter_list>(<parameter><decl><type><name>WalSndState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WALSNDSTATE_STARTUP</name></expr>:</case>
			<return>return <expr><literal type="string">"startup"</literal></expr>;</return>
		<case>case <expr><name>WALSNDSTATE_BACKUP</name></expr>:</case>
			<return>return <expr><literal type="string">"backup"</literal></expr>;</return>
		<case>case <expr><name>WALSNDSTATE_CATCHUP</name></expr>:</case>
			<return>return <expr><literal type="string">"catchup"</literal></expr>;</return>
		<case>case <expr><name>WALSNDSTATE_STREAMING</name></expr>:</case>
			<return>return <expr><literal type="string">"streaming"</literal></expr>;</return>
		<case>case <expr><name>WALSNDSTATE_STOPPING</name></expr>:</case>
			<return>return <expr><literal type="string">"stopping"</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"UNKNOWN"</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Interval</name> <modifier>*</modifier></type>
<name>offset_to_interval</name><parameter_list>(<parameter><decl><type><name>TimeOffset</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns activity of walsenders, including pids and xlog locations sent to
 * standby servers.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_stat_get_wal_senders</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_STAT_GET_WAL_SENDERS_COLS</name></cpp:macro>	<cpp:value>11</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sync_standbys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"return type must be a row type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the currently active synchronous standbys.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sync_standbys</name> <operator>=</operator> <call><name>SyncRepGetSyncStandbys</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SyncRepLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_wal_senders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WalSnd</name>	   <modifier>*</modifier></type><name>walsnd</name> <init>= <expr><operator>&amp;</operator><name><name>WalSndCtl</name><operator>-&gt;</operator><name>walsnds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>sentPtr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>write</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>flush</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>apply</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>writeLag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>flushLag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>applyLag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>priority</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WalSndState</name></type> <name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PG_STAT_GET_WAL_SENDERS_COLS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>PG_STAT_GET_WAL_SENDERS_COLS</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sentPtr</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>sentPtr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>write</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>write</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flush</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>flush</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>apply</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>apply</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>writeLag</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>writeLag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flushLag</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>flushLag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>applyLag</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>applyLag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>priority</name> <operator>=</operator> <name><name>walsnd</name><operator>-&gt;</operator><name>sync_standby_priority</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>walsnd</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_STATS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Only superusers and members of pg_read_all_stats can see
			 * details. Other users only get the pid value to know it's a
			 * walsender, but no details.
			 */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>PG_STAT_GET_WAL_SENDERS_COLS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>WalSndGetStateString</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>sentPtr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>sentPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>apply</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>apply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Treat a standby such as a pg_basebackup background process
			 * which always returns an invalid flush location, as an
			 * asynchronous standby.
			 */</comment>
			<expr_stmt><expr><name>priority</name> <operator>=</operator> <ternary><condition><expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>priority</name></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>writeLag</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><call><name>offset_to_interval</name><argument_list>(<argument><expr><name>writeLag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>flushLag</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><call><name>offset_to_interval</name><argument_list>(<argument><expr><name>flushLag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>applyLag</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><call><name>offset_to_interval</name><argument_list>(<argument><expr><name>applyLag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * More easily understood version of standby state. This is purely
			 * informational.
			 *
			 * In quorum-based sync replication, the role of each standby
			 * listed in synchronous_standby_names can be changing very
			 * frequently. Any standbys considered as "sync" at one moment can
			 * be switched to "potential" ones at the next moment. So, it's
			 * basically useless to report "sync" or "potential" as their sync
			 * states. We report just "quorum" for them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>priority</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"async"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>sync_standbys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name><name>SyncRepConfig</name><operator>-&gt;</operator><name>syncrep_method</name></name> <operator>==</operator> <name>SYNC_REP_PRIORITY</name></expr> ?</condition><then>
					<expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"sync"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"quorum"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"potential"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* clean up and return the tuplestore */</comment>
	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
  * This function is used to send a keepalive message to standby.
  * If requestReply is set, sets a flag in the message requesting the standby
  * to send a message back to us, for heartbeat purposes.
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndKeepalive</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>requestReply</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sending replication keepalive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct the message... */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><name>sentPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_message</name></expr></argument>, <argument><expr><ternary><condition><expr><name>requestReply</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and send it wrapped in CopyData */</comment>
	<expr_stmt><expr><call><name>pq_putmessage_noblock</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>output_message</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>output_message</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send keepalive message if too much time has elapsed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WalSndKeepaliveIfNecessary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ping_time</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't send keepalive messages if timeouts are globally disabled or
	 * we're doing something not partaking in timeouts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>wal_sender_timeout</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>last_reply_timestamp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>waiting_for_ping_response</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If half of wal_sender_timeout has lapsed without receiving any reply
	 * from the standby, send a keep-alive message to the standby requesting
	 * an immediate reply.
	 */</comment>
	<expr_stmt><expr><name>ping_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>last_reply_timestamp</name></expr></argument>,
											<argument><expr><name>wal_sender_timeout</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>last_processing</name> <operator>&gt;=</operator> <name>ping_time</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WalSndKeepalive</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>waiting_for_ping_response</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Try to flush pending output to the client */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_flush_if_writable</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WalSndShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record the end of the WAL and the time it was flushed locally, so that
 * LagTrackerRead can compute the elapsed time (lag) when this WAL location is
 * eventually reported to have been written, flushed and applied by the
 * standby in a reply message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LagTrackerWrite</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>local_flush_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>buffer_full</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_write_head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the lsn hasn't advanced since last time, then do nothing.  This way
	 * we only record a new sample when new WAL has been written.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>last_lsn</name></name> <operator>==</operator> <name>lsn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>last_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If advancing the write head of the circular buffer would crash into any
	 * of the read heads, then the buffer is full.  In other words, the
	 * slowest reader (presumably apply) is the one that controls the release
	 * of space.
	 */</comment>
	<expr_stmt><expr><name>new_write_head</name> <operator>=</operator> <operator>(</operator><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>LAG_TRACKER_BUFFER_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer_full</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SYNC_REP_WAIT_MODE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>new_write_head</name> <operator>==</operator> <name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>buffer_full</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the buffer is full, for now we just rewind by one slot and overwrite
	 * the last sample, as a simple (if somewhat uneven) way to lower the
	 * sampling rate.  There may be better adaptive compaction algorithms.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>buffer_full</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_write_head</name> <operator>=</operator> <name><name>LagTracker</name><operator>.</operator><name>write_head</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name> <operator>=</operator> <name>LAG_TRACKER_BUFFER_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store a sample at the current write head position. */</comment>
	<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name></expr>]</index></name><operator>.</operator><name>time</name> <operator>=</operator> <name>local_flush_time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>write_head</name></name> <operator>=</operator> <name>new_write_head</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find out how much time has elapsed between the moment WAL location 'lsn'
 * (or the highest known earlier LSN) was flushed locally and the time 'now'.
 * We have a separate read head for each of the reported LSN locations we
 * receive in replies from standby; 'head' controls which read head is
 * used.  Whenever a read head crosses an LSN which was written into the
 * lag buffer with LagTrackerWrite, we can use the associated timestamp to
 * find out the time this LSN (or an earlier one) was flushed locally, and
 * therefore compute the lag.
 *
 * Return -1 if no new sample data is available, and otherwise the elapsed
 * time in microseconds.
 */</comment>
<function><type><specifier>static</specifier> <name>TimeOffset</name></type>
<name>LagTrackerRead</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Read all unread samples up to this LSN or end of buffer. */</comment>
	<while>while <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name> <operator>!=</operator> <name><name>LagTracker</name><operator>.</operator><name>write_head</name></name> <operator>&amp;&amp;</operator>
		   <name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>&lt;=</operator> <name>lsn</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>time</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>last_read</name><index>[<expr><name>head</name></expr>]</index></name> <operator>=</operator>
			<name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name> <operator>=</operator>
			<operator>(</operator><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>LAG_TRACKER_BUFFER_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If the lag tracker is empty, that means the standby has processed
	 * everything we've ever sent so we should now clear 'last_read'.  If we
	 * didn't do that, we'd risk using a stale and irrelevant sample for
	 * interpolation at the beginning of the next burst of WAL after a period
	 * of idleness.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name> <operator>==</operator> <name><name>LagTracker</name><operator>.</operator><name>write_head</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>LagTracker</name><operator>.</operator><name>last_read</name><index>[<expr><name>head</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>time</name> <operator>&gt;</operator> <name>now</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If the clock somehow went backwards, treat as not found. */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>time</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We didn't cross a time.  If there is a future sample that we
		 * haven't reached yet, and we've already reached at least one sample,
		 * let's interpolate the local flushed time.  This is mainly useful
		 * for reporting a completely stuck apply position as having
		 * increasing lag, since otherwise we'd have to wait for it to
		 * eventually start moving again and cross one of our samples before
		 * we can show the lag increasing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name> <operator>==</operator> <name><name>LagTracker</name><operator>.</operator><name>write_head</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* There are no future samples, so we can't interpolate. */</comment>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>LagTracker</name><operator>.</operator><name>last_read</name><index>[<expr><name>head</name></expr>]</index></name><operator>.</operator><name>time</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We can interpolate between last_read and the next sample. */</comment>
			<decl_stmt><decl><type><name>double</name></type>		<name>fraction</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WalTimeSample</name></type> <name>prev</name> <init>= <expr><name><name>LagTracker</name><operator>.</operator><name>last_read</name><index>[<expr><name>head</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WalTimeSample</name></type> <name>next</name> <init>= <expr><name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>lsn</name> <operator>&lt;</operator> <name><name>prev</name><operator>.</operator><name>lsn</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Reported LSNs shouldn't normally go backwards, but it's
				 * possible when there is a timeline change.  Treat as not
				 * found.
				 */</comment>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prev</name><operator>.</operator><name>lsn</name></name> <operator>&lt;</operator> <name><name>next</name><operator>.</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>.</operator><name>time</name></name> <operator>&gt;</operator> <name><name>next</name><operator>.</operator><name>time</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If the clock somehow went backwards, treat as not found. */</comment>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* See how far we are between the previous and next samples. */</comment>
			<expr_stmt><expr><name>fraction</name> <operator>=</operator>
				<operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>lsn</name> <operator>-</operator> <name><name>prev</name><operator>.</operator><name>lsn</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>next</name><operator>.</operator><name>lsn</name></name> <operator>-</operator> <name><name>prev</name><operator>.</operator><name>lsn</name></name><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* Scale the local flush time proportionally. */</comment>
			<expr_stmt><expr><name>time</name> <operator>=</operator> <operator>(</operator><name>TimestampTz</name><operator>)</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>prev</name><operator>.</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>next</name><operator>.</operator><name>time</name></name> <operator>-</operator> <name><name>prev</name><operator>.</operator><name>time</name></name><operator>)</operator> <operator>*</operator> <name>fraction</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We have only a future sample, implying that we were entirely
			 * caught up but and now there is a new burst of WAL and the
			 * standby hasn't processed the first sample yet.  Until the
			 * standby reaches the future sample the best we can do is report
			 * the hypothetical lag if that sample were to be replayed now.
			 */</comment>
			<expr_stmt><expr><name>time</name> <operator>=</operator> <name><name>LagTracker</name><operator>.</operator><name>buffer</name><index>[<expr><name><name>LagTracker</name><operator>.</operator><name>read_heads</name><index>[<expr><name>head</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>time</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Return the elapsed time since local flush time in microseconds. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>time</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>now</name> <operator>-</operator> <name>time</name></expr>;</return>
</block_content>}</block></function>
</unit>
