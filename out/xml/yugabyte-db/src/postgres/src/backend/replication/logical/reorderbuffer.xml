<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/replication/logical/reorderbuffer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * reorderbuffer.c
 *	  PostgreSQL logical replay/reorder buffer management
 *
 *
 * Copyright (c) 2012-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/replication/reorderbuffer.c
 *
 * NOTES
 *	  This module gets handed individual pieces of transactions in the order
 *	  they are written to the WAL and is responsible to reassemble them into
 *	  toplevel transaction sized pieces. When a transaction is completely
 *	  reassembled - signalled by reading the transaction commit record - it
 *	  will then call the output plugin (cf. ReorderBufferCommit()) with the
 *	  individual changes. The output plugins rely on snapshots built by
 *	  snapbuild.c which hands them to us.
 *
 *	  Transactions and subtransactions/savepoints in postgres are not
 *	  immediately linked to each other from outside the performing
 *	  backend. Only at commit/abort (or special xact_assignment records) they
 *	  are linked together. Which means that we will have to splice together a
 *	  toplevel transaction from its subtransactions. To do that efficiently we
 *	  build a binary heap indexed by the smallest current lsn of the individual
 *	  subtransactions' changestreams. As the individual streams are inherently
 *	  ordered by LSN - since that is where we build them from - the transaction
 *	  can easily be reassembled by always using the subtransaction with the
 *	  smallest current LSN from the heap.
 *
 *	  In order to cope with large transactions - which can be several times as
 *	  big as the available memory - this module supports spooling the contents
 *	  of a large transactions to disk. When the transaction is replayed the
 *	  contents of individual (sub-)transactions will be read from disk in
 *	  chunks.
 *
 *	  This module also has to deal with reassembling toast records from the
 *	  individual chunks stored in WAL. When a new (or initial) version of a
 *	  tuple is stored in WAL it will always be preceded by the toast chunks
 *	  emitted for the columns stored out of line. Within a single toplevel
 *	  transaction there will be no other data carrying records between a row's
 *	  toast chunks and the row data itself. See ReorderBufferToast* for
 *	  details.
 *
 *	  ReorderBuffer uses two special memory context types - SlabContext for
 *	  allocations of fixed-length structures (changes and transactions), and
 *	  GenerationContext for the variable-length transaction data (allocated
 *	  and freed in groups with similar lifespan).
 *
 * -------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rewriteheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/binaryheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/reorderbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/snapbuild.h"</cpp:file></cpp:include>	<comment type="block">/* just for SnapBuildSnapDecRefcount */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>


<comment type="block">/* entry for a hash table we use to map from xid to our transaction state */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferTXNByIdEnt</name>
<block>{
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferTXNByIdEnt</name>;</typedef>

<comment type="block">/* data structures for (relfilenode, ctid) =&gt; (cmin, cmax) mapping */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferTupleCidKey</name>
<block>{
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>relnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferTupleCidKey</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ReorderBufferTupleCidEnt</name>
<block>{
	<decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>combocid</name></decl>;</decl_stmt>		<comment type="block">/* just for debugging */</comment>
}</block></struct></type> <name>ReorderBufferTupleCidEnt</name>;</typedef>

<comment type="block">/* k-way in-order change iteration support structures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferIterTXNEntry</name>
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>segno</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferIterTXNEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ReorderBufferIterTXNState</name>
<block>{
	<decl_stmt><decl><type><name>binaryheap</name> <modifier>*</modifier></type><name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nr_txns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>old_change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferIterTXNEntry</name></type> <name><name>entries</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ReorderBufferIterTXNState</name>;</typedef>

<comment type="block">/* toast datastructures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferToastEnt</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>chunk_id</name></decl>;</decl_stmt>		<comment type="block">/* toast_table.chunk_id */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>last_chunk_seq</name></decl>;</decl_stmt> <comment type="block">/* toast_table.chunk_seq of the last chunk we
								 * have seen */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>num_chunks</name></decl>;</decl_stmt>		<comment type="block">/* number of chunks we've already seen */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>			<comment type="block">/* combined size of chunks seen */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>chunks</name></decl>;</decl_stmt>			<comment type="block">/* linked list of chunks */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>reconstructed</name></decl>;</decl_stmt>	<comment type="block">/* reconstructed varlena now pointed to in
									 * main tup */</comment>
}</block></struct></type> <name>ReorderBufferToastEnt</name>;</typedef>

<comment type="block">/* Disk serialization support datastructures */</comment>
<typedef>typedef <type><struct>struct <name>ReorderBufferDiskChange</name>
<block>{
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name></type> <name>change</name></decl>;</decl_stmt>
	<comment type="block">/* data follows */</comment>
}</block></struct></type> <name>ReorderBufferDiskChange</name>;</typedef>

<comment type="block">/*
 * Maximum number of changes kept in memory, per transaction. After that,
 * changes are spooled to disk.
 *
 * The current value should be sufficient to decode the entire transaction
 * without hitting disk in OLTP workloads, while starting to spool to disk in
 * other workloads reasonably fast.
 *
 * At some point in the future it probably makes sense to have a more elaborate
 * resource management here, but it's not entirely clear what that would look
 * like.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Size</name></type> <name>max_changes_in_memory</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* ---------------------------------------
 * primary reorderbuffer support routines
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>ReorderBufferGetTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferReturnTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>ReorderBufferTXNByXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
					  <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_new</name></decl></parameter>,
					  <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_as_top</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferTransferSnapToParent</name><parameter_list>(<parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
								  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssertTXNLsnOrder</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------------------------
 * support functions for lsn-order iterating over the -&gt;changes of a
 * transaction and its subtransactions
 *
 * used for iteration over the k-way heap merge of a transaction and its
 * subtransactions
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>ReorderBufferIterTXNInit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ReorderBufferChange</name> <modifier>*</modifier></type><name>ReorderBufferIterTXNNext</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferIterTXNFinish</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
						   <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferExecuteInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ---------------------------------------
 * Disk serialization support functions
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferCheckSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferSerializeChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>ReorderBufferRestoreChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferRestoreChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferRestoreCleanup</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferCleanupSerializedTXNs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slotname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferSerializedPath</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferFreeSnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Snapshot</name></type> <name>ReorderBufferCopySnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>orig_snap</name></decl></parameter>,
					  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------------------------
 * toast reassembly support
 * ---------------------------------------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastInitHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastReset</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastReplace</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderBufferToastAppendChunk</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Allocate a new ReorderBuffer and clean out any old serialized state from
 * prior ReorderBuffer instances for the same slot.
 */</comment>
<function><type><name>ReorderBuffer</name> <modifier>*</modifier></type>
<name>ReorderBufferAllocate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>new_ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyReplicationSlot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate memory in own context, to have better accountability */</comment>
	<expr_stmt><expr><name>new_ctx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><literal type="string">"ReorderBuffer"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator>
		<operator>(</operator><name>ReorderBuffer</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>new_ctx</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>change_context</name></name> <operator>=</operator> <call><name>SlabContextCreate</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>,
											   <argument><expr><literal type="string">"Change"</literal></expr></argument>,
											   <argument><expr><name>SLAB_DEFAULT_BLOCK_SIZE</name></expr></argument>,
											   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>txn_context</name></name> <operator>=</operator> <call><name>SlabContextCreate</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>,
											<argument><expr><literal type="string">"TXN"</literal></expr></argument>,
											<argument><expr><name>SLAB_DEFAULT_BLOCK_SIZE</name></expr></argument>,
											<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>tup_context</name></name> <operator>=</operator> <call><name>GenerationContextCreate</name><argument_list>(<argument><expr><name>new_ctx</name></expr></argument>,
												  <argument><expr><literal type="string">"Tuples"</literal></expr></argument>,
												  <argument><expr><name>SLAB_LARGE_BLOCK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXNByIdEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferByXid"</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>txns_by_base_snapshot_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure there's no stale data from prior uses of this slot, in case some
	 * prior exit avoided calling ReorderBufferFree. Failure to do this can
	 * produce duplicated txns, and it's very cheap if there's nothing there.
	 */</comment>
	<expr_stmt><expr><call><name>ReorderBufferCleanupSerializedTXNs</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a ReorderBuffer
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferFree</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name> <init>= <expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We free separately allocated data by entirely scrapping reorderbuffer's
	 * memory context.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free disk space used by unconsumed reorder buffers */</comment>
	<expr_stmt><expr><call><name>ReorderBufferCleanupSerializedTXNs</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an unused, possibly preallocated, ReorderBufferTXN.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferGetTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTXN</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>txn_context</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a ReorderBufferTXN.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferReturnTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* clean the lookup cache if we were cached (quite likely) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>==</operator> <name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* free data that's contained */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an fresh ReorderBufferChange.
 */</comment>
<function><type><name>ReorderBufferChange</name> <modifier>*</modifier></type>
<name>ReorderBufferGetChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferChange</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>change_context</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>change</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an ReorderBufferChange.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferReturnChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* free contained data */</comment>
	<switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReorderBufferReturnTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReorderBufferReturnTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
			<comment type="block">/* no data in addition to the struct itself */</comment>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_TRUNCATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReorderBufferReturnRelids</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a fresh ReorderBufferTupleBuf fitting at least a tuple of size
 * tuple_len (excluding header overhead).
 */</comment>
<function><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type>
<name>ReorderBufferGetTupleBuf</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>tuple_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alloc_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>alloc_len</name> <operator>=</operator> <name>tuple_len</name> <operator>+</operator> <name>SizeofHeapTupleHeader</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleBuf</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>tup_context</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleBuf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
						   <name>MAXIMUM_ALIGNOF</name> <operator>+</operator> <name>alloc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>alloc_tuple_size</name></name> <operator>=</operator> <name>alloc_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an ReorderBufferTupleBuf.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferReturnTupleBuf</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get an array for relids of truncated relations.
 *
 * We use the global memory context (for the whole reorder buffer), because
 * none of the existing ones seems like a good match (some are SLAB, so we
 * can't use those, and tup_context is meant for tuple data, not relids). We
 * could add yet another context, but it seems like an overkill - TRUNCATE is
 * not particularly common operation, so it does not seem worth it.
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>ReorderBufferGetRelids</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name>	   <modifier>*</modifier></type><name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>	<name>alloc_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>alloc_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nrelids</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>relids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>alloc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free an array of relids.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferReturnRelids</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the ReorderBufferTXN from the given buffer, specified by Xid.
 * If create is true, and a transaction doesn't already exist, create it
 * (with the given LSN, and as top transaction if that's specified);
 * when this happens, is_new is set to true.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferTXNByXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_new</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_as_top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXNByIdEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check the one-entry lookup cache first
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>==</operator> <name>xid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found it, and it's valid */</comment>
			<if_stmt><if>if <condition>(<expr><name>is_new</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>is_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>txn</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * cached as non-existent, and asked not to create? Then nothing else
		 * to do.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* otherwise fall through to create it */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the cache wasn't hit or it yielded an "does-not-exist" and we want
	 * to create an entry.
	 */</comment>

	<comment type="block">/* search the lookup table */</comment>
	<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTXNByIdEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xid</name></expr></argument>,
					<argument><expr><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><name>HASH_ENTER</name></expr> </then><else>: <expr><name>HASH_FIND</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>txn</name></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>create</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* initialize the new entry, if creation was requested */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>txn</name></name> <operator>=</operator> <call><name>ReorderBufferGetTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>txn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>restart_decoding_lsn</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>create_as_top</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* not found and not asked to create */</comment>

	<comment type="block">/* update cache */</comment>
	<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn_last_txn</name></name> <operator>=</operator> <name>txn</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_new</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is_new</name> <operator>=</operator> <operator>!</operator><name>found</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>create</name> <operator>||</operator> <name>txn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Queue a change into a transaction so it can be replayed upon commit.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferQueueChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
						 <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InvalidXLogRecPtr</name> <operator>!=</operator> <name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferCheckSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Queue message into a transaction so it can be processed upon commit.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferQueueMessage</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>transactional</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
						  <parameter><decl><type><name>Size</name></type> <name>message_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>transactional</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name> <operator>=</operator> <name>message_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>message_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>message_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>Snapshot</name></type> <name>snapshot_now</name> <init>= <expr><name>snapshot</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* setup snapshot to allow catalog access */</comment>
		<expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>message</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>message_size</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AssertTXNLsnOrder
 *		Verify LSN ordering of transaction lists in the reorderbuffer
 *
 * Other LSN-related invariants are checked too.
 *
 * No-op if assertions are not in use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssertTXNLsnOrder</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>prev_first_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>prev_base_snap_lsn</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;rb-&gt;toplevel_by_lsn</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
													<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* start LSN must be set */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If there is an end LSN, it must be higher than start LSN */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>&lt;=</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>end_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Current initial LSN must be strictly higher than previous */</comment>
		<if_stmt><if>if <condition>(<expr><name>prev_first_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prev_first_lsn</name> <operator>&lt;</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* known-as-subtxn txns must not be listed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>prev_first_lsn</name> <operator>=</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;rb-&gt;txns_by_base_snapshot_lsn</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>,
													<argument><expr><name>base_snapshot_node</name></expr></argument>,
													<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* base snapshot (and its LSN) must be set */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cur_txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* current LSN must be strictly higher than previous */</comment>
		<if_stmt><if>if <condition>(<expr><name>prev_base_snap_lsn</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prev_base_snap_lsn</name> <operator>&lt;</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* known-as-subtxn txns must not be listed */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>cur_txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>prev_base_snap_lsn</name> <operator>=</operator> <name><name>cur_txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * ReorderBufferGetOldestTXN
 *		Return oldest transaction in reorderbuffer
 */</comment>
<function><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type>
<name>ReorderBufferGetOldestTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>toplevel_by_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>txn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReorderBufferGetOldestXmin
 *		Return oldest Xmin in reorderbuffer
 *
 * Returns oldest possibly running Xid from the point of view of snapshots
 * used in the transactions kept by reorderbuffer, or InvalidTransactionId if
 * there are none.
 *
 * Since snapshots are assigned monotonically, this equals the Xmin of the
 * base snapshot with minimal base_snapshot_lsn.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>ReorderBufferGetOldestXmin</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>txns_by_base_snapshot_lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>base_snapshot_node</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>txns_by_base_snapshot_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ReorderBufferSetRestartPoint</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>current_restart_decoding_lsn</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReorderBufferAssignChild
 *
 * Make note that we know that subxid is a subtransaction of xid, seen as of
 * the given lsn.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAssignChild</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						 <parameter><decl><type><name>TransactionId</name></type> <name>subxid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_top</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>new_sub</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_top</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_sub</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_top</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>new_sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subtransaction logged without previous top-level txn record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_sub</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* already associated, nothing to do */</comment>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We already saw this transaction, but initially added it to the
			 * list of top-level txns.  Now that we know it's not top-level,
			 * remove it from there.
			 */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>toplevel_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add to subtransaction list */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>subtxns</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Possibly transfer the subtxn's snapshot to its top-level txn. */</comment>
	<expr_stmt><expr><call><name>ReorderBufferTransferSnapToParent</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><name>subtxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Verify LSN-ordering invariant */</comment>
	<expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReorderBufferTransferSnapToParent
 *		Transfer base snapshot from subtxn to top-level txn, if needed
 *
 * This is done if the top-level txn doesn't have a base snapshot, or if the
 * subtxn's base snapshot has an earlier LSN than the top-level txn's base
 * snapshot's LSN.  This can happen if there are no changes in the toplevel
 * txn but there are some in the subtxn, or the first change in subtxn has
 * earlier LSN than first change in the top-level txn and we learned about
 * their kinship only now.
 *
 * The subtransaction's snapshot is cleared regardless of the transfer
 * happening, since it's not needed anymore in either case.
 *
 * We do this as soon as we become aware of their kinship, to avoid queueing
 * extra snapshots to txns known-as-subtxns -- only top-level txns will
 * receive further snapshots.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferTransferSnapToParent</name><parameter_list>(<parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
								  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>toplevel_xid</name></name> <operator>==</operator> <name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>&lt;</operator> <name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the toplevel transaction already has a base snapshot but
			 * it's newer than the subxact's, purge it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * The snapshot is now the top transaction's; transfer it, and
			 * adjust the list position of the top transaction in the list by
			 * moving it to where the subtransaction is.
			 */</comment>
			<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_insert_before</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The subtransaction doesn't have a snapshot anymore (so it
			 * mustn't be in the list.)
			 */</comment>
			<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Base snap of toplevel is fine, so subxact's is not needed */</comment>
			<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Associate a subtransaction with its toplevel transaction at commit
 * time. There may be no further changes added after this.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferCommitChild</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						 <parameter><decl><type><name>TransactionId</name></type> <name>subxid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>,
						 <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to do anything if that subtxn didn't contain any changes
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subtxn</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>commit_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subtxn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign this subxact as a child of the toplevel xact (no-op if already
	 * done.)
	 */</comment>
	<expr_stmt><expr><call><name>ReorderBufferAssignChild</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>subxid</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support for efficiently iterating over a transaction's and its
 * subtransactions' changes.
 *
 * We do by doing a k-way merge between transactions/subtransactions. For that
 * we model the current heads of the different transactions as a binary heap
 * so we easily know which (sub-)transaction has the change with the smallest
 * lsn next.
 *
 * We assume the changes in individual transactions are already sorted by LSN.
 */</comment>

<comment type="block">/*
 * Binary heap comparison function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReorderBufferIterCompare</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>ReorderBufferIterTXNState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>pos_a</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>lsn</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>pos_b</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>lsn</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pos_a</name> <operator>&lt;</operator> <name>pos_b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>pos_a</name> <operator>==</operator> <name>pos_b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate &amp; initialize an iterator which iterates in lsn order over a
 * transaction and all its subtransactions.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type>
<name>ReorderBufferIterTXNInit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nr_txns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>cur_txn_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>off</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate the size of our heap: one element for every transaction that
	 * contains changes.  (Besides the transactions already in the reorder
	 * buffer, we count the one we were directly passed.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nr_txns</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>cur_txn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cur_txn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nr_txns</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * TODO: Consider adding fastpath for the rather common nr_txns=1 case, no
	 * need to allocate/build a heap then.
	 */</comment>

	<comment type="block">/* allocate iteration state */</comment>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferIterTXNState</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferIterTXNState</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							   <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferIterTXNEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nr_txns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name> <operator>=</operator> <name>nr_txns</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* allocate heap */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <call><name>binaryheap_allocate</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr></argument>,
									  <argument><expr><name>ReorderBufferIterCompare</name></expr></argument>,
									  <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now insert items into the binary heap, in an unordered fashion.  (We
	 * will run a heap assembly step at the end; this is more efficient.)
	 */</comment>

	<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* add toplevel transaction if it contains changes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cur_change</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* serialize remaining changes */</comment>
			<expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>cur_change</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>cur_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>cur_change</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>txn</name> <operator>=</operator> <name>txn</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* add subtransactions if they contain changes */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>cur_txn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>cur_txn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cur_txn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cur_change</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cur_txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* serialize remaining changes */</comment>
				<expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cur_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cur_txn</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>cur_change</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>cur_txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>cur_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>cur_change</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>txn</name> <operator>=</operator> <name>cur_txn</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>binaryheap_add_unordered</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* assemble a valid binary heap */</comment>
	<expr_stmt><expr><call><name>binaryheap_build</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the next change when iterating over a transaction and its
 * subtransactions.
 *
 * Returns NULL when no further changes exist.
 */</comment>
<function><type><specifier>static</specifier> <name>ReorderBufferChange</name> <modifier>*</modifier></type>
<name>ReorderBufferIterTXNNext</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferIterTXNEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>off</name></decl>;</decl_stmt>

	<comment type="block">/* nothing there anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>heap</name><operator>-&gt;</operator><name>bh_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>binaryheap_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* free memory we might have "leaked" in the previous *Next call */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
								 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>change</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * update heap with information about which transaction has the next
	 * relevant change in LSN order
	 */</comment>

	<comment type="block">/* there are in-memory changes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>next_change</name> <init>=
		<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* txn stays the same */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>next_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>next_change</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>change</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* try to load changes from disk */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries</name></name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ugly: restoring changes will reuse *Change records, thus delete the
		 * current one from the per-tx list and only free in the next call.
		 */</comment>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ReorderBufferRestoreChanges</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>segno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* successfully restored changes from disk */</comment>
			<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>next_change</name> <init>=
			<expr><call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"restored %u/%u changes from disk"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* txn stays the same */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>lsn</name> <operator>=</operator> <name><name>next_change</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>change</name> <operator>=</operator> <name>next_change</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>binaryheap_replace_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>change</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ok, no changes there anymore, remove */</comment>
	<expr_stmt><expr><call><name>binaryheap_remove_first</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deallocate the iterator
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferIterTXNFinish</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>,
						   <parameter><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>off</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>nr_txns</name></name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>off</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* free memory we might have "leaked" in the last *Next call */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
								 <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>old_change</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>binaryheap_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup the contents of a transaction, usually after the transaction
 * committed or aborted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferCleanupTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<comment type="block">/* cleanup subtransactions &amp; their changes */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Subtransactions are always associated to the toplevel TXN, even if
		 * they originally were happening inside another subtxn, so we won't
		 * ever recurse more than one level deep here.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subtxn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subtxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* cleanup changes in the toplevel txn */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Cleanup the tuplecids we stored for decoding catalog snapshot access.
	 * They are always stored in the toplevel transaction.
	 */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;tuplecids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Cleanup the base snapshot, if set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove TXN from its containing list.
	 *
	 * Note: if txn-&gt;is_known_as_subxact, we are deleting the TXN from its
	 * parent's list of known subxacts; this leaves the parent's nsubxacts
	 * count too high, but we don't care.  Otherwise, we are deleting the TXN
	 * from the LSN-ordered list of toplevel TXNs.
	 */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now remove reference from buffer */</comment>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>by_txn</name></name></expr></argument>,
				<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
				<argument><expr><name>HASH_REMOVE</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remove entries spilled to disk */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReorderBufferRestoreCleanup</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* deallocate */</comment>
	<expr_stmt><expr><call><name>ReorderBufferReturnTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a hash with a (relfilenode, ctid) -&gt; (cmin, cmax) mapping for use by
 * tqual.c's HeapTupleSatisfiesHistoricMVCC.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferBuildTupleCidHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name> <operator>||</operator> <call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * create the hash with the exact number of to-be-stored tuplecids from
	 * the start
	 */</comment>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name> <operator>=</operator>
		<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferTupleCid"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ntuplecids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
					<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;tuplecids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* be careful about padding */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>tid</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
						<argument><expr><name>HASH_ENTER</name> <operator>|</operator> <name>HASH_FIND</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>combocid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator>
				   <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * if the tuple got valid in this transaction and now got deleted
			 * we already have a valid cmin stored. The cmax will be
			 * InvalidCommandId though.
			 */</comment>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Copy a provided snapshot so we can modify it privately. This is needed so
 * that catalog modifying transactions can look into intermediate catalog
 * states.
 */</comment>
<function><type><specifier>static</specifier> <name>Snapshot</name></type>
<name>ReorderBufferCopySnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>orig_snap</name></decl></parameter>,
					  <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>orig_snap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>txn</name><operator>-&gt;</operator><name>nsubtxns</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>orig_snap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>active_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* mark as active so nobody frees it */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>regd_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>snap</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>orig_snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * snap-&gt;subxip contains all txids that belong to our transaction which we
	 * need to check via cmin/cmax. That's why we store the toplevel
	 * transaction in there as well.
	 */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name></name> <operator>+</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * nsubxcnt isn't decreased when subtransactions abort, so count manually.
	 * Since it's an upper boundary it is safe to use it for the allocation
	 * above.
	 */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>sub_txn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sub_txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>sub_txn</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* sort so we can bsearch() later */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store the specified current CommandId */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>

	<return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a previously ReorderBufferCopySnap'ed snapshot
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferFreeSnap</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SnapBuildSnapDecRefcount</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform the replay of a transaction and its non-aborted subtransactions.
 *
 * Subtransactions previously have to be processed by
 * ReorderBufferCommitChild(), even if previously assigned to the toplevel
 * transaction with ReorderBufferAssignChild.
 *
 * We currently can only decode a transaction's contents when its commit
 * record is read because that's the only place where we know about cache
 * invalidations. Thus, once a toplevel commit is read, we iterate over the top
 * and subtransactions (using a k-way merge) and replay the changes in lsn
 * order.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferCommit</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
					<parameter><decl><type><name>XLogRecPtr</name></type> <name>commit_lsn</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>end_lsn</name></decl></parameter>,
					<parameter><decl><type><name>TimestampTz</name></type> <name>commit_time</name></decl></parameter>,
					<parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>origin_lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>Snapshot</name></type> <name>snapshot_now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>CommandId</name></type> <name>command_id</name> <init>= <expr><name>FirstCommandId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>using_subtxn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferIterTXNState</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>iterstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unknown transaction, nothing to replay */</comment>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>commit_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>end_lsn</name></name> <operator>=</operator> <name>end_lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>commit_time</name></name> <operator>=</operator> <name>commit_time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>origin_id</name></name> <operator>=</operator> <name>origin_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>origin_lsn</name></name> <operator>=</operator> <name>origin_lsn</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this transaction has no snapshot, it didn't make any changes to the
	 * database, so there's nothing to decode.  Note that
	 * ReorderBufferCommitChild will have transferred any snapshots from
	 * subtransactions if there were any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name></expr>;</expr_stmt>

	<comment type="block">/* build data to be able to lookup the CommandIds of catalog tuples */</comment>
	<expr_stmt><expr><call><name>ReorderBufferBuildTupleCidHash</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setup the initial snapshot */</comment>
	<expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decoding needs access to syscaches et al., which in turn use
	 * heavyweight locks and such. Thus we need to have enough state around to
	 * keep track of those.  The easiest way is to simply use a transaction
	 * internally.  That also allows us to easily enforce that nothing writes
	 * to the database by checking for xid assignments.
	 *
	 * When we're called via the SQL SRF there's already a transaction
	 * started, so start an explicit subtransaction there.
	 */</comment>
	<expr_stmt><expr><name>using_subtxn</name> <operator>=</operator> <call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>specinsert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><literal type="string">"replay"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>begin</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>iterstate</name> <operator>=</operator> <call><name>ReorderBufferIterTXNInit</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>change</name> <operator>=</operator> <call><name>ReorderBufferIterTXNNext</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>

					<comment type="block">/*
					 * Confirmation for speculative insertion arrived. Simply
					 * use as a normal record. It'll be cleaned up at the end
					 * of INSERT processing.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>specinsert</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid ordering of speculative insertion changes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>specinsert</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>change</name> <operator>=</operator> <name>specinsert</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>;</expr_stmt>

					<comment type="block">/* intentionally fall through */</comment>
					<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
				<case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
				<case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
												<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Mapped catalog tuple without data, emitted while
					 * catalog table was in the process of being rewritten. We
					 * can fail to look up the relfilenode, because the the
					 * relmapper has no "historic" view, in contrast to normal
					 * the normal catalog during decoding. Thus repeated
					 * rewrites can cause a lookup failure. That's OK because
					 * we do not decode catalog changes anyway. Normally such
					 * tuples would be skipped over below, but we can't
					 * identify whether the table should be logically logged
					 * without mapping the relfilenode to the oid.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>reloid</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
						<name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
						<name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>change_done</name>;</goto></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>reloid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not map filenode \"%s\" to relation OID"</literal></expr></argument>,
							 <argument><expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>,
										 <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open relation with OID %u (for filenode \"%s\")"</literal></expr></argument>,
							 <argument><expr><name>reloid</name></expr></argument>,
							 <argument><expr><call><name>relpathperm</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>relnode</name></name></expr></argument>,
										 <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>change_done</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Ignore temporary heaps created during DDL unless the
					 * plugin has asked for them.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrewrite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rb</name><operator>-&gt;</operator><name>output_rewrites</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>change_done</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * For now ignore sequence changes entirely. Most of the
					 * time they don't log changes using records we
					 * understand, so it doesn't make sense to handle the few
					 * cases we do.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>change_done</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/* user-triggered change */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReorderBufferToastReplace</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>apply_change</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Only clear reassembled toast chunks if we're sure
						 * they're not required anymore. The creator of the
						 * tuple tells us.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>clear_toast_afterwards</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ReorderBufferToastReset</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<comment type="block">/* we're not interested in toast deletions */</comment>
					<if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>REORDER_BUFFER_CHANGE_INSERT</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Need to reassemble the full toasted Datum in
						 * memory, to ensure the chunks don't get reused till
						 * we're done remove it from the list of this
						 * transaction's changes. Otherwise it will get
						 * freed/reused while restoring spooled data from
						 * disk.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ReorderBufferToastAppendChunk</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
													  <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

			<label><name>change_done</name>:</label>

					<comment type="block">/*
					 * Either speculative insertion was confirmed, or it was
					 * unsuccessful and the record isn't needed anymore.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>specinsert</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>relation</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>

					<comment type="block">/*
					 * Speculative insertions are dealt with by delaying the
					 * processing of the insert until the confirmation record
					 * arrives. For that we simply unlink the record from the
					 * chain, so it does not get freed/reused while restoring
					 * spooled data from disk.
					 *
					 * This is safe in the face of concurrent catalog changes
					 * because the relevant relation can't be changed between
					 * speculative insertion and confirmation due to
					 * CheckTableNotInUse() and locking.
					 */</comment>

					<comment type="block">/* clear out a pending (and thus failed) speculation */</comment>
					<if_stmt><if>if <condition>(<expr><name>specinsert</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* and memorize the pending insertion */</comment>
					<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>change</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_TRUNCATE</name></expr>:</case>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nrelids</name> <init>= <expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>nrelids</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>nrelations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Relation</name>   <modifier>*</modifier></type><name>relations</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nrelids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Relation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrelids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsLogicallyLogged</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>

							<expr_stmt><expr><name><name>relations</name><index>[<expr><name>nrelations</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
						</block_content>}</block></for>

						<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>apply_truncate</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>nrelations</name></expr></argument>, <argument><expr><name>relations</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrelations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name><name>relations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

						<break>break;</break>
					</block_content>}</block>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
					<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>message</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>,
								<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>,
								<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
					<comment type="block">/* get rid of the old */</comment>
					<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>snapshot_now</name> <operator>=</operator>
							<call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>,
												  <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>

					<comment type="block">/*
					 * Restored from disk, need to be careful not to double
					 * free. We could introduce refcounting for that, but for
					 * now this seems infrequent enough not to care.
					 */</comment>
					<if type="elseif">else if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>snapshot_now</name> <operator>=</operator>
							<call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr></argument>,
												  <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>


					<comment type="block">/* and continue with the new one */</comment>
					<expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name> <operator>!=</operator> <name>InvalidCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>command_id</name> <operator>&lt;</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>command_id</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* we don't use the global one anymore */</comment>
							<expr_stmt><expr><name>snapshot_now</name> <operator>=</operator> <call><name>ReorderBufferCopySnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>,
																 <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>command_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name>command_id</name></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>SetupHistoricSnapshot</name><argument_list>(<argument><expr><name>snapshot_now</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>tuplecid_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Every time the CommandId is incremented, we could
						 * see new catalog contents, so execute all
						 * invalidations.
						 */</comment>
						<expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<break>break;</break>

				<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuplecid value in changequeue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></while>

		<comment type="block">/*
		 * There's a speculative insertion remaining, just clean in up, it
		 * can't have been successful, otherwise we'd gotten a confirmation
		 * record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>specinsert</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>specinsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>specinsert</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clean up the iterator */</comment>
		<expr_stmt><expr><call><name>ReorderBufferIterTXNFinish</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iterstate</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* call commit callback */</comment>
		<expr_stmt><expr><call><name><name>rb</name><operator>-&gt;</operator><name>commit</name></name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>commit_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this is just a sanity check against bad output plugin behaviour */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"output plugin used XID %u"</literal></expr></argument>,
				 <argument><expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* cleanup */</comment>
		<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Aborting the current (sub-)transaction as a whole has the right
		 * semantics. We want all locks acquired in here to be released, not
		 * reassigned to the parent and we do not want any database access
		 * have persistent effects.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure there's no cache pollution */</comment>
		<expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* remove potential on-disk data, and deallocate */</comment>
		<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* TODO: Encapsulate cleanup from the PG_TRY and PG_CATCH blocks */</comment>
		<if_stmt><if>if <condition>(<expr><name>iterstate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReorderBufferIterTXNFinish</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>iterstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TeardownHistoricSnapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force cache invalidation to happen outside of a valid transaction
		 * to prevent catalog access as we just caught an error.
		 */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure there's no cache pollution */</comment>
		<expr_stmt><expr><call><name>ReorderBufferExecuteInvalidations</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>using_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>snapshot_now</name><operator>-&gt;</operator><name>copied</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReorderBufferFreeSnap</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>snapshot_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* remove potential on-disk data, and deallocate */</comment>
		<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort a transaction that possibly has previous changes. Needs to be first
 * called for subtransactions and then for the toplevel xid.
 *
 * NB: Transactions handled here have to have actively aborted (i.e. have
 * produced an abort record). Implicitly aborted transactions are handled via
 * ReorderBufferAbortOld(); transactions we're just not interested in, but
 * which have committed are handled in ReorderBufferForget().
 *
 * This function purges this transaction and its contents from memory and
 * disk.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAbort</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unknown, nothing to remove */</comment>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* cosmetic... */</comment>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

	<comment type="block">/* remove potential on-disk data, and deallocate */</comment>
	<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abort all transactions that aren't actually running anymore because the
 * server restarted.
 *
 * NB: These really have to be transactions that have aborted due to a server
 * crash/immediate restart, as we don't deal with invalidations here.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAbortOld</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>oldestRunningXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>it</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate through all (potential) toplevel TXNs and abort all that are
	 * older than what possibly can be running. Once we've found the first
	 * that is alive we stop, there might be some that acquired an xid earlier
	 * but started writing later, but it's unlikely and they will be cleaned
	 * up in a later call to this function.
	 */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>it</argument>, <argument>&amp;rb-&gt;toplevel_by_lsn</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>oldestRunningXid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We set final_lsn on a transaction when we decode its commit or
			 * abort record, but we never see those records for crashed
			 * transactions.  To ensure cleanup of these transactions, set
			 * final_lsn to that of their last change; this causes
			 * ReorderBufferRestoreCleanup to do the right thing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name> <operator>&amp;&amp;</operator> <name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>last</name> <init>=
				<expr><call><name>dlist_tail_element</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name><name>last</name><operator>-&gt;</operator><name>lsn</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"aborting old transaction %u"</literal></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* remove potential on-disk data, and deallocate this tx */</comment>
			<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return;</return></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Forget the contents of a transaction if we aren't interested in it's
 * contents. Needs to be first called for subtransactions and then for the
 * toplevel xid.
 *
 * This is significantly different to ReorderBufferAbort() because
 * transactions that have committed need to be treated differently from aborted
 * ones since they may have modified the catalog.
 *
 * Note that this is only allowed to be called in the moment a transaction
 * commit has just been read, not earlier; otherwise later records referring
 * to this xid might re-create the transaction incompletely.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferForget</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unknown, nothing to forget */</comment>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* cosmetic... */</comment>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process cache invalidation messages if there are any. Even if we're not
	 * interested in the transaction's contents, it could have manipulated the
	 * catalog and we need to update the caches according to that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReorderBufferImmediateInvalidation</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name></expr></argument>,
										   <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* remove potential on-disk data, and deallocate */</comment>
	<expr_stmt><expr><call><name>ReorderBufferCleanupTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute invalidations happening outside the context of a decoded
 * transaction. That currently happens either for xid-less commits
 * (cf. RecordTransactionCommit()) or for invalidations in uninteresting
 * transactions (via ReorderBufferForget()).
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferImmediateInvalidation</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>ninvalidations</name></decl></parameter>,
								   <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalidations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_subtxn</name> <init>= <expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><literal type="string">"replay"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Force invalidations to happen outside of a valid transaction - that way
	 * entries will just be marked as invalid without accessing the catalog.
	 * That's advantageous because we don't need to setup the full state
	 * necessary for catalog access.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ninvalidations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalExecuteInvalidationMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>invalidations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>use_subtxn</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tell reorderbuffer about an xid seen in the WAL stream. Has to be called at
 * least once for every xid in XLogRecord-&gt;xl_xid (other places in records
 * may, but do not have to be passed through here).
 *
 * Reorderbuffer keeps some datastructures about transactions in LSN order,
 * for efficiency. To do that it has to know about when transactions are seen
 * first in the WAL. As many types of records are not actually interesting for
 * logical decoding, they do not necessarily pass though here.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferProcessXid</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* many records won't have an xid assigned, centralize check here */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new snapshot to this transaction that may only used after lsn 'lsn'
 * because the previous snapshot doesn't describe the catalog correctly for
 * following rows.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
						 <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the transaction's base snapshot.
 *
 * If we know that xid is a subtransaction, set the base snapshot on the
 * top-level transaction instead.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferSetBaseSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							 <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_new</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>snap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the transaction to operate on.  If we know it's a subtransaction,
	 * operate on its top-level transaction instead.
	 */</comment>
	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_new</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toplevel_xid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rb</name><operator>-&gt;</operator><name>txns_by_base_snapshot_lsn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AssertTXNLsnOrder</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Access the catalog with this CommandId at this point in the changestream.
 *
 * May only be called for command ids &gt; 1
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddNewCommandId</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							 <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>command_id</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReorderBufferQueueChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Add new (relfilenode, tid) -&gt; (cmin, cmax) mappings.
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddNewTupleCids</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							 <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>,
							 <parameter><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>,
							 <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>= <expr><call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>tid</name></name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tuplecid</name><operator>.</operator><name>combocid</name></name> <operator>=</operator> <name>combocid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>lsn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>tuplecids</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>ntuplecids</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup the invalidation of the toplevel transaction.
 *
 * This needs to be done before ReorderBufferCommit is called!
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferAddInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							  <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nmsgs</name></decl></parameter>,
							  <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>msgs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only ever add one set of invalidations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmsgs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name> <operator>=</operator> <name>nmsgs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name> <operator>=</operator> <operator>(</operator><name>SharedInvalidationMessage</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name></name></expr></argument>, <argument><expr><name>msgs</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nmsgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply all invalidations we know. Possibly we only need parts at this point
 * in the changestream but we don't know which those are.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferExecuteInvalidations</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>txn</name><operator>-&gt;</operator><name>ninvalidations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LocalExecuteInvalidationMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>invalidations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a transaction as containing catalog changes
 */</comment>
<function><type><name>void</name></type>
<name>ReorderBufferXidSetCatalogChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
								  <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Query whether a transaction is already *known* to contain catalog
 * changes. This can be wrong until directly before the commit!
 */</comment>
<function><type><name>bool</name></type>
<name>ReorderBufferXidHasCatalogChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>txn</name><operator>-&gt;</operator><name>has_catalog_changes</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReorderBufferXidHasBaseSnapshot
 *		Have we already set the base snapshot for the given txn/subtxn?
 */</comment>
<function><type><name>bool</name></type>
<name>ReorderBufferXidHasBaseSnapshot</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transaction isn't known yet, ergo no snapshot */</comment>
	<if_stmt><if>if <condition>(<expr><name>txn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* a known subtxn? operate on top-level txn instead */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>is_known_as_subxact</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>txn</name> <operator>=</operator> <call><name>ReorderBufferTXNByXid</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toplevel_xid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>txn</name><operator>-&gt;</operator><name>base_snapshot</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ---------------------------------------
 * Disk serialization support
 * ---------------------------------------
 */</comment>

<comment type="block">/*
 * Ensure the IO buffer is &gt;= sz.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeReserve</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>&lt;</operator> <name>sz</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rb</name><operator>-&gt;</operator><name>outbufsize</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the transaction tx should spill its data to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferCheckSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * TODO: improve accounting so we cheaply can take subtransactions into
	 * account here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>&gt;=</operator> <name>max_changes_in_memory</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Spill data of a large transaction (and its subtransactions) to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeTXN</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>subtxn_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>change_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>curOpenSegNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>spilled</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"spill %u changes in XID %u to disk"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do the same to all child TXs */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>subtxn_i</argument>, <argument>&amp;txn-&gt;subtxns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>subtxn</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>subtxn</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferTXN</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>subtxn_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferSerializeTXN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>subtxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* serialize changestream */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>change_i</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>change_i</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * store in segment in which it belongs by start lsn, don't split over
		 * multiple segments tho
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
			<operator>!</operator><call><name>XLByteInSeg</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>curOpenSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>, <argument><expr><name>curOpenSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * No need to care about TLIs here, only used during a single run,
			 * so each LSN only maps to a specific WAL record.
			 */</comment>
			<expr_stmt><expr><call><name>ReorderBufferSerializedPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MyReplicationSlot</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
										<argument><expr><name>curOpenSegNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* open segment, create it if necessary */</comment>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
								   <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReorderBufferSerializeChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>spilled</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>spilled</name> <operator>==</operator> <name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>serialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize individual change to disk.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializeChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>change</name></name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* fall through these, they're all similar enough */</comment>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>oldtup</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>oldlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>newlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldtup</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>oldlen</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>newtup</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* make sure we have enough space */</comment>
				<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<comment type="block">/* might have been reallocated above */</comment>
				<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldlen</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>oldtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>oldlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>oldlen</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>newlen</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>newlen</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>prefix_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>prefix_size</name> <operator>+</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

				<comment type="block">/* might have been reallocated above */</comment>
				<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

				<comment type="block">/* write the prefix including the size */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefix_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>,
					   <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>prefix_size</name></expr>;</expr_stmt>

				<comment type="block">/* write the message including the size */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>,
					   <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>snap</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>sz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>
					;</expr_stmt>

				<comment type="block">/* make sure we have enough space */</comment>
				<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<comment type="block">/* might have been reallocated above */</comment>
				<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>snap</name><operator>-&gt;</operator><name>subxcnt</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_TRUNCATE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>	<name>size</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

				<comment type="block">/* account for the OIDs of truncated relations */</comment>
				<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>nrelids</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>sz</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

				<comment type="block">/* make sure we have enough space */</comment>
				<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<comment type="block">/* might have been reallocated above */</comment>
				<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
			<comment type="block">/* ReorderBufferChange contains everything important */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to data file for XID %u: %m"</literal></expr></argument>,
						<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>change</name><operator>.</operator><name>action</name></name> <operator>==</operator> <name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Restore a number of changes spilled to disk back into memory.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>ReorderBufferRestoreChanges</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>XLogSegNo</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>restored</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>last_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>cleanup_iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free current entries, so we have memory for more */</comment>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>cleanup_iter</argument>, <argument>&amp;txn-&gt;changes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cleanup</name> <init>=
		<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>cleanup_iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cleanup</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name></expr></argument>, <argument><expr><name>last_segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>restored</name> <operator>&lt;</operator> <name>max_changes_in_memory</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>segno</name> <operator>&lt;=</operator> <name>last_segno</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>readBytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* first time in */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>segno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>segno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * No need to care about TLIs here, only used during a single run,
			 * so each LSN only maps to a specific WAL record.
			 */</comment>
			<expr_stmt><expr><call><name>ReorderBufferSerializedPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MyReplicationSlot</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>,
										<argument><expr><operator>*</operator><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Read the statically sized part of a change which has information
		 * about the total size. If we couldn't read a record, we're at the
		 * end of this file.
		 */</comment>
		<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* eof */</comment>
		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: read %d instead of %u bytes"</literal></expr></argument>,
							<argument><expr><name>readBytes</name></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReorderBufferSerializeReserve</name><argument_list>(<argument><expr><name>rb</name></expr></argument>,
									  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_BUFFER_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from reorderbuffer spill file: read %d instead of %u bytes"</literal></expr></argument>,
							<argument><expr><name>readBytes</name></expr></argument>,
							<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name><name>ondisk</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ok, read a full change from disk, now restore it into proper
		 * in-memory format
		 */</comment>
		<expr_stmt><expr><call><name>ReorderBufferRestoreChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>rb</name><operator>-&gt;</operator><name>outbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restored</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>restored</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert change from its on-disk format to in-memory format and queue it onto
 * the TXN's -&gt;changes list.
 *
 * Note: although "data" is declared char*, at entry it points to a
 * maxalign'd buffer, making it safe in most of this function to assume
 * that the pointed-to data is suitably aligned for direct access.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferRestoreChange</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferDiskChange</name> <modifier>*</modifier></type><name>ondisk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ondisk</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferDiskChange</name> <operator>*</operator><operator>)</operator> <name>data</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>ReorderBufferGetChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy static part */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>change</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ondisk</name><operator>-&gt;</operator><name>change</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferDiskChange</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* restore individual stuff */</comment>
	<switch>switch <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* fall through these, they're all similar enough */</comment>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INSERT</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_UPDATE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_DELETE</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>tuplelen</name> <init>= <expr><operator>(</operator><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>data</name><operator>)</operator><operator>-&gt;</operator><name>t_len</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name> <operator>=</operator>
					<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>tuplelen</name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* restore -&gt;tuple */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

				<comment type="block">/* reset t_data pointer into the new tuplebuf */</comment>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator>
					<call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* restore tuple data itself */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>oldtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>tuplelen</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* here, data might not be suitably aligned! */</comment>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>tuplelen</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuplelen</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>, <argument><expr><name>t_len</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name> <operator>=</operator>
					<call><name>ReorderBufferGetTupleBuf</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>tuplelen</name> <operator>-</operator> <name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* restore -&gt;tuple */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
					   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HeapTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

				<comment type="block">/* reset t_data pointer into the new tuplebuf */</comment>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator>
					<call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* restore tuple data itself */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>tuplelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>tuplelen</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_MESSAGE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>prefix_size</name></decl>;</decl_stmt>

				<comment type="block">/* read prefix */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix_size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
															 <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>prefix_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>prefix</name><index>[<expr><name>prefix_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>prefix_size</name></expr>;</expr_stmt>

				<comment type="block">/* read the message */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
															  <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
					   <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>data</name> <operator>+=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>msg</name><operator>.</operator><name>message_size</name></name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Snapshot</name></type>	<name>oldsnap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Snapshot</name></type>	<name>newsnap</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oldsnap</name> <operator>=</operator> <operator>(</operator><name>Snapshot</name><operator>)</operator> <name>data</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>oldsnap</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>+</operator>
					<sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>oldsnap</name><operator>-&gt;</operator><name>subxcnt</name></name> <operator>+</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newsnap</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>snapshot</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newsnap</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
					<operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newsnap</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>subxip</name></name> <operator>=</operator> <name><name>newsnap</name><operator>-&gt;</operator><name>xip</name></name> <operator>+</operator> <name><name>newsnap</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newsnap</name><operator>-&gt;</operator><name>copied</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<comment type="block">/* the base struct contains all the data, easy peasy */</comment>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_TRUNCATE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name>	   <modifier>*</modifier></type><name>relids</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>relids</name> <operator>=</operator> <call><name>ReorderBufferGetRelids</name><argument_list>(<argument><expr><name>rb</name></expr></argument>,
												<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>nrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>nrelids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>truncate</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name>relids</name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID</name></expr>:</case>
		<case>case <expr><name>REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>txn</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>nentries_mem</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all on-disk stored for the passed in transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferRestoreCleanup</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>cur</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>last</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>first_lsn</name></name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>final_lsn</name></name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate over all possible filenames, and delete them */</comment>
	<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>cur</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ReorderBufferSerializedPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MyReplicationSlot</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Remove any leftover serialized reorder buffers from a slot directory after a
 * prior crash or decoding session exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferCleanupSerializedTXNs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slotname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>spill_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>spill_de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s"</literal></expr></argument>, <argument><expr><name>slotname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we're only handling directories here, skip if it's not ours */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>spill_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>spill_de</name> <operator>=</operator> <call><name>ReadDirExtended</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>INFO</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* only look at names that can be ours */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"xid"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"pg_replslot/%s/%s"</literal></expr></argument>, <argument><expr><name>slotname</name></expr></argument>,
					 <argument><expr><name><name>spill_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\" during removal of pg_replslot/%s/*.xid: %m"</literal></expr></argument>,
								<argument><expr><name>path</name></expr></argument>, <argument><expr><name>slotname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>spill_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a replication slot, transaction ID and segment number, fill in the
 * corresponding spill file into 'path', which is a caller-owned buffer of size
 * at least MAXPGPATH.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferSerializedPath</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>ReplicationSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
							<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogSegNoOffsetToRecPtr</name><argument_list>(<argument><expr><name>segno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot/%s/xid-%u-lsn-%X-%X.snap"</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>MyReplicationSlot</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>xid</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete all data spilled to disk after we've restarted/crashed. It will be
 * recreated when the respective slots are reused.
 */</comment>
<function><type><name>void</name></type>
<name>StartupReorderBuffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>logical_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>logical_de</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>logical_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>logical_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_replslot"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* if it cannot be a slot, skip the directory */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReplicationSlotValidateName</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ok, has to be a surviving logical slot, iterate and delete
		 * everything starting with xid-*
		 */</comment>
		<expr_stmt><expr><call><name>ReorderBufferCleanupSerializedTXNs</name><argument_list>(<argument><expr><name><name>logical_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>logical_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------------------------
 * toast reassembly support
 * ---------------------------------------
 */</comment>

<comment type="block">/*
 * Initialize per tuple toast reconstruction support.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastInitHash</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferToastEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ReorderBufferToastHash"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per toast-chunk handling for toast reconstruction
 *
 * Appends a toast chunk so we can reconstruct it when the tuple "owning" the
 * toasted Datum comes along.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastAppendChunk</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
							  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>chunksize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>chunk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>chunk_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>chunk_seq</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReorderBufferToastInitHash</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsToastRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_id</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_seq</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>chunk_id</name></expr></argument>,
					<argument><expr><name>HASH_ENTER</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>chunk_id</name></name> <operator>==</operator> <name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>chunk_seq</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got sequence entry %d for toast chunk %u instead of seq 0"</literal></expr></argument>,
				 <argument><expr><name>chunk_seq</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>chunk_seq</name> <operator>!=</operator> <name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"got sequence entry %d for toast chunk %u instead of seq %d"</literal></expr></argument>,
			 <argument><expr><name>chunk_seq</name></expr></argument>, <argument><expr><name>chunk_id</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calculate size so we can allocate the right size at once later */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* could happen due to heap_form_tuple doing its thing */</comment>
		<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected type of toast chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <name>chunksize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>last_chunk_seq</name></name> <operator>=</operator> <name>chunk_seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>num_chunks</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>chunks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rejigger change-&gt;newtuple to point to in-memory toast tuples instead to
 * on-disk toast tuples that may not longer exist (think DROP TABLE or VACUUM).
 *
 * We cannot replace unchanged toast tuples though, so those will still point
 * to on-disk toast data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastReplace</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>,
						  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>free</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tmphtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toast_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>toast_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>

	<comment type="block">/* no toast tuples changed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we should only have toast tuples in an INSERT or UPDATE */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>toast_rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toast_desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* should we allocate from stack instead? */</comment>
	<expr_stmt><expr><name>attrs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>free</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <name><name>change</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>natt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>varlena</name></decl>;</decl_stmt>

		<comment type="block">/* va_rawsize is the size of the original datum -- including header */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_external</name></name></type> <name>toast_pointer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varatt_indirect</name></name></type> <name>redirect_pointer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_datum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>reconstructed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>data_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* system columns aren't toasted */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* not a varlena datatype */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* no data */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* ok, we know we have a toast datum */</comment>
		<expr_stmt><expr><name>varlena</name> <operator>=</operator> <operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* no need to do anything if the tuple isn't external */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>varlena</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>VARATT_EXTERNAL_GET_POINTER</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>, <argument><expr><name>varlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether the toast tuple changed, replace if so.
		 */</comment>
		<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>toast_pointer</name><operator>.</operator><name>va_valueid</name></name></expr></argument>,
						<argument><expr><name>HASH_FIND</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>new_datum</name> <operator>=</operator>
			<operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>INDIRECT_POINTER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>free</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>reconstructed</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>toast_pointer</name><operator>.</operator><name>va_rawsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>=</operator> <name>reconstructed</name></expr>;</expr_stmt>

		<comment type="block">/* stitch toast tuple back together from its parts */</comment>
		<macro><name>dlist_foreach</name><argument_list>(<argument>it</argument>, <argument>&amp;ent-&gt;chunks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>cchange</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ReorderBufferTupleBuf</name> <modifier>*</modifier></type><name>ctup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Pointer</name></type>		<name>chunk</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cchange</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ctup</name> <operator>=</operator> <name><name>cchange</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>tp</name><operator>.</operator><name>newtuple</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>DatumGetPointer</name><argument_list>(
									<argument><expr><call><name>fastgetattr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctup</name><operator>-&gt;</operator><name>tuple</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>toast_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>data_done</name></expr></argument>,
				   <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_done</name> <operator>+=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>data_done</name> <operator>==</operator> <name><name>toast_pointer</name><operator>.</operator><name>va_extsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure its marked as compressed or not */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_EXTERNAL_IS_COMPRESSED</name><argument_list>(<argument><expr><name>toast_pointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SET_VARSIZE_COMPRESSED</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>, <argument><expr><name>data_done</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>reconstructed</name></expr></argument>, <argument><expr><name>data_done</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>redirect_pointer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redirect_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>redirect_pointer</name><operator>.</operator><name>pointer</name></name> <operator>=</operator> <name>reconstructed</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_VARTAG_EXTERNAL</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>, <argument><expr><name>VARTAG_INDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA_EXTERNAL</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>redirect_pointer</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>redirect_pointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Build tuple in separate memory &amp; copy tuple back into the tuplebuf
	 * passed to the output plugin. We can't directly heap_fill_tuple() into
	 * the tuplebuf because attrs[] will point back into the current content.
	 */</comment>
	<expr_stmt><expr><name>tmphtup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>&lt;=</operator> <name>MaxHeapTupleSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ReorderBufferTupleBufData</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tmphtup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name><name>tmphtup</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newtup</name><operator>-&gt;</operator><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <name><name>tmphtup</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * free resources we won't further need, more persistent stuff will be
	 * free'd in ReorderBufferToastReset().
	 */</comment>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmphtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>natt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>natt</name> <operator>&lt;</operator> <name><name>desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>natt</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>free</name><index>[<expr><name>natt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>natt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all resources allocated for toast reconstruction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderBufferToastReset</name><parameter_list>(<parameter><decl><type><name>ReorderBuffer</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>, <parameter><decl><type><name>ReorderBufferTXN</name> <modifier>*</modifier></type><name>txn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferToastEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* sequentially walk over the hash and free everything */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferToastEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>it</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>reconstructed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>dlist_foreach_modify</name><argument_list>(<argument>it</argument>, <argument>&amp;ent-&gt;chunks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ReorderBufferChange</name> <modifier>*</modifier></type><name>change</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ReorderBufferChange</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>it</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>change</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReorderBufferReturnChange</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>txn</name><operator>-&gt;</operator><name>toast_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ---------------------------------------
 * Visibility support for logical decoding
 *
 *
 * Lookup actual cmin/cmax values when using decoding snapshot. We can't
 * always rely on stored cmin/cmax values because of two scenarios:
 *
 * * A tuple got changed multiple times during a single transaction and thus
 *	 has got a combocid. Combocid's are only valid for the duration of a
 *	 single transaction.
 * * A tuple with a cmin but no cmax (and thus no combocid) got
 *	 deleted/updated in another transaction than the one which created it
 *	 which we are looking at right now. As only one of cmin, cmax or combocid
 *	 is actually stored in the heap we don't have access to the value we
 *	 need anymore.
 *
 * To resolve those problems we have a per-transaction hash of (cmin,
 * cmax) tuples keyed by (relfilenode, ctid) which contains the actual
 * (cmin, cmax) values. That also takes care of combocids by simply
 * not caring about them at all. As we have the real cmin/cmax values
 * combocids aren't interesting.
 *
 * As we only care about catalog tuples here the overhead of this
 * hashtable should be acceptable.
 *
 * Heap rewrites complicate this a bit, check rewriteheap.c for
 * details.
 * -------------------------------------------------------------------------
 */</comment>

<comment type="block">/* struct for qsort()ing mapping files by lsn somewhat efficiently */</comment>
<typedef>typedef <type><struct>struct <name>RewriteMappingFile</name>
<block>{
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RewriteMappingFile</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NOT_USED</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisplayMapping</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hstat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>, <argument><expr><name>tuplecid_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hstat</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u"</literal></expr></argument>,
			 <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
			 <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
			 <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>relnode</name><operator>.</operator><name>relNode</name></name></expr></argument>,
			 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>,
			 <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Apply a single mapping file to tuplecid_data.
 *
 * The mapping file has to have been verified to be a) committed b) for our
 * transaction c) applied in LSN order.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyLogicalMappingFile</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>readBytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LogicalRewriteMappingData</name></type> <name>map</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/mappings/%s"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>new_ent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<comment type="block">/* be careful about padding */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReorderBufferTupleCidKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* read all mappings till the end of the file */</comment>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readBytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>map</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* EOF */</comment>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>readBytes</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": read %d instead of %d bytes"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>readBytes</name></expr></argument>,
							<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalRewriteMappingData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>map</name><operator>.</operator><name>old_node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><operator>.</operator><name>old_tid</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
						<argument><expr><name>HASH_FIND</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* no existing mapping, no need to update */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>relnode</name></name> <operator>=</operator> <name><name>map</name><operator>.</operator><name>new_node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><operator>.</operator><name>new_tid</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
						<argument><expr><name>HASH_ENTER</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Make sure the existing mapping makes sense. We sometime update
			 * old records that did not yet have a cmax (e.g. pg_class' own
			 * entry while rewriting it) during rewrites, so allow that.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>==</operator> <name><name>new_ent</name><operator>-&gt;</operator><name>cmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name>InvalidCommandId</name> <operator>||</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>==</operator> <name><name>new_ent</name><operator>-&gt;</operator><name>cmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* update mapping */</comment>
			<expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>cmin</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>cmax</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_ent</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>combocid</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the TransactionOid 'xid' is in the pre-sorted array 'xip'.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionIdInArray</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xip</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><name>xip</name></expr></argument>, <argument><expr><name>num</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort() comparator for sorting RewriteMappingFiles in LSN order.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_sort_by_lsn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a_p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><name>RewriteMappingFile</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><name>RewriteMappingFile</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b_p</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply any existing logical remapping files if there are any targeted at our
 * transaction for relid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateLogicalMappings</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>mapping_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>mapping_de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>files</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier><modifier>*</modifier></type><name>files_a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dboid</name> <init>= <expr><ternary><condition><expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>mapping_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><literal type="string">"pg_logical/mappings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>mapping_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>mapping_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_logical/mappings"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>f_dboid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>f_relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>f_mapped_xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>f_create_xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>f_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>f_hi</name></decl>,
					<decl><type ref="prev"/><name>f_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Ignore files that aren't ours */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"map-"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>LOGICAL_REWRITE_FORMAT</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>f_dboid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_lo</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>f_mapped_xid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f_create_xid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not parse filename \"%s\""</literal></expr></argument>, <argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>f_lsn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>f_hi</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <name>f_lo</name></expr>;</expr_stmt>

		<comment type="block">/* mapping for another database */</comment>
		<if_stmt><if>if <condition>(<expr><name>f_dboid</name> <operator>!=</operator> <name>dboid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* mapping for another relation */</comment>
		<if_stmt><if>if <condition>(<expr><name>f_relid</name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* did the creating transaction abort? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>f_create_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* not for our transaction */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdInArray</name><argument_list>(<argument><expr><name>f_mapped_xid</name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxcnt</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* ok, relevant, queue for apply */</comment>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <name>f_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name><name>mapping_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>files</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>files</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>mapping_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build array we can easily sort */</comment>
	<expr_stmt><expr><name>files_a</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>file</argument>, <argument>files</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>files_a</name><index>[<expr><name>off</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* sort files so we apply them in LSN order */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>files_a</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RewriteMappingFile</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>file_sort_by_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>off</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RewriteMappingFile</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>files_a</name><index>[<expr><name>off</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"applying mapping: \"%s\" in %u"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>,
			 <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>subxip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ApplyLogicalMappingFile</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup cmin/cmax of a tuple, during logical decoding where we can't rely on
 * combocids.
 */</comment>
<function><type><name>bool</name></type>
<name>ResolveCminCmaxDuringDecoding</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>tuplecid_data</name></decl></parameter>,
							  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							  <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
							  <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReorderBufferTupleCidKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReorderBufferTupleCidEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updated_mapping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* be careful about padding */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsLocal</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * get relfilenode from the buffer, no convenient way to access it other
	 * than that.
	 */</comment>
	<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>relnode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forkno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tuples can only be in the main fork */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forkno</name> <operator>==</operator> <name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blockno</name> <operator>==</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ItemPointerCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>key</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label>
	<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>ReorderBufferTupleCidEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>HASH_FIND</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * failed to find a mapping, check whether the table was rewritten and
	 * apply mapping if so, but only do that once - there can be no new
	 * mappings while we are in here since we have to hold a lock on the
	 * relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>updated_mapping</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateLogicalMappings</name><argument_list>(<argument><expr><name>tuplecid_data</name></expr></argument>, <argument><expr><name><name>htup</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* now check but don't update for a mapping again */</comment>
		<expr_stmt><expr><name>updated_mapping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>cmin</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmin</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmax</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>cmax</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>cmax</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
