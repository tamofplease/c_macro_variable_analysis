<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/storage/smgr/smgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * smgr.c
 *	  public interface routines to storage manager switch.
 *
 *	  All file system operations in POSTGRES dispatch through these
 *	  routines.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/smgr/smgr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>


<comment type="block">/*
 * This struct of function pointers defines the API between smgr.c and
 * any individual storage manager module.  Note that smgr subfunctions are
 * generally expected to report problems via elog(ERROR).  An exception is
 * that smgr_unlink should use elog(WARNING), rather than erroring out,
 * because we normally unlink relations during post-commit/abort cleanup,
 * and so it's too late to raise an error.  Also, various conditions that
 * would normally be errors should be allowed during bootstrap and/or WAL
 * recovery --- see comments in md.c for details.
 */</comment>
<typedef>typedef <type><struct>struct <name>f_smgr</name>
<block>{
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_init</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_shutdown</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_close</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_create</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>bool</name></type>		(<modifier>*</modifier><name>smgr_exists</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_unlink</name>) <parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_extend</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_prefetch</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								  <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_read</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
							  <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_write</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_writeback</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								   <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>BlockNumber</name></type> (<modifier>*</modifier><name>smgr_nblocks</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_truncate</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
								  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_immedsync</name>) <parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_pre_ckpt</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_sync</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>smgr_post_ckpt</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>	<comment type="block">/* may be NULL */</comment>
}</block></struct></type> <name>f_smgr</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>f_smgr</name></type> <name><name>smgrsw</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/* magnetic disk */</comment>
	<expr><block>{<expr><name>mdinit</name></expr>, <expr><name>NULL</name></expr>, <expr><name>mdclose</name></expr>, <expr><name>mdcreate</name></expr>, <expr><name>mdexists</name></expr>, <expr><name>mdunlink</name></expr>, <expr><name>mdextend</name></expr>,
		<expr><name>mdprefetch</name></expr>, <expr><name>mdread</name></expr>, <expr><name>mdwrite</name></expr>, <expr><name>mdwriteback</name></expr>, <expr><name>mdnblocks</name></expr>, <expr><name>mdtruncate</name></expr>,
		<expr><name>mdimmedsync</name></expr>, <expr><name>mdpreckpt</name></expr>, <expr><name>mdsync</name></expr>, <expr><name>mdpostckpt</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>NSmgr</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>smgrsw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Each backend has a hashtable that stores all extant SMgrRelation objects.
 * In addition, "unowned" SMgrRelation objects are chained together in a list.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SMgrRelationHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SMgrRelation</name></type> <name>first_unowned_reln</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_to_unowned_list</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_from_unowned_list</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	smgrinit(), smgrshutdown() -- Initialize or shut down storage
 *								  managers.
 *
 * Note: smgrinit is called during backend startup (normal or standalone
 * case), *not* during postmaster start.  Therefore, any resources created
 * here or destroyed in smgrshutdown are backend-local.
 */</comment>
<function><type><name>void</name></type>
<name>smgrinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_init</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* register the shutdown proc */</comment>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>smgrshutdown</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * on_proc_exit hook for smgr cleanup during backend shutdown
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>smgrshutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_shutdown</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgropen() -- Return an SMgrRelation object, creating it if need be.
 *
 *		This does not attempt to actually open the underlying file.
 */</comment>
<function><type><name>SMgrRelation</name></type>
<name>smgropen</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>rnode</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>brnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SMgrRelationData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>SMgrRelationHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"smgr relation table"</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_unowned_reln</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up or create an entry */</comment>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>brnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backend</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>brnode</name></expr></argument>,
									  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>forknum</name></decl>;</decl_stmt>

		<comment type="block">/* hash_search already filled in the lookup key */</comment>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_targblock</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_fsm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_vm_nblocks</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* we only have md.c at present */</comment>

		<comment type="block">/* mark it not open */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* it has no owner yet */</comment>
		<expr_stmt><expr><call><name>add_to_unowned_list</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>reln</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * smgrsetowner() -- Establish a long-lived reference to an SMgrRelation object
 *
 * There can be only one owner at a time; this is sufficient since currently
 * the only such owners exist in the relcache.
 */</comment>
<function><type><name>void</name></type>
<name>smgrsetowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We don't support "disowning" an SMgrRelation here, use smgrclearowner */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, unhook any old owner.  (Normally there shouldn't be any, but it
	 * seems possible that this can happen during swap_relation_files()
	 * depending on the order of processing.  It's ok to close the old
	 * relcache entry early in that case.)
	 *
	 * If there isn't an old owner, then the reln should be in the unowned
	 * list, and we need to remove it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remove_from_unowned_list</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Now establish the ownership relationship. */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>reln</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * smgrclearowner() -- Remove long-lived reference to an SMgrRelation object
 *					   if one exists
 */</comment>
<function><type><name>void</name></type>
<name>smgrclearowner</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing if the SMgrRelation object is not owned by the owner */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>!=</operator> <name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* unset the owner's reference */</comment>
	<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* unset our reference to the owner */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_to_unowned_list</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_to_unowned_list -- link an SMgrRelation onto the unowned list
 *
 * Check remove_from_unowned_list()'s comments for performance
 * considerations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_to_unowned_list</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* place it at head of the list (to make smgrsetowner cheap) */</comment>
	<expr_stmt><expr><name><name>reln</name><operator>-&gt;</operator><name>next_unowned_reln</name></name> <operator>=</operator> <name>first_unowned_reln</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>first_unowned_reln</name> <operator>=</operator> <name>reln</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * remove_from_unowned_list -- unlink an SMgrRelation from the unowned list
 *
 * If the reln is not present in the list, nothing happens.  Typically this
 * would be caller error, but there seems no reason to throw an error.
 *
 * In the worst case this could be rather slow; but in all the cases that seem
 * likely to be performance-critical, the reln being sought will actually be
 * first in the list.  Furthermore, the number of unowned relns touched in any
 * one transaction shouldn't be all that high typically.  So it doesn't seem
 * worth expending the additional space and management logic needed for a
 * doubly-linked list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_from_unowned_list</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>cur</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>link</name> <operator>=</operator> <operator>&amp;</operator><name>first_unowned_reln</name></expr><operator>,</operator> <expr><name>cur</name> <operator>=</operator> <operator>*</operator><name>link</name></expr>;</init>
		 <condition><expr><name>cur</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>link</name> <operator>=</operator> <operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>next_unowned_reln</name></name></expr><operator>,</operator> <expr><name>cur</name> <operator>=</operator> <operator>*</operator><name>link</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>reln</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>link</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next_unowned_reln</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>next_unowned_reln</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrexists() -- Does the underlying file for a fork exist?
 */</comment>
<function><type><name>bool</name></type>
<name>smgrexists</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_exists</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclose() -- Close and delete an SMgrRelation object.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclose</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>owner</name> <operator>=</operator> <name><name>reln</name><operator>-&gt;</operator><name>smgr_owner</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>remove_from_unowned_list</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name><operator>)</operator></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SMgrRelation hashtable corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unhook the owner pointer, if any.  We do this last since in the remote
	 * possibility of failure above, the SMgrRelation object will still exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>owner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcloseall() -- Close all existing SMgrRelation objects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcloseall</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SMgrRelationHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrclosenode() -- Close SMgrRelation object for given RelFileNode,
 *					   if one exists.
 *
 * This has the same effects as smgrclose(smgropen(rnode)), but it avoids
 * uselessly creating a hashtable entry only to drop it again when no
 * such entry exists already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrclosenode</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if hashtable not set up */</comment>
	<if_stmt><if>if <condition>(<expr><name>SMgrRelationHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reln</name> <operator>=</operator> <operator>(</operator><name>SMgrRelation</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SMgrRelationHash</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rnode</name></expr></argument>,
									  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>reln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrcreate() -- Create a new relation.
 *
 *		Given an already-created (but presumably unused) SMgrRelation,
 *		cause the underlying disk file or other storage for the fork
 *		to be created.
 *
 *		If isRedo is true, it is okay for the underlying file to exist
 *		already because we are in a WAL replay sequence.
 */</comment>
<function><type><name>void</name></type>
<name>smgrcreate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Exit quickly in WAL replay mode if we've already opened the file. If
	 * it's open, it surely must exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isRedo</name> <operator>&amp;&amp;</operator> <name><name>reln</name><operator>-&gt;</operator><name>md_num_open_segs</name><index>[<expr><name>forknum</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We may be using the target table space for the first time in this
	 * database, so create a per-database subdirectory if needed.
	 *
	 * XXX this is a fairly ugly violation of module layering, but this seems
	 * to be the best place to put the check.  Maybe TablespaceCreateDbspace
	 * should be here and not in commands/tablespace.c?  But that would imply
	 * importing a lot of stuff that smgr.c oughtn't know, either.
	 */</comment>
	<expr_stmt><expr><call><name>TablespaceCreateDbspace</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
							<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>,
							<argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_create</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlink() -- Immediately unlink all forks of a relation.
 *
 *		All forks of the relation are removed from the store.  This should
 *		not be used during transactional operations, since it can't be undone.
 *
 *		If isRedo is true, it is okay for the underlying file(s) to be gone
 *		already.
 *
 *		This is equivalent to calling smgrdounlinkfork for each fork, but
 *		it's significantly quicker so should be preferred when possible.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlink</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<comment type="block">/* Close the forks at smgr level */</comment>
	<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the relation.  bufmgr will just
	 * drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodesAllBuffers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rnode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget it immediately, too.
	 * But we can't because we don't know the OID (and in cases involving
	 * relfilenode swaps, it's not always clear which table OID to forget,
	 * anyway).
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for this rel.  We should do this
	 * before starting the actual unlinking, in case we fail partway through
	 * that step.  Note that the sinval message will eventually come back to
	 * this backend, too, and thereby provide a backstop that we closed our
	 * own smgr rel.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>InvalidForkNumber</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkall() -- Immediately unlink all forks of all given relations
 *
 *		All forks of all given relations are removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file(s) to be gone
 *		already.
 *
 *		This is equivalent to calling smgrdounlink for each relation, but it's
 *		significantly quicker so should be preferred when possible.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkall</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>rnodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * create an array which contains all relations to be dropped, and close
	 * each relation's forks at the smgr level while at it
	 */</comment>
	<expr_stmt><expr><name>rnodes</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNodeBackend</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_rnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_which</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rnode</name></expr>;</expr_stmt>

		<comment type="block">/* Close the forks at smgr level */</comment>
		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the relations.  bufmgr will just
	 * drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodesAllBuffers</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget them immediately,
	 * too. But we can't because we don't know the OIDs.
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for these rels.  We should do
	 * this before starting the actual unlinking, in case we fail partway
	 * through that step.  Note that the sinval messages will eventually come
	 * back to this backend, too, and thereby provide a backstop that we
	 * closed our own smgr rel.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrels</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>rels</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>smgr_which</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>forknum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>forknum</name> <operator>&lt;=</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>forknum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name><name>rnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrdounlinkfork() -- Immediately unlink one fork of a relation.
 *
 *		The specified fork of the relation is removed from the store.  This
 *		should not be used during transactional operations, since it can't be
 *		undone.
 *
 *		If isRedo is true, it is okay for the underlying file to be gone
 *		already.
 */</comment>
<function><type><name>void</name></type>
<name>smgrdounlinkfork</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isRedo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Close the fork at smgr level */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_close</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get rid of any remaining buffers for the fork.  bufmgr will just drop
	 * them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It'd be nice to tell the stats collector to forget it immediately, too.
	 * But we can't because we don't know the OID (and in cases involving
	 * relfilenode swaps, it's not always clear which table OID to forget,
	 * anyway).
	 */</comment>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any
	 * dangling smgr references they may have for this rel.  We should do this
	 * before starting the actual unlinking, in case we fail partway through
	 * that step.  Note that the sinval message will eventually come back to
	 * this backend, too, and thereby provide a backstop that we closed our
	 * own smgr rel.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the physical file(s).
	 *
	 * Note: smgr_unlink must treat deletion failure as a WARNING, not an
	 * ERROR, because we've already decided to commit or abort the current
	 * xact.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><call><name>smgr_unlink</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>isRedo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrextend() -- Add a new block to a file.
 *
 *		The semantics are nearly the same as smgrwrite(): write at the
 *		specified position.  However, this is to be used for the case of
 *		extending a relation (i.e., blocknum is at or beyond the current
 *		EOF).  Note that we assume writing a block beyond current EOF
 *		causes intervening file space to become filled with zeroes.
 */</comment>
<function><type><name>void</name></type>
<name>smgrextend</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_extend</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										 <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrprefetch() -- Initiate asynchronous read of the specified block of a relation.
 */</comment>
<function><type><name>void</name></type>
<name>smgrprefetch</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_prefetch</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrread() -- read a particular block from a relation into the supplied
 *				  buffer.
 *
 *		This routine is called from the buffer manager in order to
 *		instantiate pages in the shared buffer cache.  All storage managers
 *		return pages in the format that POSTGRES expects.
 */</comment>
<function><type><name>void</name></type>
<name>smgrread</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_read</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrwrite() -- Write the supplied buffer out.
 *
 *		This is to be used only for updating already-existing blocks of a
 *		relation (ie, those before the current EOF).  To extend a relation,
 *		use smgrextend().
 *
 *		This is not a synchronous write -- the block is not necessarily
 *		on disk at return, only dumped out to the kernel.  However,
 *		provisions will be made to fsync the write before the next checkpoint.
 *
 *		skipFsync indicates that the caller will make other provisions to
 *		fsync the relation, so we needn't bother.  Temporary relations also
 *		do not require fsync.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipFsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_write</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
										<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>skipFsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	smgrwriteback() -- Trigger kernel writeback for the supplied range of
 *					   blocks.
 */</comment>
<function><type><name>void</name></type>
<name>smgrwriteback</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blocknum</name></decl></parameter>,
			  <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_writeback</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>,
											<argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrnblocks() -- Calculate the number of blocks in the
 *					 supplied relation.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>smgrnblocks</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_nblocks</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrtruncate() -- Truncate supplied relation to the specified number
 *					  of blocks
 *
 * The truncation is done immediately, so this can't be rolled back.
 */</comment>
<function><type><name>void</name></type>
<name>smgrtruncate</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get rid of any buffers for the about-to-be-deleted blocks. bufmgr will
	 * just drop them without bothering to write the contents.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelFileNodeBuffers</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send a shared-inval message to force other backends to close any smgr
	 * references they may have for this rel.  This is useful because they
	 * might have open file pointers to segments that got removed, and/or
	 * smgr_targblock variables pointing past the new rel end.  (The inval
	 * message will come back to our backend, too, causing a
	 * probably-unnecessary local smgr flush.  But we don't expect that this
	 * is a performance-critical path.)  As in the unlink code, we want to be
	 * sure the message is sent before we start changing things on-disk.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateSmgr</name><argument_list>(<argument><expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_rnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the truncation.
	 */</comment>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_truncate</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>, <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrimmedsync() -- Force the specified relation to stable storage.
 *
 *		Synchronously force all previous writes to the specified relation
 *		down to disk.
 *
 *		This is useful for building completely new relations (eg, new
 *		indexes).  Instead of incrementally WAL-logging the index build
 *		steps, we can just write completed index pages to disk with smgrwrite
 *		or smgrextend, and then fsync the completed index file before
 *		committing the transaction.  (This is sufficient for purposes of
 *		crash recovery, since it effectively duplicates forcing a checkpoint
 *		for the completed index.  But it is *not* sufficient if one wishes
 *		to use the WAL log for PITR or replication purposes: in that case
 *		we have to make WAL entries as well.)
 *
 *		The preceding writes should specify skipFsync = true to avoid
 *		duplicative fsyncs.
 *
 *		Note that you need to do FlushRelationBuffers() first if there is
 *		any possibility that there are dirty buffers for the relation;
 *		otherwise the sync is not very meaningful.
 */</comment>
<function><type><name>void</name></type>
<name>smgrimmedsync</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>reln</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name><name>reln</name><operator>-&gt;</operator><name>smgr_which</name></name></expr>]</index></name><operator>.</operator><call><name>smgr_immedsync</name><argument_list>(<argument><expr><name>reln</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	smgrpreckpt() -- Prepare for checkpoint.
 */</comment>
<function><type><name>void</name></type>
<name>smgrpreckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_pre_ckpt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_pre_ckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrsync() -- Sync files to disk during checkpoint.
 */</comment>
<function><type><name>void</name></type>
<name>smgrsync</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_sync</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_sync</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	smgrpostckpt() -- Post-checkpoint cleanup.
 */</comment>
<function><type><name>void</name></type>
<name>smgrpostckpt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSmgr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>smgr_post_ckpt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>smgrsw</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>smgr_post_ckpt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_SMgr
 *
 * This routine is called during transaction commit or abort (it doesn't
 * particularly care which).  All transient SMgrRelation objects are closed.
 *
 * We do this as a compromise between wanting transient SMgrRelations to
 * live awhile (to amortize the costs of blind writes of multiple blocks)
 * and needing them to not live forever (since we're probably holding open
 * a kernel file descriptor for the underlying file, and we need to ensure
 * that gets closed reasonably soon if the file gets deleted).
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_SMgr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Zap all unowned SMgrRelations.  We rely on smgrclose() to remove each
	 * one from the list.
	 */</comment>
	<while>while <condition>(<expr><name>first_unowned_reln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>first_unowned_reln</name><operator>-&gt;</operator><name>smgr_owner</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>first_unowned_reln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
