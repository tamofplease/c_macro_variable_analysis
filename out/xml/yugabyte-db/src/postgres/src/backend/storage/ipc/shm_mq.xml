<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/storage/ipc/shm_mq.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shm_mq.c
 *	  single-reader, single-writer shared memory message queue
 *
 * Both the sender and the receiver must have a PGPROC; their respective
 * process latches are used for synchronization.  Only the sender may send,
 * and only the receiver may receive.  This is intended to allow a user
 * backend to communicate with worker backends that it has registered.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/include/storage/shm_mq.h
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_mq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * This structure represents the actual queue, stored in shared memory.
 *
 * Some notes on synchronization:
 *
 * mq_receiver and mq_bytes_read can only be changed by the receiver; and
 * mq_sender and mq_bytes_written can only be changed by the sender.
 * mq_receiver and mq_sender are protected by mq_mutex, although, importantly,
 * they cannot change once set, and thus may be read without a lock once this
 * is known to be the case.
 *
 * mq_bytes_read and mq_bytes_written are not protected by the mutex.  Instead,
 * they are written atomically using 8 byte loads and stores.  Memory barriers
 * must be carefully used to synchronize reads and writes of these values with
 * reads and writes of the actual data in mq_ring.
 *
 * mq_detached needs no locking.  It can be set by either the sender or the
 * receiver, but only ever from false to true, so redundant writes don't
 * matter.  It is important that if we set mq_detached and then set the
 * counterparty's latch, the counterparty must be certain to see the change
 * after waking up.  Since SetLatch begins with a memory barrier and ResetLatch
 * ends with one, this should be OK.
 *
 * mq_ring_size and mq_ring_offset never change after initialization, and
 * can therefore be read without the lock.
 *
 * Importantly, mq_ring can be safely read and written without a lock.
 * At any given time, the difference between mq_bytes_read and
 * mq_bytes_written defines the number of bytes within mq_ring that contain
 * unread data, and mq_bytes_read defines the position where those bytes
 * begin.  The sender can increase the number of unread bytes at any time,
 * but only the receiver can give license to overwrite those bytes, by
 * incrementing mq_bytes_read.  Therefore, it's safe for the receiver to read
 * the unread bytes it knows to be present without the lock.  Conversely,
 * the sender can write to the unused portion of the ring buffer without
 * the lock, because nobody else can be reading or writing those bytes.  The
 * receiver could be making more bytes unused by incrementing mq_bytes_read,
 * but that's OK.  Note that it would be unsafe for the receiver to read any
 * data it's already marked as read, or to write any data; and it would be
 * unsafe for the sender to reread any data after incrementing
 * mq_bytes_written, but fortunately there's no need for any of that.
 */</comment>
<struct>struct <name>shm_mq</name>
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mq_mutex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>mq_receiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>mq_sender</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>mq_bytes_read</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>mq_bytes_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mq_ring_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mq_detached</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>mq_ring_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>mq_ring</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * This structure is a backend-private handle for access to a queue.
 *
 * mqh_queue is a pointer to the queue we've attached, and mqh_segment is
 * an optional pointer to the dynamic shared memory segment that contains it.
 * (If mqh_segment is provided, we register an on_dsm_detach callback to
 * make sure we detach from the queue before detaching from DSM.)
 *
 * If this queue is intended to connect the current process with a background
 * worker that started it, the user can pass a pointer to the worker handle
 * to shm_mq_attach(), and we'll store it in mqh_handle.  The point of this
 * is to allow us to begin sending to or receiving from that queue before the
 * process we'll be communicating with has even been started.  If it fails
 * to start, the handle will allow us to notice that and fail cleanly, rather
 * than waiting forever; see shm_mq_wait_internal.  This is mostly useful in
 * simple cases - e.g. where there are just 2 processes communicating; in
 * more complex scenarios, every process may not have a BackgroundWorkerHandle
 * available, or may need to watch for the failure of more than one other
 * process at a time.
 *
 * When a message exists as a contiguous chunk of bytes in the queue - that is,
 * it is smaller than the size of the ring buffer and does not wrap around
 * the end - we return the message to the caller as a pointer into the buffer.
 * For messages that are larger or happen to wrap, we reassemble the message
 * locally by copying the chunks into a backend-local buffer.  mqh_buffer is
 * the buffer, and mqh_buflen is the number of bytes allocated for it.
 *
 * mqh_partial_bytes, mqh_expected_bytes, and mqh_length_word_complete
 * are used to track the state of non-blocking operations.  When the caller
 * attempts a non-blocking operation that returns SHM_MQ_WOULD_BLOCK, they
 * are expected to retry the call at a later time with the same argument;
 * we need to retain enough state to pick up where we left off.
 * mqh_length_word_complete tracks whether we are done sending or receiving
 * (whichever we're doing) the entire length word.  mqh_partial_bytes tracks
 * the number of bytes read or written for either the length word or the
 * message itself, and mqh_expected_bytes - which is used only for reads -
 * tracks the expected total size of the payload.
 *
 * mqh_counterparty_attached tracks whether we know the counterparty to have
 * attached to the queue at some previous point.  This lets us avoid some
 * mutex acquisitions.
 *
 * mqh_context is the memory context in effect at the time we attached to
 * the shm_mq.  The shm_mq_handle itself is allocated in this context, and
 * we make sure any other allocations we do happen in this context as well,
 * to avoid nasty surprises.
 */</comment>
<struct>struct <name>shm_mq_handle</name>
<block>{
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mqh_queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>mqh_segment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>mqh_handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>mqh_buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mqh_buflen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mqh_consume_pending</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mqh_partial_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>mqh_expected_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mqh_length_word_complete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mqh_counterparty_attached</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mqh_context</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shm_mq_detach_internal</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_result</name></type> <name>shm_mq_send_bytes</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>bytes_written</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>shm_mq_result</name></type> <name>shm_mq_receive_bytes</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>,
					 <parameter><decl><type><name>Size</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>nbytesp</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>datap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>shm_mq_counterparty_gone</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>,
						 <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>shm_mq_wait_internal</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>,
					 <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shm_mq_inc_bytes_read</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shm_mq_inc_bytes_written</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shm_mq_detach_callback</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Minimum queue size is enough for header and at least one chunk of data. */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>Size</name></type>	<name>shm_mq_minimum_size</name> <init>=
<expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>shm_mq</name></expr></argument>, <argument><expr><name>mq_ring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <name>MAXIMUM_ALIGNOF</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MQH_INITIAL_BUFSIZE</name></cpp:macro>				<cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/*
 * Initialize a new shared message queue.
 */</comment>
<function><type><name>shm_mq</name> <modifier>*</modifier></type>
<name>shm_mq_create</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>address</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name>address</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_offset</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>shm_mq</name></expr></argument>, <argument><expr><name>mq_ring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If the size isn't MAXALIGN'd, just discard the odd bytes. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN_DOWN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Queue size must be large enough to hold some data. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <name>data_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize queue header. */</comment>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_read</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_size</name></name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>data_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_offset</name></name> <operator>=</operator> <name>data_offset</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>shm_mq</name></expr></argument>, <argument><expr><name>mq_ring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mq</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the identity of the process that will receive from a shared message
 * queue.
 */</comment>
<function><type><name>void</name></type>
<name>shm_mq_set_receiver</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>sender</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sender</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sender</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the identity of the process that will send to a shared message queue.
 */</comment>
<function><type><name>void</name></type>
<name>shm_mq_set_sender</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>receiver</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>receiver</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>receiver</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the configured receiver.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>shm_mq_get_receiver</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>receiver</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>receiver</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the configured sender.
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>shm_mq_get_sender</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>sender</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sender</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sender</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to a shared message queue so we can send or receive messages.
 *
 * The memory context in effect at the time this function is called should
 * be one which will last for at least as long as the message queue itself.
 * We'll allocate the handle in that context, and future allocations that
 * are needed to buffer incoming data will happen in that context as well.
 *
 * If seg != NULL, the queue will be automatically detached when that dynamic
 * shared memory segment is detached.
 *
 * If handle != NULL, the queue can be read or written even before the
 * other process has attached.  We'll wait for it to do so if needed.  The
 * handle must be for a background worker initialized with bgw_notify_pid
 * equal to our PID.
 *
 * shm_mq_detach() should be called when done.  This will free the
 * shm_mq_handle and mark the queue itself as detached, so that our
 * counterpart won't get stuck waiting for us to fill or drain the queue
 * after we've already lost interest.
 */</comment>
<function><type><name>shm_mq_handle</name> <modifier>*</modifier></type>
<name>shm_mq_attach</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shm_mq_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>==</operator> <name>MyProc</name> <operator>||</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name> <operator>=</operator> <name>mq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_segment</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_expected_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_context</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>shm_mq_detach_callback</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mqh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Associate a BackgroundWorkerHandle with a shm_mq_handle just as if it had
 * been passed to shm_mq_attach.
 */</comment>
<function><type><name>void</name></type>
<name>shm_mq_set_handle</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a message into a shared message queue.
 */</comment>
<function><type><name>shm_mq_result</name></type>
<name>shm_mq_send</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_iovec</name></type> <name>iov</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iov</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iov</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>

	<return>return <expr><call><name>shm_mq_sendv</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iov</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a message into a shared message queue, gathered from multiple
 * addresses.
 *
 * When nowait = false, we'll wait on our process latch when the ring buffer
 * fills up, and then continue writing once the receiver has drained some data.
 * The process latch is reset after each wait.
 *
 * When nowait = true, we do not manipulate the state of the process latch;
 * instead, if the buffer becomes full, we return SHM_MQ_WOULD_BLOCK.  In
 * this case, the caller should call this function again, with the same
 * arguments, each time the process latch is set.  (Once begun, the sending
 * of a message cannot be aborted except by detaching from the queue; changing
 * the length or payload will corrupt the queue.)
 */</comment>
<function><type><name>shm_mq_result</name></type>
<name>shm_mq_sendv</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>shm_mq_iovec</name> <modifier>*</modifier></type><name>iov</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iovcnt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>receiver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>bytes_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which_iov</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute total size of write. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iovcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <name><name>iov</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Try to write, or finish writing, the length word into the buffer. */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_send_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr></argument>,
								<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nbytes</name><operator>)</operator> <operator>+</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr></argument>,
								<argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reset state in case caller tries to send another message. */</comment>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+=</operator> <name>bytes_written</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Length word can't be split unless bigger than required alignment. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>||</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>MAXIMUM_ALIGNOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Write the actual data bytes into the buffer. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&lt;=</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>chunksize</name></decl>;</decl_stmt>

		<comment type="block">/* Figure out which bytes need to be sent next. */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>offset</name> <operator>-=</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>which_iov</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>which_iov</name> <operator>&gt;=</operator> <name>iovcnt</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We want to avoid copying the data if at all possible, but every
		 * chunk of bytes we write into the queue has to be MAXALIGN'd, except
		 * the last.  Thus, if a chunk other than the last one ends on a
		 * non-MAXALIGN'd boundary, we have to combine the tail end of its
		 * data with data from one or more following chunks until we either
		 * reach the last chunk or accumulate a number of bytes which is
		 * MAXALIGN'd.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>which_iov</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>iovcnt</name> <operator>&amp;&amp;</operator>
			<name>offset</name> <operator>+</operator> <name>MAXIMUM_ALIGNOF</name> <operator>&gt;</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpbuf</name><index>[<expr><name>MAXIMUM_ALIGNOF</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>tmpbuf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>MAXIMUM_ALIGNOF</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>offset</name> <operator>-=</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>which_iov</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>which_iov</name> <operator>&gt;=</operator> <name>iovcnt</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_send_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Reset state in case caller tries to send another message. */</comment>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return <expr><name>res</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+=</operator> <name>bytes_written</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If this is the last chunk, we can write all the data, even if it
		 * isn't a multiple of MAXIMUM_ALIGNOF.  Otherwise, we need to
		 * MAXALIGN_DOWN the write size.
		 */</comment>
		<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>which_iov</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>iovcnt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <call><name>MAXALIGN_DOWN</name><argument_list>(<argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_send_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><name>chunksize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iov</name><index>[<expr><name>which_iov</name></expr>]</index></name><operator>.</operator><name><name>data</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>,
								<argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SHM_MQ_DETACHED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reset state in case caller tries to send another message. */</comment>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>res</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+=</operator> <name>bytes_written</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>bytes_written</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition>;</do>

	<comment type="block">/* Reset for next message. */</comment>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* If queue has been detached, let caller know. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the counterparty is known to have attached, we can read mq_receiver
	 * without acquiring the spinlock and assume it isn't NULL.  Otherwise,
	 * more caution is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>receiver</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>receiver</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>receiver</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Notify receiver of the newly-written data, and return. */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>receiver</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive a message from a shared message queue.
 *
 * We set *nbytes to the message length and *data to point to the message
 * payload.  If the entire message exists in the queue as a single,
 * contiguous chunk, *data will point directly into shared memory; otherwise,
 * it will point to a temporary buffer.  This mostly avoids data copying in
 * the hoped-for case where messages are short compared to the buffer size,
 * while still allowing longer messages.  In either case, the return value
 * remains valid until the next receive operation is performed on the queue.
 *
 * When nowait = false, we'll wait on our process latch when the ring buffer
 * is empty and we have not yet received a full message.  The sender will
 * set our process latch after more data has been written, and we'll resume
 * processing.  Each call will therefore return a complete message
 * (unless the sender detaches the queue).
 *
 * When nowait = true, we do not manipulate the state of the process latch;
 * instead, whenever the buffer is empty and we need to read from it, we
 * return SHM_MQ_WOULD_BLOCK.  In this case, the caller should call this
 * function again after the process latch has been set.
 */</comment>
<function><type><name>shm_mq_result</name></type>
<name>shm_mq_receive</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>nbytesp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>datap</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>rb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>rawdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can't receive data until the sender has attached. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nowait</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>counterparty_gone</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We shouldn't return at this point at all unless the sender
			 * hasn't attached yet.  However, the correct return value depends
			 * on whether the sender is still attached.  If we first test
			 * whether the sender has ever attached and then test whether the
			 * sender has detached, there's a race condition: a sender that
			 * attaches and detaches very quickly might fool us into thinking
			 * the sender never attached at all.  So, test whether our
			 * counterparty is definitively gone first, and only afterwards
			 * check whether the sender ever attached in the first place.
			 */</comment>
			<expr_stmt><expr><name>counterparty_gone</name> <operator>=</operator> <call><name>shm_mq_counterparty_gone</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>counterparty_gone</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>SHM_MQ_WOULD_BLOCK</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>shm_mq_wait_internal</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name></expr></argument>)</argument_list></call>
				 <operator>&amp;&amp;</operator> <call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we've consumed an amount of data greater than 1/4th of the ring
	 * size, mark it consumed in shared memory.  We try to avoid doing this
	 * unnecessarily when only a small amount of data has been consumed,
	 * because SetLatch() is fairly expensive and we don't want to do it too
	 * often.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>&gt;</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_ring_size</name></name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>shm_mq_inc_bytes_read</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Try to read, or finish reading, the length word from the buffer. */</comment>
	<while>while <condition>(<expr><operator>!</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try to receive the message length word. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr></argument>,
								   <argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rawdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Hopefully, we'll receive the entire message length word at once.
		 * But if sizeof(Size) &gt; MAXIMUM_ALIGNOF, then it might be split over
		 * multiple reads.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rb</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>needed</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>Size</name> <operator>*</operator><operator>)</operator> <name>rawdata</name></expr>;</expr_stmt>

			<comment type="block">/* If we've already got the whole message, we're done. */</comment>
			<expr_stmt><expr><name>needed</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rb</name> <operator>&gt;=</operator> <name>needed</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>+=</operator> <name>needed</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>nbytesp</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>datap</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rawdata</name><operator>)</operator> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We don't have the whole message, but we at least have the whole
			 * length word.
			 */</comment>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_expected_bytes</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rb</name> <operator>-=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>lengthbytes</name></decl>;</decl_stmt>

			<comment type="block">/* Can't be split unless bigger than required alignment. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>MAXIMUM_ALIGNOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Message word is split; need buffer to reassemble. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_context</name></name></expr></argument>,
													 <argument><expr><name>MQH_INITIAL_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>=</operator> <name>MQH_INITIAL_BUFSIZE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy partial length word; remember to consume it. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+</operator> <name>rb</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lengthbytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>lengthbytes</name> <operator>=</operator> <name>rb</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name><index>[<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>rawdata</name></expr></argument>,
				   <argument><expr><name>lengthbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+=</operator> <name>lengthbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>lengthbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rb</name> <operator>-=</operator> <name>lengthbytes</name></expr>;</expr_stmt>

			<comment type="block">/* If we now have the whole word, we're ready to read payload. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_expected_bytes</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>Size</name> <operator>*</operator><operator>)</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_expected_bytes</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to obtain the whole message in a single chunk.  If this works,
		 * we need not copy the data and can return a pointer directly into
		 * shared memory.
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rawdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rb</name> <operator>&gt;=</operator> <name>nbytes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>nbytesp</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>datap</name> <operator>=</operator> <name>rawdata</name></expr>;</expr_stmt>
			<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The message has wrapped the buffer.  We'll need to copy it in order
		 * to return it to the client in one chunk.  First, make sure we have
		 * a large enough buffer available.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>newbuflen</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name></expr></argument>, <argument><expr><name>MQH_INITIAL_BUFSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>newbuflen</name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newbuflen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_context</name></name></expr></argument>, <argument><expr><name>newbuflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buflen</name></name> <operator>=</operator> <name>newbuflen</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Loop until we've copied the entire message. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>still_needed</name></decl>;</decl_stmt>

		<comment type="block">/* Copy as much as we can. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+</operator> <name>rb</name> <operator>&lt;=</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name><index>[<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>rawdata</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>+=</operator> <name>rb</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update count of bytes that can be consumed, accounting for
		 * alignment padding.  Note that this will never actually insert any
		 * padding except at the end of a message, because the buffer size is
		 * a multiple of MAXIMUM_ALIGNOF, and each read and write is as well.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>==</operator> <name>nbytes</name> <operator>||</operator> <name>rb</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If we got all the data, exit the loop. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>&gt;=</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Wait for some more data. */</comment>
		<expr_stmt><expr><name>still_needed</name> <operator>=</operator> <name>nbytes</name> <operator>-</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive_bytes</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>, <argument><expr><name>still_needed</name></expr></argument>, <argument><expr><name>nowait</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rawdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rb</name> <operator>&gt;</operator> <name>still_needed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rb</name> <operator>=</operator> <name>still_needed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Return the complete message, and reset for next message. */</comment>
	<expr_stmt><expr><operator>*</operator><name>nbytesp</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>datap</name> <operator>=</operator> <name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_length_word_complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_partial_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for the other process that's supposed to use this queue to attach
 * to it.
 *
 * The return value is SHM_MQ_DETACHED if the worker has already detached or
 * if it dies; it is SHM_MQ_SUCCESS if we detect that the worker has attached.
 * Note that we will only be able to detect that the worker has died before
 * attaching if a background worker handle was passed to shm_mq_attach().
 */</comment>
<function><type><name>shm_mq_result</name></type>
<name>shm_mq_wait_for_attach</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>victim</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>victim</name> <operator>=</operator> <operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>victim</name> <operator>=</operator> <operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>shm_mq_wait_internal</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>victim</name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detach from a shared message queue, and destroy the shm_mq_handle.
 */</comment>
<function><type><name>void</name></type>
<name>shm_mq_detach</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Notify counterparty that we're outta here. */</comment>
	<expr_stmt><expr><call><name>shm_mq_detach_internal</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel on_dsm_detach callback, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_segment</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cancel_on_dsm_detach</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_segment</name></name></expr></argument>,
							 <argument><expr><name>shm_mq_detach_callback</name></expr></argument>,
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release local memory associated with handle. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Notify counterparty that we're detaching from shared message queue.
 *
 * The purpose of this function is to make sure that the process
 * with which we're communicating doesn't block forever waiting for us to
 * fill or drain the queue once we've lost interest.  When the sender
 * detaches, the receiver can read any messages remaining in the queue;
 * further reads will return SHM_MQ_DETACHED.  If the receiver detaches,
 * further attempts to send messages will likewise return SHM_MQ_DETACHED.
 *
 * This is separated out from shm_mq_detach() because if the on_dsm_detach
 * callback fires, we only want to do this much.  We do not try to touch
 * the local shm_mq_handle, as it may have been pfree'd already.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shm_mq_detach_internal</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>victim</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name> <operator>==</operator> <name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>victim</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name> <operator>==</operator> <name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>victim</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>victim</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>victim</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the shm_mq from handle.
 */</comment>
<function><type><name>shm_mq</name> <modifier>*</modifier></type>
<name>shm_mq_get_queue</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write bytes into a shared message queue.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_result</name></type>
<name>shm_mq_send_bytes</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>bytes_written</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>ringsize</name> <init>= <expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>available</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>sent</name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>rb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>wb</name></decl>;</decl_stmt>

		<comment type="block">/* Compute number of ring buffer bytes used and available. */</comment>
		<expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wb</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>wb</name> <operator>&gt;=</operator> <name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>used</name> <operator>=</operator> <name>wb</name> <operator>-</operator> <name>rb</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>used</name> <operator>&lt;=</operator> <name>ringsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>available</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>ringsize</name> <operator>-</operator> <name>used</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>-</operator> <name>sent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Bail out if the queue has been detached.  Note that we would be in
		 * trouble if the compiler decided to cache the value of
		 * mq-&gt;mq_detached in a register or on the stack across loop
		 * iterations.  It probably shouldn't do that anyway since we'll
		 * always return, call an external function that performs a system
		 * call, or reach a memory barrier at some point later in the loop,
		 * but just to be sure, insert a compiler barrier here.
		 */</comment>
		<expr_stmt><expr><call><name>pg_compiler_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
			<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>available</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The queue is full, so if the receiver isn't yet known to be
			 * attached, we must wait for that to happen.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nowait</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>shm_mq_counterparty_gone</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
					<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
					<return>return <expr><name>SHM_MQ_WOULD_BLOCK</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>shm_mq_wait_internal</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name></name></expr></argument>,
										   <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_handle</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
				<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * The receiver may have read some data after attaching, so we
			 * must not wait without rechecking the queue state.
			 */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>available</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since mq-&gt;mqh_counterparty_attached is known to be true at this
			 * point, mq_receiver has been set, and it can't change once set.
			 * Therefore, we can read it without acquiring the spinlock.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_counterparty_attached</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_receiver</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Skip manipulation of our latch if nowait = true. */</comment>
			<if_stmt><if>if <condition>(<expr><name>nowait</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
				<return>return <expr><name>SHM_MQ_WOULD_BLOCK</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Wait for our latch to be set.  It might already be set for some
			 * unrelated reason, but that'll just result in one extra trip
			 * through the loop.  It's worth it to avoid resetting the latch
			 * at top of loop, because setting an already-set latch is much
			 * cheaper than setting one that has been reset.
			 */</comment>
			<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_MQ_SEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Reset the latch so we don't spin. */</comment>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* An interrupt may have occurred while we were waiting. */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>sendnow</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>wb</name> <operator>%</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>ringsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendnow</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>available</name></expr></argument>, <argument><expr><name>ringsize</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Write as much data as we can via a single memcpy(). Make sure
			 * these writes happen after the read of mq_bytes_read, above.
			 * This barrier pairs with the one in shm_mq_inc_bytes_read.
			 * (Since we're separating the read of mq_bytes_read from a
			 * subsequent write to mq_ring, we need a full barrier here.)
			 */</comment>
			<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_ring</name><index>[<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_offset</name></name> <operator>+</operator> <name>offset</name></expr>]</index></name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name> <operator>+</operator> <name>sent</name></expr></argument>, <argument><expr><name>sendnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sent</name> <operator>+=</operator> <name>sendnow</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update count of bytes written, with alignment padding.  Note
			 * that this will never actually insert any padding except at the
			 * end of a run of bytes, because the buffer size is a multiple of
			 * MAXIMUM_ALIGNOF, and each read is as well.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sent</name> <operator>==</operator> <name>nbytes</name> <operator>||</operator> <name>sendnow</name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>sendnow</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_inc_bytes_written</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>sendnow</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * For efficiency, we don't set the reader's latch here.  We'll do
			 * that only when the buffer fills up or after writing an entire
			 * message.
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>bytes_written</name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>
	<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until at least *nbytesp bytes are available to be read from the
 * shared message queue, or until the buffer wraps around.  If the queue is
 * detached, returns SHM_MQ_DETACHED.  If nowait is specified and a wait
 * would be required, returns SHM_MQ_WOULD_BLOCK.  Otherwise, *datap is set
 * to the location at which data bytes can be read, *nbytesp is set to the
 * number of bytes which can be read at that address, and the return value
 * is SHM_MQ_SUCCESS.
 */</comment>
<function><type><specifier>static</specifier> <name>shm_mq_result</name></type>
<name>shm_mq_receive_bytes</name><parameter_list>(<parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nowait</name></decl></parameter>,
					 <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>nbytesp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>datap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_queue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>ringsize</name> <init>= <expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>used</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>written</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>read</name></decl>;</decl_stmt>

		<comment type="block">/* Get bytes written, so we can compute what's available to read. */</comment>
		<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get bytes read.  Include bytes we could consume but have not yet
		 * consumed.
		 */</comment>
		<expr_stmt><expr><name>read</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_read</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
			<name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>used</name> <operator>=</operator> <name>written</name> <operator>-</operator> <name>read</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>used</name> <operator>&lt;=</operator> <name>ringsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>read</name> <operator>%</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>ringsize</name></expr>;</expr_stmt>

		<comment type="block">/* If we have enough data or buffer has wrapped, we're done. */</comment>
		<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&gt;=</operator> <name>bytes_needed</name> <operator>||</operator> <name>offset</name> <operator>+</operator> <name>used</name> <operator>&gt;=</operator> <name>ringsize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nbytesp</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>used</name></expr></argument>, <argument><expr><name>ringsize</name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>datap</name> <operator>=</operator> <operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_ring</name><index>[<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_ring_offset</name></name> <operator>+</operator> <name>offset</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Separate the read of mq_bytes_written, above, from caller's
			 * attempt to read the data itself.  Pairs with the barrier in
			 * shm_mq_inc_bytes_written.
			 */</comment>
			<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SHM_MQ_SUCCESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Fall out before waiting if the queue has been detached.
		 *
		 * Note that we don't check for this until *after* considering whether
		 * the data already available is enough, since the receiver can finish
		 * receiving a message stored in the buffer even after the sender has
		 * detached.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the writer advanced mq_bytes_written and then set
			 * mq_detached, we might not have read the final value of
			 * mq_bytes_written above.  Insert a read barrier and then check
			 * again if mq_bytes_written has advanced.
			 */</comment>
			<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<return>return <expr><name>SHM_MQ_DETACHED</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We didn't get enough data to satisfy the request, so mark any data
		 * previously-consumed as read to make more buffer space.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>shm_mq_inc_bytes_read</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mqh</name><operator>-&gt;</operator><name>mqh_consume_pending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Skip manipulation of our latch if nowait = true. */</comment>
		<if_stmt><if>if <condition>(<expr><name>nowait</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHM_MQ_WOULD_BLOCK</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Wait for our latch to be set.  It might already be set for some
		 * unrelated reason, but that'll just result in one extra trip through
		 * the loop.  It's worth it to avoid resetting the latch at top of
		 * loop, because setting an already-set latch is much cheaper than
		 * setting one that has been reset.
		 */</comment>
		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_MQ_RECEIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset the latch so we don't spin. */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* An interrupt may have occurred while we were waiting. */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether a counterparty who may not even be alive yet is definitely gone.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shm_mq_counterparty_gone</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<comment type="block">/* If the queue has been detached, counterparty is definitely gone. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If there's a handle, check worker status. */</comment>
	<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>

		<comment type="block">/* Check for unexpected worker death. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_STARTED</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>BGWH_NOT_YET_STARTED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Mark it detached, just to make it official. */</comment>
			<expr_stmt><expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Counterparty is not definitively gone. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is used when a process is waiting for its counterpart to attach to the
 * queue.  We exit when the other process attaches as expected, or, if
 * handle != NULL, when the referenced background process or the postmaster
 * dies.  Note that if handle == NULL, and the process fails to attach, we'll
 * potentially get stuck here forever waiting for a process that may never
 * start.  We do check for interrupts, though.
 *
 * ptr is a pointer to the memory address that we're expecting to become
 * non-NULL when our counterpart attaches to the queue.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shm_mq_wait_internal</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

		<comment type="block">/* Acquire the lock just long enough to check the pointer. */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fail if detached; else succeed if initialized. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mq</name><operator>-&gt;</operator><name>mq_detached</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check for unexpected worker death. */</comment>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_STARTED</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>!=</operator> <name>BGWH_NOT_YET_STARTED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Wait to be signalled. */</comment>
		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset the latch so we don't spin. */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* An interrupt may have occurred while we were waiting. */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Increment the number of bytes read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shm_mq_inc_bytes_read</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>sender</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Separate prior reads of mq_ring from the increment of mq_bytes_read
	 * which follows.  This pairs with the full barrier in
	 * shm_mq_send_bytes(). We only need a read barrier here because the
	 * increment of mq_bytes_read is actually a read followed by a dependent
	 * write.
	 */</comment>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There's no need to use pg_atomic_fetch_add_u64 here, because nobody
	 * else can be changing this value.  This method should be cheaper.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_read</name></name></expr></argument>,
						<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_read</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We shouldn't have any bytes to read without a sender, so we can read
	 * mq_sender here without a lock.  Once it's initialized, it can't change.
	 */</comment>
	<expr_stmt><expr><name>sender</name> <operator>=</operator> <name><name>mq</name><operator>-&gt;</operator><name>mq_sender</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sender</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Increment the number of bytes written.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shm_mq_inc_bytes_written</name><parameter_list>(<parameter><decl><type><name>shm_mq</name> <modifier>*</modifier></type><name>mq</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Separate prior reads of mq_ring from the write of mq_bytes_written
	 * which we're about to do.  Pairs with the read barrier found in
	 * shm_mq_get_receive_bytes.
	 */</comment>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There's no need to use pg_atomic_fetch_add_u64 here, because nobody
	 * else can be changing this value.  This method avoids taking the bus
	 * lock unnecessarily.
	 */</comment>
	<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>,
						<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mq</name><operator>-&gt;</operator><name>mq_bytes_written</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Shim for on_dsm_callback. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shm_mq_detach_callback</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><operator>(</operator><name>shm_mq</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>shm_mq_detach_internal</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
