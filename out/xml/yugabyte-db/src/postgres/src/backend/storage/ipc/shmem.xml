<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/storage/ipc/shmem.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shmem.c
 *	  create shared memory and initialize shared memory data structures.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/ipc/shmem.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * POSTGRES processes share one or more regions of shared memory.
 * The shared memory is created by a postmaster and is inherited
 * by each backend via fork() (or, in some ports, via other OS-specific
 * methods).  The routines in this file are used for allocating and
 * binding to shared memory data structures.
 *
 * NOTES:
 *		(a) There are three kinds of shared memory data structures
 *	available to POSTGRES: fixed-size structures, queues and hash
 *	tables.  Fixed-size structures contain things like global variables
 *	for a module and should never be allocated after the shared memory
 *	initialization phase.  Hash tables have a fixed maximum size, but
 *	their actual size can vary dynamically.  When entries are added
 *	to the table, more space is allocated.  Queues link data structures
 *	that have been allocated either within fixed-size structures or as hash
 *	buckets.  Each shared data structure has a string name to identify
 *	it (assigned in the module that declares it).
 *
 *		(b) During initialization, each module looks for its
 *	shared data structures in a hash table called the "Shmem Index".
 *	If the data structure is not present, the caller can allocate
 *	a new one and initialize it.  If the data structure is present,
 *	the caller "attaches" to the structure by initializing a pointer
 *	in the local address space.
 *		The shmem index has two purposes: first, it gives us
 *	a simple model of how the world looks when a backend process
 *	initializes.  If something is present in the shmem index,
 *	it is initialized.  If it is not, it is uninitialized.  Second,
 *	the shmem index allows us to allocate shared memory on demand
 *	instead of trying to preallocate structures and hard-wire the
 *	sizes and locations in header files.  If you are using a lot
 *	of shared memory in a lot of different places (and changing
 *	things during development), this is important.
 *
 *		(c) In standard Unix-ish environments, individual backends do not
 *	need to re-establish their local pointers into shared memory, because
 *	they inherit correct values of those variables via fork() from the
 *	postmaster.  However, this does not work in the EXEC_BACKEND case.
 *	In ports using EXEC_BACKEND, new backends have to set up their local
 *	pointers using the method described in (b) above.
 *
 *		(d) memory allocation model: shared memory can never be
 *	freed, once allocated.   Each hash table has its own free list,
 *	so hash buckets can be reused when an item is deleted.  However,
 *	if one hash table grows very large and then shrinks, its space
 *	cannot be redistributed to other tables.  We could build a simple
 *	hash bucket garbage collector if need be.  Right now, it seems
 *	unnecessary.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>


<comment type="block">/* shared memory global variables */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>PGShmemHeader</name> <modifier>*</modifier></type><name>ShmemSegHdr</name></decl>;</decl_stmt>	<comment type="block">/* shared mem segment header */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ShmemBase</name></decl>;</decl_stmt>			<comment type="block">/* start address of shared memory */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ShmemEnd</name></decl>;</decl_stmt>			<comment type="block">/* end+1 address of shared memory */</comment>

<decl_stmt><decl><type><name>slock_t</name>    <modifier>*</modifier></type><name>ShmemLock</name></decl>;</decl_stmt>			<comment type="block">/* spinlock for shared memory and LWLock
								 * allocation */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ShmemIndex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* primary index hashtable for shmem */</comment>


<comment type="block">/*
 *	InitShmemAccess() --- set up basic pointers to shared memory.
 *
 * Note: the argument should be declared "PGShmemHeader *seghdr",
 * but we use void to avoid having to include ipc.h in shmem.h.
 */</comment>
<function><type><name>void</name></type>
<name>InitShmemAccess</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>seghdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>shmhdr</name> <init>= <expr><operator>(</operator><name>PGShmemHeader</name> <operator>*</operator><operator>)</operator> <name>seghdr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ShmemSegHdr</name> <operator>=</operator> <name>shmhdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShmemBase</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>shmhdr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShmemEnd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ShmemBase</name> <operator>+</operator> <name><name>shmhdr</name><operator>-&gt;</operator><name>totalsize</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	InitShmemAllocation() --- set up shared-memory space allocation.
 *
 * This should be called only in the postmaster or a standalone backend.
 */</comment>
<function><type><name>void</name></type>
<name>InitShmemAllocation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>shmhdr</name> <init>= <expr><name>ShmemSegHdr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>aligned</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shmhdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the spinlock used by ShmemAlloc.  We must use
	 * ShmemAllocUnlocked, since obviously ShmemAlloc can't be called yet.
	 */</comment>
	<expr_stmt><expr><name>ShmemLock</name> <operator>=</operator> <operator>(</operator><name>slock_t</name> <operator>*</operator><operator>)</operator> <call><name>ShmemAllocUnlocked</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>slock_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocations after this point should go through ShmemAlloc, which
	 * expects to allocate everything on cache line boundaries.  Make sure the
	 * first allocation begins on a cache line boundary.
	 */</comment>
	<expr_stmt><expr><name>aligned</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
		<operator>(</operator><call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shmhdr</name><operator>)</operator> <operator>+</operator> <name><name>shmhdr</name><operator>-&gt;</operator><name>freeoffset</name></name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmhdr</name><operator>-&gt;</operator><name>freeoffset</name></name> <operator>=</operator> <name>aligned</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shmhdr</name></expr>;</expr_stmt>

	<comment type="block">/* ShmemIndex can't be set up yet (need LWLocks first) */</comment>
	<expr_stmt><expr><name><name>shmhdr</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ShmemIndex</name> <operator>=</operator> <operator>(</operator><name>HTAB</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize ShmemVariableCache for transaction manager. (This doesn't
	 * really belong here, but not worth moving.)
	 */</comment>
	<expr_stmt><expr><name>ShmemVariableCache</name> <operator>=</operator> <operator>(</operator><name>VariableCache</name><operator>)</operator>
		<call><name>ShmemAlloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ShmemVariableCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ShmemVariableCache</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ShmemVariableCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemAlloc -- allocate max-aligned chunk from shared memory
 *
 * Throws error if request cannot be satisfied.
 *
 * Assumes ShmemLock and ShmemSegHdr are initialized.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>ShmemAlloc</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newSpace</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newSpace</name> <operator>=</operator> <call><name>ShmemAllocNoError</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory (%zu bytes requested)"</literal></expr></argument>,
						<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>newSpace</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemAllocNoError -- allocate max-aligned chunk from shared memory
 *
 * As ShmemAlloc, but returns NULL if out of space, rather than erroring.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>ShmemAllocNoError</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newSpace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure all space is adequately aligned.  We used to only MAXALIGN this
	 * space but experience has proved that on modern systems that is not good
	 * enough.  Many parts of the system are very sensitive to critical data
	 * structures getting split across cache line boundaries.  To avoid that,
	 * attempt to align the beginning of the allocation to a cache line
	 * boundary.  The calling code will still need to be careful about how it
	 * uses the allocated space - e.g. by padding each element in an array of
	 * structures out to a power-of-two size - but without this, even that
	 * won't be sufficient.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ShmemSegHdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newStart</name> <operator>=</operator> <name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>freeoffset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newFree</name> <operator>=</operator> <name>newStart</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newFree</name> <operator>&lt;=</operator> <name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>totalsize</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newSpace</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ShmemBase</name> <operator>+</operator> <name>newStart</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>freeoffset</name></name> <operator>=</operator> <name>newFree</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newSpace</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>ShmemLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* note this assert is okay with newSpace == NULL */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newSpace</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>newSpace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newSpace</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemAllocUnlocked -- allocate max-aligned chunk from shared memory
 *
 * Allocate space without locking ShmemLock.  This should be used for,
 * and only for, allocations that must happen before ShmemLock is ready.
 *
 * We consider maxalign, rather than cachealign, sufficient here.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>ShmemAllocUnlocked</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newSpace</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure allocated space is adequately aligned.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ShmemSegHdr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newStart</name> <operator>=</operator> <name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>freeoffset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newFree</name> <operator>=</operator> <name>newStart</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newFree</name> <operator>&gt;</operator> <name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>totalsize</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory (%zu bytes requested)"</literal></expr></argument>,
						<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ShmemSegHdr</name><operator>-&gt;</operator><name>freeoffset</name></name> <operator>=</operator> <name>newFree</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newSpace</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ShmemBase</name> <operator>+</operator> <name>newStart</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newSpace</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newSpace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newSpace</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemAddrIsValid -- test if an address refers to shared memory
 *
 * Returns true if the pointer points within the shared memory segment.
 */</comment>
<function><type><name>bool</name></type>
<name>ShmemAddrIsValid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>addr</name> <operator>&gt;=</operator> <name>ShmemBase</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&lt;</operator> <name>ShmemEnd</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	InitShmemIndex() --- set up or attach to shmem index table.
 */</comment>
<function><type><name>void</name></type>
<name>InitShmemIndex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_flags</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the shared memory shmem index.
	 *
	 * Since ShmemInitHash calls ShmemInitStruct, which expects the ShmemIndex
	 * hashtable to exist already, we have a bit of a circularity problem in
	 * initializing the ShmemIndex itself.  The special "ShmemIndex" hash
	 * table name will tell ShmemInitStruct to fake it.
	 */</comment>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>SHMEM_INDEX_KEYSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShmemIndexEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <name>HASH_ELEM</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ShmemIndex</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"ShmemIndex"</literal></expr></argument>,
							   <argument><expr><name>SHMEM_INDEX_SIZE</name></expr></argument>, <argument><expr><name>SHMEM_INDEX_SIZE</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemInitHash -- Create and initialize, or attach to, a
 *		shared memory hash table.
 *
 * We assume caller is doing some kind of synchronization
 * so that two processes don't try to create/initialize the same
 * table at once.  (In practice, all creations are done in the postmaster
 * process; child processes should always be attaching to existing tables.)
 *
 * max_size is the estimated maximum number of hashtable entries.  This is
 * not a hard limit, but the access efficiency will degrade if it is
 * exceeded substantially (since it's used to compute directory size and
 * the hash table buckets will get overfull).
 *
 * init_size is the number of hashtable entries to preallocate.  For a table
 * whose maximum size is certain, this should be equal to max_size; that
 * ensures that no run-time out-of-shared-memory failures can occur.
 *
 * Note: before Postgres 9.0, this function returned NULL for some failure
 * cases.  Now, it always throws error instead, so callers need not check
 * for NULL.
 */</comment>
<function><type><name>HTAB</name> <modifier>*</modifier></type>
<name>ShmemInitHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,		<comment type="block">/* table string name for shmem index */</comment>
			  <parameter><decl><type><name>long</name></type> <name>init_size</name></decl></parameter>,	<comment type="block">/* initial table size */</comment>
			  <parameter><decl><type><name>long</name></type> <name>max_size</name></decl></parameter>,	<comment type="block">/* max size of the table */</comment>
			  <parameter><decl><type><name>HASHCTL</name> <modifier>*</modifier></type><name>infoP</name></decl></parameter>,	<comment type="block">/* info about key and bucket size */</comment>
			  <parameter><decl><type><name>int</name></type> <name>hash_flags</name></decl></parameter>)</parameter_list>	<comment type="block">/* info about infoP */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>location</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Hash tables allocated in shared memory have a fixed directory; it can't
	 * grow or other backends wouldn't be able to find it. So, make sure we
	 * make it big enough to start with.
	 *
	 * The shared memory allocator must be specified too.
	 */</comment>
	<expr_stmt><expr><name><name>infoP</name><operator>-&gt;</operator><name>dsize</name></name> <operator>=</operator> <name><name>infoP</name><operator>-&gt;</operator><name>max_dsize</name></name> <operator>=</operator> <call><name>hash_select_dirsize</name><argument_list>(<argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>infoP</name><operator>-&gt;</operator><name>alloc</name></name> <operator>=</operator> <name>ShmemAllocNoError</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash_flags</name> <operator>|=</operator> <name>HASH_SHARED_MEM</name> <operator>|</operator> <name>HASH_ALLOC</name> <operator>|</operator> <name>HASH_DIRSIZE</name></expr>;</expr_stmt>

	<comment type="block">/* look it up in the shmem index */</comment>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
							   <argument><expr><call><name>hash_get_shared_size</name><argument_list>(<argument><expr><name>infoP</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if it already exists, attach to it rather than allocate and initialize
	 * new space
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hash_flags</name> <operator>|=</operator> <name>HASH_ATTACH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Pass location of hashtable header to hash_create */</comment>
	<expr_stmt><expr><name><name>infoP</name><operator>-&gt;</operator><name>hctl</name></name> <operator>=</operator> <operator>(</operator><name>HASHHDR</name> <operator>*</operator><operator>)</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>init_size</name></expr></argument>, <argument><expr><name>infoP</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ShmemInitStruct -- Create/attach to a structure in shared memory.
 *
 *		This is called during initialization to find or allocate
 *		a data structure in shared memory.  If no other process
 *		has created the structure, this routine allocates space
 *		for it.  If it exists already, a pointer to the existing
 *		structure is returned.
 *
 *	Returns: pointer to the object.  *foundPtr is set true if the object was
 *		already in the shmem index (hence, already initialized).
 *
 *	Note: before Postgres 9.0, this function returned NULL for some failure
 *	cases.  Now, it always throws error instead, so callers need not check
 *	for NULL.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>ShmemInitStruct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>foundPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShmemIndexEnt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>structPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ShmemIndex</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>shmemseghdr</name> <init>= <expr><name>ShmemSegHdr</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Must be trying to create/attach to ShmemIndex itself */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"ShmemIndex"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must be initializing a (non-standalone) backend */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shmemseghdr</name><operator>-&gt;</operator><name>index</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>structPtr</name> <operator>=</operator> <name><name>shmemseghdr</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If the shmem index doesn't exist, we are bootstrapping: we must
			 * be trying to init the shmem index itself.
			 *
			 * Notice that the ShmemIndexLock is released before the shmem
			 * index has been initialized.  This should be OK because no other
			 * process can be accessing shared memory yet.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shmemseghdr</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>structPtr</name> <operator>=</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shmemseghdr</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>structPtr</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>foundPtr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>structPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* look it up in the shmem index */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>ShmemIndexEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ShmemIndex</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create ShmemIndex entry for data structure \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>foundPtr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Structure is in the shmem index so someone else has allocated it
		 * already.  The size better be the same as the size we are trying to
		 * initialize to, or there is a name conflict (or worse).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ShmemIndex entry size is wrong for data structure"</literal>
							<literal type="string">" \"%s\": expected %zu, actual %zu"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>structPtr</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* It isn't in the table yet. allocate and initialize it */</comment>
		<expr_stmt><expr><name>structPtr</name> <operator>=</operator> <call><name>ShmemAllocNoError</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>structPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* out of memory; remove the failed ShmemIndex entry */</comment>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ShmemIndex</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for data structure"</literal>
							<literal type="string">" \"%s\" (%zu bytes requested)"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>structPtr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShmemIndexLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ShmemAddrIsValid</name><argument_list>(<argument><expr><name>structPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>structPtr</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>CACHELINEALIGN</name><argument_list>(<argument><expr><name>structPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>structPtr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Add two Size values, checking for overflow
 */</comment>
<function><type><name>Size</name></type>
<name>add_size</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>s1</name> <operator>+</operator> <name>s2</name></expr>;</expr_stmt>
	<comment type="block">/* We are assuming Size is an unsigned type here... */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <name>s1</name> <operator>||</operator> <name>result</name> <operator>&lt;</operator> <name>s2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested shared memory size overflows size_t"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Multiply two Size values, checking for overflow
 */</comment>
<function><type><name>Size</name></type>
<name>mul_size</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>s2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt>
	<comment type="block">/* We are assuming Size is an unsigned type here... */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>/</operator> <name>s2</name> <operator>!=</operator> <name>s1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested shared memory size overflows size_t"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
