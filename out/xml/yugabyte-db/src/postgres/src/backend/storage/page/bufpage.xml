<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/storage/page/bufpage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bufpage.c
 *	  POSTGRES standard buffer page code.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/storage/page/bufpage.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/itup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/checksum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variable */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>ignore_checksum_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------------------------------------------------------------
 *						Page support functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * PageInit
 *		Initializes the contents of a page.
 *		Note that we don't calculate an initial checksum here; that's not done
 *		until it's time to write.
 */</comment>
<function><type><name>void</name></type>
<name>PageInit</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>pageSize</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>specialSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>p</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>specialSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>specialSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageSize</name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pageSize</name> <operator>&gt;</operator> <name>specialSize</name> <operator>+</operator> <name>SizeOfPageHeaderData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure all fields of page are zero, as well as unused space */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pd_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>=</operator> <name>SizeOfPageHeaderData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>=</operator> <name>pageSize</name> <operator>-</operator> <name>specialSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>=</operator> <name>pageSize</name> <operator>-</operator> <name>specialSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetPageSizeAndVersion</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>, <argument><expr><name>PG_PAGE_LAYOUT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* p-&gt;pd_prune_xid = InvalidTransactionId;		done by above MemSet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * PageIsVerified
 *		Check that the page header and checksum (if any) appear valid.
 *
 * This is called when a page has just been read in from disk.  The idea is
 * to cheaply detect trashed pages before we go nuts following bogus item
 * pointers, testing invalid transaction identifiers, etc.
 *
 * It turns out to be necessary to allow zeroed pages here too.  Even though
 * this routine is *not* called when deliberately adding a page to a relation,
 * there are scenarios in which a zeroed page might be found in a table.
 * (Example: a backend extends a relation, then crashes before it can write
 * any WAL entry about the new page.  The kernel will already have the
 * zeroed page in the file, and it will stay that way after restart.)  So we
 * allow zeroed pages here, and are careful that the page access macros
 * treat such a page as empty and without free space.  Eventually, VACUUM
 * will clean up such a page and make it usable.
 */</comment>
<function><type><name>bool</name></type>
<name>PageIsVerified</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>p</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name>	   <modifier>*</modifier></type><name>pagebytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checksum_failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>header_sane</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_zeroes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>checksum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't verify page data unless the page passes basic non-zero test
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>checksum</name> <operator>!=</operator> <name><name>p</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>checksum_failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The following checks don't prove the header is correct, only that
		 * it looks sane enough to allow into the buffer pool. Later usage of
		 * the block can still reveal problems, which is why we offer the
		 * checksum option.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pd_flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>PD_VALID_FLAG_BITS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&lt;=</operator> <name>BLCKSZ</name> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>==</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>header_sane</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>header_sane</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check all-zeroes case. Luckily BLCKSZ is guaranteed to always be a
	 * multiple of size_t - and it's much faster to compare memory using the
	 * native word size.
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>BLCKSZ</name> <operator>==</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					 <argument><expr><literal type="string">"BLCKSZ has to be a multiple of sizeof(size_t)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>all_zeroes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pagebytes</name> <operator>=</operator> <operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pagebytes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_zeroes</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>all_zeroes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Throw a WARNING if the checksum fails, but only after we've checked for
	 * the all-zeroes case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>checksum_failure</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><name>ERRCODE_DATA_CORRUPTED</name><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"page verification failed, calculated checksum %u but expected %u"</literal></expr></argument>,
						<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pd_checksum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>header_sane</name> <operator>&amp;&amp;</operator> <name>ignore_checksum_failure</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	PageAddItemExtended
 *
 *	Add an item to a page.  Return value is the offset at which it was
 *	inserted, or InvalidOffsetNumber if the item is not inserted for any
 *	reason.  A WARNING is issued indicating the reason for the refusal.
 *
 *	offsetNumber must be either InvalidOffsetNumber to specify finding a
 *	free item pointer, or a value between FirstOffsetNumber and one past
 *	the last existing item, to specify using that particular item pointer.
 *
 *	If offsetNumber is valid and flag PAI_OVERWRITE is set, we just store
 *	the item at the specified offsetNumber, which must be either a
 *	currently-unused item pointer, or one past the last existing item.
 *
 *	If offsetNumber is valid and flag PAI_OVERWRITE is not set, insert
 *	the item at the specified offsetNumber, moving existing items later
 *	in the array to make room.
 *
 *	If offsetNumber is not valid, then assign a slot by finding the first
 *	one that is both unused and deallocated.
 *
 *	If flag PAI_IS_HEAP is set, we enforce that there can't be more than
 *	MaxHeapTuplesPerPage line pointers on the page.
 *
 *	!!! EREPORT(ERROR) IS DISALLOWED HERE !!!
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>PageAddItemExtended</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
					<parameter><decl><type><name>Item</name></type> <name>item</name></decl></parameter>,
					<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>,
					<parameter><decl><type><name>OffsetNumber</name></type> <name>offsetNumber</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alignedSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needshuffle</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Be wary about corrupted page pointers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&gt;</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Select offsetNumber to place the new item at
	 */</comment>
	<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* was offsetNumber passed in? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>offsetNumber</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* yes, check it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PAI_OVERWRITE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>offsetNumber</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>itemId</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>offsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"will not overwrite a used ItemId"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>offsetNumber</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>needshuffle</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* need to move existing linp's */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* offsetNumber was not passed in, so find a free slot */</comment>
		<comment type="block">/* if no free slot, we'll put it at limit (1st open slot) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageHasFreeLinePointers</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Look for "recyclable" (unused) ItemId.  We check for no storage
			 * as well, just to be paranoid --- unused items should never have
			 * storage.
			 */</comment>
			<for>for <control>(<init><expr><name>offsetNumber</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>offsetNumber</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><name>offsetNumber</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>itemId</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>offsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>offsetNumber</name> <operator>&gt;=</operator> <name>limit</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the hint is wrong, so reset it */</comment>
				<expr_stmt><expr><call><name>PageClearHasFreeLinePointers</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* don't bother searching if hint says there's no free slot */</comment>
			<expr_stmt><expr><name>offsetNumber</name> <operator>=</operator> <name>limit</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Reject placing items beyond the first unused line pointer */</comment>
	<if_stmt><if>if <condition>(<expr><name>offsetNumber</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"specified item offset is too large"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reject placing items beyond heap boundary, if heap */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>PAI_IS_HEAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offsetNumber</name> <operator>&gt;</operator> <name>MaxHeapTuplesPerPage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"can't put more than MaxHeapTuplesPerPage items in a heap page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute new lower and upper pointers for page, see if it'll fit.
	 *
	 * Note: do arithmetic as signed ints, to avoid mistakes if, say,
	 * alignedSize &gt; pd_upper.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>offsetNumber</name> <operator>==</operator> <name>limit</name> <operator>||</operator> <name>needshuffle</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>alignedSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>upper</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>alignedSize</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lower</name> <operator>&gt;</operator> <name>upper</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * OK to insert the item.  First, shuffle the existing pointers if needed.
	 */</comment>
	<expr_stmt><expr><name>itemId</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>offsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needshuffle</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>itemId</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>itemId</name></expr></argument>,
				<argument><expr><operator>(</operator><name>limit</name> <operator>-</operator> <name>offsetNumber</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set the item pointer */</comment>
	<expr_stmt><expr><call><name>ItemIdSetNormal</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Items normally contain no uninitialized bytes.  Core bufpage consumers
	 * conform, but this is not a necessary coding rule; a new index AM could
	 * opt to depart from it.  However, data type input functions and other
	 * C-language functions that synthesize datums should initialize all
	 * bytes; datumIsEqual() relies on this.  Testing here, along with the
	 * similar check in printtup(), helps to catch such mistakes.
	 *
	 * Values of the "name" type retrieved via index-only scans may contain
	 * uninitialized bytes; see comment in btrescan().  Valgrind will report
	 * this as an error, but it is safe to ignore.
	 */</comment>
	<expr_stmt><expr><call><name>VALGRIND_CHECK_MEM_IS_DEFINED</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* copy the item's data onto the page */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name>upper</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* adjust page header */</comment>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>=</operator> <operator>(</operator><name>LocationIndex</name><operator>)</operator> <name>lower</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>=</operator> <operator>(</operator><name>LocationIndex</name><operator>)</operator> <name>upper</name></expr>;</expr_stmt>

	<return>return <expr><name>offsetNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PageGetTempPage
 *		Get a temporary page in local memory for special processing.
 *		The returned page is not initialized at all; caller must do that.
 */</comment>
<function><type><name>Page</name></type>
<name>PageGetTempPage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageSize</name> <operator>=</operator> <call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetTempPageCopy
 *		Get a temporary page in local memory for special processing.
 *		The page is initialized by copying the contents of the given page.
 */</comment>
<function><type><name>Page</name></type>
<name>PageGetTempPageCopy</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageSize</name> <operator>=</operator> <call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetTempPageCopySpecial
 *		Get a temporary page in local memory for special processing.
 *		The page is PageInit'd with the same special-space size as the
 *		given page, and the special space is copied from the given page.
 */</comment>
<function><type><name>Page</name></type>
<name>PageGetTempPageCopySpecial</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>temp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageSize</name> <operator>=</operator> <call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>, <argument><expr><call><name>PageGetSpecialSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><call><name>PageGetSpecialSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageRestoreTempPage
 *		Copy temporary page back to permanent page after special processing
 *		and release the temporary page.
 */</comment>
<function><type><name>void</name></type>
<name>PageRestoreTempPage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>tempPage</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>oldPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageSize</name> <operator>=</operator> <call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>tempPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>oldPage</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tempPage</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tempPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sorting support for PageRepairFragmentation and PageIndexMultiDelete
 */</comment>
<typedef>typedef <type><struct>struct <name>itemIdSortData</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>offsetindex</name></decl>;</decl_stmt>	<comment type="block">/* linp array index */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>itemoff</name></decl>;</decl_stmt>		<comment type="block">/* page offset of item data */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>alignedlen</name></decl>;</decl_stmt>		<comment type="block">/* MAXALIGN(item data len) */</comment>
}</block></struct></type> <name>itemIdSortData</name>;</typedef>
<typedef>typedef <type><name>itemIdSortData</name> <modifier>*</modifier></type><name>itemIdSort</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>itemoffcompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>itemidp1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>itemidp2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Sort in decreasing itemoff order */</comment>
	<return>return <expr><operator>(</operator><operator>(</operator><name>itemIdSort</name><operator>)</operator> <name>itemidp2</name><operator>)</operator><operator>-&gt;</operator><name>itemoff</name> <operator>-</operator>
		<operator>(</operator><operator>(</operator><name>itemIdSort</name><operator>)</operator> <name>itemidp1</name><operator>)</operator><operator>-&gt;</operator><name>itemoff</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * After removing or marking some line pointers unused, move the tuples to
 * remove the gaps caused by the removed items.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compactify_tuples</name><parameter_list>(<parameter><decl><type><name>itemIdSort</name></type> <name>itemidbase</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* sort itemIdSortData array into decreasing itemoff order */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itemidbase</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>itemIdSortData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>itemoffcompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>upper</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>itemIdSort</name></type>	<name>itemidptr</name> <init>= <expr><operator>&amp;</operator><name><name>itemidbase</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>offsetindex</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>upper</name> <operator>-=</operator> <name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name>upper</name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name></expr></argument>,
				<argument><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_off</name></name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PageRepairFragmentation
 *
 * Frees fragmented space on a page.
 * It doesn't remove unused line pointers! Please don't change this.
 *
 * This routine is usable for heap pages only, but see PageIndexMultiDelete.
 *
 * As a side effect, the page's PD_HAS_FREE_LINES hint bit is updated.
 */</comment>
<function><type><name>void</name></type>
<name>PageRepairFragmentation</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_lower</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_upper</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_special</name> <init>= <expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_special</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>itemIdSortData</name></type> <name><name>itemidbase</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>itemIdSort</name></type>	<name>itemidptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nline</name></decl>,
				<decl><type ref="prev"/><name>nstorage</name></decl>,
				<decl><type ref="prev"/><name>nunused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>totallen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's worth the trouble to be more paranoid here than in most places,
	 * because we are about to reshuffle data in (what is usually) a shared
	 * disk buffer.  If we aren't careful then corrupted pointers, lengths,
	 * etc could cause us to clobber adjacent disk buffers, spreading the data
	 * loss further.  So, check everything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pd_lower</name> <argument_list type="generic">&lt; <argument><expr><name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name>pd_lower</name></expr></argument> &gt;</argument_list></name> <name>pd_upper</name> <operator>||</operator>
		<name>pd_upper</name> <operator>&gt;</operator> <name>pd_special</name> <operator>||</operator>
		<name>pd_special</name> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>||</operator>
		<name>pd_special</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pd_special</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name>pd_lower</name></expr></argument>, <argument><expr><name>pd_upper</name></expr></argument>, <argument><expr><name>pd_special</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run through the line pointer array and collect data about live items.
	 */</comment>
	<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemidptr</name> <operator>=</operator> <name>itemidbase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nunused</name> <operator>=</operator> <name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nline</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>offsetindex</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name> <operator>=</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>pd_upper</name> <operator>||</operator>
							 <name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>pd_special</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item pointer: %u"</literal></expr></argument>,
									<argument><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>itemidptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unused entries should have lp_len = 0, but make sure */</comment>
			<expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nunused</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>nstorage</name> <operator>=</operator> <name>itemidptr</name> <operator>-</operator> <name>itemidbase</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nstorage</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Page is completely empty, so just reset it quickly */</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name> <operator>=</operator> <name>pd_special</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Need to compact the page the hard way */</comment>
		<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <operator>(</operator><name>pd_special</name> <operator>-</operator> <name>pd_lower</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item lengths: total %u, available space %u"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>totallen</name></expr></argument>, <argument><expr><name>pd_special</name> <operator>-</operator> <name>pd_lower</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>compactify_tuples</name><argument_list>(<argument><expr><name>itemidbase</name></expr></argument>, <argument><expr><name>nstorage</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Set hint bit for PageAddItem */</comment>
	<if_stmt><if>if <condition>(<expr><name>nunused</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageSetHasFreeLinePointers</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageClearHasFreeLinePointers</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetFreeSpace
 *		Returns the size of the free (allocatable) space on a page,
 *		reduced by the space needed for a new line pointer.
 *
 * Note: this should usually only be used on index pages.  Use
 * PageGetHeapFreeSpace on heap pages.
 */</comment>
<function><type><name>Size</name></type>
<name>PageGetFreeSpace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>space</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;
	 * pd_upper.
	 */</comment>
	<expr_stmt><expr><name>space</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name> <operator>-</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>space</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>space</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Size</name><operator>)</operator> <name>space</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetFreeSpaceForMultipleTuples
 *		Returns the size of the free (allocatable) space on a page,
 *		reduced by the space needed for multiple new line pointers.
 *
 * Note: this should usually only be used on index pages.  Use
 * PageGetHeapFreeSpace on heap pages.
 */</comment>
<function><type><name>Size</name></type>
<name>PageGetFreeSpaceForMultipleTuples</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>space</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;
	 * pd_upper.
	 */</comment>
	<expr_stmt><expr><name>space</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name> <operator>-</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>space</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>space</name> <operator>-=</operator> <name>ntups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Size</name><operator>)</operator> <name>space</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PageGetExactFreeSpace
 *		Returns the size of the free (allocatable) space on a page,
 *		without any consideration for adding/removing line pointers.
 */</comment>
<function><type><name>Size</name></type>
<name>PageGetExactFreeSpace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>space</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use signed arithmetic here so that we behave sensibly if pd_lower &gt;
	 * pd_upper.
	 */</comment>
	<expr_stmt><expr><name>space</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name> <operator>-</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>space</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Size</name><operator>)</operator> <name>space</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PageGetHeapFreeSpace
 *		Returns the size of the free (allocatable) space on a page,
 *		reduced by the space needed for a new line pointer.
 *
 * The difference between this and PageGetFreeSpace is that this will return
 * zero if there are already MaxHeapTuplesPerPage line pointers in the page
 * and none are free.  We use this to enforce that no more than
 * MaxHeapTuplesPerPage line pointers are created on a heap page.  (Although
 * no more tuples than that could fit anyway, in the presence of redirected
 * or dead line pointers it'd be possible to have too many line pointers.
 * To avoid breaking code that assumes MaxHeapTuplesPerPage is a hard limit
 * on the number of line pointers, we make this extra check.)
 */</comment>
<function><type><name>Size</name></type>
<name>PageGetHeapFreeSpace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>space</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>space</name> <operator>=</operator> <call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>space</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
					<decl><type ref="prev"/><name>nline</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Are there already MaxHeapTuplesPerPage line pointers in the page?
		 */</comment>
		<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nline</name> <operator>&gt;=</operator> <name>MaxHeapTuplesPerPage</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PageHasFreeLinePointers</name><argument_list>(<argument><expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Since this is just a hint, we must confirm that there is
				 * indeed a free line pointer
				 */</comment>
				<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>nline</name></expr>;</condition> <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&gt;</operator> <name>nline</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The hint is wrong, but we can't clear it here since we
					 * don't have the ability to mark the page dirty.
					 */</comment>
					<expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Although the hint might be wrong, PageAddItem will believe
				 * it anyway, so we must believe it too.
				 */</comment>
				<expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>space</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PageIndexTupleDelete
 *
 * This routine does the work of removing a tuple from an index page.
 *
 * Unlike heap pages, we compact out the line pointer for the removed tuple.
 */</comment>
<function><type><name>void</name></type>
<name>PageIndexTupleDelete</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nline</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As with PageRepairFragmentation, paranoia seems justified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&gt;</operator> <name>nline</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid index offnum: %u"</literal></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* change offset number to offset index */</comment>
	<expr_stmt><expr><name>offidx</name> <operator>=</operator> <name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>size</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name>offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item pointer: offset = %u, size = %u"</literal></expr></argument>,
						<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Amount of space to actually be deleted */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, we want to get rid of the pd_linp entry for the index tuple. We
	 * copy all subsequent linp's back one slot in the array. We don't use
	 * PageGetItemId, because we are manipulating the _array_, not individual
	 * linp's.
	 */</comment>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>-</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>phdr</name><operator>-&gt;</operator><name>pd_linp</name><index>[<expr><name>offidx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>phdr</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>pd_linp</name><index>[<expr><name>offidx</name></expr>]</index></name><operator>)</operator></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>pd_linp</name><index>[<expr><name>offidx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>,
				<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now move everything between the old upper bound (beginning of tuple
	 * space) and the beginning of the deleted tuple forward, so that space in
	 * the middle of the page is left free.  If we've just deleted the tuple
	 * at the beginning of tuple space, then there's no need to do the copy.
	 */</comment>

	<comment type="block">/* beginning of tuple space */</comment>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>offset</name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* adjust free space boundary pointers */</comment>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, we need to adjust the linp entries that remain.
	 *
	 * Anything that used to be before the deleted tuple's data was moved
	 * forward by the size of the deleted tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nline</name><operator>--</operator></expr>;</expr_stmt>				<comment type="block">/* there's one less than when we started */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nline</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>ii</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>lp_off</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PageIndexMultiDelete
 *
 * This routine handles the case of deleting multiple tuples from an
 * index page at once.  It is considerably faster than a loop around
 * PageIndexTupleDelete ... however, the caller *must* supply the array
 * of item numbers to be deleted in item number order!
 */</comment>
<function><type><name>void</name></type>
<name>PageIndexMultiDelete</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itemnos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_lower</name> <init>= <expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_upper</name> <init>= <expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Offset</name></type>		<name>pd_special</name> <init>= <expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>itemIdSortData</name></type> <name><name>itemidbase</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemIdData</name></type>	<name><name>newitemids</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>itemIdSort</name></type>	<name>itemidptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nline</name></decl>,
				<decl><type ref="prev"/><name>nused</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>totallen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextitm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nitems</name> <operator>&lt;=</operator> <name>MaxIndexTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there aren't very many items to delete, then retail
	 * PageIndexTupleDelete is the best way.  Delete the items in reverse
	 * order so we don't have to think about adjusting item numbers for
	 * previous deletions.
	 *
	 * TODO: tune the magic number here
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><operator>--</operator><name>nitems</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>itemnos</name><index>[<expr><name>nitems</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * As with PageRepairFragmentation, paranoia seems justified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pd_lower</name> <argument_list type="generic">&lt; <argument><expr><name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name>pd_lower</name></expr></argument> &gt;</argument_list></name> <name>pd_upper</name> <operator>||</operator>
		<name>pd_upper</name> <operator>&gt;</operator> <name>pd_special</name> <operator>||</operator>
		<name>pd_special</name> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>||</operator>
		<name>pd_special</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>pd_special</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name>pd_lower</name></expr></argument>, <argument><expr><name>pd_upper</name></expr></argument>, <argument><expr><name>pd_special</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the item pointer array and build a list of just the ones we are
	 * going to keep.  Notice we do not modify the page yet, since we are
	 * still validity-checking.
	 */</comment>
	<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemidptr</name> <operator>=</operator> <name>itemidbase</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextitm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>nline</name></expr>;</condition> <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><expr><name>pd_upper</name> <operator>||</operator>
			<operator>(</operator><name>offset</name> <operator>+</operator> <name>size</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name>pd_special</name> <operator>||</operator>
			<name>offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item pointer: offset = %u, length = %u"</literal></expr></argument>,
							<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nextitm</name> <operator>&lt;</operator> <name>nitems</name> <operator>&amp;&amp;</operator> <name>offnum</name> <operator>==</operator> <name><name>itemnos</name><index>[<expr><name>nextitm</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip item to be deleted */</comment>
			<expr_stmt><expr><name>nextitm</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>offsetindex</name></name> <operator>=</operator> <name>nused</name></expr>;</expr_stmt> <comment type="block">/* where it will go */</comment>
			<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>itemoff</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name><name>itemidptr</name><operator>-&gt;</operator><name>alignedlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newitemids</name><index>[<expr><name>nused</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>lp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemidptr</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nused</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* this will catch invalid or out-of-order itemnos[] */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextitm</name> <operator>!=</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect index offsets supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <operator>(</operator><name>pd_special</name> <operator>-</operator> <name>pd_lower</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item lengths: total %u, available space %u"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>totallen</name></expr></argument>, <argument><expr><name>pd_special</name> <operator>-</operator> <name>pd_lower</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Looks good. Overwrite the line pointers with the copy, from which we've
	 * removed all the unused items.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_linp</name></name></expr></argument>, <argument><expr><name>newitemids</name></expr></argument>, <argument><expr><name>nused</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>=</operator> <name>SizeOfPageHeaderData</name> <operator>+</operator> <name>nused</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* and compactify the tuple data */</comment>
	<expr_stmt><expr><call><name>compactify_tuples</name><argument_list>(<argument><expr><name>itemidbase</name></expr></argument>, <argument><expr><name>nused</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PageIndexTupleDeleteNoCompact
 *
 * Remove the specified tuple from an index page, but set its line pointer
 * to "unused" instead of compacting it out, except that it can be removed
 * if it's the last line pointer on the page.
 *
 * This is used for index AMs that require that existing TIDs of live tuples
 * remain unchanged, and are willing to allow unused line pointers instead.
 */</comment>
<function><type><name>void</name></type>
<name>PageIndexTupleDeleteNoCompact</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nline</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As with PageRepairFragmentation, paranoia seems justified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nline</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&gt;</operator> <name>nline</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid index offnum: %u"</literal></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>size</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name>offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item pointer: offset = %u, size = %u"</literal></expr></argument>,
						<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Amount of space to actually be deleted */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Either set the item pointer to "unused", or zap it if it's the last
	 * one.  (Note: it's possible that the next-to-last one(s) are already
	 * unused, but we do not trouble to try to compact them out if so.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&lt;</operator> <name>nline</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>nline</name><operator>--</operator></expr>;</expr_stmt>				<comment type="block">/* there's one less than when we started */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now move everything between the old upper bound (beginning of tuple
	 * space) and the beginning of the deleted tuple forward, so that space in
	 * the middle of the page is left free.  If we've just deleted the tuple
	 * at the beginning of tuple space, then there's no need to do the copy.
	 */</comment>

	<comment type="block">/* beginning of tuple space */</comment>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>offset</name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* adjust free space boundary pointer */</comment>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, we need to adjust the linp entries that remain.
	 *
	 * Anything that used to be before the deleted tuple's data was moved
	 * forward by the size of the deleted tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nline</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>ii</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>lp_off</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PageIndexTupleOverwrite
 *
 * Replace a specified tuple on an index page.
 *
 * The new tuple is placed exactly where the old one had been, shifting
 * other tuples' data up or down as needed to keep the page compacted.
 * This is better than deleting and reinserting the tuple, because it
 * avoids any data shifting when the tuple size doesn't change; and
 * even when it does, we avoid moving the item pointers around.
 * Conceivably this could also be of use to an index AM that cares about
 * the physical order of tuples as well as their ItemId order.
 *
 * If there's insufficient space for the new tuple, return false.  Other
 * errors represent data-corruption problems, so we just elog.
 */</comment>
<function><type><name>bool</name></type>
<name>PageIndexTupleOverwrite</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>,
						<parameter><decl><type><name>Item</name></type> <name>newtup</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>tupid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>alignednewsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size_diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemcount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As with PageRepairFragmentation, paranoia seems justified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>SizeOfPageHeaderData</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>&gt;</operator> <name>BLCKSZ</name> <operator>||</operator>
		<name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted page pointers: lower = %u, upper = %u, special = %u"</literal></expr></argument>,
						<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itemcount</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>offnum</name> <operator>&gt;</operator> <name>itemcount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid index offnum: %u"</literal></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>tupid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldsize</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>tupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>tupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>||</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>oldsize</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name><name>phdr</name><operator>-&gt;</operator><name>pd_special</name></name> <operator>||</operator>
		<name>offset</name> <operator>!=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"corrupted item pointer: offset = %u, size = %u"</literal></expr></argument>,
						<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>oldsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine actual change in space requirement, check for page overflow.
	 */</comment>
	<expr_stmt><expr><name>oldsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>oldsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>alignednewsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>alignednewsize</name> <operator>&gt;</operator> <name>oldsize</name> <operator>+</operator> <operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Relocate existing data and update line pointers, unless the new tuple
	 * is the same size as the old (after alignment), in which case there's
	 * nothing to do.  Notice that what we have to relocate is data before the
	 * target tuple, not data after, so it's convenient to express size_diff
	 * as the amount by which the tuple's size is decreasing, making it the
	 * delta to add to pd_upper and affected line pointers.
	 */</comment>
	<expr_stmt><expr><name>size_diff</name> <operator>=</operator> <name>oldsize</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>alignednewsize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>size_diff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>addr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* relocate all tuple data before the target tuple */</comment>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name>size_diff</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>offset</name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust free space boundary pointer */</comment>
		<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>+=</operator> <name>size_diff</name></expr>;</expr_stmt>

		<comment type="block">/* adjust affected line pointers too */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>itemcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>ii</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Allow items without storage; currently only BRIN needs that */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ItemIdHasStorage</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ItemIdGetOffset</name><argument_list>(<argument><expr><name>ii</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>lp_off</name></name> <operator>+=</operator> <name>size_diff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Update the item's tuple length (other fields shouldn't change) */</comment>
	<expr_stmt><expr><call><name>ItemIdSetNormal</name><argument_list>(<argument><expr><name>tupid</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <name>size_diff</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy new tuple data onto page */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>tupid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Set checksum for a page in shared buffers.
 *
 * If checksums are disabled, or if the page is not initialized, just return
 * the input.  Otherwise, we must make a copy of the page before calculating
 * the checksum, to prevent concurrent modifications (e.g. setting hint bits)
 * from making the final checksum invalid.  It doesn't matter if we include or
 * exclude hints during the copy, as long as we write a valid page and
 * associated checksum.
 *
 * Returns a pointer to the block-sized data that needs to be written. Uses
 * statically-allocated memory, so the caller must immediately write the
 * returned page and not refer to it again.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PageSetChecksumCopy</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pageCopy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we don't need a checksum, just return the passed-in data */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We allocate the copy space once and use it over on each subsequent
	 * call.  The point of palloc'ing here, rather than having a static char
	 * array, is first to ensure adequate alignment for the checksumming code
	 * and second to avoid wasting space in processes that never call this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pageCopy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pageCopy</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pageCopy</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>pageCopy</name><operator>)</operator><operator>-&gt;</operator><name>pd_checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><name>pageCopy</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pageCopy</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set checksum for a page in private memory.
 *
 * This must only be used when we know that no other process can be modifying
 * the page buffer.
 */</comment>
<function><type><name>void</name></type>
<name>PageSetChecksumInplace</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If we don't need a checksum, just return */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>DataChecksumsEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_checksum</name> <operator>=</operator> <call><name>pg_checksum_page</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
