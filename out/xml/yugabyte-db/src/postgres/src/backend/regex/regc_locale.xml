<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/regex/regc_locale.c"><comment type="block">/*
 * regc_locale.c --
 *
 *	This file contains locale-specific regexp routines.
 *	This file is #included by regcomp.c.
 *
 * Copyright (c) 1998 by Scriptics Corporation.
 *
 * This software is copyrighted by the Regents of the University of
 * California, Sun Microsystems, Inc., Scriptics Corporation, ActiveState
 * Corporation and other parties.  The following terms apply to all files
 * associated with the software unless explicitly disclaimed in
 * individual files.
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 *
 * GOVERNMENT USE: If you are acquiring this software on behalf of the
 * U.S. government, the Government shall have only "Restricted Rights"
 * in the software and related documentation as defined in the Federal
 * Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
 * are acquiring the software on behalf of the Department of Defense, the
 * software shall be classified as "Commercial Computer Software" and the
 * Government shall have only "Restricted Rights" as defined in Clause
 * 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
 * authors grant the U.S. Government and others acting in its behalf
 * permission to use and distribute the software in accordance with the
 * terms specified in this license.
 *
 * src/backend/regex/regc_locale.c
 */</comment>

<comment type="block">/* ASCII character-name table */</comment>

<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>cname</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>	<name>code</name></decl>;</decl_stmt>
}</block>			<decl><name><name>cnames</name><index>[]</index></name> <init>=

<expr><block>{
	<expr><block>{
		<expr><literal type="string">"NUL"</literal></expr>, <expr><literal type="char">'\0'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"SOH"</literal></expr>, <expr><literal type="char">'\001'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"STX"</literal></expr>, <expr><literal type="char">'\002'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ETX"</literal></expr>, <expr><literal type="char">'\003'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"EOT"</literal></expr>, <expr><literal type="char">'\004'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ENQ"</literal></expr>, <expr><literal type="char">'\005'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ACK"</literal></expr>, <expr><literal type="char">'\006'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"BEL"</literal></expr>, <expr><literal type="char">'\007'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"alert"</literal></expr>, <expr><literal type="char">'\007'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"BS"</literal></expr>, <expr><literal type="char">'\010'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"backspace"</literal></expr>, <expr><literal type="char">'\b'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"HT"</literal></expr>, <expr><literal type="char">'\011'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"tab"</literal></expr>, <expr><literal type="char">'\t'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"LF"</literal></expr>, <expr><literal type="char">'\012'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"newline"</literal></expr>, <expr><literal type="char">'\n'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"VT"</literal></expr>, <expr><literal type="char">'\013'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"vertical-tab"</literal></expr>, <expr><literal type="char">'\v'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"FF"</literal></expr>, <expr><literal type="char">'\014'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"form-feed"</literal></expr>, <expr><literal type="char">'\f'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"CR"</literal></expr>, <expr><literal type="char">'\015'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"carriage-return"</literal></expr>, <expr><literal type="char">'\r'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"SO"</literal></expr>, <expr><literal type="char">'\016'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"SI"</literal></expr>, <expr><literal type="char">'\017'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DLE"</literal></expr>, <expr><literal type="char">'\020'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DC1"</literal></expr>, <expr><literal type="char">'\021'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DC2"</literal></expr>, <expr><literal type="char">'\022'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DC3"</literal></expr>, <expr><literal type="char">'\023'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DC4"</literal></expr>, <expr><literal type="char">'\024'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"NAK"</literal></expr>, <expr><literal type="char">'\025'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"SYN"</literal></expr>, <expr><literal type="char">'\026'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ETB"</literal></expr>, <expr><literal type="char">'\027'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"CAN"</literal></expr>, <expr><literal type="char">'\030'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"EM"</literal></expr>, <expr><literal type="char">'\031'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"SUB"</literal></expr>, <expr><literal type="char">'\032'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ESC"</literal></expr>, <expr><literal type="char">'\033'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"IS4"</literal></expr>, <expr><literal type="char">'\034'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"FS"</literal></expr>, <expr><literal type="char">'\034'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"IS3"</literal></expr>, <expr><literal type="char">'\035'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"GS"</literal></expr>, <expr><literal type="char">'\035'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"IS2"</literal></expr>, <expr><literal type="char">'\036'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"RS"</literal></expr>, <expr><literal type="char">'\036'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"IS1"</literal></expr>, <expr><literal type="char">'\037'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"US"</literal></expr>, <expr><literal type="char">'\037'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"space"</literal></expr>, <expr><literal type="char">' '</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"exclamation-mark"</literal></expr>, <expr><literal type="char">'!'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"quotation-mark"</literal></expr>, <expr><literal type="char">'"'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"number-sign"</literal></expr>, <expr><literal type="char">'#'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"dollar-sign"</literal></expr>, <expr><literal type="char">'$'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"percent-sign"</literal></expr>, <expr><literal type="char">'%'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ampersand"</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"apostrophe"</literal></expr>, <expr><literal type="char">'\''</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"left-parenthesis"</literal></expr>, <expr><literal type="char">'('</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"right-parenthesis"</literal></expr>, <expr><literal type="char">')'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"asterisk"</literal></expr>, <expr><literal type="char">'*'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"plus-sign"</literal></expr>, <expr><literal type="char">'+'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"comma"</literal></expr>, <expr><literal type="char">','</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"hyphen"</literal></expr>, <expr><literal type="char">'-'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"hyphen-minus"</literal></expr>, <expr><literal type="char">'-'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"period"</literal></expr>, <expr><literal type="char">'.'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"full-stop"</literal></expr>, <expr><literal type="char">'.'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"slash"</literal></expr>, <expr><literal type="char">'/'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"solidus"</literal></expr>, <expr><literal type="char">'/'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"zero"</literal></expr>, <expr><literal type="char">'0'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"one"</literal></expr>, <expr><literal type="char">'1'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"two"</literal></expr>, <expr><literal type="char">'2'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"three"</literal></expr>, <expr><literal type="char">'3'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"four"</literal></expr>, <expr><literal type="char">'4'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"five"</literal></expr>, <expr><literal type="char">'5'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"six"</literal></expr>, <expr><literal type="char">'6'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"seven"</literal></expr>, <expr><literal type="char">'7'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"eight"</literal></expr>, <expr><literal type="char">'8'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"nine"</literal></expr>, <expr><literal type="char">'9'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"colon"</literal></expr>, <expr><literal type="char">':'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"semicolon"</literal></expr>, <expr><literal type="char">';'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"less-than-sign"</literal></expr>, <expr><literal type="char">'&lt;'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"equals-sign"</literal></expr>, <expr><literal type="char">'='</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"greater-than-sign"</literal></expr>, <expr><literal type="char">'&gt;'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"question-mark"</literal></expr>, <expr><literal type="char">'?'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"commercial-at"</literal></expr>, <expr><literal type="char">'@'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"left-square-bracket"</literal></expr>, <expr><literal type="char">'['</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"backslash"</literal></expr>, <expr><literal type="char">'\\'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"reverse-solidus"</literal></expr>, <expr><literal type="char">'\\'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"right-square-bracket"</literal></expr>, <expr><literal type="char">']'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"circumflex"</literal></expr>, <expr><literal type="char">'^'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"circumflex-accent"</literal></expr>, <expr><literal type="char">'^'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"underscore"</literal></expr>, <expr><literal type="char">'_'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"low-line"</literal></expr>, <expr><literal type="char">'_'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"grave-accent"</literal></expr>, <expr><literal type="char">'`'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"left-brace"</literal></expr>, <expr><literal type="char">'{'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"left-curly-bracket"</literal></expr>, <expr><literal type="char">'{'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"vertical-line"</literal></expr>, <expr><literal type="char">'|'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"right-brace"</literal></expr>, <expr><literal type="char">'}'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"right-curly-bracket"</literal></expr>, <expr><literal type="char">'}'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"tilde"</literal></expr>, <expr><literal type="char">'~'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"DEL"</literal></expr>, <expr><literal type="char">'\177'</literal></expr>
	}</block></expr>,
	<expr><block>{
		<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>
	}</block></expr>
}</block></expr></init></decl>;</struct>

<comment type="block">/*
 * The following arrays define the valid character class names.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>classNames</name><index>[<expr><name>NUM_CCLASSES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"alnum"</literal></expr>, <expr><literal type="string">"alpha"</literal></expr>, <expr><literal type="string">"ascii"</literal></expr>, <expr><literal type="string">"blank"</literal></expr>, <expr><literal type="string">"cntrl"</literal></expr>, <expr><literal type="string">"digit"</literal></expr>, <expr><literal type="string">"graph"</literal></expr>,
	<expr><literal type="string">"lower"</literal></expr>, <expr><literal type="string">"print"</literal></expr>, <expr><literal type="string">"punct"</literal></expr>, <expr><literal type="string">"space"</literal></expr>, <expr><literal type="string">"upper"</literal></expr>, <expr><literal type="string">"xdigit"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<enum>enum <name>classes</name>
<block>{
	<decl><name>CC_ALNUM</name></decl>, <decl><name>CC_ALPHA</name></decl>, <decl><name>CC_ASCII</name></decl>, <decl><name>CC_BLANK</name></decl>, <decl><name>CC_CNTRL</name></decl>, <decl><name>CC_DIGIT</name></decl>, <decl><name>CC_GRAPH</name></decl>,
	<decl><name>CC_LOWER</name></decl>, <decl><name>CC_PRINT</name></decl>, <decl><name>CC_PUNCT</name></decl>, <decl><name>CC_SPACE</name></decl>, <decl><name>CC_UPPER</name></decl>, <decl><name>CC_XDIGIT</name></decl>
}</block>;</enum>

<comment type="block">/*
 * We do not use the hard-wired Unicode classification tables that Tcl does.
 * This is because (a) we need to deal with other encodings besides Unicode,
 * and (b) we want to track the behavior of the libc locale routines as
 * closely as possible.  For example, it wouldn't be unreasonable for a
 * locale to not consider every Unicode letter as a letter.  So we build
 * character classification cvecs by asking libc, even for Unicode.
 */</comment>


<comment type="block">/*
 * element - map collating-element name to chr
 */</comment>
<function><type><specifier>static</specifier> <name>chr</name></type>
<name>element</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,			<comment type="block">/* context */</comment>
		<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>startp</name></decl></parameter>,		<comment type="block">/* points to start of name */</comment>
		<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>)</parameter_list>		<comment type="block">/* points just past end of name */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>cname</name></name> <modifier>*</modifier></type><name>cn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* generic:  one-chr names stand for themselves */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>startp</name> <operator>&lt;</operator> <name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>endp</name> <operator>-</operator> <name>startp</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>startp</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>NOTE</name><argument_list>(<argument><expr><name>REG_ULOCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* search table */</comment>
	<for>for <control>(<init><expr><name>cn</name> <operator>=</operator> <name>cnames</name></expr>;</init> <condition><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cn</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator>
			<call><name>pg_char_and_wchar_strncmp</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>				<comment type="block">/* NOTE BREAK OUT */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>cn</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>CHR</name><argument_list>(<argument><expr><name><name>cn</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* couldn't find it */</comment>
	<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ECOLLATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * range - supply cvec for a range, including legality check
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type>
<name>range</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,			<comment type="block">/* context */</comment>
	  <parameter><decl><type><name>chr</name></type> <name>a</name></decl></parameter>,					<comment type="block">/* range start */</comment>
	  <parameter><decl><type><name>chr</name></type> <name>b</name></decl></parameter>,					<comment type="block">/* range end, might equal a */</comment>
	  <parameter><decl><type><name>int</name></type> <name>cases</name></decl></parameter>)</parameter_list>				<comment type="block">/* case-independent? */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name></type>			<name>c</name></decl>,
				<decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>!=</operator> <name>b</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>before</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ERANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cases</name></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* easy version */</comment>
		<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>cv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When case-independent, it's hard to decide when cvec ranges are usable,
	 * so for now at least, we won't try.  We use a range for the originally
	 * specified chrs and then add on any case-equivalents that are outside
	 * that range as individual chrs.
	 *
	 * To ensure sane behavior if someone specifies a very large range, limit
	 * the allocation size to 100000 chrs (arbitrary) and check for overrun
	 * inside the loop below.
	 */</comment>
	<expr_stmt><expr><name>nchrs</name> <operator>=</operator> <name>b</name> <operator>-</operator> <name>a</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nchrs</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nchrs</name> <operator>&gt;</operator> <literal type="number">100000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nchrs</name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>nchrs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>NOERRN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>a</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>b</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>pg_wc_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <name>c</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>before</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>before</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cv</name><operator>-&gt;</operator><name>nchrs</name></name> <operator>&gt;=</operator> <name><name>cv</name><operator>-&gt;</operator><name>chrspace</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>pg_wc_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <name>c</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>before</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>before</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cv</name><operator>-&gt;</operator><name>nchrs</name></name> <operator>&gt;=</operator> <name><name>cv</name><operator>-&gt;</operator><name>chrspace</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ETOOBIG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CANCEL_REQUESTED</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>cv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * before - is chr x before chr y, for purposes of range legality?
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* predicate */</comment>
<name>before</name><parameter_list>(<parameter><decl><type><name>chr</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>chr</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * eclass - supply cvec for an equivalence class
 * Must include case counterparts on request.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type>
<name>eclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,			<comment type="block">/* context */</comment>
	   <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>,					<comment type="block">/* Collating element representing the
								 * equivalence class. */</comment>
	   <parameter><decl><type><name>int</name></type> <name>cases</name></decl></parameter>)</parameter_list>				<comment type="block">/* all cases? */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl>;</decl_stmt>

	<comment type="block">/* crude fake equivalence class for testing */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_FAKE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><call><name>CHR</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><call><name>CHR</name><argument_list>(<argument><expr><literal type="char">'y'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cases</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><call><name>CHR</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><call><name>CHR</name><argument_list>(<argument><expr><literal type="char">'Y'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>cv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* otherwise, none */</comment>
	<if_stmt><if>if <condition>(<expr><name>cases</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>allcases</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>cv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cclass - supply cvec for a character class
 *
 * Must include case counterparts if "cases" is true.
 *
 * The returned cvec might be either a transient cvec gotten from getcvec(),
 * or a permanently cached one from pg_ctype_get_cache().  This is okay
 * because callers are not supposed to explicitly free the result either way.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type>
<name>cclass</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,			<comment type="block">/* context */</comment>
	   <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>startp</name></decl></parameter>,		<comment type="block">/* where the name starts */</comment>
	   <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>endp</name></decl></parameter>,			<comment type="block">/* just past the end of the name */</comment>
	   <parameter><decl><type><name>int</name></type> <name>cases</name></decl></parameter>)</parameter_list>				<comment type="block">/* case-independent? */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>namePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Map the name to the corresponding enumerated value.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>endp</name> <operator>-</operator> <name>startp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>namePtr</name> <operator>=</operator> <name>classNames</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>namePtr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>namePtr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>namePtr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator>
			<call><name>pg_char_and_wchar_strncmp</name><argument_list>(<argument><expr><operator>*</operator><name>namePtr</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ECTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remap lower and upper to alpha if the match is case insensitive.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>cases</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator>enum <name>classes</name><operator>)</operator> <name>index</name> <operator>==</operator> <name>CC_LOWER</name> <operator>||</operator>
		 <operator>(</operator>enum <name>classes</name><operator>)</operator> <name>index</name> <operator>==</operator> <name>CC_UPPER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>CC_ALPHA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now compute the character class contents.  For classes that are based
	 * on the behavior of a &lt;wctype.h&gt; or &lt;ctype.h&gt; function, we use
	 * pg_ctype_get_cache so that we can cache the results.  Other classes
	 * have definitions that are hard-wired here, and for those we just
	 * construct a transient cvec on the fly.
	 *
	 * NB: keep this code in sync with cclass_column_index(), below.
	 */</comment>

	<switch>switch <condition>(<expr><operator>(</operator>enum <name>classes</name><operator>)</operator> <name>index</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CC_PRINT</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isprint</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_ALNUM</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isalnum</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_ALPHA</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isalpha</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_ASCII</name></expr>:</case>
			<comment type="block">/* hard-wired meaning */</comment>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cv</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0x7f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_BLANK</name></expr>:</case>
			<comment type="block">/* hard-wired meaning */</comment>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_CNTRL</name></expr>:</case>
			<comment type="block">/* hard-wired meaning */</comment>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="number">0x0</literal></expr></argument>, <argument><expr><literal type="number">0x1f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="number">0x7f</literal></expr></argument>, <argument><expr><literal type="number">0x9f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_DIGIT</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isdigit</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_PUNCT</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_ispunct</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_XDIGIT</name></expr>:</case>

			<comment type="block">/*
			 * It's not clear how to define this in non-western locales, and
			 * even less clear that there's any particular use in trying. So
			 * just hard-wire the meaning.
			 */</comment>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cv</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><literal type="char">'9'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addrange</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><literal type="char">'F'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_SPACE</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isspace</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_LOWER</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_islower</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_UPPER</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isupper</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CC_GRAPH</name></expr>:</case>
			<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>pg_ctype_get_cache</name><argument_list>(<argument><expr><name>pg_wc_isgraph</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* If cv is NULL now, the reason must be "out of memory" */</comment>
	<if_stmt><if>if <condition>(<expr><name>cv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>cv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cclass_column_index - get appropriate high colormap column index for chr
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cclass_column_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>colormap</name></name> <modifier>*</modifier></type><name>cm</name></decl></parameter>, <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>colnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't go through all these pushups for simple chrs */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>&gt;</operator> <name>MAX_SIMPLE_CHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we should not see requests to consider cclasses that are not
	 * treated as locale-specific by cclass(), above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_PRINT</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_PRINT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_ALNUM</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_ALNUM</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_ALPHA</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_ALPHA</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_ASCII</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_BLANK</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_CNTRL</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_DIGIT</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_DIGIT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_PUNCT</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_ispunct</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_PUNCT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_XDIGIT</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_SPACE</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_SPACE</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_LOWER</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_LOWER</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_UPPER</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_UPPER</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_GRAPH</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>pg_wc_isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>colnum</name> <operator>|=</operator> <name><name>cm</name><operator>-&gt;</operator><name>classbits</name><index>[<expr><name>CC_GRAPH</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>colnum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * allcases - supply cvec for all case counterparts of a chr (including itself)
 *
 * This is a shortcut, preferably an efficient one, for simple characters;
 * messy cases are done via range().
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type>
<name>allcases</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vars</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,		<comment type="block">/* context */</comment>
		 <parameter><decl><type><name>chr</name></type> <name>c</name></decl></parameter>)</parameter_list>					<comment type="block">/* character to get case equivs of */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type><name>cv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name></type>			<name>lc</name></decl>,
				<decl><type ref="prev"/><name>uc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>pg_wc_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>uc</name> <operator>=</operator> <call><name>pg_wc_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>getcvec</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>uc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addchr</name><argument_list>(<argument><expr><name>cv</name></expr></argument>, <argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>cv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cmp - chr-substring compare
 *
 * Backrefs need this.  It should preferably be efficient.
 * Note that it does not need to report anything except equal/unequal.
 * Note also that the length is exact, and the comparison should not
 * stop at embedded NULs!
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* 0 for equal, nonzero for unequal */</comment>
<name>cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <comment type="block">/* strings to compare */</comment>
	<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>					<comment type="block">/* exact length of comparison */</comment>
<block>{<block_content>
	<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VS</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VS</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * casecmp - case-independent chr-substring compare
 *
 * REG_ICASE backrefs need this.  It should preferably be efficient.
 * Note that it does not need to report anything except equal/unequal.
 * Note also that the length is exact, and the comparison should not
 * stop at embedded NULs!
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>						<comment type="block">/* 0 for equal, nonzero for unequal */</comment>
<name>casecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>chr</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <comment type="block">/* strings to compare */</comment>
		<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>				<comment type="block">/* exact length of comparison */</comment>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>len</name><operator>--</operator></expr><operator>,</operator> <expr><name>x</name><operator>++</operator></expr><operator>,</operator> <expr><name>y</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>x</name> <operator>!=</operator> <operator>*</operator><name>y</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>pg_wc_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>pg_wc_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>y</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
