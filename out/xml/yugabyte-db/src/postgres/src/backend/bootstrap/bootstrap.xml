<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/bootstrap/bootstrap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * bootstrap.c
 *	  routines to support running postgres in 'bootstrap' mode
 *	bootstrap mode is used to create the initial template database
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/bootstrap/bootstrap.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/bootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/walwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/ybcbootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/ybccmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>uint32</name></type>		<name>bootstrap_data_checksum_version</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* No checksum */</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((t *) MemoryContextAllocZero(TopMemoryContext, (unsigned)(c) * sizeof(t)))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckerModeMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BootstrapModeMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bootstrap_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownAuxiliaryProcess</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Form_pg_attribute</name></type> <name>AllocateAttribute</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>gettype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------
 *		global variables
 * ----------------
 */</comment>

<decl_stmt><decl><type><name>AuxProcType</name></type> <name>MyAuxProcType</name> <init>= <expr><name>NotAnAuxProcess</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* declared in miscadmin.h */</comment>

<decl_stmt><decl><type><name>Relation</name></type>	<name>boot_reldesc</name></decl>;</decl_stmt>		<comment type="block">/* current relation descriptor */</comment>

<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name><name>attrtypes</name><index>[<expr><name>MAXATTR</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* points to attribute info */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>numattr</name></decl>;</decl_stmt>			<comment type="block">/* number of attributes for cur. rel */</comment>


<comment type="block">/*
 * Basic information associated with each type.  This is used before
 * pg_type is filled, so it has to cover the datatypes used as column types
 * in the core "bootstrapped" catalogs.
 *
 *		XXX several of these input/output functions do catalog scans
 *			(e.g., F_REGPROCIN scans pg_proc).  this obviously creates some
 *			order dependencies in the catalog creation process.
 */</comment>
<struct>struct <name>typinfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>byval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>align</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>storage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outproc</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>typinfo</name></name></type> <name><name>TypInfo</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"bool"</literal></expr>, <expr><name>BOOLOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_BOOLIN</name></expr>, <expr><name>F_BOOLOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"bytea"</literal></expr>, <expr><name>BYTEAOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_BYTEAIN</name></expr>, <expr><name>F_BYTEAOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"char"</literal></expr>, <expr><name>CHAROID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_CHARIN</name></expr>, <expr><name>F_CHAROUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"int2"</literal></expr>, <expr><name>INT2OID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_INT2IN</name></expr>, <expr><name>F_INT2OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"int4"</literal></expr>, <expr><name>INT4OID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_INT4IN</name></expr>, <expr><name>F_INT4OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"float4"</literal></expr>, <expr><name>FLOAT4OID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>FLOAT4PASSBYVAL</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_FLOAT4IN</name></expr>, <expr><name>F_FLOAT4OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"name"</literal></expr>, <expr><name>NAMEOID</name></expr>, <expr><name>CHAROID</name></expr>, <expr><name>NAMEDATALEN</name></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_NAMEIN</name></expr>, <expr><name>F_NAMEOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regclass"</literal></expr>, <expr><name>REGCLASSOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_REGCLASSIN</name></expr>, <expr><name>F_REGCLASSOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regproc"</literal></expr>, <expr><name>REGPROCOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_REGPROCIN</name></expr>, <expr><name>F_REGPROCOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regtype"</literal></expr>, <expr><name>REGTYPEOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_REGTYPEIN</name></expr>, <expr><name>F_REGTYPEOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regrole"</literal></expr>, <expr><name>REGROLEOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_REGROLEIN</name></expr>, <expr><name>F_REGROLEOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regnamespace"</literal></expr>, <expr><name>REGNAMESPACEOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_REGNAMESPACEIN</name></expr>, <expr><name>F_REGNAMESPACEOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"text"</literal></expr>, <expr><name>TEXTOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>DEFAULT_COLLATION_OID</name></expr>,
	<expr><name>F_TEXTIN</name></expr>, <expr><name>F_TEXTOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"oid"</literal></expr>, <expr><name>OIDOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_OIDIN</name></expr>, <expr><name>F_OIDOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tid"</literal></expr>, <expr><name>TIDOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_TIDIN</name></expr>, <expr><name>F_TIDOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"xid"</literal></expr>, <expr><name>XIDOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_XIDIN</name></expr>, <expr><name>F_XIDOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"cid"</literal></expr>, <expr><name>CIDOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>true</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_CIDIN</name></expr>, <expr><name>F_CIDOUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"pg_node_tree"</literal></expr>, <expr><name>PGNODETREEOID</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>DEFAULT_COLLATION_OID</name></expr>,
	<expr><name>F_PG_NODE_TREE_IN</name></expr>, <expr><name>F_PG_NODE_TREE_OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"int2vector"</literal></expr>, <expr><name>INT2VECTOROID</name></expr>, <expr><name>INT2OID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_INT2VECTORIN</name></expr>, <expr><name>F_INT2VECTOROUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"oidvector"</literal></expr>, <expr><name>OIDVECTOROID</name></expr>, <expr><name>OIDOID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_OIDVECTORIN</name></expr>, <expr><name>F_OIDVECTOROUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"_int4"</literal></expr>, <expr><name>INT4ARRAYOID</name></expr>, <expr><name>INT4OID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_ARRAY_IN</name></expr>, <expr><name>F_ARRAY_OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"_text"</literal></expr>, <expr><literal type="number">1009</literal></expr>, <expr><name>TEXTOID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>DEFAULT_COLLATION_OID</name></expr>,
	<expr><name>F_ARRAY_IN</name></expr>, <expr><name>F_ARRAY_OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"_oid"</literal></expr>, <expr><literal type="number">1028</literal></expr>, <expr><name>OIDOID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_ARRAY_IN</name></expr>, <expr><name>F_ARRAY_OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"_char"</literal></expr>, <expr><literal type="number">1002</literal></expr>, <expr><name>CHAROID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_ARRAY_IN</name></expr>, <expr><name>F_ARRAY_OUT</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"_aclitem"</literal></expr>, <expr><literal type="number">1034</literal></expr>, <expr><name>ACLITEMOID</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>false</name></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><name>InvalidOid</name></expr>,
	<expr><name>F_ARRAY_IN</name></expr>, <expr><name>F_ARRAY_OUT</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>n_types</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>TypInfo</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>typinfo</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<struct>struct <name>typmap</name>
<block>{								<comment type="block">/* a hack */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>am_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormData_pg_type</name></type> <name>am_typ</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>Typ</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier></type><name>Ap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Datum</name></type> <name><name>values</name><index>[<expr><name>MAXATTR</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* current row's attribute values */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>Nulls</name><index>[<expr><name>MAXATTR</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>nogc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* special no-gc mem context */</comment>

<comment type="block">/*
 *	At bootstrap time, we first declare all the indices to be built, and
 *	then build them.  The IndexList structure stores enough information
 *	to allow us to build the indices after they've been declared.
 */</comment>

<typedef>typedef <type><struct>struct <name>_IndexList</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>il_heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>il_ind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>il_info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>_IndexList</name></name> <modifier>*</modifier></type><name>il_next</name></decl>;</decl_stmt>
}</block></struct></type> <name>IndexList</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>IndexList</name> <modifier>*</modifier></type><name>ILHead</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 *	 AuxiliaryProcessMain
 *
 *	 The main entry point for auxiliary processes, such as the bgwriter,
 *	 walwriter, walreceiver, bootstrapper and the shared memory checker code.
 *
 *	 This code is here just because of historical reasons.
 */</comment>
<function><type><name>void</name></type>
<name>AuxiliaryProcessMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>progname</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>userDoption</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize process environment (already done if under postmaster, but
	 * not if standalone).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitStandaloneProcess</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * process command arguments
	 */</comment>

	<comment type="block">/* Set defaults, to be overridden by explicit options below */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeGUCOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ignore the initial --boot argument, if present */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--boot"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If no -x argument, we are a CheckerProcess */</comment>
	<expr_stmt><expr><name>MyAuxProcType</name> <operator>=</operator> <name>CheckerProcess</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>flag</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"B:c:d:D:Fkr:x:X:-:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>flag</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"shared_buffers"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'D'</literal></expr>:</case>
				<expr_stmt><expr><name>userDoption</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Turn on debugging for the bootstrap process. */</comment>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>debugstr</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>debugstr</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"debug%s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"log_min_messages"</literal></expr></argument>, <argument><expr><name>debugstr</name></expr></argument>,
									<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"client_min_messages"</literal></expr></argument>, <argument><expr><name>debugstr</name></expr></argument>,
									<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>debugstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'F'</literal></expr>:</case>
				<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"fsync"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'k'</literal></expr>:</case>
				<expr_stmt><expr><name>bootstrap_data_checksum_version</name> <operator>=</operator> <name>PG_DATA_CHECKSUM_VERSION</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
				<expr_stmt><expr><name>MyAuxProcType</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>WalSegSz</name> <init>= <expr><call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidWalSegSize</name><argument_list>(<argument><expr><name>WalSegSz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-X requires a power of two value between 1 MB and 1 GB"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"wal_segment_size"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>PGC_INTERNAL</name></expr></argument>,
									<argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"--%s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"-c %s requires a value"</literal></expr></argument>,
											<argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ARGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>,
							 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <name>optind</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: invalid command-line arguments\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Identify myself via ps
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statmsg</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>MyAuxProcType</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>StartupProcess</name></expr>:</case>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BgWriterProcess</name></expr>:</case>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_BG_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CheckpointerProcess</name></expr>:</case>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_CHECKPOINTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>WalWriterProcess</name></expr>:</case>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_WAL_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>WalReceiverProcess</name></expr>:</case>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_WAL_RECEIVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>statmsg</name> <operator>=</operator> <literal type="string">"??? process"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><name>statmsg</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Acquire configuration parameters, unless inherited from postmaster */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SelectConfigFiles</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Validate we have been given a reasonable-looking DataDir and change
	 * into it (if under postmaster, should be done already).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ChangeToDataDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If standalone, create lockfile for data directory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateDataDirLockFile</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>BootstrapProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>IgnoreSystemIndexes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize MaxBackends (if under postmaster, was done already) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitializeMaxBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When we are an auxiliary process, we aren't going to do the full
	 * InitPostgres pushups, but there are a couple of things that need to get
	 * lit up even in an auxiliary process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create a PGPROC so we can use LWLocks.  In the EXEC_BACKEND case,
		 * this was already done by SubPostmasterMain().
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<expr_stmt><expr><call><name>InitAuxiliaryProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Assign the ProcSignalSlot for an auxiliary process.  Since it
		 * doesn't have a BackendId, the slot is statically allocated based on
		 * the auxiliary process type (MyAuxProcType).  Backends use slots
		 * indexed in the range from 1 to MaxBackends (inclusive), so we use
		 * MaxBackends + AuxProcType + 1 as the index of the slot for an
		 * auxiliary process.
		 *
		 * This will need rethinking if we ever want more than one of a
		 * particular auxiliary process type.
		 */</comment>
		<expr_stmt><expr><call><name>ProcSignalInit</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>+</operator> <name>MyAuxProcType</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finish setting up bufmgr.c */</comment>
		<expr_stmt><expr><call><name>InitBufferPoolBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize backend status information */</comment>
		<expr_stmt><expr><call><name>pgstat_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* register a before-shutdown callback for LWLock cleanup */</comment>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>ShutdownAuxiliaryProcess</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XLOG operations
	 */</comment>
	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>MyAuxProcType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CheckerProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, they're useless here */</comment>
			<expr_stmt><expr><call><name>CheckerModeMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>BootstrapProcess</name></expr>:</case>

			<comment type="block">/*
			 * There was a brief instant during which mode was Normal; this is
			 * okay.  We need to be in bootstrap mode during BootStrapXLOG for
			 * the sake of multixact initialization.
			 */</comment>
			<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>BootstrapProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>bootstrap_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BootStrapXLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BootstrapModeMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>StartupProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, startup process has its own agenda */</comment>
			<expr_stmt><expr><call><name>StartupProcessMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>BgWriterProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, bgwriter has its own agenda */</comment>
			<expr_stmt><expr><call><name>BackgroundWriterMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>CheckpointerProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, checkpointer has its own agenda */</comment>
			<expr_stmt><expr><call><name>CheckpointerMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>WalWriterProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, walwriter has its own agenda */</comment>
			<expr_stmt><expr><call><name>InitXLOGAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WalWriterMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<case>case <expr><name>WalReceiverProcess</name></expr>:</case>
			<comment type="block">/* don't set signals, walreceiver has its own agenda */</comment>
			<expr_stmt><expr><call><name>WalReceiverMain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* should never return */</comment>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"unrecognized process type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MyAuxProcType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * In shared memory checker mode, all we really want to do is create shared
 * memory and semaphores (just to prove we can do it with the current GUC
 * settings).  Since, in fact, that was already done by BaseInit(),
 * we have nothing more to do here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckerModeMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	 The main entry point for running the backend in bootstrap mode
 *
 *	 The bootstrap mode is used to initialize the template database.
 *	 The bootstrap backend doesn't speak SQL, but instead expects
 *	 commands in a special bootstrap language.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BootstrapModeMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do backend-like initialization for bootstrap mode
	 */</comment>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize stuff for bootstrap-file processing */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXATTR</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>


	<comment type="block">/*
	 * In YugaByte we only need to create the template1 database
	 * (corresponding to creating the "base/1" subdir as its oid is hardcoded).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBCCreateDatabase</name><argument_list>(<argument><expr><name>TemplateDbOid</name></expr></argument>,
		                  <argument><expr><literal type="string">"template1"</literal></expr></argument>,
		                  <argument><expr><name>InvalidOid</name></expr></argument>,
		                  <argument><expr><name>FirstBootstrapObjectId</name></expr></argument>,
		                  <argument><expr><name>false</name></expr></argument> <comment type="block">/* colocated */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process bootstrap input.
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>boot_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We do not use a relation map file in YugaByte mode yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should now know about all mapped relations, so it's okay to write
		 * out the initial relation mapping files.
		 */</comment>
		<expr_stmt><expr><call><name>RelationMapFinishBootstrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up and exit */</comment>
	<expr_stmt><expr><call><name>cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *						misc functions
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Set up signal handling for a bootstrap process
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bootstrap_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up appropriately for interactive use */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Begin shutdown of an auxiliary process.  This is approximately the equivalent
 * of ShutdownPostgres() in postinit.c.  We can't run transactions in an
 * auxiliary process, so most of the work of AbortTransaction() is not needed,
 * but we do need to make sure we've released any LWLocks we are holding.
 * (This is only critical during an error exit.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownAuxiliaryProcess</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *				MANUAL BACKEND INTERACTIVE INTERFACE COMMANDS
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		boot_openrel
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>boot_openrel</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>relname</name><index>[<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Typ</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can now load the pg_type data */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>app</name> <operator>=</operator> <name>Typ</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>typmap</name> <operator>*</operator></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>app</name><operator>++</operator> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>typmap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>app</name> <operator>=</operator> <name>Typ</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_typ</name></name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_typ</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>app</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>boot_reldesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closerel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"open relation %s, attrsize %d"</literal></expr></argument>,
		 <argument><expr><name>relname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>boot_reldesc</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numattr</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>AllocateAttribute</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>boot_reldesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>at</name> <init>= <expr><name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"create attribute %d name %s len %d num %d type %u"</literal></expr></argument>,
				 <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>at</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
				 <argument><expr><name><name>at</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		closerel
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>closerel</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>boot_reldesc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"close of %s when %s was expected"</literal></expr></argument>,
					 <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"close of %s before any relation was opened"</literal></expr></argument>,
				 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>boot_reldesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no open relation to close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"close relation %s"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>boot_reldesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<comment type="block">/* ----------------
 * DEFINEATTR()
 *
 * define a &lt;field,type&gt; pair
 * if there are n fields in a relation to be created, this routine
 * will be called n times
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>DefineAttr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nullness</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>boot_reldesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"no open relations allowed with CREATE command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>closerel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>=</operator> <call><name>AllocateAttribute</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"column %s %s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attnum</name> <operator>=</operator> <name>attnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* fillatt */</comment>

	<expr_stmt><expr><name>typeoid</name> <operator>=</operator> <call><name>gettype</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Typ</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attbyval</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typstorage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcollation</name> <operator>=</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typcollation</name></name></expr>;</expr_stmt>
		<comment type="block">/* if an array type, assume 1-dimensional attribute */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typelem</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name><name>Ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attndims</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attndims</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attbyval</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>byval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attstorage</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>storage</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attalign</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>align</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcollation</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>collation</name></expr>;</expr_stmt>
		<comment type="block">/* if an array type, assume 1-dimensional attribute */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>TypInfo</name><index>[<expr><name>typeoid</name></expr>]</index></name><operator>.</operator><name>elem</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attndims</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attndims</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attstattarget</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nullness</name> <operator>==</operator> <name>BOOTCOL_NULL_FORCE_NOT_NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nullness</name> <operator>==</operator> <name>BOOTCOL_NULL_FORCE_NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nullness</name> <operator>==</operator> <name>BOOTCOL_NULL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark as "not null" if type is fixed-width and prior columns are
		 * too.  This corresponds to case where column can be accessed
		 * directly via C struct declaration.
		 *
		 * oidvector and int2vector are also treated as not-nullable, even
		 * though they are no longer fixed-width.
		 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARKNOTNULL</name><parameter_list>(<parameter><type><name>att</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>((att)-&gt;attlen &gt; 0 || \
		 (att)-&gt;atttypid == OIDVECTOROID || \
		 (att)-&gt;atttypid == INT2VECTOROID)</cpp:value></cpp:define>

		<if_stmt><if>if <condition>(<expr><call><name>MARKNOTNULL</name><argument_list>(<argument><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* check earlier attributes */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attrtypes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>attnum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>attrtypes</name><index>[<expr><name>attnum</name></expr>]</index></name><operator>-&gt;</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------
 *		InsertOneTuple
 *
 * If objectid is not zero, it is a specific OID to assign to the tuple.
 * Otherwise, an OID will be assigned (if necessary) by heap_insert.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>InsertOneTuple</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objectid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"inserting row oid %u, %d columns"</literal></expr></argument>, <argument><expr><name>objectid</name></expr></argument>, <argument><expr><name>numattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>CreateTupleDesc</name><argument_list>(<argument><expr><name>numattr</name></expr></argument>,
							  <argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relhasoids</name></expr></argument>,
							  <argument><expr><name>attrtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>Nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>objectid</name> <operator>!=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>objectid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBCExecuteInsert</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>ONCONFLICT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>simple_heap_insert</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* just free's tupDesc, not the attrtypes */</comment>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"row inserted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset null markers for next tuple
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numattr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>Nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		InsertOneValue
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>InsertOneValue</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typdelim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>MAXATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"inserting column %d value \"%s\""</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>boot_reldesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>boot_get_type_io_data</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typinput</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use ereport not elog here so that parameters aren't evaluated unless
	 * the message is going to be printed, which generally it isn't
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"inserted -&gt; %s"</literal></expr></argument>,
							 <argument><expr><call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		InsertOneNull
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>InsertOneNull</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"inserting column %d NULL"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>MAXATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>boot_reldesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attnotnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"NULL value specified for not-null column \"%s\" of relation \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>boot_reldesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>boot_reldesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		cleanup
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>boot_reldesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closerel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		gettype
 *
 * NB: this is really ugly; it will return an integer index into TypInfo[],
 * and not an OID at all, until the first reference to a type not known in
 * TypInfo[].  At that point it will read and cache pg_type in the Typ array,
 * and subsequently return a real OID (and set the global pointer Ap to
 * point at the found row in Typ).  So caller must check whether Typ is
 * still NULL to determine what the return value is!
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>gettype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Typ</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>app</name> <operator>=</operator> <name>Typ</name></expr>;</init> <condition><expr><operator>*</operator><name>app</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>app</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name><name>am_typ</name><operator>.</operator><name>typname</name></name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>Ap</name> <operator>=</operator> <operator>*</operator><name>app</name></expr>;</expr_stmt>
				<return>return <expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_oid</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_types</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>TypInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"external type: %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>app</name> <operator>=</operator> <name>Typ</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>typmap</name> <operator>*</operator></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>app</name><operator>++</operator> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>typmap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>app</name> <operator>=</operator> <name>Typ</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><operator>*</operator><name>app</name><operator>++</operator><operator>)</operator><operator>-&gt;</operator><name>am_typ</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_typ</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>gettype</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized type \"%s\""</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* not reached, here to make compiler happy */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		boot_get_type_io_data
 *
 * Obtain type I/O information at bootstrap time.  This intentionally has
 * almost the same API as lsyscache.c's get_type_io_data, except that
 * we only support obtaining the typinput and typoutput routines, not
 * the binary I/O routines.  It is exported so that array_in and array_out
 * can be made to work during early bootstrap.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>boot_get_type_io_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typalign</name></decl></parameter>,
					  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typdelim</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparam</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typinput</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typoutput</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Typ</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have the boot-time contents of pg_type, so use it */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>typmap</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>app</name> <operator>=</operator> <name>Typ</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>app</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>app</name><operator>)</operator><operator>-&gt;</operator><name>am_oid</name></name> <operator>!=</operator> <name>typid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name>app</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>ap</name> <operator>=</operator> <operator>*</operator><name>app</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type OID %u not found in Typ list"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typdelim</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typdelim</name></name></expr>;</expr_stmt>

		<comment type="block">/* XXX this logic must match getTypeIOParam() */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typelem</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>typinput</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typinput</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typoutput</name> <operator>=</operator> <name><name>ap</name><operator>-&gt;</operator><name>am_typ</name><operator>.</operator><name>typoutput</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We don't have pg_type yet, so use the hard-wired TypInfo array */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>typeindex</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>typeindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>typeindex</name> <operator>&lt;</operator> <name>n_types</name></expr>;</condition> <incr><expr><name>typeindex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>oid</name> <operator>==</operator> <name>typid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>typeindex</name> <operator>&gt;=</operator> <name>n_types</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type OID %u not found in TypInfo"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>byval</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>align</name></expr>;</expr_stmt>
		<comment type="block">/* We assume typdelim is ',' for all boot-time types */</comment>
		<expr_stmt><expr><operator>*</operator><name>typdelim</name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>

		<comment type="block">/* XXX this logic must match getTypeIOParam() */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>elem</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>typinput</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>inproc</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typoutput</name> <operator>=</operator> <name><name>TypInfo</name><index>[<expr><name>typeindex</name></expr>]</index></name><operator>.</operator><name>outproc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		AllocateAttribute
 *
 * Note: bootstrap never sets any per-column ACLs, so we only need
 * ATTRIBUTE_FIXED_PART_SIZE space per attribute.
 * ----------------
 */</comment>
<function><type><specifier>static</specifier> <name>Form_pg_attribute</name></type>
<name>AllocateAttribute</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	index_register() -- record an index that has been set up for building
 *						later.
 *
 *		At bootstrap time, we define a bunch of indexes on system catalogs.
 *		We postpone actually building the indexes until just before we're
 *		finished with initialization, however.  This is because the indexes
 *		themselves have catalog entries, and those have to be included in the
 *		indexes on those catalogs.  Doing it in two phases is the simplest
 *		way of making sure the indexes have the right contents at the end.
 */</comment>
<function><type><name>void</name></type>
<name>index_register</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heap</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>ind</name></decl></parameter>,
			   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexList</name>  <modifier>*</modifier></type><name>newind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX mao 10/31/92 -- don't gc index reldescs, associated info at
	 * bootstrap time.  we'll declare the indexes now, but want to create them
	 * later.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>nogc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nogc</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><literal type="string">"BootstrapNoGC"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>nogc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newind</name> <operator>=</operator> <operator>(</operator><name>IndexList</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_ind</name></name> <operator>=</operator> <name>ind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name></name> <operator>=</operator> <operator>(</operator><name>IndexInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name></name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* expressions will likely be null, but may as well copy it */</comment>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator>
		<call><name>copyObject</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* predicate will likely be null, but may as well copy it */</comment>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>=</operator>
		<call><name>copyObject</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_info</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* no exclusion constraints at bootstrap time, so no need to copy */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newind</name><operator>-&gt;</operator><name>il_next</name></name> <operator>=</operator> <name>ILHead</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ILHead</name> <operator>=</operator> <name>newind</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * build_indices -- fill in all the indexes registered earlier
 */</comment>
<function><type><name>void</name></type>
<name>build_indices</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><name>ILHead</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ILHead</name> <operator>=</operator> <name><name>ILHead</name><operator>-&gt;</operator><name>il_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>heap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>ind</name></decl>;</decl_stmt>

		<comment type="block">/* need not bother with locks during bootstrap */</comment>
		<expr_stmt><expr><name>heap</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>ILHead</name><operator>-&gt;</operator><name>il_heap</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>ILHead</name><operator>-&gt;</operator><name>il_ind</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_build</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>ind</name></expr></argument>, <argument><expr><name><name>ILHead</name><operator>-&gt;</operator><name>il_info</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>ind</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
