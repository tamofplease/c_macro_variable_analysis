<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/nodes/makefuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * makefuncs.c
 *	  creator functions for primitive nodes. The functions here are for
 *	  the most frequently created nodes.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/makefuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>

<comment type="block">/*
 * makeA_Expr -
 *		makes an A_Expr node
 */</comment>
<function><type><name>A_Expr</name> <modifier>*</modifier></type>
<name>makeA_Expr</name><parameter_list>(<parameter><decl><type><name>A_Expr_Kind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
		   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>lexpr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rexpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>=</operator> <name>lexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>=</operator> <name>rexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeSimpleA_Expr -
 *		As above, given a simple (unqualified) operator name
 */</comment>
<function><type><name>A_Expr</name> <modifier>*</modifier></type>
<name>makeSimpleA_Expr</name><parameter_list>(<parameter><decl><type><name>A_Expr_Kind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>lexpr</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rexpr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>=</operator> <name>lexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>=</operator> <name>rexpr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeVar -
 *	  creates a Var node
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>makeVar</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
		<parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>,
		<parameter><decl><type><name>Oid</name></type> <name>vartype</name></decl></parameter>,
		<parameter><decl><type><name>int32</name></type> <name>vartypmod</name></decl></parameter>,
		<parameter><decl><type><name>Oid</name></type> <name>varcollid</name></decl></parameter>,
		<parameter><decl><type><name>Index</name></type> <name>varlevelsup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>vartype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <name>vartypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>=</operator> <name>varcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <name>varlevelsup</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since few if any routines ever create Var nodes with varnoold/varoattno
	 * different from varno/varattno, we don't provide separate arguments for
	 * them, but just initialize them to the given varno/varattno. This
	 * reduces code clutter and chance of error for most callers.
	 */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>

	<comment type="block">/* Likewise, we just set location to "unknown" here */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeVarFromTargetEntry -
 *		convenience function to create a same-level Var node from a
 *		TargetEntry
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>makeVarFromTargetEntry</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
					   <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
				   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
				   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeWholeRowVar -
 *	  creates a Var node representing a whole row of the specified RTE
 *
 * A whole-row reference is a Var with varno set to the correct range
 * table entry, and varattno == 0 to signal that it references the whole
 * tuple.  (Use of zero here is unclean, since it could easily be confused
 * with error cases, but it's not worth changing now.)  The vartype indicates
 * a rowtype; either a named composite type, or a domain over a named
 * composite type (only possible if the RTE is a function returning that),
 * or RECORD.  This function encapsulates the logic for determining the
 * correct rowtype OID to use.
 *
 * If allowScalar is true, then for the case where the RTE is a single function
 * returning a non-composite result type, we produce a normal Var referencing
 * the function's result directly, instead of the single-column composite
 * value that the whole-row notation might otherwise suggest.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>makeWholeRowVar</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
				<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
				<parameter><decl><type><name>Index</name></type> <name>varlevelsup</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>allowScalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<comment type="block">/* relation: the rowtype is a named composite type */</comment>
			<expr_stmt><expr><name>toid</name> <operator>=</operator> <call><name>get_rel_type_id</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find type OID for relation %u"</literal></expr></argument>,
					 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
							 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
							 <argument><expr><name>toid</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>

			<comment type="block">/*
			 * If there's more than one function, or ordinality is requested,
			 * force a RECORD result, since there's certainly more than one
			 * column involved and it can't be a known named type.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* always produces an anonymous RECORD result */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
								 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
								 <argument><expr><name>RECORDOID</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>fexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>funcexpr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>toid</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>toid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* func returns composite; same as relation case */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
								 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
								 <argument><expr><name>toid</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>allowScalar</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* func returns scalar; just return its output as-is */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
								 <argument><expr><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>toid</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* func returns scalar, but we want a composite result */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
								 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
								 <argument><expr><name>RECORDOID</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/*
			 * RTE is a join, subselect, tablefunc, or VALUES.  We represent
			 * this as a whole-row Var of RECORD type. (Note that in most
			 * cases the Var will be expanded to a RowExpr during planning,
			 * but that is not our concern here.)
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
							 <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
							 <argument><expr><name>RECORDOID</name></expr></argument>,
							 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeTargetEntry -
 *	  creates a TargetEntry node
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>makeTargetEntry</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				<parameter><decl><type><name>AttrNumber</name></type> <name>resno</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>resjunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name>resname</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always set these fields to 0. If the caller wants to change them he
	 * must do so explicitly.  Few callers do that, so omitting these
	 * arguments reduces the chance of error.
	 */</comment>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>resjunk</name></expr>;</expr_stmt>

	<return>return <expr><name>tle</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * flatCopyTargetEntry -
 *	  duplicate a TargetEntry, but don't copy substructure
 *
 * This is commonly used when we just want to modify the resno or substitute
 * a new expression.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>flatCopyTargetEntry</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>src_tle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>src_tle</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>src_tle</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tle</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeFromExpr -
 *	  creates a FromExpr node
 */</comment>
<function><type><name>FromExpr</name> <modifier>*</modifier></type>
<name>makeFromExpr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fromlist</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <name>fromlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
	<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeConst -
 *	  creates a Const node
 */</comment>
<function><type><name>Const</name> <modifier>*</modifier></type>
<name>makeConst</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>consttype</name></decl></parameter>,
		  <parameter><decl><type><name>int32</name></type> <name>consttypmod</name></decl></parameter>,
		  <parameter><decl><type><name>Oid</name></type> <name>constcollid</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>constlen</name></decl></parameter>,
		  <parameter><decl><type><name>Datum</name></type> <name>constvalue</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>constisnull</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>constbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>cnst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a varlena value, force it to be in non-expanded (non-toasted)
	 * format; this avoids any possible dependency on external values and
	 * improves consistency of representation, which is important for equal().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>constisnull</name> <operator>&amp;&amp;</operator> <name>constlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>constvalue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>constvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>consttype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <name>consttypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>=</operator> <name>constcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <name>constlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name>constvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>constisnull</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>constbyval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cnst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* "unknown" */</comment>

	<return>return <expr><name>cnst</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeNullConst -
 *	  creates a Const node representing a NULL of the specified type/typmod
 *
 * This is a convenience routine that just saves a lookup of the type's
 * storage properties.
 */</comment>
<function><type><name>Const</name> <modifier>*</modifier></type>
<name>makeNullConst</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>consttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consttypmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constcollid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>,
					 <argument><expr><name>consttypmod</name></expr></argument>,
					 <argument><expr><name>constcollid</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>typLen</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
					 <argument><expr><name>true</name></expr></argument>,
					 <argument><expr><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeBoolConst -
 *	  creates a Const node representing a boolean value (can be NULL too)
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>makeBoolConst</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* note that pg_type.h hardwires size of bool as 1 ... duplicate it */</comment>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							  <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeBoolExpr -
 *	  creates a BoolExpr node
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>makeBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExprType</name></type> <name>boolop</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>boolop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeAlias -
 *	  creates an Alias node
 *
 * NOTE: the given name is copied, but the colnames list (if any) isn't.
 */</comment>
<function><type><name>Alias</name> <modifier>*</modifier></type>
<name>makeAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Alias</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>colnames</name></expr>;</expr_stmt>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeRelabelType -
 *	  creates a RelabelType node
 */</comment>
<function><type><name>RelabelType</name> <modifier>*</modifier></type>
<name>makeRelabelType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>rtypmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rcollid</name></decl></parameter>,
				<parameter><decl><type><name>CoercionForm</name></type> <name>rformat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>rtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name>rtypmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>rcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name>rformat</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeRangeVar -
 *	  creates a RangeVar node (rather oversimplified case)
 */</comment>
<function><type><name>RangeVar</name> <modifier>*</modifier></type>
<name>makeRangeVar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>schemaname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>relname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeTypeName -
 *	build a TypeName node for an unqualified name.
 *
 * typmod is defaulted, but can be changed later by caller.
 */</comment>
<function><type><name>TypeName</name> <modifier>*</modifier></type>
<name>makeTypeName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typnam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>typnam</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeTypeNameFromNameList -
 *	build a TypeName node for a String list representing a qualified name.
 *
 * typmod is defaulted, but can be changed later by caller.
 */</comment>
<function><type><name>TypeName</name> <modifier>*</modifier></type>
<name>makeTypeNameFromNameList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typemod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeTypeNameFromOid -
 *	build a TypeName node to represent a type already known by OID/typmod.
 */</comment>
<function><type><name>TypeName</name> <modifier>*</modifier></type>
<name>makeTypeNameFromOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>typeOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typemod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeColumnDef -
 *	build a ColumnDef node to represent a simple column definition.
 *
 * Type and collation are specified by OID.
 * Other properties are all basic to start with.
 */</comment>
<function><type><name>ColumnDef</name> <modifier>*</modifier></type>
<name>makeColumnDef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name>collOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>fdwoptions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeFuncExpr -
 *	build an expression tree representing a function call.
 *
 * The argument expressions must have been transformed already.
 */</comment>
<function><type><name>FuncExpr</name> <modifier>*</modifier></type>
<name>makeFuncExpr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rettype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>funccollid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>CoercionForm</name></type> <name>fformat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* only allowed case here */</comment>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* only allowed case here */</comment>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name>fformat</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>funccollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name>inputcollid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>funcexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeDefElem -
 *	build a DefElem node
 *
 * This is sufficient for the "typical" case with an unqualified option name
 * and no special action.
 */</comment>
<function><type><name>DefElem</name> <modifier>*</modifier></type>
<name>makeDefElem</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defname</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defaction</name></name> <operator>=</operator> <name>DEFELEM_UNSPEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeDefElemExtended -
 *	build a DefElem node with all fields available to be specified
 */</comment>
<function><type><name>DefElem</name> <modifier>*</modifier></type>
<name>makeDefElemExtended</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nameSpace</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
					<parameter><decl><type><name>DefElemAction</name></type> <name>defaction</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>=</operator> <name>nameSpace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defname</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>defaction</name></name> <operator>=</operator> <name>defaction</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeFuncCall -
 *
 * Initialize a FuncCall struct with the information every caller must
 * supply.  Any non-default parameters have to be inserted by the caller.
 */</comment>
<function><type><name>FuncCall</name> <modifier>*</modifier></type>
<name>makeFuncCall</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncCall</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>agg_order</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>agg_filter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>agg_within_group</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>agg_star</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>agg_distinct</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>func_variadic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>over</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeGroupingSet
 *
 */</comment>
<function><type><name>GroupingSet</name> <modifier>*</modifier></type>
<name>makeGroupingSet</name><parameter_list>(<parameter><decl><type><name>GroupingSetKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>content</name></name> <operator>=</operator> <name>content</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeVacuumRelation -
 *	  create a VacuumRelation node
 */</comment>
<function><type><name>VacuumRelation</name> <modifier>*</modifier></type>
<name>makeVacuumRelation</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>va_cols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>va_cols</name></name> <operator>=</operator> <name>va_cols</name></expr>;</expr_stmt>
	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>
</unit>
