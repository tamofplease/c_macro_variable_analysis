<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/catalog/aclchk.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * aclchk.c
 *	  Routines to check access control permissions.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/aclchk.c
 *
 * NOTES
 *	  See acl.h.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_cast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_init_privs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_yb_tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/aclchk_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Internal format used by ALTER DEFAULT PRIVILEGES.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name></decl>;</decl_stmt>			<comment type="block">/* owning role */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>			<comment type="block">/* namespace, or InvalidOid if none */</comment>
	<comment type="block">/* remaining fields are same as in InternalGrant: */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_grant</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_privs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>privileges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grantees</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>grant_option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl>;</decl_stmt>
}</block></struct></type> <name>InternalDefaultACL</name>;</typedef>

<comment type="block">/*
 * When performing a binary-upgrade, pg_dump will call a function to set
 * this variable to let us know that we need to populate the pg_init_privs
 * table for the GRANT/REVOKE commands while this variable is set to true.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>binary_upgrade_record_init_privs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrantStmt_oids</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Relation</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Database</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Fdw</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_ForeignServer</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Function</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Language</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Largeobject</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Namespace</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Tablegroup</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Tablespace</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecGrant_Type</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetDefaultACLsInSchemas</name><parameter_list>(<parameter><decl><type><name>InternalDefaultACL</name> <modifier>*</modifier></type><name>iacls</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetDefaultACL</name><parameter_list>(<parameter><decl><type><name>InternalDefaultACL</name> <modifier>*</modifier></type><name>iacls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>objectNamesToOids</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>objectsInSchemaToOids</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspnames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>getRelationsInNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_col_privileges</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name></type> <name>this_privileges</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name> <modifier>*</modifier></type><name>col_privileges</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>num_col_privileges</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_all_col_privileges</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>this_privileges</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name> <modifier>*</modifier></type><name>col_privileges</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>num_col_privileges</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AclMode</name></type> <name>string_to_privilege</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>privname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>privilege_to_string</name><parameter_list>(<parameter><decl><type><name>AclMode</name></type> <name>privilege</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AclMode</name></type> <name>restrict_and_check_grant</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_grant</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>avail_goptions</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>all_privs</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>privileges</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>grantorId</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
						 <parameter><decl><type><name>AttrNumber</name></type> <name>att_number</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AclMode</name></type> <name>pg_aclmask</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recordExtensionInitPriv</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>objsubid</name></decl></parameter>,
						<parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recordExtensionInitPrivWorker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>objsubid</name></decl></parameter>,
							  <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>YbCheckAclCopiesEqual</name><parameter_list>(<parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>old_acl</name></decl></parameter>, <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACLDEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpacl</name><parameter_list>(<parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclItem</name>    <modifier>*</modifier></type><name>aip</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"acl size = %d, # acls = %d"</literal></expr></argument>,
		 <argument><expr><call><name>ACL_SIZE</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>aip</name> <operator>=</operator> <call><name>ACL_DAT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ACL_NUM</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"	acl[%d]: %s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
			 <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>aclitemout</name></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>aip</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ACLDEBUG */</comment>


<comment type="block">/*
 * If is_grant is true, adds the given privileges for the list of
 * grantees to the existing old_acl.  If is_grant is false, the
 * privileges for the given grantees are removed from old_acl.
 *
 * NB: the original old_acl is pfree'd.
 */</comment>
<function><type><specifier>static</specifier> <name>Acl</name> <modifier>*</modifier></type>
<name>merge_acl_with_grant</name><parameter_list>(<parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>old_acl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_grant</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>grant_option</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grantees</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>privileges</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>grantorId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>modechg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>modechg</name> <operator>=</operator> <ternary><condition><expr><name>is_grant</name></expr> ?</condition><then> <expr><name>ACL_MODECHG_ADD</name></expr> </then><else>: <expr><name>ACL_MODECHG_DEL</name></expr></else></ternary></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACLDEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>dumpacl</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <name>old_acl</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>grantees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclItem</name></type>		<name>aclitem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>newer_acl</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>aclitem</name><operator>.</operator><name>ai_grantee</name></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Grant options can only be granted to individual roles, not PUBLIC.
		 * The reason is that if a user would re-grant a privilege that he
		 * held through PUBLIC, and later the user is removed, the situation
		 * is impossible to clean up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_grant</name> <operator>&amp;&amp;</operator> <name>grant_option</name> <operator>&amp;&amp;</operator> <name><name>aclitem</name><operator>.</operator><name>ai_grantee</name></name> <operator>==</operator> <name>ACL_ID_PUBLIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"grant options can only be granted to roles"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>aclitem</name><operator>.</operator><name>ai_grantor</name></name> <operator>=</operator> <name>grantorId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The asymmetry in the conditions here comes from the spec.  In
		 * GRANT, the grant_option flag signals WITH GRANT OPTION, which means
		 * to grant both the basic privilege and its grant option. But in
		 * REVOKE, plain revoke revokes both the basic privilege and its grant
		 * option, while REVOKE GRANT OPTION revokes only the option.
		 */</comment>
		<expr_stmt><expr><call><name>ACLITEM_SET_PRIVS_GOPTIONS</name><argument_list>(<argument><expr><name>aclitem</name></expr></argument>,
								   <argument><expr><ternary><condition><expr><operator>(</operator><name>is_grant</name> <operator>||</operator> <operator>!</operator><name>grant_option</name><operator>)</operator></expr> ?</condition><then> <expr><name>privileges</name></expr> </then><else>: <expr><name>ACL_NO_RIGHTS</name></expr></else></ternary></expr></argument>,
								   <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>is_grant</name> <operator>||</operator> <name>grant_option</name><operator>)</operator></expr> ?</condition><then> <expr><name>privileges</name></expr> </then><else>: <expr><name>ACL_NO_RIGHTS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newer_acl</name> <operator>=</operator> <call><name>aclupdate</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aclitem</name></expr></argument>, <argument><expr><name>modechg</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* avoid memory leak when there are many grantees */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <name>newer_acl</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACLDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>dumpacl</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>

	<return>return <expr><name>new_acl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restrict the privileges to what we can actually grant, and emit
 * the standards-mandated warning and error messages.
 */</comment>
<function><type><specifier>static</specifier> <name>AclMode</name></type>
<name>restrict_and_check_grant</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_grant</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>avail_goptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>all_privs</name></decl></parameter>,
						 <parameter><decl><type><name>AclMode</name></type> <name>privileges</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>grantorId</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objname</name></decl></parameter>,
						 <parameter><decl><type><name>AttrNumber</name></type> <name>att_number</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>whole_mask</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_COLUMN</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_RELATION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_DATABASE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LANGUAGE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LARGEOBJECT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLEGROUP</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLESPACE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FDW</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FOREIGN_SERVER</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"grantable rights not supported for event triggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached, but keep compiler quiet */</comment>
			<return>return <expr><name>ACL_NO_RIGHTS</name></expr>;</return>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>whole_mask</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached, but keep compiler quiet */</comment>
			<return>return <expr><name>ACL_NO_RIGHTS</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If we found no grant options, consider whether to issue a hard error.
	 * Per spec, having any privilege at all on the object will get you by
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>avail_goptions</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_aclmask</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>att_number</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>,
					   <argument><expr><name>whole_mask</name> <operator>|</operator> <call><name>ACL_GRANT_OPTION_FOR</name><argument_list>(<argument><expr><name>whole_mask</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator> <name>colname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error_col</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NO_PRIV</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Restrict the operation to what we can actually grant or revoke, and
	 * issue a warning if appropriate.  (For REVOKE this isn't quite what the
	 * spec says to do: the spec seems to want a warning only if no privilege
	 * bits actually change in the ACL. In practice that behavior seems much
	 * too noisy, as well as inconsistent with the GRANT case.)
	 */</comment>
	<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>privileges</name> <operator>&amp;</operator> <call><name>ACL_OPTION_TO_PRIVS</name><argument_list>(<argument><expr><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_grant</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator> <name>colname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no privileges were granted for column \"%s\" of relation \"%s\""</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no privileges were granted for \"%s\""</literal></expr></argument>,
								<argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>all_privs</name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>!=</operator> <name>privileges</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator> <name>colname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not all privileges were granted for column \"%s\" of relation \"%s\""</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not all privileges were granted for \"%s\""</literal></expr></argument>,
								<argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator> <name>colname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no privileges could be revoked for column \"%s\" of relation \"%s\""</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no privileges could be revoked for \"%s\""</literal></expr></argument>,
								<argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>all_privs</name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>!=</operator> <name>privileges</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator> <name>colname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not all privileges could be revoked for column \"%s\" of relation \"%s\""</literal></expr></argument>,
								<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not all privileges could be revoked for \"%s\""</literal></expr></argument>,
								<argument><expr><name>objname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>this_privileges</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Called to execute the utility commands GRANT and REVOKE
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteGrantStmt</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InternalGrant</name></type> <name>istmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>all_privileges</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Turn the regular GrantStmt into the InternalGrant form.
	 */</comment>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>is_grant</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>;</expr_stmt>

	<comment type="block">/* Collect the OIDs of the target objects */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACL_TARGET_OBJECT</name></expr>:</case>
			<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objects</name></name> <operator>=</operator> <call><name>objectNamesToOids</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objects</name></name> <operator>=</operator> <call><name>objectsInSchemaToOids</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<comment type="block">/* ACL_TARGET_DEFAULTS should not be seen here */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.targtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* all_privs to be filled below */</comment>
	<comment type="block">/* privileges to be filled below */</comment>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>col_privs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* may get filled below */</comment>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* filled below */</comment>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>grant_option</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>behavior</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert the RoleSpec list into an Oid list.  Note that at this point we
	 * insert an ACL_ID_PUBLIC into the list if appropriate, so downstream
	 * there shouldn't be any additional work needed to support this case.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;grantees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>grantee</name> <init>= <expr><operator>(</operator><name>RoleSpec</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantee_uid</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>roletype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ROLESPEC_PUBLIC</name></expr>:</case>
				<expr_stmt><expr><name>grantee_uid</name> <operator>=</operator> <name>ACL_ID_PUBLIC</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>grantee_uid</name> <operator>=</operator> <call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>istmt</name><operator>.</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>grantee_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Convert stmt-&gt;privileges, a list of AccessPriv nodes, into an AclMode
	 * bitmask.  Note: objtype can't be OBJECT_COLUMN.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>

			<comment type="block">/*
			 * Because this might be a sequence, we test both relation and
			 * sequence bits, and later do a more limited test when we know
			 * the object type.
			 */</comment>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_RELATION</name> <operator>|</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_DATABASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for domain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LANGUAGE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for language"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LARGEOBJECT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for large object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for procedure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for routine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLEGROUP</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for tablegroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLESPACE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FDW</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for foreign-data wrapper"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FOREIGN_SERVER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for foreign server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * will be turned into ACL_ALL_RIGHTS_* by the internal routines
		 * depending on the object type
		 */</comment>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;privileges</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>privnode</name> <init>= <expr><operator>(</operator><name>AccessPriv</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AclMode</name></type>		<name>priv</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If it's a column-level specification, we just set it aside in
			 * col_privs for the moment; but insist it's for a relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>privnode</name><operator>-&gt;</operator><name>cols</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>!=</operator> <name>OBJECT_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column privileges are only valid for relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>col_privs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>istmt</name><operator>.</operator><name>col_privs</name></name></expr></argument>, <argument><expr><name>privnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>privnode</name><operator>-&gt;</operator><name>priv_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* parser mistake? */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AccessPriv node must specify privilege or columns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>priv</name> <operator>=</operator> <call><name>string_to_privilege</name><argument_list>(<argument><expr><name><name>privnode</name><operator>-&gt;</operator><name>priv_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>priv</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>all_privileges</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>, <argument><expr><call><name>privilege_to_string</name><argument_list>(<argument><expr><name>priv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>privileges</name></name> <operator>|=</operator> <name>priv</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExecGrantStmt_oids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecGrantStmt_oids
 *
 * Internal entry point for granting and revoking privileges.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrantStmt_oids</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Relation</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Database</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Type</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Fdw</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_ForeignServer</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Function</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Language</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Largeobject</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Namespace</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Tablegroup</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<expr_stmt><expr><call><name>ExecGrant_Tablespace</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Pass the info to event triggers about the just-executed GRANT.  Note
	 * that we prefer to do it after actually executing it, because that gives
	 * the functions a chance to adjust the istmt with privileges actually
	 * granted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>EventTriggerSupportsObjectType</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EventTriggerCollectGrant</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * objectNamesToOids
 *
 * Turn a list of object names of a given type into an Oid list.
 *
 * XXX: This function doesn't take any sort of locks on the objects whose
 * names it looks up.  In the face of concurrent DDL, we might easily latch
 * onto an old version of an object, causing the GRANT or REVOKE statement
 * to fail.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>objectNamesToOids</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>objects</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>objnames</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relvar</name> <init>= <expr><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>relOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dbname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>dbid</name> <operator>=</operator> <call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>typname</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>ObjectWithArgs</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>funcid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>langname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>get_language_oid</name><argument_list>(<argument><expr><name>langname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjOid</name> <init>= <expr><call><name>oidparse</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LargeObjectExists</name><argument_list>(<argument><expr><name>lobjOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object %u does not exist"</literal></expr></argument>,
									<argument><expr><name>lobjOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>lobjOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>ObjectWithArgs</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>procid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>procid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_PROCEDURE</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>procid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>ObjectWithArgs</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>routid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>routid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>OBJECT_ROUTINE</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>routid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>grpname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>				<name>grpoid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>grpoid</name> <operator>=</operator> <call><name>get_tablegroup_oid</name><argument_list>(<argument><expr><name>grpname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>grpoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>spcname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>spcoid</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>spcoid</name> <operator>=</operator> <call><name>get_tablespace_oid</name><argument_list>(<argument><expr><name>spcname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>spcoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fdwname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>fdwid</name> <init>= <expr><call><name>get_foreign_data_wrapper_oid</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>fdwid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>objnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srvname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>srvid</name> <init>= <expr><call><name>get_foreign_server_oid</name><argument_list>(<argument><expr><name>srvname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>srvid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>objects</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * objectsInSchemaToOids
 *
 * Find all objects of a given type in specified schemas, and make a list
 * of their Oids.  We check USAGE privilege on the schemas, but there is
 * no privilege checking on the individual objects here.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>objectsInSchemaToOids</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>objects</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nspnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>objs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><name>objs</name> <operator>=</operator> <call><name>getRelationsInNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>RELKIND_SEQUENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><name>objs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>keycount</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>keycount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><name>keycount</name><operator>++</operator></expr>]</index></name></expr></argument>,
								<argument><expr><name>Anum_pg_proc_pronamespace</name></expr></argument>,
								<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* includes aggregates and window functions */</comment>
						<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><name>keycount</name><operator>++</operator></expr>]</index></name></expr></argument>,
									<argument><expr><name>Anum_pg_proc_prokind</name></expr></argument>,
									<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHARNE</name></expr></argument>,
									<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>PROKIND_PROCEDURE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>objtype</name> <operator>==</operator> <name>OBJECT_PROCEDURE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><name>keycount</name><operator>++</operator></expr>]</index></name></expr></argument>,
									<argument><expr><name>Anum_pg_proc_prokind</name></expr></argument>,
									<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
									<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>PROKIND_PROCEDURE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keycount</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>objects</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>objects</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* should not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.objtype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name>objects</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getRelationsInNamespace
 *
 * Return Oid list of relations in given namespace filtered by relation kind
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>getRelationsInNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relnamespace</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relkind</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
				<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relations</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ALTER DEFAULT PRIVILEGES statement
 */</comment>
<function><type><name>void</name></type>
<name>ExecAlterDefaultPrivilegesStmt</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name>  <modifier>*</modifier></type><name>action</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>action</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InternalDefaultACL</name></type> <name>iacls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rolespecs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nspnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>drolespecs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>dnspnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>all_privileges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errormsg</name></decl>;</decl_stmt>

	<comment type="block">/* Deconstruct the "options" part of the statement */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"schemas"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dnspnames</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>dnspnames</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"roles"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>drolespecs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>drolespecs</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"option \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>dnspnames</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspnames</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>dnspnames</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>drolespecs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rolespecs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>drolespecs</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prepare the InternalDefaultACL representation of the statement */</comment>
	<comment type="block">/* roleid to be filled below */</comment>
	<comment type="block">/* nspid to be filled in SetDefaultACLsInSchemas */</comment>
	<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>is_grant</name></name> <operator>=</operator> <name><name>action</name><operator>-&gt;</operator><name>is_grant</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name><name>action</name><operator>-&gt;</operator><name>objtype</name></name></expr>;</expr_stmt>
	<comment type="block">/* all_privs to be filled below */</comment>
	<comment type="block">/* privileges to be filled below */</comment>
	<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>		<comment type="block">/* filled below */</comment>
	<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>grant_option</name></name> <operator>=</operator> <name><name>action</name><operator>-&gt;</operator><name>grant_option</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>behavior</name></name> <operator>=</operator> <name><name>action</name><operator>-&gt;</operator><name>behavior</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert the RoleSpec list into an Oid list.  Note that at this point we
	 * insert an ACL_ID_PUBLIC into the list if appropriate, so downstream
	 * there shouldn't be any additional work needed to support this case.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>action-&gt;grantees</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>grantee</name> <init>= <expr><operator>(</operator><name>RoleSpec</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantee_uid</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>grantee</name><operator>-&gt;</operator><name>roletype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ROLESPEC_PUBLIC</name></expr>:</case>
				<expr_stmt><expr><name>grantee_uid</name> <operator>=</operator> <name>ACL_ID_PUBLIC</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>grantee_uid</name> <operator>=</operator> <call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>grantee</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>iacls</name><operator>.</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>grantee_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Convert action-&gt;privileges, a list of privilege strings, into an
	 * AclMode bitmask.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>action</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_RELATION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for procedure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for routine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLEGROUP</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for tablegroup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for schema"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GrantStmt.objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>action</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* keep compiler quiet */</comment>
			<expr_stmt><expr><name>all_privileges</name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errormsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>action</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * will be turned into ACL_ALL_RIGHTS_* by the internal routines
		 * depending on the object type
		 */</comment>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>action-&gt;privileges</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>privnode</name> <init>= <expr><operator>(</operator><name>AccessPriv</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AclMode</name></type>		<name>priv</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>privnode</name><operator>-&gt;</operator><name>cols</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"default privileges cannot be set for columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>privnode</name><operator>-&gt;</operator><name>priv_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* parser mistake? */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AccessPriv node must specify privilege"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>priv</name> <operator>=</operator> <call><name>string_to_privilege</name><argument_list>(<argument><expr><name><name>privnode</name><operator>-&gt;</operator><name>priv_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>priv</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>all_privileges</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>, <argument><expr><call><name>privilege_to_string</name><argument_list>(<argument><expr><name>priv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>privileges</name></name> <operator>|=</operator> <name>priv</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rolespecs</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set permissions for myself */</comment>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>roleid</name></name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetDefaultACLsInSchemas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iacls</name></expr></argument>, <argument><expr><name>nspnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Look up the role OIDs and do permissions checks */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rolecell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rolecell</argument>, <argument>rolespecs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>rolespec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rolecell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>roleid</name></name> <operator>=</operator> <call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>rolespec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We insist that calling user be a member of each target role. If
			 * he has that, he could become that role anyway via SET ROLE, so
			 * FOR ROLE is just a syntactic convenience and doesn't give any
			 * special privileges.
			 */</comment>
			<expr_stmt><expr><call><name>check_is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>iacls</name><operator>.</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetDefaultACLsInSchemas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iacls</name></expr></argument>, <argument><expr><name>nspnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process ALTER DEFAULT PRIVILEGES for a list of target schemas
 *
 * All fields of *iacls except nspid were filled already
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetDefaultACLsInSchemas</name><parameter_list>(<parameter><decl><type><name>InternalDefaultACL</name> <modifier>*</modifier></type><name>iacls</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nspnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nspnames</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set database-wide permissions if no schema was specified */</comment>
		<expr_stmt><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetDefaultACL</name><argument_list>(<argument><expr><name>iacls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Look up the schema OIDs and set permissions for each one */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nspcell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>nspcell</argument>, <argument>nspnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>nspcell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We used to insist that the target role have CREATE privileges
			 * on the schema, since without that it wouldn't be able to create
			 * an object for which these default privileges would apply.
			 * However, this check proved to be more confusing than helpful,
			 * and it also caused certain database states to not be
			 * dumpable/restorable, since revoking CREATE doesn't cause
			 * default privileges for the schema to go away.  So now, we just
			 * allow the ALTER; if the user lacks CREATE he'll find out when
			 * he tries to create an object.
			 */</comment>

			<expr_stmt><expr><call><name>SetDefaultACL</name><argument_list>(<argument><expr><name>iacls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Create or update a pg_default_acl entry
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetDefaultACL</name><parameter_list>(<parameter><decl><type><name>InternalDefaultACL</name> <modifier>*</modifier></type><name>iacls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name> <init>= <expr><name><name>iacls</name><operator>-&gt;</operator><name>privileges</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>objtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNew</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>def_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_default_acl</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_default_acl</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_default_acl</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The default for a global entry is the hard-wired default ACL for the
	 * particular object type.  The default for non-global entries is an empty
	 * ACL.  This must be so because global entries replace the hard-wired
	 * defaults, while others are added on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>def_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>def_acl</name> <operator>=</operator> <call><name>make_empty_acl</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Convert ACL object type to pg_default_acl object type and handle
	 * all_privs option
	 */</comment>
	<switch>switch <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>objtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_RELATION</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_RELATION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_SEQUENCE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_FUNCTION</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_TYPE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_NAMESPACE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use IN SCHEMA clause when using GRANT/REVOKE ON TABLEGROUPS"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>DEFACLOBJ_TABLEGROUP</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iacls</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name>this_privileges</name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLEGROUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>iacls</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Search for existing row for this object type in catalog */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>DEFACLROLENSPOBJ</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>DEFACLROLENSPOBJ</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_default_acl_defaclacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* this case shouldn't happen, probably */</comment>
		<expr_stmt><expr><name>isNew</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>old_acl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.  Collect data before
		 * merge_acl_with_grant throws away old_acl.
		 */</comment>
		<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If no or null entry, start with the default ACL value */</comment>
		<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>aclcopy</name><argument_list>(<argument><expr><name>def_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There are no old member roles according to the catalogs */</comment>
		<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Generate new ACL.  Grantor of rights is always the same as the target
	 * role.
	 */</comment>
	<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>,
								   <argument><expr><name>this_privileges</name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>,
								   <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the result is the same as the default value, we do not need an
	 * explicit pg_default_acl entry, and should in fact remove the entry if
	 * it exists.  Must sort both arrays to compare properly.
	 */</comment>
	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>def_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>aclequal</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><name>def_acl</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* delete old entry, if indeed there is one */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNew</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The dependency machinery will take care of removing all
			 * associated dependency entries.  We use DROP_RESTRICT since
			 * there shouldn't be anything depending on this entry.
			 */</comment>
			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>DefaultAclRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>DROP_RESTRICT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Prepare to insert or update pg_default_acl entry */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNew</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* insert new entry */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_default_acl_defaclrole</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_default_acl_defaclnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_default_acl_defaclobjtype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_default_acl_defaclacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* update existing entry */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_default_acl_defaclacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_default_acl_defaclacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* these dependencies don't change in an update */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNew</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* dependency on role */</comment>
			<expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>,
									<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* dependency on namespace */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
							<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>DefaultAclRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>iacls</name><operator>-&gt;</operator><name>nspid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update the shared dependency ACL info
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name><name>iacls</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNew</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InvokeObjectPostCreateHook</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>,
									   <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InvokeObjectPostAlterHook</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>,
									  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prevent error when processing duplicate objects */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveRoleFromObjectACL
 *
 * Used by shdepDropOwned to remove mentions of a role in ACLs
 */</comment>
<function><type><name>void</name></type>
<name>RemoveRoleFromObjectACL</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>classid</name> <operator>==</operator> <name>DefaultAclRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InternalDefaultACL</name></type> <name>iacls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_default_acl</name></type> <name>pg_default_acl_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* first fetch info needed by SetDefaultACL */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>DefaultAclOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for default ACL %u"</literal></expr></argument>, <argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_default_acl_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_default_acl</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>roleid</name></name> <operator>=</operator> <name><name>pg_default_acl_tuple</name><operator>-&gt;</operator><name>defaclrole</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>nspid</name></name> <operator>=</operator> <name><name>pg_default_acl_tuple</name><operator>-&gt;</operator><name>defaclnamespace</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>pg_default_acl_tuple</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DEFACLOBJ_RELATION</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DEFACLOBJ_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DEFACLOBJ_FUNCTION</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_FUNCTION</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DEFACLOBJ_TYPE</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TYPE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DEFACLOBJ_NAMESPACE</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_SCHEMA</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DEFACLOBJ_TABLEGROUP</name></expr>:</case>
				<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_YBTABLEGROUP</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* Shouldn't get here */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected default ACL type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pg_default_acl_tuple</name><operator>-&gt;</operator><name>defaclobjtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>is_grant</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>grant_option</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iacls</name><operator>.</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>

		<comment type="block">/* Do it */</comment>
		<expr_stmt><expr><call><name>SetDefaultACL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iacls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>InternalGrant</name></type> <name>istmt</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>classid</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RelationRelationId</name></expr>:</case>
				<comment type="block">/* it's OK to use TABLE for a sequence */</comment>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DatabaseRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_DATABASE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TypeRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TYPE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ProcedureRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_ROUTINE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LanguageRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_LANGUAGE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LargeObjectRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_LARGEOBJECT</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>NamespaceRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_SCHEMA</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>YbTablegroupRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_YBTABLEGROUP</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>TableSpaceRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABLESPACE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ForeignServerRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_FOREIGN_SERVER</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ForeignDataWrapperRelationId</name></expr>:</case>
				<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_FDW</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected object class %u"</literal></expr></argument>, <argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>is_grant</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>objects</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>all_privs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_NO_RIGHTS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>col_privs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>grantees</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>grant_option</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istmt</name><operator>.</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecGrantStmt_oids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>istmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove a pg_default_acl entry
 */</comment>
<function><type><name>void</name></type>
<name>RemoveDefaultACLById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>defaclOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DefaultAclRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>defaclOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>DefaultAclOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for default ACL %u"</literal></expr></argument>, <argument><expr><name>defaclOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * expand_col_privileges
 *
 * OR the specified privilege(s) into per-column array entries for each
 * specified attribute.  The per-column array is indexed starting at
 * FirstLowInvalidHeapAttributeNumber, up to relation's last attribute.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_col_privileges</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name></type> <name>this_privileges</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name> <modifier>*</modifier></type><name>col_privileges</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>num_col_privileges</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>colnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>-=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attnum</name> <operator>&gt;=</operator> <name>num_col_privileges</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column number out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* safety check */</comment>
		<expr_stmt><expr><name><name>col_privileges</name><index>[<expr><name>attnum</name></expr>]</index></name> <operator>|=</operator> <name>this_privileges</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * expand_all_col_privileges
 *
 * OR the specified privilege(s) into per-column array entries for each valid
 * attribute of a relation.  The per-column array is indexed starting at
 * FirstLowInvalidHeapAttributeNumber, up to relation's last attribute.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_all_col_privileges</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>this_privileges</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name> <modifier>*</modifier></type><name>col_privileges</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>num_col_privileges</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>curr_att</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>&lt;</operator> <name>num_col_privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>curr_att</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init>
		 <condition><expr><name>curr_att</name> <operator>&lt;=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</condition>
		 <incr><expr><name>curr_att</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isdropped</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>curr_att</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Skip OID column if it doesn't exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>curr_att</name> <operator>==</operator> <name>ObjectIdAttributeNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>classForm</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Views don't have any system columns at all */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>curr_att</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>curr_att</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
				 <argument><expr><name>curr_att</name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>isdropped</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>isdropped</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>col_privileges</name><index>[<expr><name>curr_att</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>]</index></name> <operator>|=</operator> <name>this_privileges</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	This processes attributes, but expects to be called from
 *	ExecGrant_Relation, not directly from ExecGrantStmt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Attribute</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
					<parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>col_privileges</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>attRelation</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Acl</name> <modifier>*</modifier></type><name>old_rel_acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attr_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>pg_attribute_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>merged_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_update</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>attr_tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attr_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pg_attribute_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attr_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get working copy of existing ACL. If there's no ACL, substitute the
	 * proper default.
	 */</comment>
	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><name>attr_tuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_COLUMN</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There are no old member roles according to the catalogs */</comment>
		<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
		<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * In select_best_grantor we should consider existing table-level ACL bits
	 * as well as the per-column ACL.  Build a new ACL that is their
	 * concatenation.  (This is a bit cheap and dirty compared to merging them
	 * properly with no duplications, but it's all we need here.)
	 */</comment>
	<expr_stmt><expr><name>merged_acl</name> <operator>=</operator> <call><name>aclconcat</name><argument_list>(<argument><expr><name>old_rel_acl</name></expr></argument>, <argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
	<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>col_privileges</name></expr></argument>,
						<argument><expr><name>merged_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>merged_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restrict the privileges to what we can actually grant, and emit the
	 * standards-mandated warning and error messages.  Note: we don't track
	 * whether the user actually used the ALL PRIVILEGES(columns) syntax for
	 * each column; we just approximate it by whether all the possible
	 * privileges are specified now.  Since the all_privs flag only determines
	 * whether a warning is issued, this seems close enough.
	 */</comment>
	<expr_stmt><expr><name>col_privileges</name> <operator>=</operator>
		<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>col_privileges</name> <operator>==</operator> <name>ACL_ALL_RIGHTS_COLUMN</name><operator>)</operator></expr></argument>,
								 <argument><expr><name>col_privileges</name></expr></argument>,
								 <argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_COLUMN</name></expr></argument>,
								 <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_attribute_tuple</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate new ACL.
	 */</comment>
	<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
								   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>,
								   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>,
								   <argument><expr><name>col_privileges</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>,
								   <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need the members of both old and new ACLs so we can correct the
	 * shared dependency information.
	 */</comment>
	<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finished building new ACL value, now insert it */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the updated ACL is empty, we can set attacl to null, and maybe even
	 * avoid an update of the pg_attribute row.  This is worth testing because
	 * we'll come through here multiple times for any relation-level REVOKE,
	 * even if there were never any column GRANTs.  Note we are assuming that
	 * the "default" ACL state for columns is empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_update</name> <operator>=</operator> <operator>!</operator><name>isNull</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_update</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>attr_tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								<argument><expr><ternary><condition><expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>new_acl</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attr_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	This processes both sequences and non-sequences.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Relation</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name>    <modifier>*</modifier></type><name>col_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_col_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>have_col_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_rel_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell_colprivs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Not sensible to grant on an index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an index"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Composite types aren't tables either */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a composite type"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Used GRANT SEQUENCE on a non-sequence? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_SEQUENCE</name> <operator>&amp;&amp;</operator>
			<name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a sequence"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Adjust the default permissions based on object type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_RELATION</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * The GRANT TABLE syntax can be used for sequences and non-sequences,
		 * so we have to look at the relkind to determine the supported
		 * permissions.  The OR of table and sequence permissions were already
		 * checked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * For backward compatibility, just throw a warning for
				 * invalid sequence permissions when using the non-sequence
				 * GRANT syntax.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Mention the object name because the user needs to know
					 * which operations succeeded.  This is required because
					 * WARNING allows the command to continue.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" only supports USAGE, SELECT, and UPDATE privileges"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>this_privileges</name> <operator>&amp;=</operator> <operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_ALL_RIGHTS_SEQUENCE</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_ALL_RIGHTS_RELATION</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * USAGE is the only permission supported by sequences but
					 * not by non-sequences.  Don't mention the object name
					 * because we didn't in the combined TABLE | SEQUENCE
					 * check.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for table"</literal></expr></argument>,
									<argument><expr><literal type="string">"USAGE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set up array in which we'll accumulate any column privilege bits
		 * that need modification.  The array is indexed such that entry [0]
		 * corresponds to FirstLowInvalidHeapAttributeNumber.
		 */</comment>
		<expr_stmt><expr><name>num_col_privileges</name> <operator>=</operator> <name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relnatts</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>col_privileges</name> <operator>=</operator> <operator>(</operator><name>AclMode</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_col_privileges</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AclMode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_col_privileges</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are revoking relation privileges that are also column
		 * privileges, we must implicitly revoke them from each column too,
		 * per SQL spec.  (We don't need to implicitly add column privileges
		 * during GRANT because the permissions-checking code always checks
		 * both relation and per-column privileges.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>this_privileges</name> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_COLUMN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>expand_all_col_privileges</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>pg_class_tuple</name></expr></argument>,
									  <argument><expr><name>this_privileges</name> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_COLUMN</name></expr></argument>,
									  <argument><expr><name>col_privileges</name></expr></argument>,
									  <argument><expr><name>num_col_privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_col_privileges</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
					<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Need an extra copy of original rel ACL for column handling */</comment>
		<expr_stmt><expr><name>old_rel_acl</name> <operator>=</operator> <call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Handle relation-level privileges, if any were specified
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>!=</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectType</name></type>	<name>objtype</name></decl>;</decl_stmt>

			<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
			<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
								<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
					<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>objtype</name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * Restrict the privileges to what we can actually grant, and emit
			 * the standards-mandated warning and error messages.
			 */</comment>
			<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
				<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
										 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
										 <argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>,
										 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The original old_acl is pfree'd by merge_acl_with_grant. If the
			 * original column acl value is null, we cannot skip catalog update.
			 */</comment>
			<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
				<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Generate new ACL.
			 */</comment>
			<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>,
										   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
										   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>,
										   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
										   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>,
										   <argument><expr><name>this_privileges</name></expr></argument>,
										   <argument><expr><name>grantorId</name></expr></argument>,
										   <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
				  <name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
				  <call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We need the members of both old and new ACLs so we can correct
				 * the shared dependency information.
				 */</comment>
				<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* finished building new ACL value, now insert it */</comment>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update initial privileges for extensions */</comment>
				<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Update the shared dependency ACL info */</comment>
				<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><name>ownerId</name></expr></argument>,
									  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
									  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Handle column-level privileges, if any were specified or implied.
		 * We first expand the user-specified column privileges into the
		 * array, and then iterate over all nonempty array entries.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell_colprivs</argument>, <argument>istmt-&gt;col_privs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>col_privs</name> <init>= <expr><operator>(</operator><name>AccessPriv</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell_colprivs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>col_privs</name><operator>-&gt;</operator><name>priv_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <name>ACL_ALL_RIGHTS_COLUMN</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>this_privileges</name> <operator>=</operator> <call><name>string_to_privilege</name><argument_list>(<argument><expr><name><name>col_privs</name><operator>-&gt;</operator><name>priv_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>this_privileges</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_ALL_RIGHTS_COLUMN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid privilege type %s for column"</literal></expr></argument>,
								<argument><expr><call><name>privilege_to_string</name><argument_list>(<argument><expr><name>this_privileges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
				<name>this_privileges</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_SELECT</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The only column privilege allowed on sequences is SELECT.
				 * This is a warning not error because we do it that way for
				 * relation-level privileges.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sequence \"%s\" only supports SELECT column privileges"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>this_privileges</name> <operator>&amp;=</operator> <operator>(</operator><name>AclMode</name><operator>)</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>expand_col_privileges</name><argument_list>(<argument><expr><name><name>col_privs</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>,
								  <argument><expr><name>this_privileges</name></expr></argument>,
								  <argument><expr><name>col_privileges</name></expr></argument>,
								  <argument><expr><name>num_col_privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_col_privileges</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>have_col_privileges</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_col_privileges</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>col_privileges</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>ExecGrant_Attribute</name><argument_list>(<argument><expr><name>istmt</name></expr></argument>,
									<argument><expr><name>relOid</name></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>i</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
									<argument><expr><name>ownerId</name></expr></argument>,
									<argument><expr><name><name>col_privileges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									<argument><expr><name>attRelation</name></expr></argument>,
									<argument><expr><name>old_rel_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_rel_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>col_privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>attRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Database</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_DATABASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>datId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>pg_database_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_database</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_database</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_database</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>datId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for database %u"</literal></expr></argument>, <argument><expr><name>datId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_database_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_database_tuple</name><operator>-&gt;</operator><name>datdba</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_database_datacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_DATABASE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>datId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_DATABASE</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_database_tuple</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_database_datacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_database_datacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Fdw</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FDW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignDataWrapperRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fdwid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_foreign_data_wrapper</name></type> <name>pg_fdw_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_foreign_data_wrapper</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_foreign_data_wrapper</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_foreign_data_wrapper</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fdwid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for foreign-data wrapper %u"</literal></expr></argument>, <argument><expr><name>fdwid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_fdw_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_data_wrapper</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_fdw_tuple</name><operator>-&gt;</operator><name>fdwowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_foreign_data_wrapper_fdwacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FDW</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>fdwid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_FDW</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_fdw_tuple</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_foreign_data_wrapper_fdwacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_foreign_data_wrapper_fdwacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>fdwid</name></expr></argument>, <argument><expr><name>ForeignDataWrapperRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>ForeignDataWrapperRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_ForeignServer</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FOREIGN_SERVER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ForeignServerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>srvid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_foreign_server</name></type> <name>pg_server_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_foreign_server</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_foreign_server</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_foreign_server</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srvid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for foreign server %u"</literal></expr></argument>, <argument><expr><name>srvid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_server_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_server</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_server_tuple</name><operator>-&gt;</operator><name>srvowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_foreign_server_srvacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FOREIGN_SERVER</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>srvid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_FOREIGN_SERVER</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_server_tuple</name><operator>-&gt;</operator><name>srvname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_foreign_server_srvacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_foreign_server_srvacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>srvid</name></expr></argument>, <argument><expr><name>ForeignServerRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>ForeignServerRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Function</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_FUNCTION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>pg_proc_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_proc</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_proc_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_proc_tuple</name><operator>-&gt;</operator><name>proowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>funcId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_FUNCTION</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_proc_tuple</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_proc_proacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>funcId</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Language</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LANGUAGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>LanguageRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>langId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>pg_language_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_language</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_language</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_language</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>langId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>, <argument><expr><name>langId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_language_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pg_language_tuple</name><operator>-&gt;</operator><name>lanpltrusted</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language \"%s\" is not trusted"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_language_tuple</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"GRANT and REVOKE are not allowed on untrusted languages, "</literal>
							   <literal type="string">"because only superusers can use untrusted languages."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_language_tuple</name><operator>-&gt;</operator><name>lanowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>LANGNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_language_lanacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>langId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_language_tuple</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_language_lanacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_language_lanacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>langId</name></expr></argument>, <argument><expr><name>LanguageRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>LanguageRelationId</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Largeobject</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_LARGEOBJECT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>,
						 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>loid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_largeobject_metadata</name></type> <name>form_lo_meta</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>loname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_largeobject_metadata</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_largeobject_metadata</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_largeobject_metadata</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* There's no syscache for pg_largeobject_metadata */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>loid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								  <argument><expr><name>LargeObjectMetadataOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for large object %u"</literal></expr></argument>, <argument><expr><name>loid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>form_lo_meta</name> <operator>=</operator> <operator>(</operator><name>Form_pg_largeobject_metadata</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>form_lo_meta</name><operator>-&gt;</operator><name>lomowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_largeobject_metadata_lomacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_LARGEOBJECT</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>loname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>loname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"large object %u"</literal></expr></argument>, <argument><expr><name>loid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>loid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_LARGEOBJECT</name></expr></argument>,
									 <argument><expr><name>loname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_largeobject_metadata_lomacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_largeobject_metadata_lomacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
			<operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>loid</name></expr></argument>, <argument><expr><name>LargeObjectRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>LargeObjectRelationId</name></expr></argument>,
							  <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Namespace</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_namespace</name></type> <name>pg_namespace_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_namespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_namespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_namespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for namespace %u"</literal></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_namespace_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_namespace_tuple</name><operator>-&gt;</operator><name>nspowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>NAMESPACENAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_namespace_nspacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_SCHEMA</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_namespace_tuple</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_namespace_nspacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_namespace_nspacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>, <argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Tablegroup</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyDatabaseColocated</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set privileges of an implicit tablegroup "</literal>
						<literal type="string">"in a colocated database"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLEGROUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>YbTablegroupRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grpId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_yb_tablegroup</name></type> <name>pg_yb_tablegroup_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_yb_tablegroup</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_yb_tablegroup</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_yb_tablegroup</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>YBTABLEGROUPOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>grpId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for tablegroup %u"</literal></expr></argument>, <argument><expr><name>grpId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_yb_tablegroup_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_yb_tablegroup</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_yb_tablegroup_tuple</name><operator>-&gt;</operator><name>grpowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_yb_tablegroup_grpacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_YBTABLEGROUP</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
				<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
										 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
										 <argument><expr><name>grpId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_YBTABLEGROUP</name></expr></argument>,
										 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_yb_tablegroup_tuple</name><operator>-&gt;</operator><name>grpname</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_yb_tablegroup_grpacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_yb_tablegroup_grpacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>YbTablegroupRelationId</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Tablespace</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TABLESPACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TableSpaceRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>tblId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_tablespace</name></type> <name>pg_tablespace_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_tablespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_tablespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_tablespace</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Search syscache for pg_tablespace */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TABLESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tblId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for tablespace %u"</literal></expr></argument>, <argument><expr><name>tblId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_tablespace_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_tablespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_tablespace_tuple</name><operator>-&gt;</operator><name>spcowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_tablespace_spcacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>tblId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_tablespace_tuple</name><operator>-&gt;</operator><name>spcname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_tablespace_spcacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_tablespace_spcacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>TableSpaceRelationId</name></expr></argument>, <argument><expr><name>tblId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecGrant_Type</name><parameter_list>(<parameter><decl><type><name>InternalGrant</name> <modifier>*</modifier></type><name>istmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name> <operator>&amp;&amp;</operator> <name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>==</operator> <name>ACL_NO_RIGHTS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name> <operator>=</operator> <name>ACL_ALL_RIGHTS_TYPE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>istmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pg_type_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>avail_goptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>this_privileges</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>old_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>new_acl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>grantorId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replaces</name><index>[<expr><name>Natts_pg_type</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oldmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>newmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Search syscache for pg_type */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pg_type_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typelem</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_GRANT_OPERATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set privileges of array types"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set the privileges of the element type instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Used GRANT DOMAIN on a non-domain? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>==</operator> <name>OBJECT_DOMAIN</name> <operator>&amp;&amp;</operator>
			<name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a domain"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get owner ID and working copy of existing ACL. If there's no ACL,
		 * substitute the proper default.
		 */</comment>
		<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_type_typacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* There are no old member roles according to the catalogs */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldmembers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>old_acl</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Get the roles mentioned in the existing ACL */</comment>
			<expr_stmt><expr><name>noldmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Determine ID to do the grant as, and available grant options */</comment>
		<expr_stmt><expr><call><name>select_best_grantor</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
							<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>grantorId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avail_goptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restrict the privileges to what we can actually grant, and emit the
		 * standards-mandated warning and error messages.
		 */</comment>
		<expr_stmt><expr><name>this_privileges</name> <operator>=</operator>
			<call><name>restrict_and_check_grant</name><argument_list>(<argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>, <argument><expr><name>avail_goptions</name></expr></argument>,
									 <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>all_privs</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>privileges</name></name></expr></argument>,
									 <argument><expr><name>typId</name></expr></argument>, <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>OBJECT_TYPE</name></expr></argument>,
									 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pg_type_tuple</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The original old_acl is pfree'd by merge_acl_with_grant. If the
		 * original column acl value is null, we cannot skip catalog update.
		 */</comment>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>yb_copy_of_old_acl</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Generate new ACL.
		 */</comment>
		<expr_stmt><expr><name>new_acl</name> <operator>=</operator> <call><name>merge_acl_with_grant</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>is_grant</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grant_option</name></name></expr></argument>, <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>behavior</name></name></expr></argument>,
									   <argument><expr><name><name>istmt</name><operator>-&gt;</operator><name>grantees</name></name></expr></argument>, <argument><expr><name>this_privileges</name></expr></argument>,
									   <argument><expr><name>grantorId</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Skip catalog update if there is no ACL change. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<name>yb_copy_of_old_acl</name> <operator>&amp;&amp;</operator>
			<call><name>YbCheckAclCopiesEqual</name><argument_list>(<argument><expr><name>yb_copy_of_old_acl</name></expr></argument>, <argument><expr><call><name>aclcopy</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need the members of both old and new ACLs so we can correct the
		 * shared dependency information.
		 */</comment>
		<expr_stmt><expr><name>nnewmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* finished building new ACL value, now insert it */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replaces</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replaces</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>replaces</name><index>[<expr><name>Anum_pg_type_typacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_type_typacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update initial privileges for extensions */</comment>
		<expr_stmt><expr><call><name>recordExtensionInitPriv</name><argument_list>(<argument><expr><name>typId</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the shared dependency ACL info */</comment>
		<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><name>ownerId</name></expr></argument>,
							  <argument><expr><name>noldmembers</name></expr></argument>, <argument><expr><name>oldmembers</name></expr></argument>,
							  <argument><expr><name>nnewmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* prevent error when processing duplicate objects */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>AclMode</name></type>
<name>string_to_privilege</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>privname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_INSERT</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_SELECT</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_UPDATE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_DELETE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_TRUNCATE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"references"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_REFERENCES</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"trigger"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_TRIGGER</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_EXECUTE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"usage"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_USAGE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"create"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_CREATE</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"temporary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_CREATE_TEMP</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_CREATE_TEMP</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"connect"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACL_CONNECT</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>privname</name></expr></argument>, <argument><expr><literal type="string">"rule"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* ignore old RULE privileges */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized privilege type \"%s\""</literal></expr></argument>, <argument><expr><name>privname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* appease compiler */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>privilege_to_string</name><parameter_list>(<parameter><decl><type><name>AclMode</name></type> <name>privilege</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>privilege</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACL_INSERT</name></expr>:</case>
			<return>return <expr><literal type="string">"INSERT"</literal></expr>;</return>
		<case>case <expr><name>ACL_SELECT</name></expr>:</case>
			<return>return <expr><literal type="string">"SELECT"</literal></expr>;</return>
		<case>case <expr><name>ACL_UPDATE</name></expr>:</case>
			<return>return <expr><literal type="string">"UPDATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_DELETE</name></expr>:</case>
			<return>return <expr><literal type="string">"DELETE"</literal></expr>;</return>
		<case>case <expr><name>ACL_TRUNCATE</name></expr>:</case>
			<return>return <expr><literal type="string">"TRUNCATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_REFERENCES</name></expr>:</case>
			<return>return <expr><literal type="string">"REFERENCES"</literal></expr>;</return>
		<case>case <expr><name>ACL_TRIGGER</name></expr>:</case>
			<return>return <expr><literal type="string">"TRIGGER"</literal></expr>;</return>
		<case>case <expr><name>ACL_EXECUTE</name></expr>:</case>
			<return>return <expr><literal type="string">"EXECUTE"</literal></expr>;</return>
		<case>case <expr><name>ACL_USAGE</name></expr>:</case>
			<return>return <expr><literal type="string">"USAGE"</literal></expr>;</return>
		<case>case <expr><name>ACL_CREATE</name></expr>:</case>
			<return>return <expr><literal type="string">"CREATE"</literal></expr>;</return>
		<case>case <expr><name>ACL_CREATE_TEMP</name></expr>:</case>
			<return>return <expr><literal type="string">"TEMP"</literal></expr>;</return>
		<case>case <expr><name>ACL_CONNECT</name></expr>:</case>
			<return>return <expr><literal type="string">"CONNECT"</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized privilege: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>privilege</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* appease compiler */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Standardized reporting of aclcheck permissions failures.
 *
 * Note: we do not double-quote the %s's below, because many callers
 * supply strings that might be already quoted.
 */</comment>
<function><type><name>void</name></type>
<name>aclcheck_error</name><parameter_list>(<parameter><decl><type><name>AclResult</name></type> <name>aclerr</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objectname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>aclerr</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACLCHECK_OK</name></expr>:</case>
			<comment type="block">/* no error, so return to caller */</comment>
			<break>break;</break>
		<case>case <expr><name>ACLCHECK_NO_PRIV</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"???"</literal></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for aggregate %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for collation %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for column %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for conversion %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for database %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for domain %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for event trigger %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for extension %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for foreign-data wrapper %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for foreign server %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for foreign table %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for function %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for index %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for language %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for large object %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for materialized view %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for operator class %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for operator %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for operator family %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for policy %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for procedure %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for publication %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for routine %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for schema %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for sequence %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for statistics object %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for subscription %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for table %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for tablegroup %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for tablespace %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for text search configuration %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for text search dictionary %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for type %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"permission denied for view %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
						<comment type="block">/* these currently aren't used */</comment>
					<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<case>case <expr><name>OBJECT_AMOP</name></expr>:</case>
					<case>case <expr><name>OBJECT_AMPROC</name></expr>:</case>
					<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
					<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
					<case>case <expr><name>OBJECT_DEFAULT</name></expr>:</case>
					<case>case <expr><name>OBJECT_DEFACL</name></expr>:</case>
					<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
					<case>case <expr><name>OBJECT_PUBLICATION_REL</name></expr>:</case>
					<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
					<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
					<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
					<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
					<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<case>case <expr><name>OBJECT_USER_MAPPING</name></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object type %d"</literal></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>ACLCHECK_NOT_OWNER</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"???"</literal></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>OBJECT_AGGREGATE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of aggregate %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_COLLATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of collation %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_CONVERSION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of conversion %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of database %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_DOMAIN</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of domain %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of event trigger %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_EXTENSION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of extension %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of foreign-data wrapper %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of foreign server %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FOREIGN_TABLE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of foreign table %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of function %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_INDEX</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of index %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of language %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of large object %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_MATVIEW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of materialized view %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPCLASS</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of operator class %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPERATOR</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of operator %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_OPFAMILY</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of operator family %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_PROCEDURE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of procedure %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_PUBLICATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of publication %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_ROUTINE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of routine %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of sequence %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SUBSCRIPTION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of subscription %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of table %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of type %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_VIEW</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of view %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of schema %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of statistics object %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of tablegroup %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of tablespace %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TSCONFIGURATION</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of text search configuration %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>OBJECT_TSDICTIONARY</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of text search dictionary %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

						<comment type="block">/*
						 * Special cases: For these, the error message talks
						 * about "relation", because that's where the
						 * ownership is attached.  See also
						 * check_object_ownership().
						 */</comment>
					<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
					<case>case <expr><name>OBJECT_POLICY</name></expr>:</case>
					<case>case <expr><name>OBJECT_RULE</name></expr>:</case>
					<case>case <expr><name>OBJECT_TABCONSTRAINT</name></expr>:</case>
					<case>case <expr><name>OBJECT_TRIGGER</name></expr>:</case>
						<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"must be owner of relation %s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
						<comment type="block">/* these currently aren't used */</comment>
					<case>case <expr><name>OBJECT_ACCESS_METHOD</name></expr>:</case>
					<case>case <expr><name>OBJECT_AMOP</name></expr>:</case>
					<case>case <expr><name>OBJECT_AMPROC</name></expr>:</case>
					<case>case <expr><name>OBJECT_ATTRIBUTE</name></expr>:</case>
					<case>case <expr><name>OBJECT_CAST</name></expr>:</case>
					<case>case <expr><name>OBJECT_DEFAULT</name></expr>:</case>
					<case>case <expr><name>OBJECT_DEFACL</name></expr>:</case>
					<case>case <expr><name>OBJECT_DOMCONSTRAINT</name></expr>:</case>
					<case>case <expr><name>OBJECT_PUBLICATION_REL</name></expr>:</case>
					<case>case <expr><name>OBJECT_ROLE</name></expr>:</case>
					<case>case <expr><name>OBJECT_TRANSFORM</name></expr>:</case>
					<case>case <expr><name>OBJECT_TSPARSER</name></expr>:</case>
					<case>case <expr><name>OBJECT_TSTEMPLATE</name></expr>:</case>
					<case>case <expr><name>OBJECT_USER_MAPPING</name></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported object type %d"</literal></expr></argument>, <argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized AclResult: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>aclerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>aclcheck_error_col</name><parameter_list>(<parameter><decl><type><name>AclResult</name></type> <name>aclerr</name></decl></parameter>, <parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>objectname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>aclerr</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ACLCHECK_OK</name></expr>:</case>
			<comment type="block">/* no error, so return to caller */</comment>
			<break>break;</break>
		<case>case <expr><name>ACLCHECK_NO_PRIV</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for column \"%s\" of relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ACLCHECK_NOT_OWNER</name></expr>:</case>
			<comment type="block">/* relation msg is OK since columns don't have separate owners */</comment>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclerr</name></expr></argument>, <argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>objectname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized AclResult: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>aclerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Special common handling for types: use element type instead of array type,
 * and format nicely
 */</comment>
<function><type><name>void</name></type>
<name>aclcheck_error_type</name><parameter_list>(<parameter><decl><type><name>AclResult</name></type> <name>aclerr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclerr</name></expr></argument>, <argument><expr><name>OBJECT_TYPE</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><ternary><condition><expr><name>element_type</name></expr> ?</condition><then> <expr><name>element_type</name></expr> </then><else>: <expr><name>typeOid</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Relay for the various pg_*_mask routines depending on object kind
 */</comment>
<function><type><specifier>static</specifier> <name>AclMode</name></type>
<name>pg_aclmask</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
		   <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_COLUMN</name></expr>:</case>
			<return>return
				<expr><call><name>pg_class_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call> <operator>|</operator>
				<call><name>pg_attribute_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<return>return <expr><call><name>pg_class_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_DATABASE</name></expr>:</case>
			<return>return <expr><call><name>pg_database_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<return>return <expr><call><name>pg_proc_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_LANGUAGE</name></expr>:</case>
			<return>return <expr><call><name>pg_language_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_LARGEOBJECT</name></expr>:</case>
			<return>return <expr><call><name>pg_largeobject_aclmask_snapshot</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
												   <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<return>return <expr><call><name>pg_namespace_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_STATISTIC_EXT</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"grantable rights not supported for statistics objects"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached, but keep compiler quiet */</comment>
			<return>return <expr><name>ACL_NO_RIGHTS</name></expr>;</return>
		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<return>return <expr><call><name>pg_tablegroup_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_TABLESPACE</name></expr>:</case>
			<return>return <expr><call><name>pg_tablespace_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_FDW</name></expr>:</case>
			<return>return <expr><call><name>pg_foreign_data_wrapper_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_FOREIGN_SERVER</name></expr>:</case>
			<return>return <expr><call><name>pg_foreign_server_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OBJECT_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"grantable rights not supported for event triggers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached, but keep compiler quiet */</comment>
			<return>return <expr><name>ACL_NO_RIGHTS</name></expr>;</return>
		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<return>return <expr><call><name>pg_type_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized objtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* not reached, but keep compiler quiet */</comment>
			<return>return <expr><name>ACL_NO_RIGHTS</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* ****************************************************************
 * Exported routines for examining a user's privileges for various objects
 *
 * See aclmask() for a description of the common API for these functions.
 *
 * Note: we give lookup failure the full ereport treatment because the
 * has_xxx_privilege() family of functions allow users to pass any random
 * OID to these functions.
 * ****************************************************************
 */</comment>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a column
 *
 * Note: this considers only privileges granted specifically on the column.
 * It is caller's responsibility to take relation-level privileges into account
 * as appropriate.  (For the same reason, we have no special case for
 * superuser-ness here.)
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_attribute_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					 <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, get the column's ACL from its pg_attribute entry
	 */</comment>
	<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d of relation with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attributeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Throw error on dropped columns, too */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attribute %d of relation with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>table_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><name>attTuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we hard-wire knowledge that the default ACL for a column grants no
	 * privileges, so that we can fall out quickly in the very common case
	 * where attacl is null.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Must get the relation's ownerId from pg_class.  Since we already found
	 * a pg_attribute entry, the only likely reason for this to fail is that a
	 * concurrent DROP of the relation committed since then (which could only
	 * happen if we don't have lock on the relation).  We prefer to report "no
	 * privileges" rather than failing in such a case, so as to avoid unwanted
	 * failures in has_column_privilege() tests.
	 */</comment>
	<expr_stmt><expr><name>classTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* detoast column's ACL if necessary */</comment>
	<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a table
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_class_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
				 <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must get the relation's tuple from pg_class
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deny anyone permission to update a system catalog unless
	 * pg_authid.rolsuper is set.  Also allow it if allowSystemTableMods.
	 *
	 * As of 7.4 we have some updatable system views; those shouldn't be
	 * protected in this way.  Assume the view rules can take care of
	 * themselves.  ACL_USAGE is if we ever have system sequences.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>(</operator><name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_TRUNCATE</name> <operator>|</operator> <name>ACL_USAGE</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>IsSystemClass</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>allowSystemTableMods</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACLDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"permission denied for system catalog update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>mask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>ACL_INSERT</name> <operator>|</operator> <name>ACL_UPDATE</name> <operator>|</operator> <name>ACL_DELETE</name> <operator>|</operator> <name>ACL_TRUNCATE</name> <operator>|</operator> <name>ACL_USAGE</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, superusers bypass all permission-checking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsYbDbAdminUser</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACLDEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"OID %u is superuser, home free"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>mask</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Normal case: get the relation's ACL from pg_class
	 */</comment>
	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<switch>switch <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast rel's ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a database
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_database_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>db_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					<parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the database's ACL from pg_database
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>datdba</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_database_datacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_DATABASE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a function
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_proc_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>proc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
				<parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the function's ACL from pg_proc
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>proc_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>proc_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a language
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_language_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lang_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					<parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the language's ACL from pg_language
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lang_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>lang_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lanowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_language_lanacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_LANGUAGE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a largeobject
 *
 * When a large object is opened for reading, it is opened relative to the
 * caller's snapshot, but when it is opened for writing, a current
 * MVCC snapshot will be used.  See doc/src/sgml/lobj.sgml.  This function
 * takes a snapshot argument so that the permissions check can be made
 * relative to the same snapshot that will be used to read the underlying
 * data.  The caller will actually pass NULL for an instantaneous MVCC
 * snapshot, since all we do with the snapshot argument is pass it through
 * to systable_beginscan().
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_largeobject_aclmask_snapshot</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lobj_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
								<parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>,
								<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_lo_meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the largeobject's ACL from pg_language_metadata
	 */</comment>
	<expr_stmt><expr><name>pg_lo_meta</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lobj_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_lo_meta</name></expr></argument>,
							  <argument><expr><name>LargeObjectMetadataOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object %u does not exist"</literal></expr></argument>, <argument><expr><name>lobj_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_largeobject_metadata</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lomowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_largeobject_metadata_lomacl</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_lo_meta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_LARGEOBJECT</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_lo_meta</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a namespace
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_namespace_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nsp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					 <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>IsYbExtensionUser</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>creating_extension</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we have been assigned this namespace as a temp namespace, check to
	 * make sure we have CREATE TEMP permission on the database, and if so act
	 * as though we have all standard (but not GRANT OPTION) permissions on
	 * the namespace.  If we don't have CREATE TEMP, act as though we have
	 * only USAGE (and not CREATE) rights.
	 *
	 * This may seem redundant given the check in InitTempTableNamespace, but
	 * it really isn't since current user ID may have changed since then. The
	 * upshot of this behavior is that a SECURITY DEFINER function can create
	 * temp tables that can then be accessed (if permission is granted) by
	 * code in the same session that doesn't have permissions to create temp
	 * tables.
	 *
	 * XXX Would it be safe to ereport a special error message as
	 * InitTempTableNamespace does?  Returning zero here means we'll get a
	 * generic "permission denied for schema pg_temp_N" message, which is not
	 * remarkably user-friendly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_database_aclcheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
								 <argument><expr><name>ACL_CREATE_TEMP</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>mask</name> <operator>&amp;</operator> <name>ACL_ALL_RIGHTS_SCHEMA</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>mask</name> <operator>&amp;</operator> <name>ACL_USAGE</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the schema's ACL from pg_namespace
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nspowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_namespace_nspacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_SCHEMA</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a tablegroup
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_tablegroup_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>grp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* First check that the pg_tablegroup catalog actually exists. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>YbTablegroupCatalogExists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Tablegroup system catalog does not exist."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the tablegroup's ACL from pg_yb_tablegroup
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>YBTABLEGROUPOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>grp_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
		 			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablegroup with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>grp_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_yb_tablegroup</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>grpowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>YBTABLEGROUPOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_yb_tablegroup_grpacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_YBTABLEGROUP</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a tablespace
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_tablespace_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>spc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
					  <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers and yb_db_admin role bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsYbDbAdminUser</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the tablespace's ACL from pg_tablespace
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TABLESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>spc_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>spc_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_tablespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>spcowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TABLESPACEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_tablespace_spcacl</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TABLESPACE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a foreign
 * data wrapper
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_foreign_data_wrapper_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fdw_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
								<parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_foreign_data_wrapper</name></type> <name>fdwForm</name></decl>;</decl_stmt>

	<comment type="block">/* Bypass permission checks for superusers */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must get the FDW's tuple from pg_foreign_data_wrapper
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fdw_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign-data wrapper with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>fdw_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>fdwForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_data_wrapper</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normal case: get the FDW's ACL from pg_foreign_data_wrapper
	 */</comment>
	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>fdwForm</name><operator>-&gt;</operator><name>fdwowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_foreign_data_wrapper_fdwacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FDW</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast rel's ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a foreign
 * server.
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_foreign_server_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srv_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>,
						  <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_foreign_server</name></type> <name>srvForm</name></decl>;</decl_stmt>

	<comment type="block">/* Bypass permission checks for superusers */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must get the FDW's tuple from pg_foreign_data_wrapper
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign server with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>srvForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_foreign_server</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normal case: get the foreign server's ACL from pg_foreign_server
	 */</comment>
	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>srvForm</name><operator>-&gt;</operator><name>srvowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_foreign_server_srvacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_FOREIGN_SERVER</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast rel's ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for examining a user's privileges for a type.
 */</comment>
<function><type><name>AclMode</name></type>
<name>pg_type_aclmask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>

	<comment type="block">/* Bypass permission checks for superusers */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mask</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must get the type's tuple from pg_type
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * "True" array types don't manage permissions of their own; consult the
	 * element type instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elttype_oid</name> <init>= <expr><name><name>typeForm</name><operator>-&gt;</operator><name>typelem</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>elttype_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* this case is not a user-facing error, so elog not ereport */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>elttype_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now get the type's owner and ACL from the tuple
	 */</comment>
	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <name><name>typeForm</name><operator>-&gt;</operator><name>typowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_type_typacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No ACL, so build default ACL */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>OBJECT_TYPE</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* detoast rel's ACL if necessary */</comment>
		<expr_stmt><expr><name>acl</name> <operator>=</operator> <call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmask</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we have a detoasted copy, free it */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>acl</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a column
 *
 * Returns ACLCHECK_OK if the user has any of the privileges identified by
 * 'mode'; otherwise returns a suitable error code (in practice, always
 * ACLCHECK_NO_PRIV).
 *
 * As with pg_attribute_aclmask, only privileges granted directly on the
 * column are considered here.
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_attribute_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_attribute_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to any/all columns
 *
 * If 'how' is ACLMASK_ANY, then returns ACLCHECK_OK if user has any of the
 * privileges identified by 'mode' on any non-dropped column in the relation;
 * otherwise returns a suitable error code (in practice, always
 * ACLCHECK_NO_PRIV).
 *
 * If 'how' is ACLMASK_ALL, then returns ACLCHECK_OK if user has any of the
 * privileges identified by 'mode' on each non-dropped column in the relation
 * (and there must be at least one such column); otherwise returns a suitable
 * error code (in practice, always ACLCHECK_NO_PRIV).
 *
 * As with pg_attribute_aclmask, only privileges granted directly on the
 * column(s) are considered here.
 *
 * Note: system columns are not considered here; there are cases where that
 * might be appropriate but there are also cases where it wouldn't.
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_attribute_aclcheck_all</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>,
						  <parameter><decl><type><name>AclMaskHow</name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>nattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>curr_att</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must fetch pg_class row to check number of attributes.  As in
	 * pg_attribute_aclmask, we prefer to return "no privileges" instead of
	 * throwing an error if we get any unexpected lookup errors.
	 */</comment>
	<expr_stmt><expr><name>classTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize result in case there are no non-dropped columns.  We want to
	 * report failure in such cases for either value of 'how'.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ACLCHECK_NO_PRIV</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>curr_att</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_att</name> <operator>&lt;=</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>curr_att</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AclMode</name></type>		<name>attmask</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>curr_att</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Here we hard-wire knowledge that the default ACL for a column
		 * grants no privileges, so that we can fall out quickly in the very
		 * common case where attacl is null.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>, <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>attmask</name> <operator>=</operator> <call><name>pg_attribute_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>curr_att</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
										   <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attmask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ACLCHECK_OK</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>how</name> <operator>==</operator> <name>ACLMASK_ANY</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* succeed on any success */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ACLCHECK_NO_PRIV</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>how</name> <operator>==</operator> <name>ACLMASK_ALL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* fail on any failure */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a table
 *
 * Returns ACLCHECK_OK if the user has any of the privileges identified by
 * 'mode'; otherwise returns a suitable error code (in practice, always
 * ACLCHECK_NO_PRIV).
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_class_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>table_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_class_aclmask</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a database
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_database_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>db_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_aclmask</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a function
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_proc_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>proc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_proc_aclmask</name><argument_list>(<argument><expr><name>proc_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a language
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_language_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lang_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_language_aclmask</name><argument_list>(<argument><expr><name>lang_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a largeobject
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_largeobject_aclcheck_snapshot</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lobj_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>,
								 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_largeobject_aclmask_snapshot</name><argument_list>(<argument><expr><name>lobj_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
										<argument><expr><name>ACLMASK_ANY</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a namespace
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_namespace_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nsp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_namespace_aclmask</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a tablegroup
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_tablegroup_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>grp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_tablegroup_aclmask</name><argument_list>(<argument><expr><name>grp_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a tablespace
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_tablespace_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>spc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_tablespace_aclmask</name><argument_list>(<argument><expr><name>spc_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a foreign
 * data wrapper
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_foreign_data_wrapper_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fdw_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_foreign_data_wrapper_aclmask</name><argument_list>(<argument><expr><name>fdw_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a foreign
 * server
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_foreign_server_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srv_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_foreign_server_aclmask</name><argument_list>(<argument><expr><name>srv_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exported routine for checking a user's access privileges to a type
 */</comment>
<function><type><name>AclResult</name></type>
<name>pg_type_aclcheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_type_aclmask</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>ACLMASK_ANY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_OK</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ACLCHECK_NO_PRIV</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a relation (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_class_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>class_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>class_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>class_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a type (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_type_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>type_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for an operator (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_oper_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oper_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oper_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>oper_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oprowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a function (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_proc_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>proc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>proc_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>proc_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a procedural language (specified by OID)
 */</comment>
<function><type><name>bool</name></type>
<name>pg_language_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lan_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lan_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"language with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>lan_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lanowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a largeobject (specified by OID)
 *
 * This is only used for operations like ALTER LARGE OBJECT that are always
 * relative to an up-to-date snapshot.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_largeobject_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>lobj_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_lo_meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* There's no syscache for pg_largeobject_metadata */</comment>
	<expr_stmt><expr><name>pg_lo_meta</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lobj_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_lo_meta</name></expr></argument>,
							  <argument><expr><name>LargeObjectMetadataOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object %u does not exist"</literal></expr></argument>, <argument><expr><name>lobj_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_largeobject_metadata</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>lomowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_lo_meta</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a namespace (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_namespace_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nsp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>nspowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a tablegroup (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_tablegroup_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>grp_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>grptuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>grpowner</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure that the pg_yb_tablegroup catalog actually exists. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>YbTablegroupCatalogExists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Tablegroup system catalog does not exist."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Superusers and yb_db_admin role bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsYbDbAdminUser</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search syscache for the tablegroup */</comment>
	<expr_stmt><expr><name>grptuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>YBTABLEGROUPOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>grp_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>grptuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablegroup with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>grp_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>grpowner</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_yb_tablegroup</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>grptuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>grpowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>grptuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>grpowner</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a tablespace (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_tablespace_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>spc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>spctuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>spcowner</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers and yb_db_admin role bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsYbDbAdminUser</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Search syscache for pg_tablespace */</comment>
	<expr_stmt><expr><name>spctuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TABLESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>spc_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>spctuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>spc_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>spcowner</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_tablespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>spctuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>spcowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>spctuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>spcowner</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for an operator class (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_opclass_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opc_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opc_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>opc_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>opcowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for an operator family (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_opfamily_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opf_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opf_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator family with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>opf_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_opfamily</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>opfowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a text search dictionary (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_ts_dict_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dict_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dict_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search dictionary with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>dict_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_ts_dict</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>dictowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a text search configuration (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_ts_config_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cfg_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfg_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search configuration with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>cfg_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_ts_config</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>cfgowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a foreign-data wrapper (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_foreign_data_wrapper_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srv_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign-data wrapper with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_foreign_data_wrapper</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fdwowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a foreign server (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_foreign_server_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>srv_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign server with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>srv_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_foreign_server</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>srvowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for an event trigger (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_event_trigger_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>et_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers and yb_db_admin bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsYbDbAdminUser</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>EVENTTRIGGEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>et_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>et_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_event_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>evtowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a database (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_database_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>db_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dba</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>db_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>db_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dba</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>datdba</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>dba</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a collation (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_collation_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>coll_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>coll_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>coll_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>collowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a conversion (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_conversion_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conv_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONVOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conv_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conversion with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>conv_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_conversion</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>conowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for an extension (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_extension_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ext_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_extension</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* There's no syscache for pg_extension, so do it the hard way */</comment>
	<expr_stmt><expr><name>pg_extension</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ext_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_extension</name></expr></argument>,
							  <argument><expr><name>ExtensionOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>ext_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_extension</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>extowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_extension</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a publication (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_publication_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>pub_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PUBLICATIONOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>pub_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"publication with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>pub_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_publication</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pubowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a subscription (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_subscription_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sub_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>SUBSCRIPTIONOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sub_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subscription with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>sub_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_subscription</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>subowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ownership check for a statistics object (specified by OID).
 */</comment>
<function><type><name>bool</name></type>
<name>pg_statistics_object_ownercheck</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>stat_oid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ownerId</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>stat_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics object with OID %u does not exist"</literal></expr></argument>,
						<argument><expr><name>stat_oid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ownerId</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stxowner</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>has_privs_of_role</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether specified role has CREATEROLE privilege (or is a superuser)
 *
 * Note: roles do not have owners per se; instead we use this test in
 * places where an ownership-like permissions test is needed for a role.
 * Be sure to apply it to the role trying to do the operation, not the
 * role being operated on!	Also note that this generally should not be
 * considered enough privilege if the target role is a superuser.
 * (We don't handle that consideration here because we want to give a
 * separate error message for such cases, so the caller has to deal with it.)
 */</comment>
<function><type><name>bool</name></type>
<name>has_createrole_privilege</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>utup</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>utup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolcreaterole</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>has_bypassrls_privilege</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>utup</name></decl>;</decl_stmt>

	<comment type="block">/* Superusers bypass all permission checking. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser_arg</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>utup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolbypassrls</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch pg_default_acl entry for given role, namespace and object type
 * (object type must be given in pg_default_acl's encoding).
 * Returns NULL if no such entry.
 */</comment>
<function><type><specifier>static</specifier> <name>Acl</name> <modifier>*</modifier></type>
<name>get_default_acl_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nsp_oid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>objtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>DEFACLROLENSPOBJ</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleId</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nsp_oid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>DEFACLROLENSPOBJ</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_default_acl_defaclacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetAclPCopy</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get default permissions for newly created object within given schema
 *
 * Returns NULL if built-in system defaults should be used.
 *
 * If the result is not NULL, caller must call recordDependencyOnNewAcl
 * once the OID of the new object is known.
 */</comment>
<function><type><name>Acl</name> <modifier>*</modifier></type>
<name>get_user_default_acl</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nsp_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>glob_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>schema_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>def_acl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>defaclobjtype</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use NULL during bootstrap, since pg_default_acl probably isn't there
	 * yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Check if object type is supported in pg_default_acl */</comment>
	<switch>switch <condition>(<expr><name>objtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OBJECT_TABLE</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_RELATION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SEQUENCE</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_SEQUENCE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_FUNCTION</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_TYPE</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_NAMESPACE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OBJECT_YBTABLEGROUP</name></expr>:</case>
			<expr_stmt><expr><name>defaclobjtype</name> <operator>=</operator> <name>DEFACLOBJ_TABLEGROUP</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* Look up the relevant pg_default_acl entries */</comment>
	<expr_stmt><expr><name>glob_acl</name> <operator>=</operator> <call><name>get_default_acl_internal</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>defaclobjtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>schema_acl</name> <operator>=</operator> <call><name>get_default_acl_internal</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>, <argument><expr><name>nsp_oid</name></expr></argument>, <argument><expr><name>defaclobjtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick out if neither entry exists */</comment>
	<if_stmt><if>if <condition>(<expr><name>glob_acl</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>schema_acl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We need to know the hard-wired default value, too */</comment>
	<expr_stmt><expr><name>def_acl</name> <operator>=</operator> <call><name>acldefault</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there's no global entry, substitute the hard-wired default */</comment>
	<if_stmt><if>if <condition>(<expr><name>glob_acl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>glob_acl</name> <operator>=</operator> <name>def_acl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Merge in any per-schema privileges */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>aclmerge</name><argument_list>(<argument><expr><name>glob_acl</name></expr></argument>, <argument><expr><name>schema_acl</name></expr></argument>, <argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For efficiency, we want to return NULL if the result equals default.
	 * This requires sorting both arrays to get an accurate comparison.
	 */</comment>
	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>def_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>aclequal</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>def_acl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record dependencies on roles mentioned in a new object's ACL.
 */</comment>
<function><type><name>void</name></type>
<name>recordDependencyOnNewAcl</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>, <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if ACL is defaulted */</comment>
	<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Extract roles mentioned in ACL */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>aclmembers</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the shared dependency ACL info */</comment>
	<expr_stmt><expr><call><name>updateAclDependencies</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>objsubId</name></expr></argument>,
						  <argument><expr><name>ownerId</name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record initial privileges for the top-level object passed in.
 *
 * For the object passed in, this will record its ACL (if any) and the ACLs of
 * any sub-objects (eg: columns) into pg_init_privs.
 *
 * Any new kinds of objects which have ACLs associated with them and can be
 * added to an extension should be added to the if-else tree below.
 */</comment>
<function><type><name>void</name></type>
<name>recordExtObjInitPriv</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * pg_class / pg_attribute
	 *
	 * If this is a relation then we need to see if there are any sub-objects
	 * (eg: columns) for it and, if so, be sure to call
	 * recordExtensionInitPrivWorker() for each one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Indexes don't have permissions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Composite types don't have permissions either */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this isn't a sequence, index, or composite type then it's
		 * possibly going to have columns associated with it that might have
		 * ACLs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>curr_att</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>nattrs</name> <init>= <expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relnatts</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>curr_att</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_att</name> <operator>&lt;=</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>curr_att</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>attaclDatum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>curr_att</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* ignore dropped columns */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>attaclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><name>attTuple</name></expr></argument>,
											  <argument><expr><name>Anum_pg_attribute_attacl</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* no need to do anything for a NULL ACL */</comment>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><name>curr_att</name></expr></argument>,
											  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>attaclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_foreign_data_wrapper */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>ForeignDataWrapperRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for foreign data wrapper %u"</literal></expr></argument>,
				 <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNDATAWRAPPEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_foreign_data_wrapper_fdwacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_foreign_server */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>ForeignServerRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for foreign data wrapper %u"</literal></expr></argument>,
				 <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>FOREIGNSERVEROID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_foreign_server_srvacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_language */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>LanguageRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_language_lanacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_largeobject_metadata */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>LargeObjectMetadataRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>LargeObjectMetadataRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* There's no syscache for pg_largeobject_metadata */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								  <argument><expr><name>LargeObjectMetadataOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for large object %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_largeobject_metadata_lomacl</name></expr></argument>,
								<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_namespace */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>NamespaceRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_namespace_nspacl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_proc */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>ProcedureRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* pg_type */</comment>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>TypeRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>aclDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>aclDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_type_typacl</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the record, if any, for the top-level object */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>DatumGetAclP</name><argument_list>(<argument><expr><name>aclDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>AccessMethodRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>AggregateRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>CastRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>CollationRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>ConversionRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>EventTriggerRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>OperatorRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>OperatorClassRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>OperatorFamilyRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>NamespaceRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>TSConfigRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>TSDictionaryRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>TSParserRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>TSTemplateRelationId</name> <operator>||</operator>
			 <name>classoid</name> <operator>==</operator> <name>TransformRelationId</name></expr>
		)</condition>
	<block>{<block_content>
		<comment type="block">/* no ACL for these object types, so do nothing. */</comment>
	</block_content>}</block></if>

	<comment type="block">/*
	 * complain if we are given a class OID for a class that extensions don't
	 * support or that we don't recognize.
	 */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized or unsupported class OID: %u"</literal></expr></argument>, <argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For the object passed in, remove its ACL and the ACLs of any object subIds
 * from pg_init_privs (via recordExtensionInitPrivWorker()).
 */</comment>
<function><type><name>void</name></type>
<name>removeExtObjInitPriv</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If this is a relation then we need to see if there are any sub-objects
	 * (eg: columns) for it and, if so, be sure to call
	 * recordExtensionInitPrivWorker() for each one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>classoid</name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>pg_class_tuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Indexes don't have permissions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
			<name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Composite types don't have permissions either */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If this isn't a sequence, index, or composite type then it's
		 * possibly going to have columns associated with it that might have
		 * ACLs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>curr_att</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>nattrs</name> <init>= <expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relnatts</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>curr_att</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>curr_att</name> <operator>&lt;=</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>curr_att</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>attTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>curr_att</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* when removing, remove all entries, even dropped columns */</comment>

				<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><name>curr_att</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Remove the record, if any, for the top-level object */</comment>
	<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record initial ACL for an extension object
 *
 * Can be called at any time, we check if 'creating_extension' is set and, if
 * not, exit immediately.
 *
 * Pass in the object OID, the OID of the class (the OID of the table which
 * the object is defined in) and the 'sub' id of the object (objsubid), if
 * any.  If there is no 'sub' id (they are currently only used for columns of
 * tables) then pass in '0'.  Finally, pass in the complete ACL to store.
 *
 * If an ACL already exists for this object/sub-object then we will replace
 * it with what is passed in.
 *
 * Passing in NULL for 'new_acl' will result in the entry for the object being
 * removed, if one is found.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recordExtensionInitPriv</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>objsubid</name></decl></parameter>, <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Generally, we only record the initial privileges when an extension is
	 * being created, but because we don't actually use CREATE EXTENSION
	 * during binary upgrades with pg_upgrade, there is a variable to let us
	 * know that the GRANT and REVOKE statements being issued, while this
	 * variable is true, are for the initial privileges of the extension
	 * object and therefore we need to record them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>creating_extension</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>binary_upgrade_record_init_privs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>recordExtensionInitPrivWorker</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>classoid</name></expr></argument>, <argument><expr><name>objsubid</name></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record initial ACL for an extension object, worker.
 *
 * This will perform a wholesale replacement of the entire ACL for the object
 * passed in, therefore be sure to pass in the complete new ACL to use.
 *
 * Generally speaking, do *not* use this function directly but instead use
 * recordExtensionInitPriv(), which checks if 'creating_extension' is set.
 * This function does *not* check if 'creating_extension' is set as it is also
 * used when an object is added to or removed from an extension via ALTER
 * EXTENSION ... ADD/DROP.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recordExtensionInitPrivWorker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>objoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>objsubid</name></decl></parameter>, <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InitPrivsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_init_privs_objoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_init_privs_classoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_init_privs_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>InitPrivsObjIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There should exist only one entry or none. */</comment>
	<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we find an entry, update it with the latest ACL. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_init_privs</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_init_privs</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replace</name><index>[<expr><name>Natts_pg_init_privs</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* If we have a new ACL to set, then update the row with it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_acl</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_initprivs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_init_privs_initprivs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* new_acl is NULL, so delete the entry we found. */</comment>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_init_privs</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_init_privs</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only add a new entry if the new ACL is non-NULL.
		 *
		 * If we are passed in a NULL ACL and no entry exists, we can just
		 * fall through and do nothing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_acl</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No entry found, so add it. */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_objoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_classoid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* This function only handles initial privileges of extensions */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_privtype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>CharGetDatum</name><argument_list>(<argument><expr><name>INITPRIVS_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_init_privs_initprivs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prevent error when processing objects multiple times */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if the two copies of ACLs are equal.
 * NB: both old_acl and new_acl are pfree'd.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>YbCheckAclCopiesEqual</name><parameter_list>(<parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>old_acl</name></decl></parameter>, <parameter><decl><type><name>Acl</name> <modifier>*</modifier></type><name>new_acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>aclitemsort</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_equal</name> <init>= <expr><call><name>aclequal</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>, <argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>is_equal</name></expr>;</return>
</block_content>}</block></function>
</unit>
