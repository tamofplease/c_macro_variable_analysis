<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/catalog/pg_inherits.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_inherits.c
 *	  routines to support manipulation of the pg_inherits relation
 *
 * Note: currently, this module only contains inquiry functions; the actual
 * creation and deletion of pg_inherits entries is done in tablecmds.c.
 * Perhaps someday that code should be moved here, but it'd have to be
 * disentangled from other stuff such as pg_depend updates.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/pg_inherits.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Entry of a hash table used in find_all_inheritors. See below.
 */</comment>
<typedef>typedef <type><struct>struct <name>SeenRelsEntry</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rel_id</name></decl>;</decl_stmt>			<comment type="block">/* relation oid */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>numparents_cell</name></decl>;</decl_stmt>	<comment type="block">/* corresponding list cell */</comment>
}</block></struct></type> <name>SeenRelsEntry</name>;</typedef>

<comment type="block">/*
 * find_inheritance_children
 *
 * Returns a list containing the OIDs of all relations which
 * inherit *directly* from the relation with OID 'parentrelId'.
 *
 * The specified lock type is acquired on each child relation (but not on the
 * given rel; caller should already have locked it).  If lockmode is NoLock
 * then no locks are acquired, but caller must beware of race conditions
 * against possible DROPs of child relations.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>find_inheritance_children</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentrelId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inheritsTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inhrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oidarr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxoids</name></decl>,
				<decl><type ref="prev"/><name>numoids</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can skip the scan if pg_class shows the relation has never had a
	 * subclass.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>parentrelId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan pg_inherits and build a working array of subclass OIDs.
	 */</comment>
	<expr_stmt><expr><name>oidarr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numoids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		* In a Yugabyte cluster, the pg_inherits table is cached, hence the
		* relevant information can be fetched from the SysCache.
		*/</comment>
		<decl_stmt><decl><type><name>CatCList</name> <modifier>*</modifier></type><name>inhlist</name> <init>= <expr><call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>INHERITSRELID</name></expr></argument>,
		<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentrelId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>oidarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>inhlist</name><operator>-&gt;</operator><name>n_members</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>inhlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>inheritsTuple</name> <init>= <expr><operator>&amp;</operator><name><name>inhlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>oidarr</name><index>[<expr><name>numoids</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<operator>(</operator><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>inhrelid</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ReleaseCatCacheList</name><argument_list>(<argument><expr><name>inhlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>maxoids</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>oidarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxoids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentrelId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>InheritsParentIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>inhrelid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>inhrelid</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>numoids</name> <operator>&gt;=</operator> <name>maxoids</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>maxoids</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>oidarr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>oidarr</name></expr></argument>, <argument><expr><name>maxoids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>oidarr</name><index>[<expr><name>numoids</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>inhrelid</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we found more than one child, sort them by OID.  This ensures
	 * reasonably consistent behavior regardless of the vagaries of an
	 * indexscan.  This is important since we need to be sure all backends
	 * lock children in the same order to avoid needless deadlocks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numoids</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>oidarr</name></expr></argument>, <argument><expr><name>numoids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Acquire locks and build the result list.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numoids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>inhrelid</name> <operator>=</operator> <name><name>oidarr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Get the lock to synchronize against concurrent drop */</comment>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>inhrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we have the lock, double-check to see if the relation
			 * really exists or not.  If not, assume it was dropped while we
			 * waited to acquire lock, and ignore it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Release useless lock */</comment>
				<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>inhrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* And ignore this relation */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oidarr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * find_all_inheritors -
 *		Returns a list of relation OIDs including the given rel plus
 *		all relations that inherit from it, directly or indirectly.
 *		Optionally, it also returns the number of parents found for
 *		each such relation within the inheritance tree rooted at the
 *		given rel.
 *
 * The specified lock type is acquired on all child relations (but not on the
 * given rel; caller should already have locked it).  If lockmode is NoLock
 * then no locks are acquired, but caller must beware of race conditions
 * against possible DROPs of child relations.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>find_all_inheritors</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentrelId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>numparents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* hash table for O(1) rel_oid -&gt; rel_numparents cell lookup */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>seen_rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rels_list</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rel_numparents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SeenRelsEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seen_rels</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"find_all_inheritors temporary table"</literal></expr></argument>,
							<argument><expr><literal type="number">32</literal></expr></argument>, <comment type="block">/* start small and extend */</comment>
							<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
							<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We build a list starting with the given rel and adding all direct and
	 * indirect children.  We can use a single list as both the record of
	 * already-found rels and the agenda of rels yet to be scanned for more
	 * children.  This is a bit tricky but works because the foreach() macro
	 * doesn't fetch the next list element until the bottom of the loop.
	 */</comment>
	<expr_stmt><expr><name>rels_list</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>parentrelId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel_numparents</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rels_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>currentrel</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>currentchildren</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Get the direct children of this rel */</comment>
		<expr_stmt><expr><name>currentchildren</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><name>currentrel</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add to the queue only those children not already seen. This avoids
		 * making duplicate entries in case of multiple inheritance paths from
		 * the same parent.  (It'll also keep us from getting into an infinite
		 * loop, though theoretically there can't be any cycles in the
		 * inheritance graph anyway.)
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>currentchildren</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>child_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SeenRelsEntry</name> <modifier>*</modifier></type><name>hash_entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>hash_entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>seen_rels</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>child_oid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if the rel is already there, bump number-of-parents counter */</comment>
				<expr_stmt><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name><name>hash_entry</name><operator>-&gt;</operator><name>numparents_cell</name></name></expr></argument>)</argument_list></call><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* if it's not there, add it. expect 1 parent, initially. */</comment>
				<expr_stmt><expr><name>rels_list</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>rels_list</name></expr></argument>, <argument><expr><name>child_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rel_numparents</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>rel_numparents</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hash_entry</name><operator>-&gt;</operator><name>numparents_cell</name></name> <operator>=</operator> <name><name>rel_numparents</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>numparents</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>numparents</name> <operator>=</operator> <name>rel_numparents</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>rel_numparents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>seen_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rels_list</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_subclass - does this relation have any children?
 *
 * In the current implementation, has_subclass returns whether a
 * particular class *might* have a subclass. It will not return the
 * correct result if a class had a subclass which was later dropped.
 * This is because relhassubclass in pg_class is not updated immediately
 * when a subclass is dropped, primarily because of concurrency concerns.
 *
 * Currently has_subclass is only used as an efficiency hack to skip
 * unnecessary inheritance searches, so this is OK.  Note that ANALYZE
 * on a childless table will clean up the obsolete relhassubclass flag.
 *
 * Although this doesn't actually touch pg_inherits, it seems reasonable
 * to keep it here since it's normally used with the other routines here.
 */</comment>
<function><type><name>bool</name></type>
<name>has_subclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relhassubclass</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * has_superclass - does this relation inherit from another?  The caller
 * should hold a lock on the given relation so that it can't be concurrently
 * added to or removed from an inheritance hierarchy.
 */</comment>
<function><type><name>bool</name></type>
<name>has_superclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given two type OIDs, determine whether the first is a complex type
 * (class type) that inherits from the second.
 *
 * This essentially asks whether the first type is guaranteed to be coercible
 * to the second.  Therefore, we allow the first type to be a domain over a
 * complex type that inherits from the second; that creates no difficulties.
 * But the second type cannot be a domain.
 */</comment>
<function><type><name>bool</name></type>
<name>typeInheritsFrom</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>subclassTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>superclassTypeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>subclassRelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>superclassRelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inhrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>visited</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>queue_item</name></decl>;</decl_stmt>

	<comment type="block">/* We need to work with the associated relation OIDs */</comment>
	<expr_stmt><expr><name>subclassRelid</name> <operator>=</operator> <call><name>typeOrDomainTypeRelid</name><argument_list>(<argument><expr><name>subclassTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>subclassRelid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not a complex type or domain over one */</comment>
	<expr_stmt><expr><name>superclassRelid</name> <operator>=</operator> <call><name>typeidTypeRelid</name><argument_list>(<argument><expr><name>superclassTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>superclassRelid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not a complex type */</comment>

	<comment type="block">/* No point in searching if the superclass has no subclasses */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>superclassRelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Begin the search at the relation itself, so add its relid to the queue.
	 */</comment>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>subclassRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>visited</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>inhrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use queue to do a breadth-first traversal of the inheritance graph from
	 * the relid supplied up to the root.  Notice that we append to the queue
	 * inside the loop --- this is okay because the foreach() macro doesn't
	 * advance queue_item until the next loop iteration begins.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>queue_item</argument>, <argument>queue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>this_relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>queue_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>inhscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inhtup</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we've seen this relid already, skip it.  This avoids extra work
		 * in multiple-inheritance scenarios, and also protects us from an
		 * infinite loop in case there is a cycle in pg_inherits (though
		 * theoretically that shouldn't happen).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><name>this_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Okay, this is a not-yet-seen relid. Add it to the list of
		 * already-visited OIDs, then find all the types this relid inherits
		 * from and add them to the queue.
		 */</comment>
		<expr_stmt><expr><name>visited</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><name>this_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
					<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>this_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>inhscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>inhrel</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>inhtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>inhscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_inherits</name></type> <name>inh</name> <init>= <expr><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inhtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>inhparent</name> <init>= <expr><name><name>inh</name><operator>-&gt;</operator><name>inhparent</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If this is the target superclass, we're done */</comment>
			<if_stmt><if>if <condition>(<expr><name>inhparent</name> <operator>==</operator> <name>superclassRelid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Else add to queue */</comment>
			<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>inhscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up ... */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inhrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a single pg_inherits row with the given data
 */</comment>
<function><type><name>void</name></type>
<name>StoreSingleInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>parentOid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>seqNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_inherits</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_inherits</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>inhRelation</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>inhRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the pg_inherits entry
	 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhparent</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_inherits_inhseqno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>seqNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>inhRelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>inhRelation</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>inhRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DeleteInheritsTuple
 *
 * Delete pg_inherits tuples with the given inhrelid.  inhparent may be given
 * as InvalidOid, in which case all tuples matching inhrelid are deleted;
 * otherwise only delete tuples with the specified inhparent.
 *
 * Returns whether at least one row was deleted.
 */</comment>
<function><type><name>bool</name></type>
<name>DeleteInheritsTuple</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>inhrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inhparent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>inheritsTuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find pg_inherits entries by inhrelid.
	 */</comment>
	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>inheritsTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>parent</name></decl>;</decl_stmt>

		<comment type="block">/* Compare inhparent if it was given, and do the actual deletion. */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_inherits</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>inhparent</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>inhparent</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>parent</name> <operator>==</operator> <name>inhparent</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>inheritsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Done */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>
</unit>
