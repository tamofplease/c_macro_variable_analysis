<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/heap/pruneheap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pruneheap.c
 *	  heap page pruning and HOT-chain management code
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/heap/pruneheap.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* Working data for heap_page_prune and subroutines */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>new_prune_xid</name></decl>;</decl_stmt>	<comment type="block">/* new prune hint value for page */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestRemovedXid</name></decl>;</decl_stmt> <comment type="block">/* latest xid to be removed by this prune */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nredirected</name></decl>;</decl_stmt>	<comment type="block">/* numbers of entries in arrays below */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nunused</name></decl>;</decl_stmt>
	<comment type="block">/* arrays that accumulate indexes of items to be changed */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>redirected</name><index>[<expr><name>MaxHeapTuplesPerPage</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>nowdead</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>nowunused</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* marked[i] is true if item i is entered in one of the above arrays */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>marked</name><index>[<expr><name>MaxHeapTuplesPerPage</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PruneState</name>;</typedef>

<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>heap_prune_chain</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>rootoffnum</name></decl></parameter>,
				 <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
				 <parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>heap_prune_record_prunable</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>heap_prune_record_redirect</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>,
						   <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>rdoffnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>heap_prune_record_dead</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>heap_prune_record_unused</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Optionally prune and repair fragmentation in the specified page.
 *
 * This is an opportunistic function.  It will perform housekeeping
 * only if the page heuristically looks like a candidate for pruning and we
 * can acquire buffer cleanup lock without blocking.
 *
 * Note: this is called quite often.  It's important that it fall out quickly
 * if there's not any use in pruning.
 *
 * Caller must have pin on the buffer, and must *not* have a lock on it.
 *
 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD
 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
 */</comment>
<function><type><name>void</name></type>
<name>heap_page_prune_opt</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>minfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can't write WAL in recovery mode, so there's no point trying to
	 * clean the page. The master will likely issue a cleaning WAL record soon
	 * anyway, so this is no particular loss.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use the appropriate xmin horizon for this relation. If it's a proper
	 * catalog relation or a user defined, additional, catalog relation, we
	 * need to use the horizon that includes slots, otherwise the data-only
	 * horizon can be used. Note that the toast relation of user defined
	 * relations are *not* considered catalog relations.
	 *
	 * It is OK to apply the old snapshot limit before acquiring the cleanup
	 * lock because the worst that can happen is that we are not quite as
	 * aggressive about the cleanup (by however many transaction IDs are
	 * consumed between this point and acquiring the lock).  This allows us to
	 * save significant overhead in the case where the page is found not to be
	 * prunable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>RelationIsAccessibleInLogicalDecoding</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <name>RecentGlobalXmin</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator>
			<call><name>TransactionIdLimitedForOldSnapshots</name><argument_list>(<argument><expr><name>RecentGlobalDataXmin</name></expr></argument>,
												<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let's see if we really need pruning.
	 *
	 * Forget it if page is not hinted to contain something prunable that's
	 * older than OldestXmin.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIsPrunable</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We prune when a previous UPDATE failed to find enough space on the page
	 * for a new tuple version, or when free space falls below the relation's
	 * fill-factor target (but not less than 10%).
	 *
	 * Checking free space here is questionable since we aren't holding any
	 * lock on the buffer; in the worst case we could get a bogus answer. It's
	 * unlikely to be *seriously* wrong, though, since reading either pd_lower
	 * or pd_upper is probably atomic.  Avoiding taking a lock seems more
	 * important than sometimes getting a wrong answer in what is after all
	 * just a heuristic estimate.
	 */</comment>
	<expr_stmt><expr><name>minfree</name> <operator>=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
											 <argument><expr><name>HEAP_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>minfree</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>minfree</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageIsFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minfree</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, try to get exclusive buffer lock */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBufferForCleanup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Now that we have buffer lock, get accurate information about the
		 * page's free space, and recheck the heuristic about whether to
		 * prune. (We needn't recheck PageIsPrunable, since no one else could
		 * have pruned while we hold pin.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageGetHeapFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>minfree</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>ignore</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* return value not
															 * needed */</comment>

			<comment type="block">/* OK to prune */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>heap_page_prune</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ignore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And release buffer lock */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Prune and repair fragmentation in the specified page.
 *
 * Caller must have pin and buffer cleanup lock on the page.
 *
 * OldestXmin is the cutoff XID used to distinguish whether tuples are DEAD
 * or RECENTLY_DEAD (see HeapTupleSatisfiesVacuum).
 *
 * If report_stats is true then we send the number of reclaimed heap-only
 * tuples to pgstats.  (This must be false during vacuum, since vacuum will
 * send its own new total to pgstats, and we don't want this delta applied
 * on top of that.)
 *
 * Returns the number of tuples deleted from the page and sets
 * latestRemovedXid.
 */</comment>
<function><type><name>int</name></type>
<name>heap_page_prune</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>report_stats</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>latestRemovedXid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PruneState</name></type>	<name>prstate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Our strategy is to scan the page and make lists of items to change,
	 * then apply the changes within a critical section.  This keeps as much
	 * logic as possible out of the critical section, and also ensures that
	 * WAL replay will work the same as the normal case.
	 *
	 * First, initialize the new pd_prune_xid value to zero (indicating no
	 * prunable tuples).  If we find any tuples which may soon become
	 * prunable, we will save the lowest relevant XID in new_prune_xid. Also
	 * initialize the rest of our working state.
	 */</comment>
	<expr_stmt><expr><name><name>prstate</name><operator>.</operator><name>new_prune_xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>.</operator><name>latestRemovedXid</name></name> <operator>=</operator> <operator>*</operator><name>latestRemovedXid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>.</operator><name>nredirected</name></name> <operator>=</operator> <name><name>prstate</name><operator>.</operator><name>ndead</name></name> <operator>=</operator> <name><name>prstate</name><operator>.</operator><name>nunused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>prstate</name><operator>.</operator><name>marked</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>prstate</name><operator>.</operator><name>marked</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan the page */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore items already processed as part of an earlier chain */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prstate</name><operator>.</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Nothing to do if slot is empty or already dead */</comment>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Process this item or chain of items */</comment>
		<expr_stmt><expr><name>ndeleted</name> <operator>+=</operator> <call><name>heap_prune_chain</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>,
									 <argument><expr><name>OldestXmin</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>prstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Any error while applying the changes is critical */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Have we found any prunable items? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prstate</name><operator>.</operator><name>nredirected</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>prstate</name><operator>.</operator><name>ndead</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>prstate</name><operator>.</operator><name>nunused</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Apply the planned item changes, then repair page fragmentation, and
		 * update the page's hint bit about whether it has free line pointers.
		 */</comment>
		<expr_stmt><expr><call><name>heap_page_prune_execute</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
								<argument><expr><name><name>prstate</name><operator>.</operator><name>redirected</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>nredirected</name></name></expr></argument>,
								<argument><expr><name><name>prstate</name><operator>.</operator><name>nowdead</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>ndead</name></name></expr></argument>,
								<argument><expr><name><name>prstate</name><operator>.</operator><name>nowunused</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>nunused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update the page's pd_prune_xid field to either zero, or the lowest
		 * XID of any soon-prunable tuple.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_prune_xid</name> <operator>=</operator> <name><name>prstate</name><operator>.</operator><name>new_prune_xid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also clear the "page is full" flag, since there's no point in
		 * repeating the prune/defrag process until something else happens to
		 * the page.
		 */</comment>
		<expr_stmt><expr><call><name>PageClearFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Emit a WAL XLOG_HEAP2_CLEAN record showing what we did
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>log_heap_clean</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>,
									<argument><expr><name><name>prstate</name><operator>.</operator><name>redirected</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>nredirected</name></name></expr></argument>,
									<argument><expr><name><name>prstate</name><operator>.</operator><name>nowdead</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>ndead</name></name></expr></argument>,
									<argument><expr><name><name>prstate</name><operator>.</operator><name>nowunused</name></name></expr></argument>, <argument><expr><name><name>prstate</name><operator>.</operator><name>nunused</name></name></expr></argument>,
									<argument><expr><name><name>prstate</name><operator>.</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't prune anything, but have found a new value for the
		 * pd_prune_xid field, update it and mark the buffer dirty. This is
		 * treated as a non-WAL-logged hint.
		 *
		 * Also clear the "page is full" flag if it is set, since there's no
		 * point in repeating the prune/defrag process until something else
		 * happens to the page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_prune_xid</name> <operator>!=</operator> <name><name>prstate</name><operator>.</operator><name>new_prune_xid</name></name> <operator>||</operator>
			<call><name>PageIsFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_prune_xid</name> <operator>=</operator> <name><name>prstate</name><operator>.</operator><name>new_prune_xid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageClearFull</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If requested, report the number of tuples reclaimed to pgstats. This is
	 * ndeleted minus ndead, because we don't want to count a now-DEAD root
	 * item as a deletion for this purpose.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>report_stats</name> <operator>&amp;&amp;</operator> <name>ndeleted</name> <operator>&gt;</operator> <name><name>prstate</name><operator>.</operator><name>ndead</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_update_heap_dead_tuples</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ndeleted</name> <operator>-</operator> <name><name>prstate</name><operator>.</operator><name>ndead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>latestRemovedXid</name> <operator>=</operator> <name><name>prstate</name><operator>.</operator><name>latestRemovedXid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX Should we update the FSM information of this page ?
	 *
	 * There are two schools of thought here. We may not want to update FSM
	 * information so that the page is not used for unrelated UPDATEs/INSERTs
	 * and any free space in this page will remain available for further
	 * UPDATEs in *this* page, thus improving chances for doing HOT updates.
	 *
	 * But for a large table and where a page does not receive further UPDATEs
	 * for a long time, we might waste this space by not updating the FSM
	 * information. The relation may get extended and fragmented further.
	 *
	 * One possibility is to leave "fillfactor" worth of space in this page
	 * and update FSM with the remaining space.
	 */</comment>

	<return>return <expr><name>ndeleted</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Prune specified item pointer or a HOT chain originating at that item.
 *
 * If the item is an index-referenced tuple (i.e. not a heap-only tuple),
 * the HOT chain is pruned by removing all DEAD tuples at the start of the HOT
 * chain.  We also prune any RECENTLY_DEAD tuples preceding a DEAD tuple.
 * This is OK because a RECENTLY_DEAD tuple preceding a DEAD tuple is really
 * DEAD, the OldestXmin test is just too coarse to detect it.
 *
 * The root line pointer is redirected to the tuple immediately after the
 * latest DEAD tuple.  If all tuples in the chain are DEAD, the root line
 * pointer is marked LP_DEAD.  (This includes the case of a DEAD simple
 * tuple, which we treat as a chain of length 1.)
 *
 * OldestXmin is the cutoff XID used to identify dead tuples.
 *
 * We don't actually change the page here, except perhaps for hint-bit updates
 * caused by HeapTupleSatisfiesVacuum.  We just add entries to the arrays in
 * prstate showing the changes to be made.  Items to be redirected are added
 * to the redirected[] array (two entries per redirection); items to be set to
 * LP_DEAD state are added to nowdead[]; and items to be set to LP_UNUSED
 * state are added to nowunused[].
 *
 * Returns the number of tuples (to be) deleted from the page.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>heap_prune_chain</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>rootoffnum</name></decl></parameter>,
				 <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
				 <parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>dp</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>priorXmax</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>rootlp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>latestdead</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>,
				<decl><type ref="prev"/><name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>chainitems</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rootlp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a heap-only tuple, then it is not the start of a HOT chain.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>htup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderIsHeapOnly</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the tuple is DEAD and doesn't chain to anything else, mark
			 * it unused immediately.  (If it does chain, we can only remove
			 * it as part of pruning its chain.)
			 *
			 * We need this primarily to handle aborted HOT updates, that is,
			 * XMIN_INVALID heap-only tuples.  Those might not be linked to by
			 * any chain, since the parent tuple might be re-updated before
			 * any pruning occurs.  So we have to be able to reap them
			 * separately from chain-pruning.  (Note that
			 * HeapTupleHeaderIsHotUpdated will never return true for an
			 * XMIN_INVALID tuple, so this code will work even when there were
			 * sequential updates within the aborted transaction.)
			 *
			 * Note that we might first arrive at a dead heap-only tuple
			 * either here or while following a chain below.  Whichever path
			 * gets there first will mark the tuple unused.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call>
				<operator>==</operator> <name>HEAPTUPLE_DEAD</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HeapTupleHeaderIsHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>heap_prune_record_unused</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>HeapTupleHeaderAdvanceLatestRemovedXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name><name>prstate</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ndeleted</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Nothing more to do */</comment>
			<return>return <expr><name>ndeleted</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Start from the root tuple */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>rootoffnum</name></expr>;</expr_stmt>

	<comment type="block">/* while not end of the chain */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tupdead</name></decl>,
					<decl><type ref="prev"/><name>recent_dead</name></decl>;</decl_stmt>

		<comment type="block">/* Some sanity checks */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>offnum</name> <argument_list type="generic">&lt; <argument><expr><name>FirstOffsetNumber</name> <operator>||</operator> <name>offnum</name></expr></argument> &gt;</argument_list></name> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* If item is already processed, stop --- it must not be same chain */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Unused item obviously isn't part of the chain */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we are looking at the redirected root line pointer, jump to the
		 * first normal tuple in the chain.  If we find a redirect somewhere
		 * else, stop --- it must not be same chain.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nchain</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* not at start of chain */</comment>
			<expr_stmt><expr><name><name>chainitems</name><index>[<expr><name>nchain</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemIdGetRedirect</name><argument_list>(<argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Likewise, a dead item pointer can't be part of the chain. (We
		 * already eliminated the case of dead root tuple outside this
		 * function.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>htup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check the tuple XMIN against prior XMAX, if any
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, this tuple is indeed a member of the chain.
		 */</comment>
		<expr_stmt><expr><name><name>chainitems</name><index>[<expr><name>nchain</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check tuple's visibility status.
		 */</comment>
		<expr_stmt><expr><name>tupdead</name> <operator>=</operator> <name>recent_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tup</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
				<expr_stmt><expr><name>tupdead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>
				<expr_stmt><expr><name>recent_dead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * This tuple may soon become DEAD.  Update the hint field so
				 * that the page is reconsidered for pruning in future.
				 */</comment>
				<expr_stmt><expr><call><name>heap_prune_record_prunable</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>,
										   <argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * This tuple may soon become DEAD.  Update the hint field so
				 * that the page is reconsidered for pruning in future.
				 */</comment>
				<expr_stmt><expr><call><name>heap_prune_record_prunable</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>,
										   <argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
			<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

				<comment type="block">/*
				 * If we wanted to optimize for aborts, we might consider
				 * marking the page prunable when we see INSERT_IN_PROGRESS.
				 * But we don't.  See related decisions about when to mark the
				 * page prunable in heapam.c.
				 */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Remember the last DEAD tuple seen.  We will advance past
		 * RECENTLY_DEAD tuples just in case there's a DEAD one after them;
		 * but we can't advance past anything else.  (XXX is it really worth
		 * continuing to scan beyond RECENTLY_DEAD?  The case where we will
		 * find another DEAD tuple is a fairly unusual corner case.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupdead</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>latestdead</name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>HeapTupleHeaderAdvanceLatestRemovedXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>prstate</name><operator>-&gt;</operator><name>latestRemovedXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>recent_dead</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the tuple is not HOT-updated, then we are at the end of this
		 * HOT-update chain.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderIsHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* HOT implies it can't have moved to different partition */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Advance to next chain member.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
			   <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we found a DEAD tuple in the chain, adjust the HOT chain so that all
	 * the DEAD tuples at the start of the chain are removed and the root line
	 * pointer is appropriately redirected.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>latestdead</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Mark as unused each intermediate item that we are able to remove
		 * from the chain.
		 *
		 * When the previous item is the last dead tuple seen, we are at the
		 * right candidate for redirection.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>nchain</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>chainitems</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>latestdead</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>heap_prune_record_unused</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>, <argument><expr><name><name>chainitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ndeleted</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If the root entry had been a normal tuple, we are deleting it, so
		 * count it in the result.  But changing a redirect (even to DEAD
		 * state) doesn't count.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ndeleted</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the DEAD tuple is at the end of the chain, the entire chain is
		 * dead and the root line pointer can be marked dead.  Otherwise just
		 * redirect the root to the correct chain member.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nchain</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_prune_record_dead</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>heap_prune_record_redirect</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>, <argument><expr><name><name>chainitems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nchain</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>rootlp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We found a redirect item that doesn't point to a valid follow-on
		 * item.  This can happen if the loop in heap_page_prune caused us to
		 * visit the dead successor of a redirect item before visiting the
		 * redirect item.  We can clean up by setting the redirect item to
		 * DEAD state.
		 */</comment>
		<expr_stmt><expr><call><name>heap_prune_record_dead</name><argument_list>(<argument><expr><name>prstate</name></expr></argument>, <argument><expr><name>rootoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ndeleted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Record lowest soon-prunable XID */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_prune_record_prunable</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This should exactly match the PageSetPrunable macro.  We can't store
	 * directly into the page header yet, so we update working state.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>prstate</name><operator>-&gt;</operator><name>new_prune_xid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>prstate</name><operator>-&gt;</operator><name>new_prune_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>new_prune_xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Record item pointer to be redirected */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_prune_record_redirect</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>,
						   <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>rdoffnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prstate</name><operator>-&gt;</operator><name>nredirected</name></name> <operator>&lt;</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>redirected</name><index>[<expr><name><name>prstate</name><operator>-&gt;</operator><name>nredirected</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>redirected</name><index>[<expr><name><name>prstate</name><operator>-&gt;</operator><name>nredirected</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>rdoffnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>nredirected</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>rdoffnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>rdoffnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record item pointer to be marked dead */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_prune_record_dead</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prstate</name><operator>-&gt;</operator><name>ndead</name></name> <operator>&lt;</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>nowdead</name><index>[<expr><name><name>prstate</name><operator>-&gt;</operator><name>ndead</name></name></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>ndead</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Record item pointer to be marked unused */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>heap_prune_record_unused</name><parameter_list>(<parameter><decl><type><name>PruneState</name> <modifier>*</modifier></type><name>prstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prstate</name><operator>-&gt;</operator><name>nunused</name></name> <operator>&lt;</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>nowunused</name><index>[<expr><name><name>prstate</name><operator>-&gt;</operator><name>nunused</name></name></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>nunused</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prstate</name><operator>-&gt;</operator><name>marked</name><index>[<expr><name>offnum</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Perform the actual page changes needed by heap_page_prune.
 * It is expected that the caller has suitable pin and lock on the
 * buffer, and is inside a critical section.
 *
 * This is split out because it is also used by heap_xlog_clean()
 * to replay the WAL record when needed after a crash.  Note that the
 * arguments are identical to those of log_heap_clean().
 */</comment>
<function><type><name>void</name></type>
<name>heap_page_prune_execute</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>redirected</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nredirected</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowdead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndead</name></decl></parameter>,
						<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>nowunused</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nunused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Update all redirected line pointers */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>redirected</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nredirected</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>fromoff</name> <init>= <expr><operator>*</operator><name>offnum</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>tooff</name> <init>= <expr><operator>*</operator><name>offnum</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>fromlp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>fromoff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ItemIdSetRedirect</name><argument_list>(<argument><expr><name>fromlp</name></expr></argument>, <argument><expr><name>tooff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Update all now-dead line pointers */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>nowdead</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndead</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><operator>*</operator><name>offnum</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ItemIdSetDead</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Update all now-unused line pointers */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>nowunused</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nunused</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><operator>*</operator><name>offnum</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ItemIdSetUnused</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Finally, repair any fragmentation, and update the page's hint bit about
	 * whether it has free pointers.
	 */</comment>
	<expr_stmt><expr><call><name>PageRepairFragmentation</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * For all items in this page, find their respective root line pointers.
 * If item k is part of a HOT-chain with root at item j, then we set
 * root_offsets[k - 1] = j.
 *
 * The passed-in root_offsets array must have MaxHeapTuplesPerPage entries.
 * We zero out all unused entries.
 *
 * The function must be called with at least share lock on the buffer, to
 * prevent concurrent prune operations.
 *
 * Note: The information collected here is valid only as long as the caller
 * holds a pin on the buffer. Once pin is released, a tuple might be pruned
 * and reused by a completely unrelated tuple.
 */</comment>
<function><type><name>void</name></type>
<name>heap_get_root_tuples</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>root_offsets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>root_offsets</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MaxHeapTuplesPerPage</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>htup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>nextoffnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>priorXmax</name></decl>;</decl_stmt>

		<comment type="block">/* skip unused and dead items */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsUsed</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if this tuple is part of a HOT-chain rooted at some other
			 * tuple. If so, skip it for now; we'll process it when we find
			 * its root.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHeaderIsHeapOnly</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * This is either a plain tuple or the root of a HOT-chain.
			 * Remember it in the mapping.
			 */</comment>
			<expr_stmt><expr><name><name>root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>

			<comment type="block">/* If it's not the start of a HOT-chain, we're done with it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderIsHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Set up to scan the HOT-chain */</comment>
			<expr_stmt><expr><name>nextoffnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Must be a redirect item. We do not set its root_offsets entry */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemIdIsRedirected</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set up to scan the HOT-chain */</comment>
			<expr_stmt><expr><name>nextoffnum</name> <operator>=</operator> <call><name>ItemIdGetRedirect</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Now follow the HOT-chain and collect other tuples in the chain.
		 *
		 * Note: Even though this is a nested loop, the complexity of the
		 * function is O(N) because a tuple in the page should be visited not
		 * more than twice, once in the outer loop and once in HOT-chain
		 * chases.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nextoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check for broken chains */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsNormal</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>htup</name> <operator>=</operator> <operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>priorXmax</name></expr></argument>, <argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Remember the root line pointer for this item */</comment>
			<expr_stmt><expr><name><name>root_offsets</name><index>[<expr><name>nextoffnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>

			<comment type="block">/* Advance to next chain member, if any */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderIsHotUpdated</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* HOT implies it can't have moved to different partition */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderIndicatesMovedPartitions</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nextoffnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_ctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>priorXmax</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
</block_content>}</block></function>
</unit>
