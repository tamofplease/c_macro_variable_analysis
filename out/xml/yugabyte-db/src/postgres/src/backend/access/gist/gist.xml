<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/gist/gist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gist.c
 *	  interface routines for the postgres GiST index access method.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/gist/gist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gistscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/index_selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistfixsplit</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gistinserttuple</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gistinserttuples</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				 <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
				 <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>,
				 <parameter><decl><type><name>Buffer</name></type> <name>leftchild</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rightchild</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>unlockbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlockleftchild</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistfinishsplit</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>releasebuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistvacuumpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
			   <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROTATEDIST</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
	SplitedPageLayout *tmp=(SplitedPageLayout*)palloc(sizeof(SplitedPageLayout)); \
	memset(tmp,0,sizeof(SplitedPageLayout)); \
	tmp-&gt;block.blkno = InvalidBlockNumber;	\
	tmp-&gt;buffer = InvalidBuffer;	\
	tmp-&gt;next = (d); \
	(d)=tmp; \
} while(0)</cpp:value></cpp:define>


<comment type="block">/*
 * GiST handler function: return IndexAmRoutine with access method parameters
 * and callbacks.
 */</comment>
<function><type><name>Datum</name></type>
<name>gisthandler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>=</operator> <name>GISTNProcs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amclusterable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcaninclude</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuild</name></name> <operator>=</operator> <name>gistbuild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name> <operator>=</operator> <name>gistbuildempty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminsert</name></name> <operator>=</operator> <name>gistinsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name> <operator>=</operator> <name>gistbulkdelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name> <operator>=</operator> <name>gistvacuumcleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name>gistcanreturn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name>gistcostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name> <operator>=</operator> <name>gistoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amproperty</name></name> <operator>=</operator> <name>gistproperty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvalidate</name></name> <operator>=</operator> <name>gistvalidate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name> <operator>=</operator> <name>gistbeginscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrescan</name></name> <operator>=</operator> <name>gistrescan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>=</operator> <name>gistgettuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>=</operator> <name>gistgetbitmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amendscan</name></name> <operator>=</operator> <name>gistendscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create and return a temporary memory context for use by GiST. We
 * _always_ invoke user-provided methods in a temporary memory
 * context, so that memory leaks in those functions cannot cause
 * problems. Also, we use some additional temporary contexts in the
 * GiST code itself, to avoid the need to do some awkward manual
 * memory management.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>createTempGistContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
								 <argument><expr><literal type="string">"GiST temporary context"</literal></expr></argument>,
								 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	gistbuildempty() -- build an empty gist index in the initialization fork
 */</comment>
<function><type><name>void</name></type>
<name>gistbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the root page */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize and xlog buffer */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GISTInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>F_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unlock and release the buffer */</comment>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	gistinsert -- wrapper for GiST tuple insertion.
 *
 *	  This is the public interface routine for tuple insertion in GiSTs.
 *	  It doesn't do any work; just locks the relation and passes the buck.
 */</comment>
<function><type><name>bool</name></type>
<name>gistinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>ht_ctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
		   <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
		   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name> <init>= <expr><operator>(</operator><name>GISTSTATE</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize GISTSTATE cache if first call in this statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>giststate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>giststate</name> <operator>=</operator> <call><name>initGISTstate</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name> <operator>=</operator> <call><name>createTempGistContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>giststate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>gistFormTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
						 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* size is currently bogus */</comment> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <operator>*</operator><name>ht_ctid</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gistdoinsert</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cleanup */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Place tuples from 'itup' to 'buffer'. If 'oldoffnum' is valid, the tuple
 * at that offset is atomically removed along with inserting the new tuples.
 * This is used to replace a tuple with a new one.
 *
 * If 'leftchildbuf' is valid, we're inserting the downlink for the page
 * to the right of 'leftchildbuf', or updating the downlink for 'leftchildbuf'.
 * F_FOLLOW_RIGHT flag on 'leftchildbuf' is cleared and NSN is set.
 *
 * If 'markfollowright' is true and the page is split, the left child is
 * marked with F_FOLLOW_RIGHT flag. That is the normal case. During buffered
 * index build, however, there is no concurrent access and the page splitting
 * is done in a slightly simpler fashion, and false is passed.
 *
 * If there is not enough room on the page, it is split. All the split
 * pages are kept pinned and locked and returned in *splitinfo, the caller
 * is responsible for inserting the downlinks for them. However, if
 * 'buffer' is the root page and it needs to be split, gistplacetopage()
 * performs the split as one atomic operation, and *splitinfo is set to NIL.
 * In that case, we continue to hold the root page locked, and the child
 * pages are released; note that new tuple(s) are *not* on the root page
 * but in one of the new child pages.
 *
 * If 'newblkno' is not NULL, returns the block number of page the first
 * new/updated tuple was inserted to. Usually it's the given page, but could
 * be its right sibling if the page was split.
 *
 * Returns 'true' if the page was split, 'false' otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>gistplacetopage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>freespace</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
				<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
				<parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>,
				<parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>newblkno</name></decl></parameter>,
				<parameter><decl><type><name>Buffer</name></type> <name>leftchildbuf</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>splitinfo</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>markfollowright</name></decl></parameter>,
				<parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_leaf</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_split</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Refuse to modify a page that's incompletely split. This should not
	 * happen because we finish any incomplete splits while we walk down the
	 * tree. However, it's remotely possible that another concurrent inserter
	 * splits a parent page, and errors out before completing the split. We
	 * will just throw an error in that case, and leave any split we had in
	 * progress unfinished too. The next insert that comes along will clean up
	 * the mess.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"concurrent GiST page split was incomplete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>splitinfo</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if isupdate, remove old key: This node's key has been modified, either
	 * because a child split occurred or because we needed to adjust our key
	 * for an insert in a child node. Therefore, remove the old version of
	 * this node's key.
	 *
	 * for WAL replay, in the non-split case we handle this by setting up a
	 * one-element todelete array; in the split case, it's handled implicitly
	 * because the tuple vector passed to gistSplit won't include this tuple.
	 */</comment>
	<expr_stmt><expr><name>is_split</name> <operator>=</operator> <call><name>gistnospace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If leaf page is full, try at first to delete dead tuples. And then
	 * check again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_split</name> <operator>&amp;&amp;</operator> <call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GistPageHasGarbage</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gistvacuumpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_split</name> <operator>=</operator> <call><name>gistnospace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_split</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no space for insertion */</comment>
		<decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itvec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SplitedPageLayout</name> <modifier>*</modifier></type><name>dist</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>oldrlink</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GistNSN</name></type>		<name>oldnsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SplitedPageLayout</name></type> <name>rootpg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_rootsplit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npage</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_rootsplit</name> <operator>=</operator> <operator>(</operator><name>blkno</name> <operator>==</operator> <name>GIST_ROOT_BLKNO</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Form index tuples vector to split. If we're replacing an old tuple,
		 * remove the old version from the vector.
		 */</comment>
		<expr_stmt><expr><name>itvec</name> <operator>=</operator> <call><name>gistextractpage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>oldoffnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* on inner page we should remove old tuple */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><name>oldoffnum</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tlen</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>!=</operator> <name>tlen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>itvec</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>itvec</name> <operator>+</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>tlen</name> <operator>-</operator> <name>pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>itvec</name> <operator>=</operator> <call><name>gistjoinvector</name><argument_list>(<argument><expr><name>itvec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tlen</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>gistSplit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itvec</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that split didn't produce too many pages.
		 */</comment>
		<expr_stmt><expr><name>npage</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>npage</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
		<comment type="block">/* in a root split, we'll add one more page to the list below */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_rootsplit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>npage</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>npage</name> <operator>&gt;</operator> <name>GIST_MAX_SPLIT_PAGES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GiST page split into too many halves (%d, maximum %d)"</literal></expr></argument>,
				 <argument><expr><name>npage</name></expr></argument>, <argument><expr><name>GIST_MAX_SPLIT_PAGES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Set up pages to work with. Allocate new buffers for all but the
		 * leftmost page. The original page becomes the new leftmost page, and
		 * is just replaced with the new contents.
		 *
		 * For a root-split, allocate new buffers for all child pages, the
		 * original page is overwritten with new root page containing
		 * downlinks to the new child pages.
		 */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_rootsplit</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* save old rightlink and NSN */</comment>
			<expr_stmt><expr><name>oldrlink</name> <operator>=</operator> <call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldnsn</name> <operator>=</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>PageGetTempPageCopySpecial</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* clean all flags except F_LEAF */</comment>
			<expr_stmt><expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>is_leaf</name><operator>)</operator></expr> ?</condition><then> <expr><name>F_LEAF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Allocate new page */</comment>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>gistNewBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GISTInitBuffer</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>is_leaf</name><operator>)</operator></expr> ?</condition><then> <expr><name>F_LEAF</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Now that we know which blocks the new pages go to, set up downlink
		 * tuples to point to them.
		 */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>ptr</name><operator>-&gt;</operator><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GistTupleSetValid</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>itup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If this is a root split, we construct the new root page with the
		 * downlinks here directly, instead of requiring the caller to insert
		 * them. Add the new root page to the list along with the child pages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_rootsplit</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>downlinks</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ndownlinks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>page</name></name> <operator>=</operator> <call><name>PageGetTempPageCopySpecial</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>rootpg</name><operator>.</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name><name>rootpg</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Prepare a vector of all the downlinks */</comment>
			<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ndownlinks</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name>downlinks</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndownlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>downlinks</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>itup</name></name></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>block</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>block</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name>ndownlinks</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>list</name></name> <operator>=</operator> <call><name>gistfillitupvec</name><argument_list>(<argument><expr><name>downlinks</name></expr></argument>, <argument><expr><name>ndownlinks</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>rootpg</name><operator>.</operator><name>lenlist</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>itup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rootpg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>&amp;</operator><name>rootpg</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Prepare split-info to be returned to caller */</comment>
			<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageSplitInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>itup</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>splitinfo</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>splitinfo</name></expr></argument>, <argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Fill all pages. All the pages are new, ie. freshly allocated empty
		 * pages, or a temporary copy of the old page.
		 */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>ptr</name><operator>-&gt;</operator><name>list</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ptr</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>thistup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>data</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>thistup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>FirstOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If this is the first inserted/updated tuple, let the caller
				 * know which page it landed on.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newblkno</name> <operator>&amp;&amp;</operator> <call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thistup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>itup</name><operator>)</operator><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>newblkno</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>data</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>thistup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Set up rightlinks */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>&amp;&amp;</operator> <name><name>ptr</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name> <operator>!=</operator> <name>GIST_ROOT_BLKNO</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator>
					<name><name>ptr</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>blkno</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name>oldrlink</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Mark the all but the right-most page with the follow-right
			 * flag. It will be cleared as soon as the downlink is inserted
			 * into the parent, but this ensures that if we error out before
			 * that, the index is still consistent. (in buffering build mode,
			 * any error will abort the index build anyway, so this is not
			 * needed.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_rootsplit</name> <operator>&amp;&amp;</operator> <name>markfollowright</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>GistMarkFollowRight</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>GistClearFollowRight</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Copy the NSN of the original page to all pages. The
			 * F_FOLLOW_RIGHT flags ensure that scans will follow the
			 * rightlinks until the downlinks are inserted.
			 */</comment>
			<expr_stmt><expr><call><name>GistPageSetNSN</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>oldnsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * gistXLogSplit() needs to WAL log a lot of pages, prepare WAL
		 * insertion for that. NB: The number of pages and data segments
		 * specified here must match the calculations in gistXLogSplit()!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogEnsureRecordSpace</name><argument_list>(<argument><expr><name>npage</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>npage</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must mark buffers dirty before XLogInsert, even though we'll still
		 * be changing their opaque fields below.
		 */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The first page in the chain was a temporary working copy meant to
		 * replace the old page. Copy it over the old page.
		 */</comment>
		<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dist</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>dist</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write the WAL record */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistXLogSplit</name><argument_list>(<argument><expr><name>is_leaf</name></expr></argument>,
								   <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>oldrlink</name></expr></argument>, <argument><expr><name>oldnsn</name></expr></argument>, <argument><expr><name>leftchildbuf</name></expr></argument>,
								   <argument><expr><name>markfollowright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>dist</name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Return the new child buffers to the caller.
		 *
		 * If this was a root split, we've already inserted the downlink
		 * pointers, in the form of a new root page. Therefore we can release
		 * all the new buffers, and keep just the root page locked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_rootsplit</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>dist</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Enough space.  We always get here if ntup==0.
		 */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Delete old tuple if any, then insert new tuple(s) if any.  If
		 * possible, use the fast path of PageIndexTupleOverwrite.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>oldoffnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ntup</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* One-for-one replacement, so use PageIndexTupleOverwrite */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PageIndexTupleOverwrite</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <operator>*</operator><name>itup</name></expr></argument>,
											 <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><operator>*</operator><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Delete old, then append new tuple(s) to page */</comment>
				<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gistfillbuffer</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Just append new tuples at the end of the page */</comment>
			<expr_stmt><expr><call><name>gistfillbuffer</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>ndeloffs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
						<decl><type ref="prev"/><name><name>deloffs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>oldoffnum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>deloffs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>oldoffnum</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ndeloffs</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistXLogUpdate</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
									<argument><expr><name>deloffs</name></expr></argument>, <argument><expr><name>ndeloffs</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>,
									<argument><expr><name>leftchildbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>newblkno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>newblkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we inserted the downlink for a child page, set NSN and clear
	 * F_FOLLOW_RIGHT flag on the left child, so that concurrent scans know to
	 * follow the rightlink if and only if they looked at the parent page
	 * before we inserted the downlink.
	 *
	 * Note that we do this *after* writing the WAL record. That means that
	 * the possible full page image in the WAL record does not include these
	 * changes, and they must be replayed even if the page is restored from
	 * the full page image. There's a chicken-and-egg problem: if we updated
	 * the child pages first, we wouldn't know the recptr of the WAL record
	 * we're about to write.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>leftpg</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>leftchildbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GistPageSetNSN</name><argument_list>(<argument><expr><name>leftpg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GistClearFollowRight</name><argument_list>(<argument><expr><name>leftpg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>leftpg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>is_split</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Workhouse routine for doing insertion into a GiST index. Note that
 * this routine assumes it is invoked in a short-lived memory context,
 * so it does not bother releasing palloc'd allocations.
 */</comment>
<function><type><name>void</name></type>
<name>gistdoinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>freespace</name></decl></parameter>,
			 <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTInsertStack</name></type> <name>firststack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTInsertState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>xlocked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTInsertState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>freespace</name></name> <operator>=</operator> <name>freespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>r</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapRel</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>

	<comment type="block">/* Start from the root */</comment>
	<expr_stmt><expr><name><name>firststack</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firststack</name><operator>.</operator><name>lsn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firststack</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firststack</name><operator>.</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <operator>&amp;</operator><name>firststack</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk down along the path of smallest penalty, updating the parent
	 * pointers with the key we're inserting as we go. If we crash in the
	 * middle, the tree is consistent, although the possible parent updates
	 * were a waste.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Be optimistic and grab shared lock first. Swap it for an exclusive
		 * lock later if we need to update the page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlocked</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <ternary><condition><expr><name>xlocked</name></expr> ?</condition><then>
			<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>r</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>lsn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this page was split but the downlink was never inserted to the
		 * parent because the inserting backend crashed before doing that, fix
		 * that now.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlocked</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* someone might've completed the split when we unlocked */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GistFollowRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>gistfixsplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>!=</operator> <name>GIST_ROOT_BLKNO</name> <operator>&amp;&amp;</operator>
			<name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&lt;</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Concurrent split detected. There's no guarantee that the
			 * downlink for this page is consistent with the tuple we're
			 * inserting anymore, so go back to parent and rechoose the best
			 * child.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is an internal page so continue to walk down the tree.
			 * Find the child node that has the minimum insertion penalty.
			 */</comment>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblkno</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>downlinkoffnum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>downlinkoffnum</name> <operator>=</operator> <call><name>gistchoose</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>downlinkoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>childblkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check that it's not a leftover invalid tuple from pre-9.1
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>GistTupleIsInvalid</name><argument_list>(<argument><expr><name>idxtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains an inner tuple marked as invalid"</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This is caused by an incomplete page split at crash recovery before upgrading to PostgreSQL 9.1."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please REINDEX it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check that the key representing the target child node is
			 * consistent with the key we're inserting. Update it if it's not.
			 */</comment>
			<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>gistgetadjusted</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>r</name></name></expr></argument>, <argument><expr><name>idxtuple</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newtup</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Swap shared lock for an exclusive one. Beware, the page may
				 * change while we unlock/lock the page...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlocked</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>stack</name><operator>-&gt;</operator><name>lsn</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* the page was changed while we unlocked it, retry */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Update the tuple.
				 *
				 * We still hold the lock after gistinserttuple(), but it
				 * might have to split the page to make the updated tuple fit.
				 * In that case the updated tuple might migrate to the other
				 * half of the split, so we have to go back to the parent and
				 * descend back to the half that's a better fit for the new
				 * tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>gistinserttuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>,
									<argument><expr><name>downlinkoffnum</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If this was a root split, the root page continues to be
					 * the parent and the updated tuple went to one of the
					 * child pages, so we just need to retry from the root
					 * page.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>!=</operator> <name>GIST_ROOT_BLKNO</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* descend to the chosen child */</comment>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>GISTInsertStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTInsertStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>childblkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>downlinkoffnum</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Leaf page. Insert the new key. We've already updated all the
			 * parents on the way down, but we might have to split the page if
			 * it doesn't fit. gistinserthere() will take care of that.
			 */</comment>

			<comment type="block">/*
			 * Swap shared lock for an exclusive one. Be careful, the page may
			 * change while we unlock/lock the page...
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xlocked</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name>GIST_ROOT_BLKNO</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * the only page that can become inner instead of leaf is
					 * the root page, so for root we should recheck it
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * very rare situation: during unlock/lock index with
						 * number of pages = 1 was increased
						 */</comment>
						<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * we don't need to check root split, because checking
					 * leaf/inner is enough to recognize split for root
					 */</comment>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
						 <name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&lt;</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The page was split while we momentarily unlocked the
					 * page. Go back to parent.
					 */</comment>
					<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>xlocked</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* now state.stack-&gt;(page, buffer and blkno) points to leaf page */</comment>

			<expr_stmt><expr><call><name>gistinserttuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
							<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Release any pins we might still hold before exiting */</comment>
			<for>for <control>(<init>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Traverse the tree to find path from root page to specified "child" block.
 *
 * returns a new insertion stack, starting from the parent of "child", up
 * to the root. *downlinkoffnum is set to the offset of the downlink in the
 * direct parent of child.
 *
 * To prevent deadlocks, this should lock only one page at a time.
 */</comment>
<function><type><specifier>static</specifier> <name>GISTInsertStack</name> <modifier>*</modifier></type>
<name>gistFindPath</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>downlinkoffnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fifo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>top</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>top</name> <operator>=</operator> <operator>(</operator><name>GISTInsertStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTInsertStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fifo</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>fifo</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get next page to visit */</comment>
		<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fifo</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>top</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Because we scan the index top-down, all the rest of the pages
			 * in the queue must be leaf pages as well.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>lsn</name></name> <operator>=</operator> <call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If F_FOLLOW_RIGHT is set, the page to the right doesn't have a
		 * downlink. This should not normally happen..
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"concurrent GiST page split was incomplete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator> <name><name>top</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>lsn</name></name> <operator>&lt;</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> <comment type="block">/* sanity check */</comment> )</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Page was split while we looked elsewhere. We didn't see the
			 * downlink to the right page when we scanned the parent, so add
			 * it to the queue now.
			 *
			 * Put the right page ahead of the queue, so that we visit it
			 * next. That's important, because if this is the lowest internal
			 * level, just above leaves, we might already have queued up some
			 * leaf pages, and we assume that there can't be any non-leaf
			 * pages behind leaf pages.
			 */</comment>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>GISTInsertStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTInsertStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>top</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>fifo</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>fifo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>child</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it! */</comment>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>downlinkoffnum</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<return>return <expr><name>top</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Append this child to the list of pages to visit later */</comment>
				<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>GISTInsertStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTInsertStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>top</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>fifo</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find parent of a page in index \"%s\", block %u"</literal></expr></argument>,
		 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Updates the stack so that child-&gt;parent is the correct parent of the
 * child. child-&gt;parent must be exclusively locked on entry, and will
 * remain so at exit, but it might not be the same page anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistFindCorrectParent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>child</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* here we don't need to distinguish between split and page update */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>child</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name> <operator>||</operator>
		<name><name>parent</name><operator>-&gt;</operator><name>lsn</name></name> <operator>!=</operator> <call><name>PageGetLSN</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* parent is changed, look child in right links until found */</comment>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
					<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>child</name><operator>-&gt;</operator><name>blkno</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* yes!!, found */</comment>
					<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>downlinkoffnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * End of chain and still didn't find parent. It's a very-very
				 * rare situation when root splited.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * awful!!, we need search tree to find parent ... , but before we
		 * should release all old parent
		 */</comment>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>	<comment type="block">/* child-&gt;parent already released
										 * above */</comment>
		<while>while <condition>(<expr><name>ptr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* ok, find new path */</comment>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>parent</name> <operator>=</operator> <call><name>gistFindPath</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>child</name><operator>-&gt;</operator><name>downlinkoffnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* read all buffers as expected by caller */</comment>
		<comment type="block">/* note we don't lock them or gistcheckpage them here! */</comment>
		<while>while <condition>(<expr><name>ptr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* install new chain of parents to stack */</comment>
		<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>

		<comment type="block">/* make recursive call to normal processing */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>child</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistFindCorrectParent</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Form a downlink pointer for the page in 'buf'.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>gistformdownlink</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
				 <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>downlink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offset</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>offset</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ituple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator>
		<call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>downlink</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>ituple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>newdownlink</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>newdownlink</name> <operator>=</operator> <call><name>gistgetadjusted</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>downlink</name></expr></argument>, <argument><expr><name>ituple</name></expr></argument>,
										  <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newdownlink</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>downlink</name> <operator>=</operator> <name>newdownlink</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the page is completely empty, we can't form a meaningful downlink
	 * for it. But we have to insert a downlink for the page. Any key will do,
	 * as long as its consistent with the downlink of parent page, so that we
	 * can legally insert it to the parent. A minimal one that matches as few
	 * scans as possible would be best, to keep scans from doing useless work,
	 * but we don't know how to construct that. So we just use the downlink of
	 * the original page that was split - that's as far from optimal as it can
	 * get but will do..
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>downlink</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistFindCorrectParent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>downlinkoffnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>downlink</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GistTupleSetValid</name><argument_list>(<argument><expr><name>downlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>downlink</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Complete the incomplete split of state-&gt;stack-&gt;page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistfixsplit</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>splitinfo</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"fixing incomplete split in index \"%s\", block %u"</literal></expr></argument>,
		 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>downlinkoffnum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the chain of split pages, following the rightlinks. Construct a
	 * downlink tuple for each page.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageSplitInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>downlink</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Form the new downlink tuples to insert to parent */</comment>
		<expr_stmt><expr><name>downlink</name> <operator>=</operator> <call><name>gistformdownlink</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>downlink</name></name> <operator>=</operator> <name>downlink</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>splitinfo</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>splitinfo</name></expr></argument>, <argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* lock next page */</comment>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Insert the downlinks */</comment>
	<expr_stmt><expr><call><name>gistfinishsplit</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>splitinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert or replace a tuple in stack-&gt;buffer. If 'oldoffnum' is valid, the
 * tuple at 'oldoffnum' is replaced, otherwise the tuple is inserted as new.
 * 'stack' represents the path from the root to the page being updated.
 *
 * The caller must hold an exclusive lock on stack-&gt;buffer.  The lock is still
 * held on return, but the page might not contain the inserted tuple if the
 * page was split. The function returns true if the page was split, false
 * otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistinserttuple</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>gistinserttuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>,
							<argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 * An extended workhorse version of gistinserttuple(). This version allows
 * inserting multiple tuples, or replacing a single tuple with multiple tuples.
 * This is used to recursively update the downlinks in the parent when a page
 * is split.
 *
 * If leftchild and rightchild are valid, we're inserting/replacing the
 * downlink for rightchild, and leftchild is its left sibling. We clear the
 * F_FOLLOW_RIGHT flag and update NSN on leftchild, atomically with the
 * insertion of the downlink.
 *
 * To avoid holding locks for longer than necessary, when recursing up the
 * tree to update the parents, the locking is a bit peculiar here. On entry,
 * the caller must hold an exclusive lock on stack-&gt;buffer, as well as
 * leftchild and rightchild if given. On return:
 *
 *	- Lock on stack-&gt;buffer is released, if 'unlockbuf' is true. The page is
 *	  always kept pinned, however.
 *	- Lock on 'leftchild' is released, if 'unlockleftchild' is true. The page
 *	  is kept pinned.
 *	- Lock and pin on 'rightchild' are always released.
 *
 * Returns 'true' if the page had to be split. Note that if the page was
 * split, the inserted/updated tuples might've been inserted to a right
 * sibling of stack-&gt;buffer instead of stack-&gt;buffer itself.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistinserttuples</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				 <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>,
				 <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>,
				 <parameter><decl><type><name>Buffer</name></type> <name>leftchild</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rightchild</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>unlockbuf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlockleftchild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>splitinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_split</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for any rw conflicts (in serializable isolation level) just
	 * before we intend to modify the page
	 */</comment>
	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert the tuple(s) to the page, splitting the page if necessary */</comment>
	<expr_stmt><expr><name>is_split</name> <operator>=</operator> <call><name>gistplacetopage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>freespace</name></name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>,
							   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>,
							   <argument><expr><name>tuples</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>,
							   <argument><expr><name>oldoffnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>leftchild</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>splitinfo</name></expr></argument>,
							   <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapRel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before recursing up in case the page was split, release locks on the
	 * child pages. We don't need to keep them locked when updating the
	 * parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>rightchild</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rightchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>leftchild</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>unlockleftchild</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>leftchild</name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we had to split, insert/update the downlinks in the parent. If the
	 * caller requested us to release the lock on stack-&gt;buffer, tell
	 * gistfinishsplit() to do that as soon as it's safe to do so. If we
	 * didn't have to split, release it ourselves.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>splitinfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gistfinishsplit</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>splitinfo</name></expr></argument>, <argument><expr><name>unlockbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>unlockbuf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>is_split</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finish an incomplete split by inserting/updating the downlinks in parent
 * page. 'splitinfo' contains all the child pages involved in the split,
 * from left-to-right.
 *
 * On entry, the caller must hold a lock on stack-&gt;buffer and all the child
 * pages in 'splitinfo'. If 'unlockbuf' is true, the lock on stack-&gt;buffer is
 * released on return. The child pages are always unlocked and unpinned.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistfinishsplit</name><parameter_list>(<parameter><decl><type><name>GISTInsertState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>GISTInsertStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
				<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unlockbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>reversed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name><name>tuples</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* A split always contains at least two halves */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>splitinfo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to insert downlinks for each new page, and update the downlink
	 * for the original (leftmost) page in the split. Begin at the rightmost
	 * page, inserting one downlink at a time until there's only two pages
	 * left. Finally insert the downlink for the last new page and update the
	 * downlink for the original page as one operation.
	 */</comment>

	<comment type="block">/* for convenience, create a copy of the list in reverse order */</comment>
	<expr_stmt><expr><name>reversed</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>splitinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>reversed</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistFindCorrectParent</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * insert downlinks for the siblings from right to left, until there are
	 * only two siblings left.
	 */</comment>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>GISTPageSplitInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>GISTPageSplitInfo</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>gistinserttuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>right</name><operator>-&gt;</operator><name>downlink</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							 <argument><expr><name>InvalidOffsetNumber</name></expr></argument>,
							 <argument><expr><name><name>left</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the parent page was split, need to relocate the original
			 * parent pointer.
			 */</comment>
			<expr_stmt><expr><call><name>gistFindCorrectParent</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>r</name></name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* gistinserttuples() released the lock on right-&gt;buf. */</comment>
		<expr_stmt><expr><name>reversed</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>GISTPageSplitInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>GISTPageSplitInfo</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally insert downlink for the remaining right page and update the
	 * downlink for the original page to not contain the tuples that were
	 * moved to the new pages.
	 */</comment>
	<expr_stmt><expr><name><name>tuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuples</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>right</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistinserttuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>,
					 <argument><expr><name>tuples</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
					 <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>downlinkoffnum</name></name></expr></argument>,
					 <argument><expr><name><name>left</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
					 <argument><expr><name>true</name></expr></argument>,		<comment type="block">/* Unlock parent */</comment>
					 <argument><expr><name>unlockbuf</name></expr></argument>	<comment type="block">/* Unlock stack-&gt;buffer if caller wants that */</comment>
		)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gistSplit -- split a page in the tree and fill struct
 * used for XLOG and real writes buffers. Function is recursive, ie
 * it will split page until keys will fit in every page.
 */</comment>
<function><type><name>SplitedPageLayout</name> <modifier>*</modifier></type>
<name>gistSplit</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>,
		  <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
		  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>,		<comment type="block">/* contains compressed entry */</comment>
		  <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
		  <parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>lvectup</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rvectup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GistSplitVector</name></type> <name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitedPageLayout</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this should never recurse very deeply, but better safe than sorry */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there's no point in splitting an empty page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a single tuple doesn't fit on a page, no amount of splitting will
	 * help.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>itup</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>GiSTPageSize</name></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>spl_lisnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>spl_risnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistSplitByKey</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* form left and right vector */</comment>
	<expr_stmt><expr><name>lvectup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rvectup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lvectup</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>itup</name><index>[<expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_left</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rvectup</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>itup</name><index>[<expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_right</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* finalize splitting (may need another split) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gistfitpage</name><argument_list>(<argument><expr><name>rvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>gistSplit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>rvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ROTATEDIST</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>gistfillitupvec</name><argument_list>(<argument><expr><name>rvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nright</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>lenlist</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>itup</name></name> <operator>=</operator> <call><name>gistFormTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>spl_rattr</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>spl_risnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gistfitpage</name><argument_list>(<argument><expr><name>lvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SplitedPageLayout</name> <modifier>*</modifier></type><name>resptr</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>subres</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>resptr</name> <operator>=</operator> <name>subres</name> <operator>=</operator> <call><name>gistSplit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>lvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* install on list's tail */</comment>
		<while>while <condition>(<expr><name><name>resptr</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resptr</name> <operator>=</operator> <name><name>resptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name><name>resptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>subres</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ROTATEDIST</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>num</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>gistfillitupvec</name><argument_list>(<argument><expr><name>lvectup</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>splitVector</name><operator>.</operator><name>spl_nleft</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>res</name><operator>-&gt;</operator><name>lenlist</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>itup</name></name> <operator>=</operator> <call><name>gistFormTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>spl_lattr</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>spl_lisnull</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a GISTSTATE and fill it with information about the index
 */</comment>
<function><type><name>GISTSTATE</name> <modifier>*</modifier></type>
<name>initGISTstate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* safety check to protect fixed-size arrays in GISTSTATE */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"numberOfAttributes %d &gt; %d"</literal></expr></argument>,
			 <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Create the memory context that will hold the GISTSTATE */</comment>
	<expr_stmt><expr><name>scanCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
									<argument><expr><literal type="string">"GiST scan context"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create and fill in the GISTSTATE */</comment>
	<expr_stmt><expr><name>giststate</name> <operator>=</operator> <operator>(</operator><name>GISTSTATE</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GISTSTATE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>scanCxt</name></name> <operator>=</operator> <name>scanCxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name> <operator>=</operator> <name>scanCxt</name></expr>;</expr_stmt>	<comment type="block">/* caller must change this if needed */</comment>
	<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>consistentFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
					   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_CONSISTENT_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>unionFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
					   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_UNION_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* opclasses are not required to provide a Compress method */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>compressFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
						   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>compressFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* opclasses are not required to provide a Decompress method */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_DECOMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>decompressFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
						   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_DECOMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>decompressFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>penaltyFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
					   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_PENALTY_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>picksplitFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
					   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_PICKSPLIT_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>equalFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
					   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_EQUAL_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* opclasses are not required to provide a Distance method */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_DISTANCE_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>distanceFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
						   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_DISTANCE_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>distanceFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* opclasses are not required to provide a Fetch method */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_FETCH_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>giststate</name><operator>-&gt;</operator><name>fetchFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>,
						   <argument><expr><call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>GIST_FETCH_PROC</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>scanCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>fetchFn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * If the index column has a specified collation, we should honor that
		 * while doing comparisons.  However, we may have a collatable storage
		 * type for a noncollatable indexed data type.  If there's no index
		 * collation then specify default collation in case the support
		 * functions need collation.  This is harmless if the support
		 * functions don't care about collation, so we just do it
		 * unconditionally.  (We could alternatively call get_typcollation,
		 * but that seems like expensive overkill --- there aren't going to be
		 * any cases where a GiST storage type has a nondefault collation.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>giststate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>giststate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>freeGISTstate</name><parameter_list>(<parameter><decl><type><name>GISTSTATE</name> <modifier>*</modifier></type><name>giststate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* It's sufficient to delete the scanCxt */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>scanCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gistvacuumpage() -- try to remove LP_DEAD items from the given page.
 * Function assumes that buffer is exclusively locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistvacuumpage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>deletable</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeletable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan over all items to see which ones need to be deleted according to
	 * LP_DEAD flags.
	 */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>ndeletable</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark the page as not containing any LP_DEAD items.  This is not
		 * certainly true (there might be some that have recently been marked,
		 * but weren't included in our target-item list), but it will almost
		 * always be true and it doesn't seem worth an additional page scan to
		 * check it. Remember that F_HAS_GARBAGE is only a hint anyway.
		 */</comment>
		<expr_stmt><expr><call><name>GistClearPageHasGarbage</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>gistXLogUpdate</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
									<argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>heapRel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note: if we didn't find any LP_DEAD items, then the page's
	 * F_HAS_GARBAGE hint bit is falsely set.  We do not bother expending a
	 * separate write to clear it, however.  We will clear it when we split
	 * the page.
	 */</comment>
</block_content>}</block></function>
</unit>
