<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/brin/brin.c"><comment type="block">/*
 * brin.c
 *		Implementation of BRIN indexes for Postgres
 *
 * See src/backend/access/brin/README for details.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/brin/brin.c
 *
 * TODO
 *		* ScalarArrayOpExpr (amsearcharray -&gt; SK_SEARCHARRAY)
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_page.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_pageops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/freespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/index_selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 * We use a BrinBuildState during initial construction of a BRIN index.
 * The running state is kept in a BrinMemTuple.
 */</comment>
<typedef>typedef <type><struct>struct <name>BrinBuildState</name>
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>bs_irel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bs_numtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>bs_currentInsertBuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bs_pagesPerRange</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bs_currRangeStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>bs_rmAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinDesc</name>   <modifier>*</modifier></type><name>bs_bdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>bs_dtuple</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrinBuildState</name>;</typedef>

<comment type="block">/*
 * Struct used as "opaque" during index scans
 */</comment>
<typedef>typedef <type><struct>struct <name>BrinOpaque</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bo_pagesPerRange</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>bo_rmAccess</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinDesc</name>   <modifier>*</modifier></type><name>bo_bdesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>BrinOpaque</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BRIN_ALL_BLOCKRANGES</name></cpp:macro>	<cpp:value>InvalidBlockNumber</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>BrinBuildState</name> <modifier>*</modifier></type><name>initialize_brin_buildstate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>,
						   <parameter><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>terminate_brin_buildstate</name><parameter_list>(<parameter><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>brinsummarize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageRange</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>include_partial</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>numSummarized</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>numExisting</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>form_and_insert_tuple</name><parameter_list>(<parameter><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>union_tuples</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>bdesc</name></decl></parameter>, <parameter><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
			 <parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>brin_vacuum_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * BRIN handler function: return IndexAmRoutine with access method parameters
 * and callbacks.
 */</comment>
<function><type><name>Datum</name></type>
<name>brinhandler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>=</operator> <name>BRIN_LAST_OPTIONAL_PROCNUM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amclusterable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcaninclude</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuild</name></name> <operator>=</operator> <name>brinbuild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name> <operator>=</operator> <name>brinbuildempty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminsert</name></name> <operator>=</operator> <name>brininsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name> <operator>=</operator> <name>brinbulkdelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name> <operator>=</operator> <name>brinvacuumcleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name>brincostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name> <operator>=</operator> <name>brinoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amproperty</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvalidate</name></name> <operator>=</operator> <name>brinvalidate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name> <operator>=</operator> <name>brinbeginscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrescan</name></name> <operator>=</operator> <name>brinrescan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>=</operator> <name>bringetbitmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amendscan</name></name> <operator>=</operator> <name>brinendscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A tuple in the heap is being inserted.  To keep a brin index up to date,
 * we need to obtain the relevant index tuple and compare its stored values
 * with those of the new tuple.  If the tuple values are not consistent with
 * the summary tuple, we need to update the index tuple.
 *
 * If autosummarization is enabled, check if we need to summarize the previous
 * page range.
 *
 * If the range is not currently summarized (i.e. the revmap returns NULL for
 * it), there's nothing to do for this tuple.
 */</comment>
<function><type><name>bool</name></type>
<name>brininsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
		   <parameter><decl><type><name>ItemPointer</name></type> <name>heaptid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
		   <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
		   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>origHeapBlk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinDesc</name>   <modifier>*</modifier></type><name>bdesc</name> <init>= <expr><operator>(</operator><name>BrinDesc</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tupcxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>autosummarize</name> <init>= <expr><call><name>BrinGetAutoSummarize</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>revmap</name> <operator>=</operator> <call><name>brinRevmapInitialize</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pagesPerRange</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * origHeapBlk is the block number where the insertion occurred.  heapBlk
	 * is the first block in the corresponding page range.
	 */</comment>
	<expr_stmt><expr><name>origHeapBlk</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>heaptid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapBlk</name> <operator>=</operator> <operator>(</operator><name>origHeapBlk</name> <operator>/</operator> <name>pagesPerRange</name><operator>)</operator> <operator>*</operator> <name>pagesPerRange</name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_insert</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>brtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If auto-summarization is enabled and we just inserted the first
		 * tuple into the first block of a new non-first page range, request a
		 * summarization run of the previous range.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>autosummarize</name> <operator>&amp;&amp;</operator>
			<name>heapBlk</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>heapBlk</name> <operator>==</operator> <name>origHeapBlk</name> <operator>&amp;&amp;</operator>
			<call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heaptid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FirstOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastPageRange</name> <init>= <expr><name>heapBlk</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>lastPageTuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lastPageTuple</name> <operator>=</operator>
				<call><name>brinGetTupleForHeapBlock</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>lastPageRange</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lastPageTuple</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>recorded</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>recorded</name> <operator>=</operator> <call><name>AutoVacuumRequestWork</name><argument_list>(<argument><expr><name>AVW_BRINSummarizeRange</name></expr></argument>,
												 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>lastPageRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recorded</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"request for BRIN range summarization for index \"%s\" page %u was not recorded"</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>lastPageRange</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>brtup</name> <operator>=</operator> <call><name>brinGetTupleForHeapBlock</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if range is unsummarized, there's nothing to do */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>brtup</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* First time through in this statement? */</comment>
		<if_stmt><if>if <condition>(<expr><name>bdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bdesc</name> <operator>=</operator> <call><name>brin_build_desc</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>bdesc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* First time through in this brininsert call? */</comment>
		<if_stmt><if>if <condition>(<expr><name>tupcxt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tupcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><literal type="string">"brininsert cxt"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tupcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dtup</name> <operator>=</operator> <call><name>brin_deform_tuple</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>, <argument><expr><name>brtup</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compare the key values of the new tuple to the stored index values;
		 * our deformed tuple will get updated if the new tuple doesn't fit
		 * the original range (note this means we can't break out of the loop
		 * early). Make a note of whether this happens, so that we know to
		 * insert the modified tuple later.
		 */</comment>
		<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BrinValues</name> <modifier>*</modifier></type><name>bval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>addValue</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>bval</name> <operator>=</operator> <operator>&amp;</operator><name><name>dtup</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>addValue</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>BRIN_PROCNUM_ADDVALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><name>addValue</name></expr></argument>,
									   <argument><expr><name><name>idxRel</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
									   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bval</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>nulls</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* if that returned true, we need to insert the updated tuple */</comment>
			<expr_stmt><expr><name>need_insert</name> <operator>|=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_insert</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The tuple is consistent with the new values, so there's nothing
			 * to do.
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>lp</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>origsz</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>origtup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>newsz</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>samepage</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Make a copy of the old tuple, so that we can compare it after
			 * re-acquiring the lock.
			 */</comment>
			<expr_stmt><expr><name>origsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>origtup</name> <operator>=</operator> <call><name>brin_copy_tuple</name><argument_list>(<argument><expr><name>brtup</name></expr></argument>, <argument><expr><name>origsz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Before releasing the lock, check if we can attempt a same-page
			 * update.  Another process could insert a tuple concurrently in
			 * the same page though, so downstream we must be prepared to cope
			 * if this turns out to not be possible after all.
			 */</comment>
			<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>brin_form_tuple</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>dtup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>samepage</name> <operator>=</operator> <call><name>brin_can_do_samepage_update</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>origsz</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Try to update the tuple.  If this doesn't work for whatever
			 * reason, we need to restart from the top; the revmap might be
			 * pointing at a different tuple for this block now, so we need to
			 * recompute to ensure both our new heap tuple and the other
			 * inserter's are covered by the combined tuple.  It might be that
			 * we don't need to update at all.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>brin_doupdate</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>pagesPerRange</name></expr></argument>, <argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>,
							   <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>origtup</name></expr></argument>, <argument><expr><name>origsz</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>newsz</name></expr></argument>,
							   <argument><expr><name>samepage</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no luck; start over */</comment>
				<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>tupcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* success! */</comment>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>brinRevmapTerminate</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tupcxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tupcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize state for a BRIN index scan.
 *
 * We read the metapage here to determine the pages-per-range number that this
 * index was built with.  Note that since this cannot be changed while we're
 * holding lock on index, it's not necessary to recompute it during brinrescan.
 */</comment>
<function><type><name>IndexScanDesc</name></type>
<name>brinbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinOpaque</name> <modifier>*</modifier></type><name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BrinOpaque</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinOpaque</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>bo_rmAccess</name></name> <operator>=</operator> <call><name>brinRevmapInitialize</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opaque</name><operator>-&gt;</operator><name>bo_pagesPerRange</name></name></expr></argument>,
											   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>bo_bdesc</name></name> <operator>=</operator> <call><name>brin_build_desc</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>opaque</name></expr>;</expr_stmt>

	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Execute the index scan.
 *
 * This works by reading index TIDs from the revmap, and obtaining the index
 * tuples pointed to by them; the summary values in the index tuples are
 * compared to the scan keys.  We return into the TID bitmap all the pages in
 * ranges corresponding to index tuples that match the scan keys.
 *
 * If a TID from the revmap is read as InvalidTID, we know that range is
 * unsummarized.  Pages in those ranges need to be returned regardless of scan
 * keys.
 */</comment>
<function><type><name>int64</name></type>
<name>bringetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idxRel</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinDesc</name>   <modifier>*</modifier></type><name>bdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinOpaque</name> <modifier>*</modifier></type><name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalpages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>consistentFn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>perRangeCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>dtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>btup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>btupsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BrinOpaque</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bdesc</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>bo_bdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to know the size of the table so that we know how long to
	 * iterate on the revmap.
	 */</comment>
	<expr_stmt><expr><name>heapOid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make room for the consistent support procedures of indexed columns.  We
	 * don't look them up here; we do that lazily the first time we see a scan
	 * key reference each of them.  We rely on zeroing fn_oid to InvalidOid.
	 */</comment>
	<expr_stmt><expr><name>consistentFn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate an initial in-memory tuple, out of the per-range memcxt */</comment>
	<expr_stmt><expr><name>dtup</name> <operator>=</operator> <call><name>brin_new_memtuple</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup and use a per-range memory context, which is reset every time we
	 * loop below.  This avoids having to free the tuples within the loop.
	 */</comment>
	<expr_stmt><expr><name>perRangeCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><literal type="string">"bringetbitmap cxt"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perRangeCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the revmap.  We start by querying for heap page 0,
	 * incrementing by the number of pages per range; this gives us a full
	 * view of the table.
	 */</comment>
	<for>for <control>(<init><expr><name>heapBlk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>heapBlk</name> <operator>&lt;</operator> <name>nblocks</name></expr>;</condition> <incr><expr><name>heapBlk</name> <operator>+=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>bo_pagesPerRange</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>addrange</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>gottuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>perRangeCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>brinGetTupleForHeapBlock</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>bo_rmAccess</name></name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>,
									   <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>gottuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>btup</name> <operator>=</operator> <call><name>brin_copy_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>btup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btupsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For page ranges with no indexed tuple, we must return the whole
		 * range; otherwise, compare it to the scan keys.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gottuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addrange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>dtup</name> <operator>=</operator> <call><name>brin_deform_tuple</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>, <argument><expr><name>btup</name></expr></argument>, <argument><expr><name>dtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dtup</name><operator>-&gt;</operator><name>bt_placeholder</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Placeholder tuples are always returned, regardless of the
				 * values stored in them.
				 */</comment>
				<expr_stmt><expr><name>addrange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Compare scan keys with summary values stored for the range.
				 * If scan keys are matched, the page range must be added to
				 * the bitmap.  We initially assume the range needs to be
				 * added; in particular this serves the case where there are
				 * no keys.
				 */</comment>
				<expr_stmt><expr><name>addrange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ScanKey</name></type>		<name>key</name> <init>= <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>keyData</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>keyattno</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>BrinValues</name> <modifier>*</modifier></type><name>bval</name> <init>= <expr><operator>&amp;</operator><name><name>dtup</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>add</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * The collation of the scan key must match the collation
					 * used in the index column (but only if the search is not
					 * IS NULL/ IS NOT NULL).  Otherwise we shouldn't be using
					 * this index ...
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name><operator>)</operator> <operator>||</operator>
						   <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name> <operator>==</operator>
							<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name></name></expr></argument>,
										  <argument><expr><name>keyattno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* First time this column? look up consistent function */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>consistentFn</name><index>[<expr><name>keyattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fn_oid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>, <argument><expr><name>keyattno</name></expr></argument>,
												<argument><expr><name>BRIN_PROCNUM_CONSISTENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>fmgr_info_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>consistentFn</name><index>[<expr><name>keyattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>,
									   <argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Check whether the scan key is consistent with the page
					 * range values; if so, have the pages in the range added
					 * to the output bitmap.
					 *
					 * When there are multiple scan keys, failure to meet the
					 * criteria for a single one of them is enough to discard
					 * the range as a whole, so break out of the loop as soon
					 * as a false return value is obtained.
					 */</comment>
					<expr_stmt><expr><name>add</name> <operator>=</operator> <call><name>FunctionCall3Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>consistentFn</name><index>[<expr><name>keyattno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
											<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bval</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>addrange</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addrange</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* add the pages in the range to the output bitmap, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>addrange</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>pageno</name> <operator>=</operator> <name>heapBlk</name></expr>;</init>
				 <condition><expr><name>pageno</name> <operator>&lt;=</operator> <name>heapBlk</name> <operator>+</operator> <name><name>opaque</name><operator>-&gt;</operator><name>bo_pagesPerRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition>
				 <incr><expr><name>pageno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>tbm_add_page</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>totalpages</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>perRangeCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>perRangeCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * XXX We have an approximation of the number of *pages* that our scan
	 * returns, but we don't have a precise idea of the number of heap tuples
	 * involved.
	 */</comment>
	<return>return <expr><name>totalpages</name> <operator>*</operator> <literal type="number">10</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Re-initialize state for a BRIN index scan
 */</comment>
<function><type><name>void</name></type>
<name>brinrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,
		   <parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Other index AMs preprocess the scan keys at this point, or sometime
	 * early during the scan; this lets them optimize by removing redundant
	 * keys, or doing early returns when they are impossible to satisfy; see
	 * _bt_preprocess_keys for an example.  Something like that could be added
	 * here someday, too.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>scankey</name> <operator>&amp;&amp;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
				<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ScanKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close down a BRIN index scan
 */</comment>
<function><type><name>void</name></type>
<name>brinendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinOpaque</name> <modifier>*</modifier></type><name>opaque</name> <init>= <expr><operator>(</operator><name>BrinOpaque</name> <operator>*</operator><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>brinRevmapTerminate</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>bo_rmAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>brin_free_desc</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>bo_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Per-heap-tuple callback for IndexBuildHeapScan.
 *
 * Note we don't worry about the page range at the end of the table here; it is
 * present in the build state struct after we're called the last time, but not
 * inserted into the index.  Caller must ensure to do so, if appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>brinbuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				  <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>brstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>BrinBuildState</name> <operator>*</operator><operator>)</operator> <name>brstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>thisblock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>thisblock</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're in a block that belongs to a future range, summarize what
	 * we've got and start afresh.  Note the scan might have skipped many
	 * pages, if they were devoid of live tuples; make sure to insert index
	 * tuples for those too.
	 */</comment>
	<while>while <condition>(<expr><name>thisblock</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><call><name>BRIN_elog</name><argument_list>(<argument><expr><operator>(</operator><name>DEBUG2</name><operator>,</operator>
				   <literal type="string">"brinbuildCallback: completed a range: %u--%u"</literal><operator>,</operator>
				   <name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name><operator>,</operator>
				   <name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create the index tuple and insert it */</comment>
		<expr_stmt><expr><call><name>form_and_insert_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set state to correspond to the next range */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr>;</expr_stmt>

		<comment type="block">/* re-initialize state for it */</comment>
		<expr_stmt><expr><call><name>brin_memtuple_initialize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Accumulate the current tuple into the running state */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>addValue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinValues</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>addValue</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									 <argument><expr><name>BRIN_PROCNUM_ADDVALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update dtuple state, if and as necessary.
		 */</comment>
		<expr_stmt><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><name>addValue</name></expr></argument>,
						  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * brinbuild() -- build a new BRIN index.
 */</comment>
<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>brinbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>idxtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>meta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We expect to be called exactly once for any index relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Critical section not required, because on error the creation of the
	 * whole relation will be rolled back.
	 */</comment>

	<expr_stmt><expr><name>meta</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BRIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>meta</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>brin_metapage_init</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BrinGetPagesPerRange</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>BRIN_CURRENT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_brin_createidx</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>version</name></name> <operator>=</operator> <name>BRIN_CURRENT_VERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>pagesPerRange</name></name> <operator>=</operator> <call><name>BrinGetPagesPerRange</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBrinCreateIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>meta</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BRIN_ID</name></expr></argument>, <argument><expr><name>XLOG_BRIN_CREATE_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize our state, including the deformed tuple state.
	 */</comment>
	<expr_stmt><expr><name>revmap</name> <operator>=</operator> <call><name>brinRevmapInitialize</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pagesPerRange</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>initialize_brin_buildstate</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>pagesPerRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the relation.  No syncscan allowed here because we want the
	 * heap blocks in physical order.
	 */</comment>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>IndexBuildHeapScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><name>brinbuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process the final batch */</comment>
	<expr_stmt><expr><call><name>form_and_insert_tuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release resources */</comment>
	<expr_stmt><expr><name>idxtuples</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_numtuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>brinRevmapTerminate</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>terminate_brin_buildstate</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name>idxtuples</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>brinbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>

	<comment type="block">/* An empty BRIN index has a metapage only. */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator>
		<call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize and xlog metabuffer. */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>brin_metapage_init</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BrinGetPagesPerRange</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>BRIN_CURRENT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>log_newpage_buffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * brinbulkdelete
 *		Since there are no per-heap-tuple index tuples in BRIN indexes,
 *		there's not a lot we can do here.
 *
 * XXX we could mark item tuples as "dirty" (when a minimum or maximum heap
 * tuple is deleted), meaning the need to re-run summarization on the affected
 * range.  Would need to add an extra flag in brintuples for that.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>brinbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			   <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* allocate stats if first time through, else re-use existing struct */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This routine is in charge of "vacuuming" a BRIN index: we just summarize
 * ranges that are currently unsummarized.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>brinvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>

	<comment type="block">/* No-op in ANALYZE ONLY mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>analyze_only</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>stats</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* rest of stats is initialized by zeroing */</comment>

	<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>brin_vacuum_scan</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>brinsummarize</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>BRIN_ALL_BLOCKRANGES</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reloptions processor for BRIN indexes
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>brinoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>relopt_value</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinOptions</name> <modifier>*</modifier></type><name>rdopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numoptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>relopt_parse_elt</name></type> <name><name>tab</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="string">"pages_per_range"</literal></expr>, <expr><name>RELOPT_TYPE_INT</name></expr>, <macro><name>offsetof</name><argument_list>(<argument>BrinOptions</argument>, <argument>pagesPerRange</argument>)</argument_list></macro>}</block></expr>,
		<expr><block>{<expr><literal type="string">"autosummarize"</literal></expr>, <expr><name>RELOPT_TYPE_BOOL</name></expr>, <macro><name>offsetof</name><argument_list>(<argument>BrinOptions</argument>, <argument>autosummarize</argument>)</argument_list></macro>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>parseRelOptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_BRIN</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if none set, we're done */</comment>
	<if_stmt><if>if <condition>(<expr><name>numoptions</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rdopts</name> <operator>=</operator> <call><name>allocateReloptStruct</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillRelOptions</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>rdopts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinOptions</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>numoptions</name></expr></argument>,
				   <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <name>rdopts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL-callable function to scan through an index and summarize all ranges
 * that are not currently summarized.
 */</comment>
<function><type><name>Datum</name></type>
<name>brin_summarize_new_values</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>relation</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>brin_summarize_range</name></expr></argument>,
							   <argument><expr><name>relation</name></expr></argument>,
							   <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>BRIN_ALL_BLOCKRANGES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL-callable function to summarize the indicated page range, if not already
 * summarized.  If the second argument is BRIN_ALL_BLOCKRANGES, all
 * unsummarized ranges are summarized.
 */</comment>
<function><type><name>Datum</name></type>
<name>brin_summarize_range</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>heapBlk64</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numSummarized</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"BRIN control functions cannot be executed during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>heapBlk64</name> <operator>&gt;</operator> <name>BRIN_ALL_BLOCKRANGES</name> <operator>||</operator> <name>heapBlk64</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>blk</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>heapBlk64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block number out of range: %s"</literal></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>heapBlk</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>heapBlk64</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must lock table before index to avoid deadlocks.  However, if the
	 * passed indexoid isn't an index then IndexGetRelation() will fail.
	 * Rather than emitting a not-very-helpful error message, postpone
	 * complaining, expecting that the is-it-an-index test below will fail.
	 */</comment>
	<expr_stmt><expr><name>heapoid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Autovacuum calls us.  For its benefit, switch to the table owner's
		 * userid, so that any index functions are run as that user.  Also
		 * lock down security-restricted operations and arrange to make GUC
		 * variable changes local to this command.  This is harmless, albeit
		 * unnecessary, when called from SQL, because we fail shortly if the
		 * user does not own the index.
		 */</comment>
		<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>heapRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
							   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must be a BRIN index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BRIN_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a BRIN index"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* User must own the index (comparable to privileges needed for VACUUM) */</comment>
	<if_stmt><if>if <condition>(<expr><name>heapRel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>save_userid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since we did the IndexGetRelation call above without any lock, it's
	 * barely possible that a race against an index drop/recreation could have
	 * netted us the wrong table.  Recheck.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>heapRel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>heapoid</name> <operator>!=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open parent table of index %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, do it */</comment>
	<expr_stmt><expr><call><name>brinsummarize</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numSummarized</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>numSummarized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL-callable interface to mark a range as no longer summarized
 */</comment>
<function><type><name>Datum</name></type>
<name>brin_desummarize_range</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>heapBlk64</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recovery is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"BRIN control functions cannot be executed during recovery."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>heapBlk64</name> <operator>&gt;</operator> <name>MaxBlockNumber</name> <operator>||</operator> <name>heapBlk64</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>blk</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>heapBlk64</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"block number out of range: %s"</literal></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>heapBlk</name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>heapBlk64</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must lock table before index to avoid deadlocks.  However, if the
	 * passed indexoid isn't an index then IndexGetRelation() will fail.
	 * Rather than emitting a not-very-helpful error message, postpone
	 * complaining, expecting that the is-it-an-index test below will fail.
	 *
	 * Unlike brin_summarize_range(), autovacuum never calls this.  Hence, we
	 * don't switch userid.
	 */</comment>
	<expr_stmt><expr><name>heapoid</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must be a BRIN index */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name><name>indexRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BRIN_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a BRIN index"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* User must own the index (comparable to privileges needed for VACUUM) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since we did the IndexGetRelation call above without any lock, it's
	 * barely possible that a race against an index drop/recreation could have
	 * netted us the wrong table.  Recheck.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>heapRel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>heapoid</name> <operator>!=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open parent table of index %s"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* the revmap does the hard work */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>brinRevmapDesummarizeRange</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build a BrinDesc used to create or scan a BRIN index
 */</comment>
<function><type><name>BrinDesc</name> <modifier>*</modifier></type>
<name>brin_build_desc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinOpcInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>opcinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinDesc</name>   <modifier>*</modifier></type><name>bdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalstored</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>totalsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><literal type="string">"brin desc cxt"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain BrinOpcInfo for each indexed column.  While at it, accumulate
	 * the number of columns stored, since the number is opclass-defined.
	 */</comment>
	<expr_stmt><expr><name>opcinfo</name> <operator>=</operator> <operator>(</operator><name>BrinOpcInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinOpcInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>opcInfoFn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>opcInfoFn</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>BRIN_PROCNUM_OPCINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>opcinfo</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BrinOpcInfo</name> <operator>*</operator><operator>)</operator>
			<call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><name>opcInfoFn</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalstored</name> <operator>+=</operator> <name><name>opcinfo</name><index>[<expr><name>keyno</name></expr>]</index></name><operator>-&gt;</operator><name>oi_nstored</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocate our result struct and fill it in */</comment>
	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BrinDesc</name></expr></argument>, <argument><expr><name>bd_info</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>BrinOpcInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>bdesc</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_context</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_index</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_disktdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* generated lazily */</comment>
	<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_totalstored</name></name> <operator>=</operator> <name>totalstored</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_info</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>opcinfo</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bdesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>brin_free_desc</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>bdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure the tupdesc is still valid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* no need for retail pfree */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch index's statistical data into *stats
 */</comment>
<function><type><name>void</name></type>
<name>brinGetStats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BrinStatsData</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>BRIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadata</name> <operator>=</operator> <operator>(</operator><name>BrinMetaPageData</name> <operator>*</operator><operator>)</operator> <call><name>PageGetContents</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>pagesPerRange</name></name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>pagesPerRange</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>revmapNumPages</name></name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>lastRevmapPage</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a BrinBuildState appropriate to create tuples on the given index.
 */</comment>
<function><type><specifier>static</specifier> <name>BrinBuildState</name> <modifier>*</modifier></type>
<name>initialize_brin_buildstate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxRel</name></decl></parameter>, <parameter><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BrinBuildState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name> <operator>=</operator> <name>idxRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_numtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name> <operator>=</operator> <name>pagesPerRange</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name> <operator>=</operator> <name>revmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name> <operator>=</operator> <call><name>brin_build_desc</name><argument_list>(<argument><expr><name>idxRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name> <operator>=</operator> <call><name>brin_new_memtuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>brin_memtuple_initialize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release resources associated with a BrinBuildState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>terminate_brin_buildstate</name><parameter_list>(<parameter><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Release the last index buffer used.  We might as well ensure that
	 * whatever free space remains in that page is available in FSM, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsInvalid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>blk</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecordPageWithFreeSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name>blk</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreeSpaceMapVacuumRange</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name>blk</name></expr></argument>, <argument><expr><name>blk</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>brin_free_desc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * On the given BRIN index, summarize the heap page range that corresponds
 * to the heap block number given.
 *
 * This routine can run in parallel with insertions into the heap.  To avoid
 * missing those values from the summary tuple, we first insert a placeholder
 * index tuple into the index, then execute the heap scan; transactions
 * concurrent with the scan update the placeholder tuple.  After the scan, we
 * union the placeholder tuple with the one computed by this routine.  The
 * update of the index value happens in a loop, so that if somebody updates
 * the placeholder tuple after we read it, we detect the case and try again.
 * This ensures that the concurrently inserted tuples are not lost.
 *
 * A further corner case is this routine being asked to summarize the partial
 * range at the end of the table.  heapNumBlocks is the (possibly outdated)
 * table size; if we notice that the requested range lies beyond that size,
 * we re-compute the table size after inserting the placeholder tuple, to
 * avoid missing pages that were appended recently.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>summarize_range</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
				<parameter><decl><type><name>BlockNumber</name></type> <name>heapBlk</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>heapNumBlks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>phbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>phtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>phsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>scanNumBlks</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Insert the placeholder tuple
	 */</comment>
	<expr_stmt><expr><name>phbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>phtup</name> <operator>=</operator> <call><name>brin_form_placeholder_tuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>brin_doinsert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr></argument>,
						   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phbuf</name></expr></argument>,
						   <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>phtup</name></expr></argument>, <argument><expr><name>phsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute range end.  We hold ShareUpdateExclusive lock on table, so it
	 * cannot shrink concurrently (but it can grow).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapBlk</name> <operator>%</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>heapBlk</name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name> <operator>&gt;</operator> <name>heapNumBlks</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're asked to scan what we believe to be the final range on the
		 * table (i.e. a range that might be partial) we need to recompute our
		 * idea of what the latest page is after inserting the placeholder
		 * tuple.  Anyone that grows the table later will update the
		 * placeholder tuple, so it doesn't matter that we won't scan these
		 * pages ourselves.  Careful: the table might have been extended
		 * beyond the current range, so clamp our result.
		 *
		 * Fortunately, this should occur infrequently.
		 */</comment>
		<expr_stmt><expr><name>scanNumBlks</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>heapBlk</name></expr></argument>,
						  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Easy case: range is known to be complete */</comment>
		<expr_stmt><expr><name>scanNumBlks</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Execute the partial heap scan covering the heap blocks in the specified
	 * page range, summarizing the heap tuples in it.  This scan stops just
	 * short of brinbuildCallback creating the new index entry.
	 *
	 * Note that it is critical we use the "any visible" mode of
	 * IndexBuildHeapRangeScan here: otherwise, we would miss tuples inserted
	 * by transactions that are still in progress, among other corner cases.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name> <operator>=</operator> <name>heapBlk</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>IndexBuildHeapRangeScan</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							<argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>scanNumBlks</name></expr></argument>,
							<argument><expr><name>brinbuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we update the values obtained by the scan with the placeholder
	 * tuple.  We do this in a loop which only terminates if we're able to
	 * update the placeholder tuple successfully; if we are not, this means
	 * somebody else modified the placeholder tuple after we read it.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>newtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>newsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>didupdate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>samepage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update the summary tuple and try to update.
		 */</comment>
		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>brin_form_tuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>,
								 <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>samepage</name> <operator>=</operator> <call><name>brin_can_do_samepage_update</name><argument_list>(<argument><expr><name>phbuf</name></expr></argument>, <argument><expr><name>phsz</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>didupdate</name> <operator>=</operator>
			<call><name>brin_doupdate</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr></argument>,
						  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><name>phbuf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
						  <argument><expr><name>phtup</name></expr></argument>, <argument><expr><name>phsz</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>samepage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>brin_free_tuple</name><argument_list>(<argument><expr><name>phtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>brin_free_tuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the update succeeded, we're done. */</comment>
		<if_stmt><if>if <condition>(<expr><name>didupdate</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the update didn't work, it might be because somebody updated the
		 * placeholder tuple concurrently.  Extract the new version, union it
		 * with the values we have from the scan, and start over.  (There are
		 * other reasons for the update to fail, but it's simple to treat them
		 * the same.)
		 */</comment>
		<expr_stmt><expr><name>phtup</name> <operator>=</operator> <call><name>brinGetTupleForHeapBlock</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name></expr></argument>, <argument><expr><name>heapBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phbuf</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phsz</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* the placeholder tuple must exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>phtup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing placeholder tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>phtup</name> <operator>=</operator> <call><name>brin_copy_tuple</name><argument_list>(<argument><expr><name>phtup</name></expr></argument>, <argument><expr><name>phsz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>phbuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* merge it into the tuple from the heap scan */</comment>
		<expr_stmt><expr><call><name>union_tuples</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><name>phtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>phbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Summarize page ranges that are not already summarized.  If pageRange is
 * BRIN_ALL_BLOCKRANGES then the whole table is scanned; otherwise, only the
 * page range containing the given heap page number is scanned.
 * If include_partial is true, then the partial range at the end of the table
 * is summarized, otherwise not.
 *
 * For each new index tuple inserted, *numSummarized (if not NULL) is
 * incremented; for each existing tuple, *numExisting (if not NULL) is
 * incremented.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>brinsummarize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageRange</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>include_partial</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>numSummarized</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>numExisting</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinRevmap</name> <modifier>*</modifier></type><name>revmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>heapNumBlocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pagesPerRange</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>startBlk</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>revmap</name> <operator>=</operator> <call><name>brinRevmapInitialize</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pagesPerRange</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine range of pages to process */</comment>
	<expr_stmt><expr><name>heapNumBlocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pageRange</name> <operator>==</operator> <name>BRIN_ALL_BLOCKRANGES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>startBlk</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>startBlk</name> <operator>=</operator> <operator>(</operator><name>pageRange</name> <operator>/</operator> <name>pagesPerRange</name><operator>)</operator> <operator>*</operator> <name>pagesPerRange</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>heapNumBlocks</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>heapNumBlocks</name></expr></argument>, <argument><expr><name>startBlk</name> <operator>+</operator> <name>pagesPerRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>startBlk</name> <operator>&gt;</operator> <name>heapNumBlocks</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do if start point is beyond end of table */</comment>
		<expr_stmt><expr><call><name>brinRevmapTerminate</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan the revmap to find unsummarized items.
	 */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>startBlk</name> <operator>&lt;</operator> <name>heapNumBlocks</name></expr>;</condition> <incr><expr><name>startBlk</name> <operator>+=</operator> <name>pagesPerRange</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Unless requested to summarize even a partial range, go away now if
		 * we think the next range is partial.  Caller would pass true when it
		 * is typically run once bulk data loading is done
		 * (brin_summarize_new_values), and false when it is typically the
		 * result of arbitrarily-scheduled maintenance command (vacuuming).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>include_partial</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>startBlk</name> <operator>+</operator> <name>pagesPerRange</name> <operator>&gt;</operator> <name>heapNumBlocks</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>brinGetTupleForHeapBlock</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>, <argument><expr><name>startBlk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no revmap entry for this heap range. Summarize it. */</comment>
			<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* first time through */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>initialize_brin_buildstate</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>revmap</name></expr></argument>,
												   <argument><expr><name>pagesPerRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>summarize_range</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>startBlk</name></expr></argument>, <argument><expr><name>heapNumBlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* and re-initialize state for the next range */</comment>
			<expr_stmt><expr><call><name>brin_memtuple_initialize</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>numSummarized</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>numSummarized</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numExisting</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>numExisting</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* free resources */</comment>
	<expr_stmt><expr><call><name>brinRevmapTerminate</name><argument_list>(<argument><expr><name>revmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>terminate_brin_buildstate</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a deformed tuple in the build state, convert it into the on-disk
 * format and insert it into the index, making the revmap point to it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>form_and_insert_tuple</name><parameter_list>(<parameter><decl><type><name>BrinBuildState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BrinTuple</name>  <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>brin_form_tuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_bdesc</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name></expr></argument>,
						  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_dtuple</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>brin_doinsert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_irel</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_pagesPerRange</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_rmAccess</name></name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>bs_currentInsertBuf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>bs_currRangeStart</name></name></expr></argument>,
				  <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>bs_numtuples</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given two deformed tuples, adjust the first one so that it's consistent
 * with the summary values in both.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>union_tuples</name><parameter_list>(<parameter><decl><type><name>BrinDesc</name> <modifier>*</modifier></type><name>bdesc</name></decl></parameter>, <parameter><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BrinTuple</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinMemTuple</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Use our own memory context to avoid retail pfree */</comment>
	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><literal type="string">"brin union"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>brin_deform_tuple</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>bdesc</name><operator>-&gt;</operator><name>bd_tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>unionFn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinValues</name> <modifier>*</modifier></type><name>col_a</name> <init>= <expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BrinValues</name> <modifier>*</modifier></type><name>col_b</name> <init>= <expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>bt_columns</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>unionFn</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_index</name></name></expr></argument>, <argument><expr><name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><name>BRIN_PROCNUM_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FunctionCall3Coll</name><argument_list>(<argument><expr><name>unionFn</name></expr></argument>,
						  <argument><expr><name><name>bdesc</name><operator>-&gt;</operator><name>bd_index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bdesc</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>col_a</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>col_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * brin_vacuum_scan
 *		Do a complete scan of the index during VACUUM.
 *
 * This routine scans the complete index looking for uncatalogued index pages,
 * i.e. those that might have been lost due to a crash after index extension
 * and such.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>brin_vacuum_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>idxrel</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan the index in physical order, and clean up any possible mess in
	 * each page.
	 */</comment>
	<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>blkno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>nblocks</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								 <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>brin_page_cleanup</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Update all upper pages in the index's FSM, as well.  This ensures not
	 * only that we propagate leaf-page FSM updates made by brin_page_cleanup,
	 * but also that any pre-existing damage or out-of-dateness is repaired.
	 */</comment>
	<expr_stmt><expr><call><name>FreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
