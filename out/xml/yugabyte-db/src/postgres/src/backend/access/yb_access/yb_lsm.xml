<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/yb_access/yb_lsm.c"><comment type="block">/*--------------------------------------------------------------------------------------------------
 *
 * yb_lsm.c
 *	  Implementation of YugaByte indexes.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing permissions and limitations
 * under the License.
 *
 * src/backend/access/yb_access/yb_lsm.c
 *
 * TODO: currently this file contains skeleton index access methods. They will be implemented in
 * coming revisions.
 *--------------------------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_scan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/yb_lsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/ybccmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcModifyTable.h"</cpp:file></cpp:include>

<comment type="block">/* --------------------------------------------------------------------------------------------- */</comment>

<comment type="block">/* Working state for ybcinbuild and its callback */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type>	<name>isprimary</name></decl>;</decl_stmt>		<comment type="block">/* are we building a primary index? */</comment>
	<decl_stmt><decl><type><name>double</name></type>	<name>index_tuples</name></decl>;</decl_stmt>	<comment type="block">/* # of tuples inserted into index */</comment>
	<comment type="block">/*
	 * Write time for rows written to index as part of online index backfill.
	 * This field being non-null signifies that we are doing online index
	 * backfill.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>backfill_write_time</name></decl>;</decl_stmt>
}</block></struct></type> <name>YBCBuildState</name>;</typedef>

<comment type="block">/*
 * LSM handler function: return IndexAmRoutine with access method parameters
 * and callbacks.
 */</comment>
<function><type><name>Datum</name></type>
<name>ybcinhandler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name> <operator>=</operator> <name>BTMaxStrategyNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>=</operator> <name>BTNProcs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amclusterable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* TODO: support parallel scan */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcaninclude</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuild</name></name> <operator>=</operator> <name>ybcinbuild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name> <operator>=</operator> <name>ybcinbuildempty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminsert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* use yb_aminsert below instead */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name> <operator>=</operator> <name>ybcinbulkdelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name> <operator>=</operator> <name>ybcinvacuumcleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name>ybcincanreturn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name>ybcincostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name> <operator>=</operator> <name>ybcinoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amproperty</name></name> <operator>=</operator> <name>ybcinproperty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvalidate</name></name> <operator>=</operator> <name>ybcinvalidate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name> <operator>=</operator> <name>ybcinbeginscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrescan</name></name> <operator>=</operator> <name>ybcinrescan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>=</operator> <name>ybcingettuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* TODO: support bitmap scan */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amendscan</name></name> <operator>=</operator> <name>ybcinendscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* TODO: support mark/restore pos with ordering */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* TODO: support parallel scan */</comment>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>yb_aminsert</name></name> <operator>=</operator> <name>ybcininsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>yb_amdelete</name></name> <operator>=</operator> <name>ybcindelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>yb_ambackfill</name></name> <operator>=</operator> <name>ybcinbackfill</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to bind const to column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bindColumn</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>stmt</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>attr_num</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>,
		   <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>,
									<argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attr_num</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to set binds for index write statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doBindsForIdxWrite</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>stmt</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexstate</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>n_bound_atts</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>ybbasectid</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>ybctid_as_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name>		<init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		  <name>indnkeyatts</name>	<init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ybbasectid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Missing base table ybctid in index write request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>has_null_attr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>n_bound_atts</name></expr>;</condition> <incr><expr><operator>++</operator><name>attnum</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>type_id</name> <init>= <expr><call><name>GetTypeId</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collation_id</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
													   <argument><expr><call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name>   <init>= <expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name> <init>= <expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>bindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If any of the indexed columns is null, we need to take case of
		 * SQL null != null semantics.
		 * For details, see comment on kYBUniqueIdxKeySuffix.
		 */</comment>
		<expr_stmt><expr><name>has_null_attr</name> <operator>=</operator> <name>has_null_attr</name> <operator>||</operator> <operator>(</operator><name>is_null</name> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <name>indnkeyatts</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>unique_index</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For unique indexes we need to set the key suffix system column:
	 * - to ybbasectid if at least one index key column is null.
	 * - to NULL otherwise (setting is_null to true is enough).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>unique_index</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
				   <argument><expr><name>YBUniqueIdxKeySuffixAttributeNumber</name></expr></argument>,
				   <argument><expr><name>BYTEAOID</name></expr></argument>,
				   <argument><expr><name>InvalidOid</name></expr></argument>,
				   <argument><expr><name>ybbasectid</name></expr></argument>,
				   <argument><expr><operator>!</operator><name>has_null_attr</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We may need to set the base ctid column:
	 * - for unique indexes only if we need it as a value (i.e. for inserts)
	 * - for non-unique indexes always (it is a key column).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ybctid_as_value</name> <operator>||</operator> <operator>!</operator><name>unique_index</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>bindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
				   <argument><expr><name>YBIdxBaseTupleIdAttributeNumber</name></expr></argument>,
				   <argument><expr><name>BYTEAOID</name></expr></argument>,
				   <argument><expr><name>InvalidOid</name></expr></argument>,
				   <argument><expr><name>ybbasectid</name></expr></argument>,
				   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcinbuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCBuildState</name>  <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>YBCBuildState</name> <operator>*</operator><operator>)</operator><name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buildstate</name><operator>-&gt;</operator><name>isprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBCExecuteInsertIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
							  <argument><expr><name>values</name></expr></argument>,
							  <argument><expr><name>isnull</name></expr></argument>,
							  <argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>,
							  <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>backfill_write_time</name></name></expr></argument>,
							  <argument><expr><name>doBindsForIdxWrite</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* indexstate */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ybcinbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCBuildState</name></type>	<name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>heap_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the heap scan */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>isprimary</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>index_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>backfill_write_time</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * Primary key index is an implicit part of the base table in Yugabyte.
	 * We don't need to scan the base table to build a primary key index. (#8024)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>heap_tuples</name> <operator>=</operator> <call><name>IndexBuildHeapScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>ybcinbuildCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name>  <operator>=</operator> <name>heap_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>index_tuples</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ybcinbackfill</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>,
			  <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
			  <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			  <parameter><decl><type><name>YbBackfillInfo</name> <modifier>*</modifier></type><name>bfinfo</name></decl></parameter>,
			  <parameter><decl><type><name>YbPgExecOutParam</name> <modifier>*</modifier></type><name>bfresult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCBuildState</name></type>	<name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>			<name>heap_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the heap scan */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>isprimary</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>index_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Backfilled rows should be as if they happened at the time of backfill */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>backfill_write_time</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>bfinfo</name><operator>-&gt;</operator><name>read_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>heap_tuples</name> <operator>=</operator> <call><name>IndexBackfillHeapRangeScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>,
											 <argument><expr><name>index</name></expr></argument>,
											 <argument><expr><name>indexInfo</name></expr></argument>,
											 <argument><expr><name>ybcinbuildCallback</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>,
											 <argument><expr><name>bfinfo</name></expr></argument>,
											 <argument><expr><name>bfresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name>  <operator>=</operator> <name>heap_tuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>index_tuples</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybcinbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected building of empty unlogged index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ybcininsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>,
			<parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sharedInsert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sharedInsert</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsYsqlUpgrade</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shared insert cannot be done outside of YSQL upgrade"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<macro><name>YB_FOR_EACH_DB</name><argument_list>(<argument>pg_db_tuple</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>pg_db_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * Since this is a catalog index, we assume it exists in all databases.
				 * YB doesn't use PG locks so it's okay not to take them.
				 */</comment>
				<expr_stmt><expr><call><name>YBCExecuteInsertIndexForDb</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
										   <argument><expr><name>index</name></expr></argument>,
										   <argument><expr><name>values</name></expr></argument>,
										   <argument><expr><name>isnull</name></expr></argument>,
										   <argument><expr><name>ybctid</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* backfill_write_time */</comment>,
										   <argument><expr><name>doBindsForIdxWrite</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* indexstate */</comment>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>YB_FOR_EACH_DB_END</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YBCExecuteInsertIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
								  <argument><expr><name>values</name></expr></argument>,
								  <argument><expr><name>isnull</name></expr></argument>,
								  <argument><expr><name>ybctid</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* backfill_write_time */</comment>,
								  <argument><expr><name>doBindsForIdxWrite</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* indexstate */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybcindelete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>,
			<parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>YBCExecuteDeleteIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
							  <argument><expr><name>doBindsForIdxWrite</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* indexstate */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>ybcinbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
				<parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected bulk delete of index via vacuum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>ybcinvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected index cleanup via vacuum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------------------------- */</comment>

<function><type><name>bool</name></type> <name>ybcincanreturn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If "canreturn" is true, Postgres will attempt to perform index-only scan on the indexed
	 * columns and expect us to return the column values as an IndexTuple. This will be the case
	 * for secondary index.
	 *
	 * For indexes which are primary keys, we will return the table row as a HeapTuple instead.
	 * For this reason, we set "canreturn" to false for primary keys.
	 */</comment>
	<return>return <expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybcincostestimate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexPath</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				  <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>,
				  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Information is lacking for hypothetical index in order for estimation
	 * in YB to work.
	 * So we skip hypothetical index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>hypothetical</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ybcIndexCostEstimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						 <argument><expr><name>path</name></expr></argument>,
						 <argument><expr><name>indexSelectivity</name></expr></argument>,
						 <argument><expr><name>indexStartupCost</name></expr></argument>,
						 <argument><expr><name>indexTotalCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>ybcinoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_YB_LSM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ybcinproperty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>, <parameter><decl><type><name>IndexAMProperty</name></type> <name>prop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>propname</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ybcinvalidate</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclassoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------------------------- */</comment>

<function><type><name>IndexScanDesc</name></type>
<name>ybcinbeginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<comment type="block">/* no order by operators allowed */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>norderbys</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the scan */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>RelationGetIndexScan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>norderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybcinrescan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nscankeys</name></decl></parameter>,	<parameter><decl><type><name>ScanKey</name></type> <name>orderbys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norderbys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For rescan, end the previous scan. */</comment>
		<expr_stmt><expr><call><name>ybcinendscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name> <init>= <expr><call><name>ybcBeginScan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr></argument>, <argument><expr><name>nscankeys</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>yb_scan_plan</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>yb_rel_pushdown</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>yb_idx_pushdown</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>ybScan</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Processing the following SELECT.
 *   SELECT data FROM heapRelation WHERE rowid IN
 *     ( SELECT rowid FROM indexRelation WHERE key = given_value )
 *
 * TODO(neil) Postgres layer should make just one request for IndexScan.
 *   - Query ROWID from IndexTable using key.
 *   - Query data from Table (relation) using ROWID.
 */</comment>
<function><type><name>bool</name></type>
<name>ybcingettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dir</name> <operator>==</operator> <name>ForwardScanDirection</name> <operator>||</operator> <name>dir</name> <operator>==</operator> <name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_forward_scan</name> <init>= <expr><operator>(</operator><name>dir</name> <operator>==</operator> <name>ForwardScanDirection</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybscan</name> <init>= <expr><operator>(</operator><name>YbScanDesc</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ybscan</name><operator>-&gt;</operator><name>exec_params</name></name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>yb_exec_params</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybscan</name><operator>-&gt;</operator><name>exec_params</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null exec_params"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>ybscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * IndexScan(SysTable, Index) --&gt; HeapTuple.
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ybscan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ybc_getnext_indextuple</name><argument_list>(<argument><expr><name>ybscan</name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itup</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_itupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ybc_getnext_heaptuple</name><argument_list>(<argument><expr><name>ybscan</name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybcinendscan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ybc_free_ybscan</name><argument_list>(<argument><expr><operator>(</operator><name>YbScanDesc</name><operator>)</operator><name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
