<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/yb_access/yb_scan.c"><comment type="block">/*--------------------------------------------------------------------------------------------------
 *
 * yb_scan.c
 *	  YugaByte catalog scan API.
 *	  This is used to access data from YugaByte's system catalog tables.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing permissions and limitations
 * under the License.
 *
 * src/backend/access/yb_access/yb_scan.c
 *
 *--------------------------------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablegroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>YbScanPlanData</name>
<block>{
	<comment type="block">/* The relation where to read data from */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>target_relation</name></decl>;</decl_stmt>

	<comment type="block">/* Primary and hash key columns of the referenced table/relation. */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>primary_key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>hash_key</name></decl>;</decl_stmt>

	<comment type="block">/* Set of key columns whose values will be used for scanning. */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>sk_cols</name></decl>;</decl_stmt>

	<comment type="block">/* Description and attnums of the columns to bind */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>bind_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name><name>bind_key_attnums</name><index>[<expr><name>YB_MAX_SCAN_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>YbScanPlanData</name>;</typedef>

<typedef>typedef <type><name>YbScanPlanData</name> <modifier>*</modifier></type><name>YbScanPlan</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcAddAttributeColumn</name><parameter_list>(<parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if an attribute is a hash or primary key column and note it in
 * the scan plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcCheckPrimaryKeyAttribute</name><parameter_list>(<parameter><decl><type><name>YbScanPlan</name></type>      <name>scan_plan</name></decl></parameter>,
										<parameter><decl><type><name>YBCPgTableDesc</name></type>  <name>ybc_table_desc</name></decl></parameter>,
										<parameter><decl><type><name>AttrNumber</name></type>      <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgColumnInfo</name></type> <name>column_info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * TODO(neil) We shouldn't need to upload YugaByte table descriptor here because the structure
	 * Postgres::Relation already has all information.
	 * - Primary key indicator: IndexRelation-&gt;rd_index-&gt;indisprimary
	 * - Number of key columns: IndexRelation-&gt;rd_index-&gt;indnkeyatts
	 * - Number of all columns: IndexRelation-&gt;rd_index-&gt;indnatts
	 * - Hash, range, etc: IndexRelation-&gt;rd_indoption (Bits INDOPTION_HASH, RANGE, etc)
	 */</comment>
	<expr_stmt><expr><call><name>HandleYBTableDescStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetColumnInfo</name><argument_list>(<argument><expr><name>ybc_table_desc</name></expr></argument>,
											   <argument><expr><name>attnum</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>column_info</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>column_info</name><operator>.</operator><name>is_hash</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>hash_key</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>hash_key</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>column_info</name><operator>.</operator><name>is_primary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get YugaByte-specific table metadata and load it into the scan_plan.
 * Currently only the hash and primary key info.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcLoadTableInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>            <name>dboid</name>          <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTableDesc</name></type> <name>ybc_table_desc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetTableDesc</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>, <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ybc_table_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ybcCheckPrimaryKeyAttribute</name><argument_list>(<argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>ybc_table_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ybcCheckPrimaryKeyAttribute</name><argument_list>(<argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>ybc_table_desc</name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type> <name>ybc_get_atttypid</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>bind_desc</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>atttypid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the type from the description */</comment>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* This must be an OID column. */</comment>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

  <return>return <expr><name>atttypid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bind a scan key.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbBindColumn</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>bind_desc</name></decl></parameter>,
             <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>atttypid</name> <init>= <expr><call><name>ybc_get_atttypid</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>attcollation</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										   <argument><expr><call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>ybc_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbBindColumnCondBetween</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>,
                        <parameter><decl><type><name>TupleDesc</name></type> <name>bind_desc</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>start_valid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>start_inclusive</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
                        <parameter><decl><type><name>bool</name></type> <name>end_valid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>end_inclusive</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>atttypid</name> <init>= <expr><call><name>ybc_get_atttypid</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>attcollation</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										   <argument><expr><call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr</name> <init>= <expr><ternary><condition><expr><name>start_valid</name></expr> ?</condition><then> <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
													  <argument><expr><name>atttypid</name></expr></argument>,
													  <argument><expr><name>attcollation</name></expr></argument>,
													  <argument><expr><name>value</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument> <comment type="block">/* isnull */</comment>)</argument_list></call></expr>
									 </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybc_expr_end</name> <init>= <expr><ternary><condition><expr><name>end_valid</name></expr> ?</condition><then> <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
														<argument><expr><name>atttypid</name></expr></argument>,
														<argument><expr><name>attcollation</name></expr></argument>,
														<argument><expr><name>value_end</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument> <comment type="block">/* isnull */</comment>)</argument_list></call></expr>
									   </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumnCondBetween</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
												 <argument><expr><name>ybc_expr</name></expr></argument>, <argument><expr><name>start_inclusive</name></expr></argument>,
												 <argument><expr><name>ybc_expr_end</name></expr></argument>, <argument><expr><name>end_inclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Bind an array of scan keys for a column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcBindColumnCondIn</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>bind_desc</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>atttypid</name> <init>= <expr><call><name>ybc_get_atttypid</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>attcollation</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
										   <argument><expr><call><name>ybc_get_attcollation</name><argument_list>(<argument><expr><name>bind_desc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name><name>ybc_exprs</name><index>[<expr><name>nvalues</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="block">/*
		 * For IN we are removing all null values in ybcBindScanKeys before
		 * getting here (relying on btree/lsm operators being strict).
		 * So we can safely set is_null to false for all options left here.
		 */</comment>
		<expr_stmt><expr><name><name>ybc_exprs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>,
									  <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumnCondIn</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>nvalues</name></expr></argument>, <argument><expr><name>ybc_exprs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a target column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcAddTargetColumn</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Regular (non-system) attribute. */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>atttypid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>attcollation</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>atttypmod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Ignore dropped attributes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>atttypid</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>atttypmod</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attcollation</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name>atttypmod</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ybcUpdateFKCache</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybScan</name><operator>-&gt;</operator><name>exec_params</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>exec_params</name><operator>-&gt;</operator><name>rowmark</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>ROW_MARK_EXCLUSIVE</name></expr>:</case>
	<case>case <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>:</case>
	<case>case <expr><name>ROW_MARK_SHARE</name></expr>:</case>
	<case>case <expr><name>ROW_MARK_KEYSHARE</name></expr>:</case>
		<expr_stmt><expr><call><name>YBCPgAddIntoForeignKeyReferenceCache</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>ROW_MARK_REFERENCE</name></expr>:</case>
	<case>case <expr><name>ROW_MARK_COPY</name></expr>:</case>
		<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>ybcFetchNextHeapTuple</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_forward_scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>      <name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name>  <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name>           <modifier>*</modifier></type><name>values</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>            <modifier>*</modifier></type><name>nulls</name>  <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>

	<comment type="block">/* Execute the select statement. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybScan</name><operator>-&gt;</operator><name>is_exec_done</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetForwardScan</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>exec_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fetch one row. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
	                             <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
	                             <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
	                             <argument><expr><name>nulls</name></expr></argument>,
	                             <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
	                             <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>syscols</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ybcUpdateFKCache</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexTuple</name></type> <name>ybcFetchNextIndexTuple</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_forward_scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type> <name>tuple</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>       <name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>  <name>tupdesc</name>  <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name>           <modifier>*</modifier></type><name>values</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>            <modifier>*</modifier></type><name>nulls</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>

	<comment type="block">/* Execute the select statement. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybScan</name><operator>-&gt;</operator><name>is_exec_done</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetForwardScan</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>exec_params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fetch one row. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
	                             <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
	                             <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
	                             <argument><expr><name>nulls</name></expr></argument>,
	                             <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
	                             <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Return the IndexTuple. If this is a primary key, reorder the values first as expected
		 * in the index's column order first.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name> <operator>&lt;=</operator> <name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name><name>ivalues</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>  <name><name>inulls</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attno</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>ivalues</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inulls</name><index>[<expr><name>i</name></expr>]</index></name>  <operator>=</operator> <name><name>nulls</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ivalues</name></expr></argument>, <argument><expr><name>inulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ybcUpdateFKCache</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybbasectid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybbasectid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ybcUpdateFKCache</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set up scan plan.
 * This function sets up target and bind columns for each type of scans.
 *    SELECT &lt;Target_columns&gt; FROM &lt;Table&gt; WHERE &lt;Key_columns&gt; op &lt;Binds&gt;
 *
 * 1. SequentialScan(Table) and PrimaryIndexScan(Table): index = 0
 *    - Table can be systable or usertable.
 *    - YugaByte doesn't have a separate PrimaryIndexTable. It's a special case.
 *    - Both target and bind descriptors are specified by the &lt;Table&gt;
 *
 * 2. IndexScan(SysTable, Index).
 *    - Target descriptor is specifed by the SysTable.
 *    - Bind descriptor is specified by the IndexTable.
 *    - For this scan, YugaByte returns a heap-tuple, which has all user's requested data.
 *
 * 3. IndexScan(UserTable, Index)
 *    - Both target and bind descriptors are specifed by the IndexTable.
 *    - For this scan, YugaByte returns an index-tuple, which has a ybctid (ROWID) to be used for
 *      querying data from the UserTable.
 *    - TODO(neil) By batching ybctid and processing it on YugaByte for all index-scans, the target
 *      for index-scan on regular table should also be the table itself (relation).
 *
 * 4. IndexOnlyScan(Table, Index)
 *    - Table can be systable or usertable.
 *    - Both target and bind descriptors are specifed by the IndexTable.
 *    - For this scan, YugaByte ALWAYS return index-tuple, which is expected by Postgres layer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcSetupScanPlan</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>xs_want_itup</name></decl></parameter>, <parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>scan_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup control-parameters for Yugabyte preparing statements for different
	 * types of scan.
	 * - "querying_colocated_table": Support optimizations for (system,
	 *   user database and tablegroup) colocated tables
	 * - "index_oid, index_only_scan, use_secondary_index": Different index
	 *   scans.
	 * NOTE: Primary index is a special case as there isn't a primary index
	 * table in YugaByte.
	 */</comment>

	<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>querying_colocated_table</name></name> <operator>=</operator>
		<call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>YbGetTableProperties</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_colocated</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>index</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_oid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name> <operator>=</operator> <name>xs_want_itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>use_secondary_index</name></name> <operator>=</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Setup descriptors for target and bind. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>index</name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * SequentialScan or PrimaryIndexScan
		 * - YugaByte does not have a separate table for PrimaryIndex.
		 * - The target table descriptor, where data is read and returned, is the main table.
		 * - The binding table descriptor, whose column is bound to values, is also the main table.
		 */</comment>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ybcLoadTableInfo</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Index-Scan: SELECT data FROM UserTable WHERE rowid IN (SELECT ybctid FROM indexTable)
		 *
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * IndexOnlyScan
			 * - This special case is optimized where data is read from index table.
			 * - The target table descriptor, where data is read and returned, is the index table.
			 * - The binding table descriptor, whose column is bound to values, is also the index table.
			 */</comment>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * IndexScan ( SysTable / UserTable)
			 * - YugaByte will use the binds to query base-ybctid in the index table, which is then used
			 *   to query data from the main table.
			 * - The target table descriptor, where data is read and returned, is the main table.
			 * - The binding table descriptor, whose column is bound to values, is the index table.
			 */</comment>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ybcLoadTableInfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Setup bind and target attnum of ScanKey.
	 * - The target-attnum comes from the table that is being read by the scan
	 * - The bind-attnum comes from the table that is being scan by the scan.
	 *
	 * Examples:
	 * - For IndexScan(SysTable, Index), SysTable is used for targets, but Index is for binds.
	 * - For IndexOnlyScan(Table, Index), only Index is used to setup both target and bind.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>index</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Sequential scan */</comment>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * PrimaryIndex scan: This is a special case in YugaByte. There is no PrimaryIndexTable.
			 * The table itself will be scanned.
			 */</comment>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>	<name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * IndexOnlyScan(Table, Index) returns IndexTuple.
			 * Use the index attnum for both targets and binds.
			 */</comment>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * IndexScan(SysTable or UserTable, Index) returns HeapTuple.
			 * Use SysTable attnum for targets. Use its index attnum for binds.
			 */</comment>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>ybc_should_pushdown_op</name><parameter_list>(<parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>=  <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>op_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<return>return <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<comment type="block">/* range key */</comment>
			<return>return <expr><operator>(</operator><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>hash_key</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

		<default>default:</default>
			<comment type="block">/* TODO: support other logical operators */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsHashCodeSearch</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_hash_search</name> <init>= <expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>YB_SK_IS_HASHED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We currently don't support hash code search with any other flags */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_hash_search</name> <operator>||</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>==</operator> <name>YB_SK_IS_HASHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>is_hash_search</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is this a basic (c =/&lt;/&lt;=/&gt;=/&gt; value) (in)equality condition possibly on
 * hashed values?
 * TODO: The null value case (SK_ISNULL) should always evaluate to false
 *       per SQL semantics but in DocDB it will be true. So this case
 *       will require PG filtering (for null values only).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsBasicOpSearch</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	       <name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>==</operator> <name>SK_ISNULL</name> <operator>||</operator>
	       <call><name>YbIsHashCodeSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is this a null search (c IS NULL) -- same as equality cond for DocDB.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsSearchNull</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>==</operator> <operator>(</operator><name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is this an array search (c = ANY(..) or c IN ..).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsSearchArray</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>==</operator> <name>SK_SEARCHARRAY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is the condition never TRUE because of c {=|&lt;|&lt;=|&gt;=|&gt;} NULL, etc.?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsNeverTrueNullCond</name><parameter_list>(<parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	       <operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>SK_SEARCHNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the conditions lead to empty result regardless of the values
 * in the index because of always FALSE or UNKNOWN conditions.
 * Return true if the combined key conditions are unsatisfiable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsEmptyResultCondition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name><name>keys</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>YbIsNeverTrueNullCond</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScanKey</name></type> <name>subkey</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * ROW value comparison: ROW(x, y, z) {&lt;|&lt;=|&gt;|&gt;=} ROW(a, b, c)
			 * is equivalent to:
			 *   (x {&lt;|&gt;} a) OR (x = a AND y {&lt;|&gt;} b)
			 *     OR (x = a AND y = b AND z {&lt;|&lt;=|&gt;|&gt;=} c)
			 * when a is NULL then each OR'ed term is either UNKNOWN or FALSE,
			 * hence the entire comparison results in UNKNOWN if the first item
			 * in the ROW value is NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>!=</operator> <name>BTEqualStrategyNumber</name> <operator>&amp;&amp;</operator>
			    <call><name>YbIsNeverTrueNullCond</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In case of equality, ROW(x, y, z, ...) = ROW(a, b, c, ...)
			 * is equivalent to:
			 *   (x = a) AND (y = b) AND (z = c) ...
			 * NULL at any position makes the entire comparision either UNKNOWN
			 * or FALSE.
			 */</comment>
			<for>for <control>(<init>;</init> <condition><expr><operator>!</operator><operator>(</operator><name><name>subkey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_END</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>subkey</name></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>YbIsNeverTrueNullCond</name><argument_list>(<argument><expr><name>subkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbShouldPushdownScanPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>,
                               <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YbIsBasicOpSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Eq strategy for hash key, eq + ineq for range key. */</comment>
		<return>return <expr><call><name>ybc_should_pushdown_op</name><argument_list>(<argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YbIsSearchNull</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Always expect InvalidStrategy for NULL search. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YbIsSearchArray</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only allow equal strategy here (i.e. IN .. or = ANY(..) conditions,
		 * NOT IN will generate &lt;&gt; which is not a supported LSM/BTREE
		 * operator, so it should not get to this point.
		 */</comment>
		<return>return <expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* No other operators are supported. */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* int comparator for qsort() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>int_compar_cb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><name>v1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><name>v2</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>k1</name> <operator>&lt;</operator> <operator>*</operator><name>k2</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>k1</name> <operator>&gt;</operator> <operator>*</operator><name>k2</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use the scan-descriptor and scan-plan to setup scan key for filtering */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcSetupScanKeys</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Find the scan keys that are the primary key.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * TODO: Can we have bound keys on non-pkey columns here?
		 *       If not we do not need the is_primary_key below.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_primary_key</name> <init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_primary_key</name> <operator>&amp;&amp;</operator>
		    <call><name>YbShouldPushdownScanPrimaryKey</name><argument_list>(
		    	<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If hash key is not fully set, we must do a full-table scan so clear all
	 * the scan keys if the hash code was explicitly specified as a
	 * scan key then we also shouldn't be clearing the scan keys
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>hash_key</name></name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if typid is one of the Object Identifier Types */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>YbIsOidType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>REGPROCOID</name></expr>:</case>
		<case>case <expr><name>REGPROCEDUREOID</name></expr>:</case>
		<case>case <expr><name>REGOPEROID</name></expr>:</case>
		<case>case <expr><name>REGOPERATOROID</name></expr>:</case>
		<case>case <expr><name>REGCLASSOID</name></expr>:</case>
		<case>case <expr><name>REGTYPEOID</name></expr>:</case>
		<case>case <expr><name>REGROLEOID</name></expr>:</case>
		<case>case <expr><name>REGNAMESPACEOID</name></expr>:</case>
		<case>case <expr><name>REGCONFIGOID</name></expr>:</case>
		<case>case <expr><name>REGDICTIONARYOID</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>YbIsIntegerInRange</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>value_typid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>val</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>value_typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not an integer type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>val</name> <operator>&gt;=</operator> <name>min</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>&lt;=</operator> <name>max</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if a scan key column type is compatible with value type. 'equal_strategy' is true
 * for BTEqualStrategyNumber.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>YbIsScanCompatible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>column_typid</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>value_typid</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>equal_strategy</name></decl></parameter>,
							   <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>column_typid</name> <operator>==</operator> <name>value_typid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>column_typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT2OID</name></expr>:</case>

			<comment type="block">/*
			 * If column c0 has INT2OID type and value type is INT4OID, the value may overflow
			 * INT2OID. For example, where clause condition "c0 = 65539" would become "c0 = 3"
			 * and will unnecessarily fetch a row with key of 3. This will not affect correctness
			 * because at upper Postgres layer filtering will be subsequently applied for equality/
			 * inequality conditions. For example, "c0 = 65539" will be applied again to filter out
			 * this row. We prefer to bind scan key c0 to account for the common case where INT4OID
			 * value does not overflow INT2OID, which happens in some system relation scan queries.
			 *
			 * For this purpose, specifically for inequalities, we return true when we are sure that
			 * there isn't a data overflow. For instance, if column c0 has INT2OID and value type is
			 * INT4OID, and its an inequality strategy, we check if the actual value is within the
			 * bounds of INT2OID. If yes, then we return true, otherwise false.
			 */</comment>
			<return>return <expr><ternary><condition><expr><name>equal_strategy</name></expr> ?</condition><then> <expr><operator>(</operator><name>value_typid</name> <operator>==</operator> <name>INT4OID</name> <operator>||</operator> <name>value_typid</name> <operator>==</operator> <name>INT8OID</name><operator>)</operator></expr> </then><else>:
				   <expr><call><name>YbIsIntegerInRange</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_typid</name></expr></argument>, <argument><expr><name>SHRT_MIN</name></expr></argument>, <argument><expr><name>SHRT_MAX</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><name>equal_strategy</name></expr> ?</condition><then> <expr><operator>(</operator><name>value_typid</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name>value_typid</name> <operator>==</operator> <name>INT8OID</name><operator>)</operator></expr> </then><else>:
				   <expr><call><name>YbIsIntegerInRange</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_typid</name></expr></argument>, <argument><expr><name>INT_MIN</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><name>value_typid</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name>value_typid</name> <operator>==</operator> <name>INT4OID</name></expr>;</return>

		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
			<return>return <expr><name>value_typid</name> <operator>==</operator> <name>TEXTOID</name> <operator>||</operator> <name>value_typid</name> <operator>==</operator> <name>BPCHAROID</name> <operator>||</operator> <name>value_typid</name> <operator>==</operator> <name>VARCHAROID</name></expr>;</return>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>YbIsOidType</name><argument_list>(<argument><expr><name>column_typid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YbIsOidType</name><argument_list>(<argument><expr><name>value_typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Conservatively return false. */</comment>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * We require compatible column type and value type to avoid misinterpreting the value Datum
 * using a column type that can cause wrong scan results. Returns true if the column type
 * and value type are compatible.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbCheckScanTypes</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>atttypid</name> <init>=
		<expr><call><name>ybc_get_atttypid</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>valtypid</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * Example: CREATE TABLE t1(c0 REAL, c1 TEXT, PRIMARY KEY(c0 asc));
	 *          INSERT INTO t1(c0, c1) VALUES(0.4, 'SHOULD BE IN RESULT');
	 *          SELECT ALL t1.c1 FROM t1 WHERE ((0.6)&gt;(t1.c0));
	 * Internally, c0 has float4 type, 0.6 has float8 type. If we bind 0.6 directly with
	 * column c0, float8 0.6 will be misinterpreted as float4. However, casting to float4
	 * may lose precision. Here we simply do not bind a key when there is a type mismatch
	 * by leaving start_valid[idx] and end_valid[idx] as false. For the following cases
	 * we assume that Postgres ensures there is no concern for type mismatch.
	 * (1) value type is not a valid type id
	 * (2) InvalidStrategy (for IS NULL)
	 * (3) value type is a polymorphic pseudotype
	 */</comment>
	<return>return <expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>valtypid</name></expr></argument>)</argument_list></call> <operator>||</operator>
	       <name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>InvalidStrategy</name> <operator>||</operator>
	       <call><name>YbIsScanCompatible</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>valtypid</name></expr></argument>,
	                          <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr></argument>,
	                          <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	       <call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>valtypid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Use the scan-descriptor and scan-plan to setup binds for the queryplan */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbBindScanKeys</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewSelect</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name></name></expr></argument>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the arrays to store the search intervals for each PG/YSQL
	 * attribute (i.e. DocDB column).
	 * The size of the arrays will be based on the max attribute
	 * number used in the query but, as usual, offset to account for the
	 * negative attribute numbers of system attributes.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>max_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>max_idx</name> <operator>&lt;</operator> <name>idx</name> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max_idx</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>max_idx</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Find intervals for columns */</comment>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>is_column_bound</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>is_column_bound</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>start_valid</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>start_valid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>end_valid</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>end_valid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>start</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>end</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space */</comment>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>start_inclusive</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* VLA - scratch space */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>start_inclusive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>end_inclusive</name><index>[<expr><name>max_idx</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* VLA - scratch space */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>end_inclusive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * find an order of relevant keys such that for the same column, an EQUAL
	 * condition is encountered before IN or BETWEEN. is_column_bound is then used
	 * to establish priority order EQUAL &gt; IN &gt; BETWEEN.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>noffsets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name><name>offsets</name><index>[<expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* VLA - scratch space: +1 to avoid zero elements */</comment>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Check if this is full key row comparison expression */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ROW_HEADER</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKey</name></type> <name>subkeys</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>last_att_no</name> <init>= <expr><name>YBFirstLowInvalidAttributeNumber</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can only push down right now if the primary key columns
			 * are specified in the correct order and the primary key
			 * has no hashed columns. We also need to ensure that
			 * the same comparison operation is done to all subkeys.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>can_pushdown</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>strategy</name> <init>= <expr><name><name>subkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<do>do <block>{<block_content>
				<decl_stmt><decl><type><name>ScanKey</name></type> <name>current</name> <init>= <expr><operator>&amp;</operator><name><name>subkeys</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* Make sure that the specified keys are in the right order. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>current</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>&gt;</operator> <name>last_att_no</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>can_pushdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Make sure that the same comparator is applied to
				 * all subkeys.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>!=</operator> <name><name>current</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>can_pushdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>last_att_no</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>

				<comment type="block">/* Make sure that there are no hash key columns. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name><name>current</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
					<operator>&amp;</operator> <name>INDOPTION_HASH</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>can_pushdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			while<condition>(<expr><operator>(</operator><name><name>subkeys</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>sk_flags</name> <operator>&amp;</operator> <name>SK_ROW_END</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<comment type="block">/*
			 * Make sure that the primary key has no hash columns in order
			 * to push down.
			 */</comment>

			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_HASH</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>can_pushdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>can_pushdown</name></expr>)</condition>
			<block>{<block_content>

				<decl_stmt><decl><type><name>YBCPgExpr</name> <modifier>*</modifier></type><name>col_values</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YBCPgExpr</name></expr></argument>)</argument_list></sizeof>
											<operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * Prepare upper/lower bound tuples determined from this
				 * clause for bind. Care must be taken in the case
				 * that primary key columns in the index are ordered
				 * differently from each other. For example, consider
				 * if the underlying index has primary key
				 * (r1 ASC, r2 DESC, r3 ASC) and we are dealing with
				 * a clause like (r1, r2, r3) &lt;= (40, 35, 12).
				 * We cannot simply bind (40, 35, 12) as an upper bound
				 * as that will miss tuples such as (40, 32, 0).
				 * Instead we must push down (40, Inf, 12) in this case
				 * for correctness. (Note that +Inf in this context
				 * is higher in STORAGE order than all other values not
				 * necessarily logical order, similar to the role of
				 * docdb::ValueType::kHighest.
				 */</comment>

				<comment type="block">/*
				 * Is the first column in ascending order in the index?
				 * This is important because whether or not the RHS of a
				 * (row key) &gt;= (row key values) expression is
				 * considered an upper bound is dependent on the answer
				 * to this question. The RHS of such an expression will
				 * be the scan upper bound if the first column is in
				 * descending order and lower if else. Similar logic
				 * applies to the RHS of (row key) &lt;= (row key values)
				 * expressions.
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_direction_asc</name> <init>=
									<expr><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>rd_indoption</name><index>[
										<expr><name><name>subkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name>
										<operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>gt</name> <init>= <expr><name>strategy</name> <operator>==</operator> <name>BTGreaterEqualStrategyNumber</name>
								<operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_inclusive</name> <init>= <expr><name>strategy</name> <operator>!=</operator> <name>BTGreaterStrategyNumber</name>
										<operator>&amp;&amp;</operator> <name>strategy</name> <operator>!=</operator> <name>BTLessStrategyNumber</name></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>is_point_scan</name> <init>= <expr><operator>(</operator><name>count</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name><operator>)</operator>
										<operator>&amp;&amp;</operator> <operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Whether or not the RHS values make up a DocDB upper bound */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_upper_bound</name> <init>= <expr><name>gt</name> <operator>^</operator> <name>is_direction_asc</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type> <name>subkey_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_column_specified</name> <init>= <expr><name>subkey_index</name> <operator>&lt;</operator> <name>count</name>
											<operator>&amp;&amp;</operator> <operator>(</operator><name><name>subkeys</name><index>[<expr><name>subkey_index</name></expr>]</index></name>
												<operator>.</operator><name>sk_attno</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>j</name></expr></init></decl>;</decl_stmt>
					<comment type="block">/*
					 * Is the current column stored in ascending order in the
					 * underlying index?
					 */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>asc</name> <init>= <expr><operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>INDOPTION_DESC</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * If this column has different directionality than the
					 * first column then we have to adjust the bounds on this
					 * column.
					 */</comment>
					<if_stmt><if>if<condition>(<expr><operator>!</operator><name>is_column_specified</name>
						<operator>||</operator> <operator>(</operator><name>asc</name> <operator>!=</operator> <name>is_direction_asc</name> <operator>&amp;&amp;</operator>
							<operator>!</operator><name>is_point_scan</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>col_values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>ScanKey</name></type> <name>current</name> <init>= <expr><operator>&amp;</operator><name><name>subkeys</name><index>[<expr><name>subkey_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name><name>col_values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
											<argument><expr><call><name>ybc_get_atttypid</name>
												<argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>,
											<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
											<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>is_column_specified</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>subkey_index</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><name>is_upper_bound</name> <operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAddRowUpperBound</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
												<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr></argument>,
												<argument><expr><name>col_values</name></expr></argument>, <argument><expr><name>is_inclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_upper_bound</name> <operator>||</operator> <name>strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAddRowLowerBound</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
												<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr></argument>,
												<argument><expr><name>col_values</name></expr></argument>, <argument><expr><name>is_inclusive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check if this is primary columns */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>bind_key_attnum</name> <init>= <expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>bind_key_attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>sk_cols</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Assign key offsets */</comment>
		<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>InvalidStrategy</name></expr>:</case>
				<comment type="block">/* Should be ensured during planning. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbIsSearchNull</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* fallthrough  -- treating IS NULL as (DocDB) = (null) */</comment>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>YbIsBasicOpSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>YbIsSearchNull</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Use a -ve value so that qsort places EQUAL before others */</comment>
					<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>noffsets</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>YbIsSearchArray</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>noffsets</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>noffsets</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<default>default:</default>
				<break>break;</break> <comment type="block">/* unreachable */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>noffsets</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>int_compar_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* restore -ve offsets to +ve */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noffsets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<break>break;</break></block_content></block></else></if_stmt></block_content></block></for>

	<comment type="block">/* Bind keys for EQUALS and IN */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>noffsets</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>offsets</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * YBAttnumToBmsIndex should guarantee that index is positive
		 * -- needed for hash code search below.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do not bind more than one condition to a column */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>is_column_bound</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbCheckScanTypes</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>scan_plan</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>bound_inclusive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>InvalidStrategy</name></expr>:</case>
				<comment type="block">/* c IS NULL -&gt; c = NULL (checked above) */</comment>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<comment type="block">/* Bind the scan keys */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>YbIsBasicOpSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>YbIsSearchNull</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Either c = NULL or c IS NULL. */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name><operator>)</operator> <operator>==</operator> <name>SK_ISNULL</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>YbBindColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>,
					             <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
					             <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>is_column_bound</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>YbIsSearchArray</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* based on _bt_preprocess_array_keys() */</comment>
					<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>num_valid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * First, deconstruct the array into elements.  Anything allocated
					 * here (including a possibly detoasted array value) is in the
					 * workspace context.
					 */</comment>
					<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_subtype</name></name> <operator>==</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* We could cache this data, but not clear it's worth it */</comment>
					<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
										<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Compress out any null elements.  We can ignore them since we assume
					 * all btree operators are strict. Also remove elements that are too large or
					 * too small. eg. WHERE element = INT_MAX + k, where k is positive and element
					 * is of integer type.
					 */</comment>
					<decl_stmt><decl><type><name>Oid</name></type> <name>atttype</name> <init>= <expr><call><name>ybc_get_atttypid</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>num_valid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<comment type="block">/* Skip integer element where the value overflows the column type */</comment>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name>atttype</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name>atttype</name> <operator>==</operator> <name>INT4OID</name><operator>)</operator> <operator>&amp;&amp;</operator>
							<operator>!</operator><call><name>YbIsIntegerInRange</name><argument_list>(<argument><expr><name><name>elem_values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sk_subtype</name></expr></argument>,
                                  			   <argument><expr><ternary><condition><expr><name>atttype</name> <operator>==</operator> <name>INT2OID</name></expr> ?</condition><then> <expr><name>SHRT_MIN</name></expr> </then><else>: <expr><name>INT_MIN</name></expr></else></ternary></expr></argument>,
								               <argument><expr><ternary><condition><expr><name>atttype</name> <operator>==</operator> <name>INT2OID</name></expr> ?</condition><then> <expr><name>SHRT_MAX</name></expr> </then><else>: <expr><name>INT_MAX</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>elem_values</name><index>[<expr><name>num_valid</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></for>

					<comment type="block">/* We could pfree(elem_nulls) now, but not worth the cycles */</comment>

					<comment type="block">/*
						* If there's no non-nulls, the scan qual is unsatisfiable
						* Example: SELECT ... FROM ... WHERE h = ... AND r IN (NULL,NULL);
						*/</comment>
					<if_stmt><if>if <condition>(<expr><name>num_valid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* Build temporary vars */</comment>
					<decl_stmt><decl><type><name>IndexScanDescData</name></type> <name>tmp_scan_desc</name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_scan_desc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>tmp_scan_desc</name><operator>.</operator><name>indexRelation</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

					<comment type="block">/*
						* Sort the non-null elements and eliminate any duplicates.  We must
						* sort in the same ordering used by the index column, so that the
						* successive primitive indexscans produce data in index order.
						*/</comment>
					<expr_stmt><expr><name>num_elems</name> <operator>=</operator> <call><name>_bt_sort_array_elements</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_scan_desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
														<argument><expr><name>false</name></expr></argument> <comment type="block">/* reverse */</comment>,
														<argument><expr><name>elem_values</name></expr></argument>, <argument><expr><name>num_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
						* And set up the BTArrayKeyInfo data.
						*/</comment>
					<expr_stmt><expr><call><name>ybcBindColumnCondIn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_key_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>num_elems</name></expr></argument>, <argument><expr><name>elem_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>is_column_bound</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name>bound_inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>start_valid</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* take max of old value and new value */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_gt</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
						<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>, <argument><expr><name><name>start</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_gt</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>start</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>start_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>bound_inclusive</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>start</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>start_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>bound_inclusive</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>start_valid</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name>bound_inclusive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>end_valid</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* take min of old value and new value */</comment>
					<decl_stmt><decl><type><name>bool</name></type> <name>is_lt</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
						<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>, <argument><expr><name><name>end</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_lt</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>end</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>end_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>bound_inclusive</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>end</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>end_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>bound_inclusive</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>end_valid</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break> <comment type="block">/* unreachable */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* Bind keys for BETWEEN */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>min_idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name>min_idx</name></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>max_idx</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Do not bind more than one condition to a column */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>is_column_bound</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>start_valid</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>end_valid</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>YbBindColumnCondBetween</name><argument_list>(
			<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>bind_desc</name></name></expr></argument>, <argument><expr><call><name>YBBmsIndexToAttnum</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>start_valid</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>start_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>start</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
			<argument><expr><name><name>end_valid</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>end_inclusive</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>end</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>YBCPgBoundType</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbBound</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>YbBound</name></type> <name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbBound</name></type> <name>end</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbRange</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbBoundValid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbBound</name><modifier>*</modifier></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>bound</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>YB_YQL_BOUND_INVALID</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>YbBoundInclusive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbBound</name><modifier>*</modifier></type> <name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>bound</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>YB_YQL_BOUND_VALID_INCLUSIVE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbIsValidRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>YbBound</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>YbBound</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>YbBoundValid</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>start</name><operator>-&gt;</operator><name>value</name></name> <operator>&lt;</operator> <name><name>end</name><operator>-&gt;</operator><name>value</name></name> <operator>||</operator>
	       <operator>(</operator><name><name>start</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name><name>end</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator>
	        <call><name>YbBoundInclusive</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	        <call><name>YbBoundInclusive</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbApplyStartBound</name><parameter_list>(<parameter><decl><type><name>YbRange</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>YbBound</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YbIsValidRange</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	    <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>value</name></name> <operator>&lt;</operator> <name><name>start</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>start</name><operator>.</operator><name>value</name></name> <operator>==</operator> <name><name>start</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YbBoundInclusive</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <operator>*</operator><name>start</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbApplyEndBound</name><parameter_list>(<parameter><decl><type><name>YbRange</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>YbBound</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YbIsValidRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
	    <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>value</name></name> <operator>&gt;</operator> <name><name>end</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>end</name><operator>.</operator><name>value</name></name> <operator>==</operator> <name><name>end</name><operator>-&gt;</operator><name>value</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YbBoundInclusive</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>range</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <operator>*</operator><name>end</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>YbBindHashKeys</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbRange</name></type> <name>range</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>YbIsHashCodeSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>YbBound</name></type> <name>bound</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>YB_YQL_BOUND_VALID</name></expr>,
			<expr><operator>.</operator><name>value</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
					<expr_stmt><expr><name><name>bound</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>YB_YQL_BOUND_VALID_INCLUSIVE</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbApplyStartBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound</name></expr></argument>)</argument_list></call> <operator>||</operator>
					    <operator>!</operator><call><name>YbApplyEndBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>bound</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>YB_YQL_BOUND_VALID_INCLUSIVE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbApplyStartBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name><name>bound</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>YB_YQL_BOUND_VALID_INCLUSIVE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbApplyEndBound</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break> <comment type="block">/* unreachable */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>YbBoundValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>range</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindHashCodes</name><argument_list>(
			<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
			<argument><expr><name><name>range</name><operator>.</operator><name>start</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>range</name><operator>.</operator><name>start</name><operator>.</operator><name>value</name></name></expr></argument>,
			<argument><expr><name><name>range</name><operator>.</operator><name>end</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>range</name><operator>.</operator><name>end</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * YbColumnFilter struct stores list of target columns required by scan plan.
 * All other non system columns may be excluded from reading from DocDB for optimization.
 * Required columns are:
 * - all bound key columns
 * - all query targets columns (from index for Index Only Scan case and from table otherwise)
 * - all qual columns (not bound to the scan keys), they are requirted for filtering results
 *   on the postgres side
 *
 * Example:
 * SELECT &lt;target columns from index or table&gt; FROM t
 *     WHERE &lt;bound key columns&gt; + &lt;table filtering columns&gt;
 */</comment>
<typedef>typedef <type><struct>struct <name>YbColumnFilter</name> <block>{
	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>min_attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>required_attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>all_attrs_required</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbColumnFilter</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbInitColumnFilter</name><parameter_list>(
	<parameter><decl><type><name>YbColumnFilter</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_attr</name> <init>= <expr><call><name>YBGetFirstLowInvalidAttributeNumber</name><argument_list>(
		<argument><expr><ternary><condition><expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr> ?</condition><then> <expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr> </then><else>: <expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>ybScan</name></name> <operator>=</operator> <name>ybScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>=</operator> <name>min_attr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>all_attrs_required</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pg_scan_plan</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Collect bound key attributes */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sk_attno</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name></name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sk_attno_end</name> <init>= <expr><name>sk_attno</name> <operator>+</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</init>
	     <condition><expr><name>sk_attno</name> <operator>!=</operator> <name>sk_attno_end</name></expr>;</condition>
	     <incr><expr><operator>++</operator><name>sk_attno</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><operator>*</operator><name>sk_attno</name> <operator>-</operator> <name>min_attr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>Index</name></type> <name>target_relid</name> <init>= <expr><ternary><condition><expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name></expr>
		?</condition><then> <expr><name>INDEX_VAR</name></expr> </then><else>: <expr><name><name>pg_scan_plan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<comment type="block">/* Collect target attributes */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pg_scan_plan-&gt;plan.targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>target_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>items</name></expr></argument>, <argument><expr><name>min_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Collect table filtering attributes */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pg_scan_plan-&gt;plan.qual</argument>)</argument_list></macro>
		<expr_stmt><expr><call><name>pull_varattnos_min_attr</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>items</name></expr></argument>, <argument><expr><name>min_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name> <operator>=</operator> <name>items</name></expr>;</expr_stmt>
	<comment type="block">/* In case InvalidAttrNumber is set whole row columns are required */</comment>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>all_attrs_required</name></name> <operator>=</operator> <call><name>bms_is_member</name><argument_list>(
		<argument><expr><name>InvalidAttrNumber</name> <operator>-</operator> <name>min_attr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbResetColumnFilter</name><parameter_list>(<parameter><decl><type><name>YbColumnFilter</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filter</name><operator>-&gt;</operator><name>ybScan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YbAddTargetColumnIfRequired</name><parameter_list>(<parameter><decl><type><name>YbColumnFilter</name> <modifier>*</modifier></type><name>filter</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>filter</name><operator>-&gt;</operator><name>all_attrs_required</name></name> <operator>||</operator>
	    <call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name> <operator>-</operator> <name><name>filter</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>filter</name><operator>-&gt;</operator><name>required_attrs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name><name>filter</name><operator>-&gt;</operator><name>ybScan</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Setup the targets */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybcSetupTargets</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>YbScanPlan</name></type> <name>scan_plan</name></decl></parameter>, <parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_index_only_scan</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>prepare_params</name><operator>.</operator><name>index_only_scan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbColumnFilter</name></type> <name>filter</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>YbInitColumnFilter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>pg_scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_index_only_scan</name> <operator>&amp;&amp;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Special case: For Primary-Key-ONLY-Scan, we select ONLY the primary key from the target
		 * table instead of the whole target table.
		 */</comment>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YbAddTargetColumnIfRequired</name><argument_list>(
				<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YbAddTargetColumnIfRequired</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>YbResetColumnFilter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Query uses the yb_hash_code function, all hash key components are
		 * required for further tuple recheck.
		 * Note: Relation's attribute is required in case of using secondary index.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>secondary_index</name> <init>=
			<expr><ternary><condition><expr><operator>(</operator><name>index</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_index_only_scan</name><operator>)</operator></expr>
				?</condition><then> <expr><name>index</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name></decl>;</init> <condition><expr><operator>(</operator><name>idx</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>hash_key</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>YBBmsIndexToAttnum</name><argument_list>(
				<argument><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>secondary_index</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>secondary_index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan_plan</name><operator>-&gt;</operator><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_index_only_scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * IndexOnlyScan:
		 *   SELECT [ data, ] ybbasectid (ROWID of UserTable, relation) FROM secondary-index-table
		 * In this case, Postgres requests base_ctid and maybe also data from IndexTable and then uses
		 * them for further processing.
		 */</comment>
		<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>YBIdxBaseTupleIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Two cases:
		 * - Primary Scan (Key or sequential)
		 *     SELECT data, ybctid FROM table [ WHERE primary-key-condition ]
		 * - Secondary IndexScan
		 *     SELECT data, ybctid FROM table WHERE ybctid IN ( SELECT base_ybctid FROM IndexTable )
		 */</comment>
		<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * IndexScan: Postgres layer sends both actual-query and index-scan to PgGate, who will
			 * select and immediately use base_ctid to query data before responding.
			 */</comment>
			<expr_stmt><expr><call><name>ybcAddTargetColumn</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>YBIdxBaseTupleIdAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybSetupScanQual
 *
 * Add remote filter expressions to the YbScanDesc.
 * The expression are pushed down to DocDB and used to filter rows early to
 * avoid sending them across network.
 * Set is_primary to false if the filter expression is to apply to secondary
 * index. In this case Var nodes must be properly adjusted to refer the index
 * columns rather than main relation columns.
 * For primary key scan or sequential scan is_primary should be true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybSetupScanQual</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_primary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Create new PgExpr wrapper for the expression */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewEvalExprCall</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Add the PgExpr to the statement */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbPgDmlAppendQual</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>yb_expr</name></expr></argument>, <argument><expr><name>is_primary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * ybSetupScanColumnRefs
 *
 * Add the list of column references used by pushed down expressions to the
 * YbScanDesc.
 * The colref list is expected to be the list of YbExprParamDesc nodes.
 * Set is_primary to false if the filter expression is to apply to secondary
 * index. In this case attno field values must be properly adjusted to refer
 * the index columns rather than main relation columns.
 * For primary key scan or sequential scan is_primary should be true.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybSetupScanColumnRefs</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colrefs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_primary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colrefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YbExprParamDesc</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>YbExprParamDesc</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>param</name><operator>-&gt;</operator><name>typmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Create new PgExpr wrapper for the column reference */</comment>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>yb_expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>attno</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>typid</name></name></expr></argument>,
											<argument><expr><name><name>param</name><operator>-&gt;</operator><name>collid</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Add the PgExpr to the statement */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YbPgDmlAppendColumnRef</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
											  <argument><expr><name>yb_expr</name></expr></argument>,
											  <argument><expr><name>is_primary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Begin a scan for
 *   SELECT &lt;Targets&gt; FROM &lt;Relation relation&gt; USING &lt;Relation index&gt;
 * NOTES:
 * - "relation" is the table being SELECTed.
 * - "index" identify the INDEX that will be used for scaning.
 * - "nkeys" and "key" identify which key columns are provided in the SELECT WHERE clause.
 *   nkeys = Number of key.
 *   keys[].sk_attno = the columns' attnum in the IndexTable or "index"
 *                     (This is not the attnum in UserTable or "relation")
 *
 * - If "xs_want_itup" is true, Postgres layer is expecting an IndexTuple that has ybctid to
 *   identify the desired row.
 * - "rel_remote" defines expressions to pushdown to remote relation scan
 * - "idx_remote" defines expressions to pushdown to remote secondary index
 *   scan. If the scan is not over a secondary index.
 */</comment>
<function><type><name>YbScanDesc</name></type>
<name>ybcBeginScan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
			 <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>xs_want_itup</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>keys</name></decl></parameter>,
			 <parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name></decl></parameter>,
			 <parameter><decl><type><name>PushdownExprs</name> <modifier>*</modifier></type><name>rel_remote</name></decl></parameter>,
			 <parameter><decl><type><name>PushdownExprs</name> <modifier>*</modifier></type><name>idx_remote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>nkeys</name> <operator>&gt;</operator> <name>YB_MAX_SCAN_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use more than %d predicates in a table or index scan"</literal></expr></argument>,
						<argument><expr><name>YB_MAX_SCAN_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up YugaByte scan description */</comment>
	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name> <init>= <expr><operator>(</operator><name>YbScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Keys for hash code search should be placed after regular keys.
		 * For this purpose they are written into keys array from right to left.
		 */</comment>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name><index>[<expr><ternary><condition><expr><call><name>YbIsHashCodeSearch</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>
			?</condition><then> <expr><operator>(</operator><name>nkeys</name> <operator>-</operator> <operator>(</operator><operator>++</operator><name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name><operator>)</operator><operator>)</operator></expr>
			</then><else>: <expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name><operator>++</operator></expr></else></ternary></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>exec_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>quit_scan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Setup the scan plan */</comment>
	<decl_stmt><decl><type><name>YbScanPlanData</name></type> <name>scan_plan</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ybcSetupScanPlan</name><argument_list>(<argument><expr><name>xs_want_itup</name></expr></argument>, <argument><expr><name>ybScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ybcSetupScanKeys</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>YbIsEmptyResultCondition</name><argument_list>(<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <call><name>YbBindScanKeys</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <call><name>YbBindHashKeys</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Setup the scan targets with respect to postgres scan plan
		 * (i.e. set only required targets)
		 */</comment>
		<expr_stmt><expr><call><name>ybcSetupTargets</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>, <argument><expr><name>pg_scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* Set up pushdown expressions.
		* Sequential, IndexOnly and primary key scans are refer only one
		* relation, and all expression they push down are in the rel_remote.
		* Secondary index scan may have pushable expressions that refer columns
		* not included in the index, those go to the rel_remote as well.
		* Secondary index scan's expressions that refer only columns available
		* from the index are go to the idx_remote and pushed down when the index
		* is scanned.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>rel_remote</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ybSetupScanQual</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>rel_remote</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_primary */</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ybSetupScanColumnRefs</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>rel_remote</name><operator>-&gt;</operator><name>colrefs</name></name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_primary */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>idx_remote</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ybSetupScanQual</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>idx_remote</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_primary */</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ybSetupScanColumnRefs</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name><name>idx_remote</name><operator>-&gt;</operator><name>colrefs</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_primary */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		* Set the current syscatalog version (will check that we are up to date).
		* Avoid it for syscatalog tables so that we can still use this for
		* refreshing the caches when we are behind.
		* Note: This works because we do not allow modifying schemas (alter/drop)
		* for system catalog tables.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YbSetCatalogCacheVersion</name><argument_list>(
				<argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ybScan</name><operator>-&gt;</operator><name>quit_scan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>.</operator><name>hash_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>.</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>.</operator><name>sk_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ybScan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>heaptuple_matches_key</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
					  <parameter><decl><type><name>ScanKey</name></type> <name><name>keys</name><index>[]</index></name></decl></parameter>,
					  <parameter><decl><type><name>AttrNumber</name></type> <name><name>sk_attno</name><index>[]</index></name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sk_attno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>  <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>res_datum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>sk_attno</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * TODO: support the different search options like SK_SEARCHARRAY.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>matches</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>, <argument><expr><name>res_datum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matches</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>indextuple_matches_key</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>tup</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
					   <parameter><decl><type><name>ScanKey</name></type> <name><name>keys</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>AttrNumber</name></type> <name><name>sk_attno</name><index>[]</index></name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sk_attno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type>  <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>res_datum</name> <init>= <expr><call><name>index_getattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>sk_attno</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ScanKey</name></type> <name>key</name> <init>= <expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * TODO: support the different search options like SK_SEARCHARRAY.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>matches</name> <init>= <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
			<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>, <argument><expr><name>res_datum</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matches</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type> <name>ybc_getnext_heaptuple</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_forward_scan</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>nkeys</name>    <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name>    <modifier>*</modifier></type><name>keys</name>     <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sk_attno</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tup</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>quit_scan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * YB Scan may not be able to push down the scan key condition so we may
	 * need additional filtering here.
	 */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>ybcFetchNextHeapTuple</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>heaptuple_matches_key</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_desc</name></name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>sk_attno</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In case of yb_hash_code pushdown tuple must be rechecked */</comment>
			<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>|=</operator> <operator>(</operator><name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<return>return <expr><name>tup</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexTuple</name></type> <name>ybc_getnext_indextuple</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybScan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_forward_scan</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>nkeys</name>    <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name>    <modifier>*</modifier></type><name>keys</name>     <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>keys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sk_attno</name> <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>target_key_attnums</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>    <name>index</name>    <init>= <expr><name><name>ybScan</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>tup</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ybScan</name><operator>-&gt;</operator><name>quit_scan</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * YB Scan may not be able to push down the scan key condition so we may
	 * need additional filtering here.
	 */</comment>
	<while>while <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>ybcFetchNextIndexTuple</name><argument_list>(<argument><expr><name>ybScan</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>indextuple_matches_key</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>sk_attno</name></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* In case of pushdown yb_hash_code tuple must be rechecked */</comment>
			<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>|=</operator> <operator>(</operator><name><name>ybScan</name><operator>-&gt;</operator><name>nhash_keys</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<return>return <expr><name>tup</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ybc_free_ybscan</name><parameter_list>(<parameter><decl><type><name>YbScanDesc</name></type> <name>ybscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>ybscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name><name>ybscan</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ybscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SysScanDesc</name></type> <name>ybc_systable_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
                                   <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>indexOK</name></decl></parameter>,
                                   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
                                   <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up the index to scan with if we can. If the index is the primary key which is part
	 * of the table in YugaByte, we should scan the table directly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexOK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IgnoreSystemIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ReindexIsProcessingIndex</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>index</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Change attribute numbers to be index column numbers.
			 * - This conversion is the same as function systable_beginscan() in file "genam.c". If we
			 *   ever reuse Postgres index code, this conversion is a must because the key entries must
			 *   match what Postgres code expects.
			 *
			 * - When selecting using INDEX, the key values are bound to the IndexTable, so index attnum
			 *   must be used for bindings.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_attno</name> <operator>=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column is not in index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* In current context scan plan is not available */</comment>
	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name> <init>= <expr><call><name>ybcBeginScan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									 <argument><expr><name>index</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument> <comment type="block">/* xs_want_itup */</comment>,
									 <argument><expr><name>nkeys</name></expr></argument>,
									 <argument><expr><name>key</name></expr></argument>,
									 <argument><expr><name>pg_scan_plan</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rel_remote */</comment>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* idx_remote */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set up Postgres sys table scan description */</comment>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name> <init>= <expr><operator>(</operator><name>SysScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SysScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>heap_rel</name></name>   <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>snapshot</name></name>   <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name>     <operator>=</operator> <name>ybScan</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>index</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>scan_desc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type> <name>ybc_systable_getnext</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>recheck</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ybc_getnext_heaptuple</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_forward_scan */</comment>,
											<argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ybc_systable_endscan</name><parameter_list>(<parameter><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ybc_free_ybscan</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>HeapScanDesc</name></type> <name>ybc_heap_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
                                <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
                                <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>temp_snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Restart should not be prevented if operation caused by system read of system table. */</comment>
	<decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* In current context scan plan is not available */</comment>
	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name> <init>= <expr><call><name>ybcBeginScan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* index */</comment>,
									 <argument><expr><name>false</name></expr></argument> <comment type="block">/* xs_want_itup */</comment>,
									 <argument><expr><name>nkeys</name></expr></argument>,
									 <argument><expr><name>key</name></expr></argument>,
									 <argument><expr><name>pg_scan_plan</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* rel_remote */</comment>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* idx_remote */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set up Postgres sys table scan description */</comment>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_rd</name></name>        <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_snapshot</name></name>  <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_temp_snap</name></name> <operator>=</operator> <name>temp_snap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_cblock</name></name>    <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name>       <operator>=</operator> <name>ybScan</name></expr>;</expr_stmt>

	<return>return <expr><name>scan_desc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type> <name>ybc_heap_getnext</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>recheck</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>ybc_getnext_heaptuple</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* is_forward_scan */</comment>,
											<argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ybc_heap_endscan</name><parameter_list>(<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ybc_free_ybscan</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_temp_snap</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ybc_remote_beginscan
 *   Begin sequential scan of a YB relation.
 * The YbSeqScan uses it directly, not via heap scan interception, so it has
 * more controls on what is passed over to the ybcBeginScan.
 * The HeapScanDesc structure is still being used, in future we may increase
 * the level of integration.
 * The structure is compatible with one the ybc_heap_beginscan returns, so
 * ybc_heap_getnext and ybc_heap_endscan are respectively used to fetch tuples
 * and finish the scan.
 */</comment>
<function><type><name>HeapScanDesc</name></type>
<name>ybc_remote_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
					 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					 <parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>pg_scan_plan</name></decl></parameter>,
					 <parameter><decl><type><name>PushdownExprs</name> <modifier>*</modifier></type><name>remote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbScanDesc</name></type> <name>ybScan</name> <init>= <expr><call><name>ybcBeginScan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* index */</comment>,
									 <argument><expr><name>false</name></expr></argument> <comment type="block">/* xs_want_itup */</comment>,
									 <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nkeys */</comment>,
									 <argument><expr><name>NULL</name></expr></argument><comment type="block">/* key */</comment>,
									 <argument><expr><name>pg_scan_plan</name></expr></argument>,
									 <argument><expr><name>remote</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* idx_remote */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set up Postgres sys table scan description */</comment>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name> <init>= <expr><operator>(</operator><name>HeapScanDesc</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HeapScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_rd</name></name>        <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_snapshot</name></name>  <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_temp_snap</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>rs_cblock</name></name>    <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_desc</name><operator>-&gt;</operator><name>ybscan</name></name>       <operator>=</operator> <name>ybScan</name></expr>;</expr_stmt>

	<return>return <expr><name>scan_desc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------------------------------- */</comment>

<function><type><name>void</name></type> <name>ybcCostEstimate</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name></type> <name>selectivity</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>is_backwards_scan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_seq_scan</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>is_uncovered_idx_scan</name></decl></parameter>,
					 <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>index_tablespace_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>is_seq_scan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>enable_seqscan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>startup_cost</name> <operator>=</operator> <name>disable_cost</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Yugabyte-specific per-tuple cost considerations:
	 *   - 10x the regular CPU cost to account for network/RPC + DocDB overhead.
	 *   - backwards scan scale factor as it will need that many more fetches
	 *     to get all rows/tuples.
	 *   - uncovered index scan is more costly than index-only or seq scan because
	 *     it requires extra request to the main table.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>tsp_cost</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_valid_tsp_cost</name> <init>= <expr><operator>(</operator><operator>!</operator><name>is_uncovered_idx_scan</name>
							  <operator>&amp;&amp;</operator> <call><name>get_yb_tablespace_cost</name><argument_list>(<argument><expr><name>index_tablespace_oid</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>tsp_cost</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>yb_per_tuple_cost_factor</name> <init>= <expr><name>YB_DEFAULT_PER_TUPLE_COST</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_valid_tsp_cost</name> <operator>&amp;&amp;</operator> <name>yb_per_tuple_cost_factor</name> <operator>&gt;</operator> <name>tsp_cost</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>yb_per_tuple_cost_factor</name> <operator>=</operator> <name>tsp_cost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_valid_tsp_cost</name> <operator>||</operator> <name>tsp_cost</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_backwards_scan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>yb_per_tuple_cost_factor</name> <operator>*=</operator> <name>YBC_BACKWARDS_SCAN_COST_FACTOR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_uncovered_idx_scan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>yb_per_tuple_cost_factor</name> <operator>*=</operator> <name>YBC_UNCOVERED_INDEX_COST_FACTOR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Cost</name></type> <name>cost_per_tuple</name> <init>= <expr><name>cpu_tuple_cost</name> <operator>*</operator> <name>yb_per_tuple_cost_factor</name> <operator>+</operator>
	                      <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>startup_cost</name> <operator>+=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>total_cost</name>   <operator>=</operator> <operator>*</operator><name>startup_cost</name> <operator>+</operator> <name>cost_per_tuple</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <name>selectivity</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate the selectivity for yb_hash_code qualifiers.
 * Returns 1.0 if there are no yb_hash_code comparison expressions for this
 * index.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>ybcEvalHashSelectivity</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashed_qinfos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>greatest_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>greatest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>lowest_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lowest</name> <init>= <expr><name>USHRT_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>selectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type> <name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hashed_qinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexQualInfo</name> <modifier>*</modifier></type><name>qinfo</name> <init>= <expr><operator>(</operator><name>IndexQualInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><name><name>qinfo</name><operator>-&gt;</operator><name>rinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>qinfo</name><operator>-&gt;</operator><name>other_operand</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>strategy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>lefttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>righttype</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name><operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr></argument>,
								   <argument><expr><name>INTEGER_LSM_FAM_OID</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>signed_val</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator> <name><name>qinfo</name><operator>-&gt;</operator><name>other_operand</name></name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>signed_val</name> <operator>=</operator> <ternary><condition><expr><name>signed_val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>signed_val</name></expr></else></ternary></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name> <init>= <expr><ternary><condition><expr><name>signed_val</name> <operator>&gt;</operator> <name>USHRT_MAX</name></expr> ?</condition><then> <expr><name>USHRT_MAX</name></expr> </then><else>: <expr><name>signed_val</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The goal here is to calculate selectivity based on qualifiers.
		 *
		 * 1. yb_hash_code(hash_col) -- Single Key selectivity
		 * 2. yb_hash_code(hash_col) &gt;= ABC and yb_hash_code(hash_col) &lt;= XYZ
		 *    This specifically means that we return all the hash codes between
		 *    ABC and XYZ. YBCEvalHashValueSelectivity takes in ABC and XYZ as
		 *    arguments and finds the number of buckets to search to return what
		 *    is required. If it needs to search 16 buckets out of 48 buckets
		 *    then the selectivity is 0.33 which YBCEvalHashValueSelectivity
		 *    returns.
		 */</comment>
		<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name>greatest_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>greatest</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&gt;</operator> <name>greatest</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><name>greatest</name></expr></else></ternary></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case> <expr_stmt><expr><call><name>switch_fallthrough</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<expr_stmt><expr><name>lowest_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lowest</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&lt;</operator> <name>lowest</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><name>lowest</name></expr></else></ternary></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
				<return>return <expr><name>YBC_SINGLE_KEY_SELECTIVITY</name></expr>;</return>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>greatest</name> <operator>==</operator> <name>lowest</name> <operator>&amp;&amp;</operator> <name>greatest_set</name> <operator>&amp;&amp;</operator> <name>lowest_set</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>greatest_set</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>lowest_set</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>greatest</name> <operator>=</operator> <ternary><condition><expr><name>greatest_set</name></expr> ?</condition><then> <expr><name>greatest</name></expr> </then><else>: <expr><name>INT32_MAX</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>lowest</name> <operator>=</operator> <ternary><condition><expr><name>lowest_set</name></expr> ?</condition><then> <expr><name>lowest</name></expr> </then><else>: <expr><name>INT32_MIN</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>selectivity</name> <operator>=</operator> <call><name>YBCEvalHashValueSelectivity</name><argument_list>(<argument><expr><name>lowest</name></expr></argument>, <argument><expr><name>greatest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SELECTIVITY_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"yb_hash_code selectivity is %f"</literal></expr></argument>, <argument><expr><name>selectivity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>selectivity</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Evaluate the selectivity for some qualified cols given the hash and primary key cols.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> <name>ybcIndexEvalClauseSelectivity</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
											<parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>,
											<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>qual_cols</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>is_unique_idx</name></decl></parameter>,
                                            <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>hash_key</name></decl></parameter>,
                                            <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>primary_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If there is no search condition, or not all of the hash columns have
	 * search conditions, it will be a full-table scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>qual_cols</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>hash_key</name></expr></argument>, <argument><expr><name>qual_cols</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>YBC_FULL_SCAN_SELECTIVITY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, it will be either a primary key lookup or range scan
	 * on a hash key.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>primary_key</name></expr></argument>, <argument><expr><name>qual_cols</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For unique indexes full key guarantees single row. */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_unique_idx</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><operator>(</operator><name>reltuples</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>YBC_SINGLE_ROW_SELECTIVITY</name></expr> </then><else>:
									 <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <name>reltuples</name><operator>)</operator></expr></else></ternary></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>YBC_SINGLE_KEY_SELECTIVITY</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>YBC_HASH_SCAN_SELECTIVITY</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type> <name>ybc_get_attcollation</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ybcIndexCostEstimate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
						  <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>selectivity</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>startup_cost</name></decl></parameter>,
						  <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>total_cost</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isprimary</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><ternary><condition><expr><name>isprimary</name></expr> ?</condition><then> <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>qinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>is_backwards_scan</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>==</operator> <name>BackwardScanDirection</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>is_unique</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>is_partial_idx</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indpred</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>predOK</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>const_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashed_qinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> 		<name>baserel_rows_estimate</name></decl>;</decl_stmt>

	<comment type="block">/* Primary-index scans are always covered in Yugabyte (internally) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>       <name>is_uncovered_idx_scan</name> <init>= <expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>&amp;&amp;</operator>
	                                   <name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>!=</operator> <name>T_IndexOnlyScan</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>YbScanPlanData</name></type>	<name>scan_plan</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scan_plan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan_plan</name><operator>.</operator><name>target_relation</name></name> <operator>=</operator> <ternary><condition><expr><name>isprimary</name></expr> ?</condition><then> <expr><name>relation</name></expr> </then><else>: <expr><name>index</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ybcLoadTableInfo</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>.</operator><name>target_relation</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do preliminary analysis of indexquals */</comment>
	<expr_stmt><expr><name>qinfos</name> <operator>=</operator> <call><name>deconstruct_indexquals</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find out the search conditions on the primary key columns */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexQualInfo</name> <modifier>*</modifier></type><name>qinfo</name> <init>= <expr><operator>(</operator><name>IndexQualInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><name><name>qinfo</name><operator>-&gt;</operator><name>rinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	 <name>attnum</name> <init>= <expr><ternary><condition><expr><name>isprimary</name></expr> ?</condition><then> <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name><name>qinfo</name><operator>-&gt;</operator><name>indexcol</name></name></expr>]</index></name></expr>
										</then><else>: <expr><operator>(</operator><name><name>qinfo</name><operator>-&gt;</operator><name>indexcol</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bms_idx</name> <init>= <expr><call><name>YBAttnumToBmsIndex</name><argument_list>(<argument><expr><name><name>scan_plan</name><operator>.</operator><name>target_relation</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>const_quals</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>const_quals</name></expr></argument>, <argument><expr><name>bms_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ybcAddAttributeColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>	<name>clause_op</name> <init>= <expr><name><name>qinfo</name><operator>-&gt;</operator><name>clause_op</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ybcAddAttributeColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_plan</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>qinfo</name><operator>-&gt;</operator><name>other_operand</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>qinfo</name><operator>-&gt;</operator><name>other_operand</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>const_quals</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>const_quals</name></expr></argument>, <argument><expr><name>bms_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>qinfo</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hashed_qinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hashed_qinfos</name></expr></argument>, <argument><expr><name>qinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>hashed_qinfos</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>selectivity</name> <operator>=</operator> <call><name>ybcEvalHashSelectivity</name><argument_list>(<argument><expr><name>hashed_qinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>baserel_rows_estimate</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>selectivity</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yb_enable_optimizer_statistics</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>selectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument> <comment type="block">/* PlannerInfo */</comment>,
												<argument><expr><name>clauses</name></expr></argument>,
												<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument> <comment type="block">/* varrelid */</comment>,
												<argument><expr><name>JOIN_INNER</name></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* SpecialJoinInfo */</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>baserel_rows_estimate</name> <operator>=</operator> <ternary><condition><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>selectivity</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">1</literal></expr>
				?</condition><then> <expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>selectivity</name><operator>)</operator></expr>
				</then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>selectivity</name> <operator>=</operator> <call><name>ybcIndexEvalClauseSelectivity</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
														<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
														<argument><expr><name><name>scan_plan</name><operator>.</operator><name>sk_cols</name></name></expr></argument>,
														<argument><expr><name>is_unique</name></expr></argument>,
														<argument><expr><name><name>scan_plan</name><operator>.</operator><name>hash_key</name></name></expr></argument>,
														<argument><expr><name><name>scan_plan</name><operator>.</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>baserel_rows_estimate</name> <operator>=</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>selectivity</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>baserel_rows_estimate</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For partial indexes, scale down the rows to account for the predicate.
	 * Do this after setting the baserel rows since this does not apply to base rel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>yb_enable_optimizer_statistics</name> <operator>&amp;&amp;</operator> <name>is_partial_idx</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>selectivity</name> <operator>*=</operator> <name>YBC_PARTIAL_IDX_PRED_SELECTIVITY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ybcCostEstimate</name><argument_list>(<argument><expr><name>baserel</name></expr></argument>, <argument><expr><operator>*</operator><name>selectivity</name></expr></argument>, <argument><expr><name>is_backwards_scan</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument> <comment type="block">/* is_seq_scan */</comment>, <argument><expr><name>is_uncovered_idx_scan</name></expr></argument>,
					<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>,
					<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>yb_enable_optimizer_statistics</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to evaluate the number of rows this baserel might return.
		 * We cannot rely on the join conditions here (e.g. t1.c1 = t2.c2) because
		 * they may not be applied if another join path is chosen.
		 * So only use the t1.c1 = &lt;const_value&gt; quals (filtered above) for this.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type> <name>const_qual_selectivity</name> <init>= <expr><call><name>ybcIndexEvalClauseSelectivity</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
																	  <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
																	  <argument><expr><name>const_quals</name></expr></argument>,
																	  <argument><expr><name>is_unique</name></expr></argument>,
																	  <argument><expr><name><name>scan_plan</name><operator>.</operator><name>hash_key</name></name></expr></argument>,
																	  <argument><expr><name><name>scan_plan</name><operator>.</operator><name>primary_key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>baserel_rows_estimate</name> <operator>=</operator> <name>const_qual_selectivity</name> <operator>*</operator> <name><name>baserel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>baserel_rows_estimate</name> <operator>&lt;</operator> <name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>baserel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>baserel_rows_estimate</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>HeapTuple</name></type> <name>YBCFetchTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>ybc_stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>      <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewSelect</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>YbGetStorageRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* prepare_params */</comment>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>ybc_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bind ybctid to identify the current row. */</comment>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybctid_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>,
										   <argument><expr><name>BYTEAOID</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name>ybctid</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name>ybctid_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the scan targets. For index-based scan we need to return all "real" columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relhasoids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type>   <name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type>   <name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type>   <name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>,
									   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the select statement.
	 * This select statement fetch the row for a specific YBCTID, LIMIT setting is not needed.
	 */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* exec_params */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>      <name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name>           <modifier>*</modifier></type><name>values</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>            <modifier>*</modifier></type><name>nulls</name>  <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch one row. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>,
								 <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
								 <argument><expr><name>nulls</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>syscols</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>HTSU_Result</name></type>
<name>YBCLockTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>, <parameter><decl><type><name>RowMarkType</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>,
						 <parameter><decl><type><name>EState</name><modifier>*</modifier></type> <name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>wait_policy</name> <operator>==</operator> <name>LockWaitBlock</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>YBIsWaitQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * If wait-queues are not enabled, we default to the "Fail-on-Conflict" policy which is mapped
		 * to LockWaitError right now (see WaitPolicy proto for meaning of "Fail-on-Conflict" and the
		 * reason why LockWaitError is not mapped to no-wait semantics but to Fail-on-Conflict
		 * semantics).
		 */</comment>
		<expr_stmt><expr><name>wait_policy</name> <operator>=</operator> <name>LockWaitError</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>YBCPgStatement</name></type> <name>ybc_stmt</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewSelect</name><argument_list>(<argument><expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* prepare_params */</comment>,
								<argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>ybc_stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bind ybctid to identify the current row. */</comment>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type> <name>ybctid_expr</name> <init>= <expr><call><name>YBCNewConstant</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name>ybctid_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>YBCPgExecParameters</name></type> <name>exec_params</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>exec_params</name><operator>.</operator><name>limit_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_params</name><operator>.</operator><name>rowmark</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_params</name><operator>.</operator><name>wait_policy</name></name> <operator>=</operator> <name>wait_policy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exec_params</name><operator>.</operator><name>statement_in_txn_limit</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>yb_exec_params</name><operator>.</operator><name>statement_in_txn_limit</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HTSU_Result</name></type> <name>res</name> <init>= <expr><name>HeapTupleMayBeUpdated</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>exec_context</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Execute the select statement to lock the tuple with given ybctid.
		 */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exec_params</name></expr></argument> <comment type="block">/* exec_params */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Below is done to ensure the read request is flushed to tserver.
		 */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(
				<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(
						<argument><expr><name>ybc_stmt</name></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
						<argument><expr><name>nulls</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>YBCPgAddIntoForeignKeyReferenceCache</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>error_context</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>exec_context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ErrorData</name><modifier>*</modifier></type> <name>edata</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Error when trying to lock row. wait_policy=%d txn_errcode=%d message=%s"</literal></expr></argument>,
			 <argument><expr><name>wait_policy</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>YBCIsTxnConflictError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>HeapTupleUpdated</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>YBCIsTxnSkipLockingError</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>yb_txn_errcode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>HeapTupleWouldBlock</name></expr>;</expr_stmt></block_content></block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>error_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Discard the error if not rethrown */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name>ybc_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ANALYZE support: take random sample of a YB table data
 */</comment>

<function><type><name>YbSample</name></type>
<name>ybBeginSample</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservoirStateData</name></type> <name>rstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dboid</name> <init>= <expr><call><name>YBCGetDatabaseOid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbSample</name></type> <name>ybSample</name> <init>= <expr><operator>(</operator><name>YbSample</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>YbSampleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ybSample</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybSample</name><operator>-&gt;</operator><name>targrows</name></name> <operator>=</operator> <name>targrows</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybSample</name><operator>-&gt;</operator><name>liverows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ybSample</name><operator>-&gt;</operator><name>deadrows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create new sampler command
	 */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewSample</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>,
								  <argument><expr><name>relid</name></expr></argument>,
								  <argument><expr><name>targrows</name></expr></argument>,
								  <argument><expr><call><name>YBCIsRegionLocal</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the scan targets. We need to return all "real" columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relhasoids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
										   <argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name> <init>= <expr><block>{ <expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type>   <name>expr</name> <init>= <expr><call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
										   <argument><expr><name>attnum</name></expr></argument>,
										   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Initialize sampler random state
	 */</comment>
	<expr_stmt><expr><call><name>reservoir_init_selection_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstate</name></expr></argument>, <argument><expr><name>targrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgInitRandomState</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
										<argument><expr><name><name>rstate</name><operator>.</operator><name>W</name></name></expr></argument>,
										<argument><expr><call><name>SamplerRandomStateToUint64</name><argument_list>(<argument><expr><name><name>rstate</name><operator>.</operator><name>randstate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ybSample</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sequentially scan next block of YB table and select rows for the sample.
 * Block is a sequence of rows from one partition, up to specific number of
 * rows or the end of the partition.
 * Algorithm selects every scanned row until targrows are selected, then it
 * select random rows, with decreasing probability, to replace one of the
 * previously selected rows.
 * The IDs of selected rows are stored in the internal buffer (reservoir).
 * Scan ends and function returns false if one of two is true:
 *  - end of the table is reached
 *  or
 *  - targrows are selected and end of a table partition is reached.
 */</comment>
<function><type><name>bool</name></type>
<name>ybSampleNextBlock</name><parameter_list>(<parameter><decl><type><name>YbSample</name></type> <name>ybSample</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_more</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSampleNextBlock</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_more</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>has_more</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the rows selected for the sample into pre-allocated buffer.
 * Return number of rows fetched.
 */</comment>
<function><type><name>int</name></type>
<name>ybFetchSample</name><parameter_list>(<parameter><decl><type><name>YbSample</name></type> <name>ybSample</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name>  <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>numrows</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Execute equivalent of
	 *   SELECT * FROM table WHERE ybctid IN [yctid0, ybctid1, ...];
	 */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSample</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Retrieve liverows and deadrows counters.
	 * TODO: count deadrows
	 */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgGetEstimatedRowCount</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>ybSample</name><operator>-&gt;</operator><name>liverows</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>ybSample</name><operator>-&gt;</operator><name>deadrows</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>numrows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>numrows</name> <operator>&lt;</operator> <name><name>ybSample</name><operator>-&gt;</operator><name>targrows</name></name></expr>;</condition> <incr><expr><name>numrows</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>

		<comment type="block">/* Fetch one row. */</comment>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
									 <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
									 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
									 <argument><expr><name>nulls</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_data</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Make a heap tuple in current memory context */</comment>
		<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name></expr>]</index></name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name><name>rows</name><index>[<expr><name>numrows</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>syscols</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name></expr>]</index></name><operator>-&gt;</operator><name>t_ybctid</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rows</name><index>[<expr><name>numrows</name></expr>]</index></name><operator>-&gt;</operator><name>t_tableOid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Close the DocDB statement */</comment>
	<expr_stmt><expr><call><name>YBCPgDeleteStatement</name><argument_list>(<argument><expr><name><name>ybSample</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>numrows</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ybFetchNext
 *
 *  Fetch next row from the provided YBCPgStatement and load it into the slot.
 *
 * The statement must be ready to be fetched from, in other words it should be
 * executed, that means request is sent to the DocDB.
 *
 * Fetched values are copied from the DocDB response and memory for by-reference
 * data types is allocated from the current memory context, so be sure that
 * lifetime of that context is appropriate.
 *
 * By default the slot holds a virtual tuple, a heap tuple is only formed if
 * the DocDB returns oid. If heap tuple is formed, its t_tableOid field is
 * updated with provided relid and t_ybctid field is set to returned ybctid
 * value. The heap tuple is allocated in the slot's memory context.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ybFetchNext</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>,
			<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fetch one row. */</comment>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
								 <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
								 <argument><expr><name>nulls</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isempty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>syscols</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_ybctid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>
</unit>
