<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/gin/ginentrypage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginentrypage.c
 *	  routines for handling GIN entry tree pages.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/ginentrypage.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>entrySplitPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>origbuf</name></decl></parameter>,
			   <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name></decl></parameter>,
			   <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
			   <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Form a tuple for entry tree.
 *
 * If the tuple would be too big to be stored, function throws a suitable
 * error if errorTooBig is true, or returns NULL if errorTooBig is false.
 *
 * See src/backend/access/gin/README for a description of the index tuple
 * format that is being built here.  We build on the assumption that we
 * are making a leaf-level key entry containing a posting list of nipd items.
 * If the caller is actually trying to make a posting-tree entry, non-leaf
 * entry, or pending-list entry, it should pass dataSize = 0 and then overwrite
 * the t_tid fields as necessary.  In any case, 'data' can be NULL to skip
 * filling in the posting list; the caller is responsible for filling it
 * afterwards if data = NULL and nipd &gt; 0.
 */</comment>
<function><type><name>IndexTuple</name></type>
<name>GinFormTuple</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>category</name></decl></parameter>,
			 <parameter><decl><type><name>Pointer</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>dataSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nipd</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>errorTooBig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>datums</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>newsize</name></decl>;</decl_stmt>

	<comment type="block">/* Build the basic tuple: optional column number, plus key datum */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ginstate</name><operator>-&gt;</operator><name>oneCol</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>category</name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>datums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>category</name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>index_form_tuple</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>tupdesc</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>datums</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine and store offset to the posting list, making sure there is
	 * room for the category byte if needed.
	 *
	 * Note: because index_form_tuple MAXALIGNs the tuple size, there may well
	 * be some wasted pad space.  Is it worth recomputing the data length to
	 * prevent that?  That would also allow us to Assert that the real data
	 * doesn't overlap the GinNullCategory byte, which this code currently
	 * takes on faith.
	 */</comment>
	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>minsize</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>category</name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minsize</name> <operator>=</operator> <call><name>GinCategoryOffset</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ginstate</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinNullCategory</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>minsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinSetPostingOffset</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinSetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>nipd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add space needed for posting list, if any.  Then check that the tuple
	 * won't be too big to store.
	 */</comment>
	<expr_stmt><expr><name>newsize</name> <operator>+=</operator> <name>dataSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <name>GinMaxItemSize</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errorTooBig</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>newsize</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>GinMaxItemSize</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Resize tuple if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>!=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * PostgreSQL 9.3 and earlier did not clear this new space, so we
		 * might find uninitialized padding when reading tuples from disk.
		 */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itup</name> <operator>+</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newsize</name> <operator>-</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* set new size in tuple header */</comment>
		<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_SIZE_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy in the posting list, if provided
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>GinGetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>dataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Insert category byte, if needed
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>category</name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinSetNullCategory</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>itup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read item pointers from leaf entry tuple.
 *
 * Returns a palloc'd array of ItemPointers. The number of items is returned
 * in *nitems.
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>ginReadTuple</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name> <init>= <expr><call><name>GinGetPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nipd</name> <init>= <expr><call><name>GinGetNPosting</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ipd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndecoded</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinItupIsCompressed</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nipd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ipd</name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><operator>(</operator><name>GinPostingList</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndecoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nipd</name> <operator>!=</operator> <name>ndecoded</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of items mismatch in GIN entry tuple, %d in tuple header, %d decoded"</literal></expr></argument>,
					 <argument><expr><name>nipd</name></expr></argument>, <argument><expr><name>ndecoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ipd</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ipd</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nipd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ipd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nipd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>nitems</name> <operator>=</operator> <name>nipd</name></expr>;</expr_stmt>
	<return>return <expr><name>ipd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Form a non-leaf entry tuple by copying the key data from the given tuple,
 * which can be either a leaf or non-leaf entry tuple.
 *
 * Any posting list in the source tuple is not copied.  The specified child
 * block number is inserted into t_tid.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>GinFormInteriorTuple</name><parameter_list>(<parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>childblk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>nitup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GinIsPostingTree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Tuple contains a posting list, just copy stuff before that */</comment>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>origsize</name> <init>= <expr><call><name>GinGetPostingOffset</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>origsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>origsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>origsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nitup</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>origsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... be sure to fix the size header field ... */</comment>
		<expr_stmt><expr><name><name>nitup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>&amp;=</operator> <operator>~</operator><name>INDEX_SIZE_MASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nitup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>|=</operator> <name>origsize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Copy the tuple as-is */</comment>
		<expr_stmt><expr><name>nitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nitup</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Now insert the correct downlink */</comment>
	<expr_stmt><expr><call><name>GinSetDownlink</name><argument_list>(<argument><expr><name>nitup</name></expr></argument>, <argument><expr><name>childblk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nitup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Entry tree is a "static", ie tuple never deletes from it,
 * so we don't use right bound, we use rightmost key instead.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>getRightMostTuple</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>entryIsMoveRight</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>getRightMostTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ginCompareAttEntries</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
							 <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryAttnum</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryKey</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryCategory</name></name></expr></argument>,
							 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find correct tuple in non-leaf page. It supposed that
 * page correctly chosen and searching value SHOULD be on page
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>entryLocateEntry</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>low</name></decl>,
				<decl><type ref="prev"/><name>high</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>predictNumber</name></name> <operator>*=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name><name>btree</name><operator>-&gt;</operator><name>getLeftMostChild</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>high</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;=</operator> <name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>high</name><operator>++</operator></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>mid</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>maxoff</name> <operator>&amp;&amp;</operator> <call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Right infinity */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ginCompareAttEntries</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
										  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryAttnum</name></name></expr></argument>,
										  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryKey</name></name></expr></argument>,
										  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryCategory</name></name></expr></argument>,
										  <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GIN_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>high</name> <operator>&lt;=</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>high</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GIN_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Searches correct position for value on leaf page.
 * Page should be correctly chosen.
 * Returns true if value found on page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>entryLocateLeafEntry</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>low</name></decl>,
				<decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>high</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>high</name> <operator>&lt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>high</name><operator>++</operator></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>mid</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GinNullCategory</name></type> <name>category</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>gintuple_get_attrnum</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>gintuple_get_key</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ginCompareAttEntries</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name></expr></argument>,
									  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryAttnum</name></name></expr></argument>,
									  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryKey</name></name></expr></argument>,
									  <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>entryCategory</name></name></expr></argument>,
									  <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>high</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>entryFindChildPtr</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>storedOff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if page isn't changed, we returns storedOff */</comment>
	<if_stmt><if>if <condition>(<expr><name>storedOff</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>storedOff</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>storedOff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>storedOff</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * we hope, that needed pointer goes to right. It's true if there
		 * wasn't a deletion
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>storedOff</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>storedOff</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* last chance */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>entryGetLeftMostPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>GinGetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>entryIsEnoughSpace</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
				   <parameter><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>releasedsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>addedsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>insertData</name><operator>-&gt;</operator><name>isDelete</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>releasedsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>addedsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>releasedsz</name> <operator>&gt;=</operator> <name>addedsz</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete tuple on leaf page if tuples existed and we
 * should update it, update old child blkno to new right page
 * if child split occurred
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>entryPreparePage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>off</name></decl></parameter>,
				 <parameter><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>insertData</name><operator>-&gt;</operator><name>isDelete</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>updateblkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GinSetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to insert data on an entry page.
 *
 * If it will fit, return GPTP_INSERT after doing whatever setup is needed
 * before we enter the insertion critical section.  *ptp_workspace can be
 * set to pass information along to the execPlaceToPage function.
 *
 * If it won't fit, perform a page split and return two temporary page
 * images into *newlpage and *newrpage, with result GPTP_SPLIT.
 *
 * In neither case should the given page buffer be modified here.
 *
 * Note: on insertion to an internal node, in addition to inserting the given
 * item, the downlink of the existing item at stack-&gt;off will be updated to
 * point to updateblkno.
 */</comment>
<function><type><specifier>static</specifier> <name>GinPlaceToPageRC</name></type>
<name>entryBeginPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertPayload</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>,
					  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name> <init>= <expr><name>insertPayload</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If it doesn't fit, deal with split case */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>entryIsEnoughSpace</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>insertData</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>entrySplitPage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>insertData</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>,
					   <argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>GPTP_SPLIT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else, we're ready to proceed with insertion */</comment>
	<return>return <expr><name>GPTP_INSERT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform data insertion after beginPlaceToPage has decided it will fit.
 *
 * This is invoked within a critical section, and XLOG record creation (if
 * needed) is already started.  The target buffer is registered in slot 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>entryExecPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertPayload</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name> <init>= <expr><name>insertPayload</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>placed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>entryPreparePage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>insertData</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>placed</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>,
						 <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>placed</name> <operator>!=</operator> <name>off</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This must be static, because it has to survive until XLogInsert,
		 * and we can't palloc here.  Ugly, but the XLogInsert infrastructure
		 * isn't reentrant anyway.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>ginxlogInsertEntry</name></type> <name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>isDelete</name></name> <operator>=</operator> <name><name>insertData</name><operator>-&gt;</operator><name>isDelete</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>,
							<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ginxlogInsertEntry</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>,
							<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split entry page and insert new data.
 *
 * Returns new temp pages to *newlpage and *newrpage.
 * The original buffer is left untouched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>entrySplitPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>origbuf</name></decl></parameter>,
			   <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name></decl></parameter>,
			   <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
			   <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>separator</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>totalsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>lsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name> <init>= <expr><call><name>PageGetTempPageCopy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>origbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rpage</name> <init>= <expr><call><name>PageGetTempPageCopy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>origbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name> <init>= <expr><call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name><name>tupstore</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* could need 2 pages' worth of tuples */</comment>

	<expr_stmt><expr><call><name>entryPreparePage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>insertData</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, append all the existing tuples and the new tuple we're inserting
	 * one after another in a temporary workspace.
	 */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>tupstore</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>off</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalsize</name> <operator>+=</operator> <name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize the left and right pages, and copy all the tuples back to
	 * them.
	 */</comment>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>tupstore</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>data</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>lsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <name>lpage</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Decide where to split.  We try to equalize the pages' total data
		 * size, not number of tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lsize</name> <operator>&gt;</operator> <name>totalsize</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>separator</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>separator</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <name>rpage</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>lsize</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* return temp pages to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>newlpage</name> <operator>=</operator> <name>lpage</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>newrpage</name> <operator>=</operator> <name>rpage</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct insertion payload for inserting the downlink for given buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>entryPrepareDownlink</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeEntryInsertData</name> <modifier>*</modifier></type><name>insertData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lblkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>getRightMostTuple</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>insertData</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeEntryInsertData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertData</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>GinFormInteriorTuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>lblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertData</name><operator>-&gt;</operator><name>isDelete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>insertData</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fills new root by rightest values from child.
 * Also called from ginxlog, should not use btree
 */</comment>
<function><type><name>void</name></type>
<name>ginEntryFillRoot</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>root</name></decl></parameter>,
				 <parameter><decl><type><name>BlockNumber</name></type> <name>lblkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>lpage</name></decl></parameter>,
				 <parameter><decl><type><name>BlockNumber</name></type> <name>rblkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>rpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>GinFormInteriorTuple</name><argument_list>(<argument><expr><call><name>getRightMostTuple</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>lblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index root page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>GinFormInteriorTuple</name><argument_list>(<argument><expr><call><name>getRightMostTuple</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>rblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index root page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up GinBtree for entry page access
 *
 * Note: during WAL recovery, there may be no valid data in ginstate
 * other than a faked-up Relation pointer; the key datum is bogus too.
 */</comment>
<function><type><name>void</name></type>
<name>ginPrepareEntryScan</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>GinNullCategory</name></type> <name>category</name></decl></parameter>,
					<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>ginstate</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name> <operator>=</operator> <name>GIN_ROOT_BLKNO</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>ginstate</name></name> <operator>=</operator> <name>ginstate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findChildPage</name></name> <operator>=</operator> <name>entryLocateEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>getLeftMostChild</name></name> <operator>=</operator> <name>entryGetLeftMostPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isMoveRight</name></name> <operator>=</operator> <name>entryIsMoveRight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findItem</name></name> <operator>=</operator> <name>entryLocateLeafEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findChildPtr</name></name> <operator>=</operator> <name>entryFindChildPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>beginPlaceToPage</name></name> <operator>=</operator> <name>entryBeginPlaceToPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>execPlaceToPage</name></name> <operator>=</operator> <name>entryExecPlaceToPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>fillRoot</name></name> <operator>=</operator> <name>ginEntryFillRoot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>prepareDownlink</name></name> <operator>=</operator> <name>entryPrepareDownlink</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isData</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>entryAttnum</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>entryKey</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>entryCategory</name></name> <operator>=</operator> <name>category</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
