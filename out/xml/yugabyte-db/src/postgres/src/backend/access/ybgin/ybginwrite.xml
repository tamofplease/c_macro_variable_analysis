<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/ybgin/ybginwrite.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ybginwrite.c
 *	  insert and delete routines for the Yugabyte inverted index access method.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *			src/backend/access/ybgin/ybginwrite.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ybgin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/yb_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/ybcModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/off.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Parts copied from GinBuildState.  Differences:
 * - no buildStats because those are tied to postgres storage
 * - no tmpCtx because that's tied to bulk inserts, which we won't do because
 *   it seems to be particularly beneficial for postgres btrees and not for
 *   Yugabyte DocDB
 * - no accum for the same reason
 * - add backfilltime to both indicate that the build is for online index
 *   backfill and specify the write time for it
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>GinState</name></type>	<name>ginstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indtuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>funcCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name>   <modifier>*</modifier></type><name>backfilltime</name></decl>;</decl_stmt>
}</block></struct></type> <name>YbginBuildState</name>;</typedef>

<comment type="block">/*
 * Utility method to create constant.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>newConstant</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>stmt</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>,
			<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>,
			<parameter><decl><type><name>YBCPgExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>YBCPgTypeEntity</name> <modifier>*</modifier></type><name>type_entity</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type_entity</name> <operator>=</operator> <operator>&amp;</operator><name>YBCGinNullTypeEntity</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>type_entity</name> <operator>=</operator> <call><name>YbDataTypeFromOidMod</name><argument_list>(<argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<decl_stmt><decl><type><name>YBCPgCollationInfo</name></type> <name>collation_info</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>YBGetCollationInfo</name><argument_list>(<argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>type_entity</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>collation_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgNewConstant</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>type_entity</name></expr></argument>,
									<argument><expr><name><name>collation_info</name><operator>.</operator><name>collate_is_valid_non_c</name></name></expr></argument>,
									<argument><expr><name><name>collation_info</name><operator>.</operator><name>sortkey</name></name></expr></argument>,
									<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to bind const to column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bindColumn</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>stmt</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>attr_num</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>,
		   <parameter><decl><type><name>Oid</name></type> <name>collation_id</name></decl></parameter>,
		   <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>newConstant</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attr_num</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Utility method to set binds for index write statement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doBindsForIdxWrite</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>stmt</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexstate</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>n_bound_atts</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>ybbasectid</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>ybctid_as_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>(</operator><name>GinState</name> <operator>*</operator><operator>)</operator> <name>indexstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ybbasectid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing base table ybctid in index write request"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>n_bound_atts</name></expr>;</condition> <incr><expr><operator>++</operator><name>attnum</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>type_id</name> <init>= <expr><call><name>GetTypeId</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collation_id</name> <init>= <expr><call><name>YBEncodingCollation</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
													   <argument><expr><name><name>ginstate</name><operator>-&gt;</operator><name>supportCollation</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name>   <init>= <expr><name><name>values</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name> <init>= <expr><name><name>isnull</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>bindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>collation_id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Gin indexes cannot be unique. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indisunique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write base ctid column because it is a key column. */</comment>
	<expr_stmt><expr><call><name>bindColumn</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>,
			   <argument><expr><name>YBIdxBaseTupleIdAttributeNumber</name></expr></argument>,
			   <argument><expr><name>BYTEAOID</name></expr></argument>,
			   <argument><expr><name>InvalidOid</name></expr></argument>,
			   <argument><expr><name>ybbasectid</name></expr></argument>,
			   <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract entries and write values.
 *
 * The first part here is identical to first part of ginHeapTupleInsert.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>ybginTupleWrite</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>backfilltime</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>isinsert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinNullCategory</name> <modifier>*</modifier></type><name>categories</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>,
				<decl><type ref="prev"/><name>nentries</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>ginExtractEntries</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>nentries</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>categories</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure that this is a single-column index. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name><name>categories</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Pass the null category down using the spot where the data usually
		 * goes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>categories</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>categories</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Assume single-column index for parameters values and isnull. */</comment>
		<if_stmt><if>if <condition>(<expr><name>isinsert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>YBCExecuteInsertIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
								  <argument><expr><name>backfilltime</name></expr></argument> <comment type="block">/* backfill_write_time */</comment>,
								  <argument><expr><name>doBindsForIdxWrite</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ginstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>backfilltime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>YBCExecuteDeleteIndex</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
								  <argument><expr><name>doBindsForIdxWrite</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ginstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>nentries</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert index entries for a single indexable item during "normal"
 * (non-fast-update) insertion
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>ybginTupleInsert</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>backfilltime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ybginTupleWrite</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
						   <argument><expr><name>backfilltime</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* isinsert */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Delete index entries for a single indexable item during "normal"
 * (non-fast-update) insertion
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>ybginTupleDelete</name><parameter_list>(<parameter><decl><type><name>GinState</name> <modifier>*</modifier></type><name>ginstate</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>attnum</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ybginTupleWrite</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* backfilltime */</comment>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* isinsert */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to insert index tuples after a base table tuple is retrieved.  See
 * similar ybcinbuildCallback.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginBuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbginBuildState</name> <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>YbginBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>&amp;</operator><name><name>buildstate</name><operator>-&gt;</operator><name>ginstate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nentries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ginstate</name><operator>-&gt;</operator><name>origTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nentries</name> <operator>+=</operator> <call><name>ybginTupleInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
									 <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr></argument>,
									 <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>backfilltime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <name>nentries</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build code for both ybginbuild and ybginbackfill.
 *
 * Parts copied from ginbuild.  Differences are
 * - don't deal with postgres storage (e.g. buffers, pages, tmpCtx)
 * - additionally pass through backfill parameters
 * - name memory context Ybgin
 */</comment>
<function><type><specifier>static</specifier> <name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ybginBuildCommon</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
				 <parameter><decl><type><name><name>struct</name> <name>YbBackfillInfo</name></name> <modifier>*</modifier></type><name>bfinfo</name></decl></parameter>,
				 <parameter><decl><type><name><name>struct</name> <name>YbPgExecOutParam</name></name> <modifier>*</modifier></type><name>bfresult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buildstate</name><operator>.</operator><name>ginstate</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bfinfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>backfilltime</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>bfinfo</name><operator>-&gt;</operator><name>read_time</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>backfilltime</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * create a temporary memory context that is used for calling
	 * ginExtractEntries(), and can be reset after each tuple
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>funcCtx</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
											   <argument><expr><literal type="string">"Ybgin build temporary context for user-defined function"</literal></expr></argument>,
											   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the heap scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bfinfo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>IndexBuildHeapScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									   <argument><expr><name>ybginBuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* HeapScanDesc */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>IndexBackfillHeapRangeScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
											   <argument><expr><name>ybginBuildCallback</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>,
											   <argument><expr><name>bfinfo</name></expr></argument>,
											   <argument><expr><name>bfresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>funcCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ybginbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ybginBuildCommon</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* bfinfo */</comment>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* bfresult */</comment>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybginbuildempty</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected building of empty unlogged index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>ybginbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
				<parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected bulk delete of index via vacuum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>ybginvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>YBC_LOG_WARNING</name><argument_list>(<argument><expr><literal type="string">"Unexpected index cleanup via vacuum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write code for both ybgininsert and ybgindelete.
 *
 * Parts copied from gininsert.  Differences are
 * - don't copy fastupdate code since it's not supported
 * - additionally handle deletes
 * - name memory context Ybgin
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginWrite</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
		   <parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isinsert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinState</name>   <modifier>*</modifier></type><name>ginstate</name> <init>= <expr><operator>(</operator><name>GinState</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>writeCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize GinState cache if first call in this statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>ginstate</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ginstate</name> <operator>=</operator> <operator>(</operator><name>GinState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initGinState</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ginstate</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>writeCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><literal type="string">"Ybgin write temporary context"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>writeCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinGetUseFastUpdate</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fast update is not yet supported for ybgin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ginstate</name><operator>-&gt;</operator><name>origTupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isinsert</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ybginTupleInsert</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
							 <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* backfilltime */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ybginTupleDelete</name><argument_list>(<argument><expr><name>ginstate</name></expr></argument>, <argument><expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
							 <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><name>ybctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>writeCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ybgininsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
			<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>,
			<parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared_insert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ybginWrite</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
			   <argument><expr><name>true</name></expr></argument> <comment type="block">/* isinsert */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* index cannot be unique */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ybgindelete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>ybctid</name></decl></parameter>,
			<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ybginWrite</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>ybctid</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
			   <argument><expr><name>false</name></expr></argument> <comment type="block">/* isinsert */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>ybginbackfill</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>IndexInfo</name></name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			  <parameter><decl><type><name><name>struct</name> <name>YbBackfillInfo</name></name> <modifier>*</modifier></type><name>bfinfo</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>YbPgExecOutParam</name></name> <modifier>*</modifier></type><name>bfresult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ybginBuildCommon</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>bfinfo</name></expr></argument>, <argument><expr><name>bfresult</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
