<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/gin/ginpostinglist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginpostinglist.c
 *	  routines for dealing with posting lists.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/ginpostinglist.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ENCODING_ROUNDTRIP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * For encoding purposes, item pointers are represented as 64-bit unsigned
 * integers. The lowest 11 bits represent the offset number, and the next
 * lowest 32 bits are the block number. That leaves 17 bits unused, i.e.
 * only 43 low bits are used.
 *
 * These 43-bit integers are encoded using varbyte encoding. In each byte,
 * the 7 low bits contain data, while the highest bit is a continuation bit.
 * When the continuation bit is set, the next byte is part of the same
 * integer, otherwise this is the last byte of this integer.  43 bits fit
 * conveniently in at most 6 bytes when varbyte encoded (the 6th byte does
 * not need a continuation bit, because we know the max size to be 43 bits):
 *
 * 0XXXXXXX
 * 1XXXXXXX 0XXXXYYY
 * 1XXXXXXX 1XXXXYYY 0YYYYYYY
 * 1XXXXXXX 1XXXXYYY 1YYYYYYY 0YYYYYYY
 * 1XXXXXXX 1XXXXYYY 1YYYYYYY 1YYYYYYY 0YYYYYYY
 * 1XXXXXXX 1XXXXYYY 1YYYYYYY 1YYYYYYY 1YYYYYYY YYYYYYYY
 *
 * X = bits used for offset number
 * Y = bits used for block number
 *
 * The bytes are in stored in little-endian order.
 *
 * An important property of this encoding is that removing an item from list
 * never increases the size of the resulting compressed posting list. Proof:
 *
 * Removing number is actually replacement of two numbers with their sum. We
 * have to prove that varbyte encoding of a sum can't be longer than varbyte
 * encoding of its summands. Sum of two numbers is at most one bit wider than
 * the larger of the summands. Widening a number by one bit enlarges its length
 * in varbyte encoding by at most one byte. Therefore, varbyte encoding of sum
 * is at most one byte longer than varbyte encoding of larger summand. Lesser
 * summand is at least one byte, so the sum cannot take more space than the
 * summands, Q.E.D.
 *
 * This property greatly simplifies VACUUM, which can assume that posting
 * lists always fit on the same page after vacuuming. Note that even though
 * that holds for removing items from a posting list, you must also be
 * careful to not cause expansion e.g. when merging uncompressed items on the
 * page into the compressed lists, when vacuuming.
 */</comment>

<comment type="block">/*
 * How many bits do you need to encode offset number? OffsetNumber is a 16-bit
 * integer, but you can't fit that many items on a page. 11 ought to be more
 * than enough. It's tempting to derive this from MaxHeapTuplesPerPage, and
 * use the minimum number of bits, but that would require changing the on-disk
 * format if MaxHeapTuplesPerPage changes. Better to leave some slack.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MaxHeapTuplesPerPageBits</name></cpp:macro>		<cpp:value>11</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>itemptr_to_uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ItemPointer</name></type> <name>iptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>MaxHeapTuplesPerPageBits</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>GinItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <name>MaxHeapTuplesPerPageBits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>|=</operator> <call><name>GinItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>uint64_to_itemptr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>iptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>GinItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>, <argument><expr><name>val</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>MaxHeapTuplesPerPageBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>&gt;&gt;</operator> <name>MaxHeapTuplesPerPageBits</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinItemPointerSetBlockNumber</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><name>iptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Varbyte-encode 'val' into *ptr. *ptr is incremented to next integer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>encode_varbyte</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>val</name> <operator>&gt;</operator> <literal type="number">0x7F</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode varbyte-encoded integer at *ptr. *ptr is incremented to next integer.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>decode_varbyte</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">21</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">28</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">35</literal></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* last byte, no continuation bit */</comment>
							<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>p</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
							<expr_stmt><expr><name>val</name> <operator>|=</operator> <name>c</name> <operator>&lt;&lt;</operator> <literal type="number">42</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Encode a posting list.
 *
 * The encoded list is returned in a palloc'd struct, which will be at most
 * 'maxsize' bytes in size.  The number items in the returned segment is
 * returned in *nwritten. If it's not equal to nipd, not all the items fit
 * in 'maxsize', and only the first *nwritten were encoded.
 *
 * The allocated size of the returned struct is short-aligned, and the padding
 * byte at the end, if any, is zero.
 */</comment>
<function><type><name>GinPostingList</name> <modifier>*</modifier></type>
<name>ginCompressPostingList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ItemPointer</name></type> <name>ipd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nipd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nwritten</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalpacked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxsize</name> <operator>=</operator> <call><name>SHORTALIGN_DOWN</name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxbytes</name> <operator>=</operator> <name>maxsize</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>GinPostingList</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the first special item */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>ipd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>itemptr_to_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <name>maxbytes</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>totalpacked</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>totalpacked</name> <operator>&lt;</operator> <name>nipd</name></expr>;</condition> <incr><expr><name>totalpacked</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name> <init>= <expr><call><name>itemptr_to_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ipd</name><index>[<expr><name>totalpacked</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>delta</name> <init>= <expr><name>val</name> <operator>-</operator> <name>prev</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>encode_varbyte</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * There are less than 6 bytes left. Have to check if the next
			 * item fits in that space before writing it out.
			 */</comment>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>encode_varbyte</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>buf</name> <operator>&gt;</operator> <operator>(</operator><name>endptr</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* output is full */</comment>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we wrote an odd number of bytes, zero out the padding byte at the
	 * end.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>!=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>bytes</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>nbytes</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nwritten</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>nwritten</name> <operator>=</operator> <name>totalpacked</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that the encoded segment decodes back to the original items.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>CHECK_ENCODING_ROUNDTRIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndecoded</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tmp</name> <init>= <expr><call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndecoded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndecoded</name> <operator>==</operator> <name>totalpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndecoded</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ipd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decode a compressed posting list into an array of item pointers.
 * The number of items is returned in *ndecoded.
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>ginPostingListDecode</name><parameter_list>(<parameter><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndecoded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ginPostingListDecodeAllSegments</name><argument_list>(<argument><expr><name>plist</name></expr></argument>,
										   <argument><expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>ndecoded</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decode multiple posting list segments into an array of item pointers.
 * The number of items is returned in *ndecoded_out. The segments are stored
 * one after each other, with total size 'len' bytes.
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>ginPostingListDecodeAllSegments</name><parameter_list>(<parameter><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ndecoded_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nallocated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endseg</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>segment</name><operator>)</operator> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndecoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Guess an initial size of the array.
	 */</comment>
	<expr_stmt><expr><name>nallocated</name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nallocated</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndecoded</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>segment</name> <operator>&lt;</operator> <name>endseg</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* enlarge output array if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>ndecoded</name> <operator>&gt;=</operator> <name>nallocated</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nallocated</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nallocated</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* copy the first item */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segment</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndecoded</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segment</name><operator>-&gt;</operator><name>first</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>ndecoded</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>ndecoded</name></expr>]</index></name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndecoded</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>itemptr_to_uint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segment</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>bytes</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <name><name>segment</name><operator>-&gt;</operator><name>nbytes</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* enlarge output array if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>ndecoded</name> <operator>&gt;=</operator> <name>nallocated</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nallocated</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nallocated</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>val</name> <operator>+=</operator> <call><name>decode_varbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>uint64_to_itemptr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>ndecoded</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ndecoded</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>GinNextPostingListSegment</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>ndecoded_out</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ndecoded_out</name> <operator>=</operator> <name>ndecoded</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add all item pointers from a bunch of posting lists to a TIDBitmap.
 */</comment>
<function><type><name>int</name></type>
<name>ginPostingListDecodeAllSegmentsToTbm</name><parameter_list>(<parameter><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
									 <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndecoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>items</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>ginPostingListDecodeAllSegments</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ndecoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>ndecoded</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ndecoded</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Merge two ordered arrays of itempointers, eliminating any duplicates.
 *
 * Returns a palloc'd array, and *nmerged is set to the number of items in
 * the result, after eliminating duplicates.
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>ginMergeItemPointers</name><parameter_list>(<parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>na</name></decl></parameter>,
					 <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nb</name></decl></parameter>,
					 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nmerged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>na</name> <operator>+</operator> <name>nb</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the argument arrays don't overlap, we can just append them to each
	 * other.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>na</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>nb</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>na</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>na</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><index>[<expr><name>na</name></expr>]</index></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>nb</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nmerged</name> <operator>=</operator> <name>na</name> <operator>+</operator> <name>nb</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><index>[<expr><name>nb</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>nb</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dst</name><index>[<expr><name>nb</name></expr>]</index></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>na</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>nmerged</name> <operator>=</operator> <name>na</name> <operator>+</operator> <name>nb</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>dptr</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>aptr</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>bptr</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>aptr</name> <operator>-</operator> <name>a</name> <operator>&lt;</operator> <name>na</name> <operator>&amp;&amp;</operator> <name>bptr</name> <operator>-</operator> <name>b</name> <operator>&lt;</operator> <name>nb</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>bptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* only keep one copy of the identical items */</comment>
				<expr_stmt><expr><operator>*</operator><name>dptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>bptr</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>aptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>aptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><name>aptr</name> <operator>-</operator> <name>a</name> <operator>&lt;</operator> <name>na</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>dptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>aptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<while>while <condition>(<expr><name>bptr</name> <operator>-</operator> <name>b</name> <operator>&lt;</operator> <name>nb</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>dptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>bptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><operator>*</operator><name>nmerged</name> <operator>=</operator> <name>dptr</name> <operator>-</operator> <name>dst</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>
</unit>
