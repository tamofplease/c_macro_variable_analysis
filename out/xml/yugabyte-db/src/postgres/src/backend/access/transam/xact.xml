<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/xact.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xact.c
 *	  top level transaction system support routines
 *
 * See src/backend/access/transam/README for more information.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/transam/xact.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/be-fsstubs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logical.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relmapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pg_typedefs.h"</cpp:file></cpp:include>

<comment type="block">/*
 *	User-tweakable parameters
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>DefaultXactIsoLevel</name> <init>= <expr><name>XACT_READ_COMMITTED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>XactIsoLevel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>DefaultXactReadOnly</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>XactReadOnly</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>DefaultXactDeferrable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>XactDeferrable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>synchronous_commit</name> <init>= <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * When running as a parallel worker, we place only a single
 * TransactionStateData on the parallel worker's state stack, and the XID
 * reflected there will be that of the *innermost* currently-active
 * subtransaction in the backend that initiated parallelism.  However,
 * GetTopTransactionId() and TransactionIdIsCurrentTransactionId()
 * need to return the same answers in the parallel worker as they would have
 * in the user backend, so we need some additional bookkeeping.
 *
 * XactTopTransactionId stores the XID of our toplevel transaction, which
 * will be the same as TopTransactionState.transactionId in an ordinary
 * backend; but in a parallel backend, which does not have the entire
 * transaction state, it will instead be copied from the backend that started
 * the parallel operation.
 *
 * nParallelCurrentXids will be 0 and ParallelCurrentXids NULL in an ordinary
 * backend, but in a parallel backend, nParallelCurrentXids will contain the
 * number of XIDs that need to be considered current, and ParallelCurrentXids
 * will contain the XIDs themselves.  This includes all XIDs that were current
 * or sub-committed in the parent at the time the parallel operation began.
 * The XIDs are stored sorted in numerical order (not logical order) to make
 * lookups as fast as possible.
 */</comment>
<decl_stmt><decl><type><name>TransactionId</name></type> <name>XactTopTransactionId</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>nParallelCurrentXids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>ParallelCurrentXids</name></decl>;</decl_stmt>

<comment type="block">/*
 * Miscellaneous flag bits to record events which occur on the top level
 * transaction. These flags are only persisted in MyXactFlags and are intended
 * so we remember to do certain things later on in the transaction. This is
 * globally accessible, so can be set from anywhere in the code that requires
 * recording flags.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>MyXactFlags</name></decl>;</decl_stmt>

<comment type="block">/*
 *	transaction states - transaction state from server perspective
 */</comment>
<typedef>typedef <type><enum>enum <name>TransState</name>
<block>{
	<decl><name>TRANS_DEFAULT</name></decl>,				<comment type="block">/* idle */</comment>
	<decl><name>TRANS_START</name></decl>,				<comment type="block">/* transaction starting */</comment>
	<decl><name>TRANS_INPROGRESS</name></decl>,			<comment type="block">/* inside a valid transaction */</comment>
	<decl><name>TRANS_COMMIT</name></decl>,				<comment type="block">/* commit in progress */</comment>
	<decl><name>TRANS_ABORT</name></decl>,				<comment type="block">/* abort in progress */</comment>
	<decl><name>TRANS_PREPARE</name></decl>				<comment type="block">/* prepare in progress */</comment>
}</block></enum></type> <name>TransState</name>;</typedef>

<comment type="block">/*
 *	transaction block states - transaction state of client queries
 *
 * Note: the subtransaction states are used only for non-topmost
 * transactions; the others appear only in the topmost transaction.
 */</comment>
<typedef>typedef <type><enum>enum <name>TBlockState</name>
<block>{
	<comment type="block">/* not-in-transaction-block states */</comment>
	<decl><name>TBLOCK_DEFAULT</name></decl>,				<comment type="block">/* idle */</comment>
	<decl><name>TBLOCK_STARTED</name></decl>,				<comment type="block">/* running single-query transaction */</comment>

	<comment type="block">/* transaction block states */</comment>
	<decl><name>TBLOCK_BEGIN</name></decl>,				<comment type="block">/* starting transaction block */</comment>
	<decl><name>TBLOCK_INPROGRESS</name></decl>,			<comment type="block">/* live transaction */</comment>
	<decl><name>TBLOCK_IMPLICIT_INPROGRESS</name></decl>, <comment type="block">/* live transaction after implicit BEGIN */</comment>
	<decl><name>TBLOCK_PARALLEL_INPROGRESS</name></decl>, <comment type="block">/* live transaction inside parallel worker */</comment>
	<decl><name>TBLOCK_END</name></decl>,					<comment type="block">/* COMMIT received */</comment>
	<decl><name>TBLOCK_ABORT</name></decl>,				<comment type="block">/* failed xact, awaiting ROLLBACK */</comment>
	<decl><name>TBLOCK_ABORT_END</name></decl>,			<comment type="block">/* failed xact, ROLLBACK received */</comment>
	<decl><name>TBLOCK_ABORT_PENDING</name></decl>,		<comment type="block">/* live xact, ROLLBACK received */</comment>
	<decl><name>TBLOCK_PREPARE</name></decl>,				<comment type="block">/* live xact, PREPARE received */</comment>

	<comment type="block">/* subtransaction states */</comment>
	<decl><name>TBLOCK_SUBBEGIN</name></decl>,			<comment type="block">/* starting a subtransaction */</comment>
	<decl><name>TBLOCK_SUBINPROGRESS</name></decl>,		<comment type="block">/* live subtransaction */</comment>
	<decl><name>TBLOCK_SUBRELEASE</name></decl>,			<comment type="block">/* RELEASE received */</comment>
	<decl><name>TBLOCK_SUBCOMMIT</name></decl>,			<comment type="block">/* COMMIT received while TBLOCK_SUBINPROGRESS */</comment>
	<decl><name>TBLOCK_SUBABORT</name></decl>,			<comment type="block">/* failed subxact, awaiting ROLLBACK */</comment>
	<decl><name>TBLOCK_SUBABORT_END</name></decl>,		<comment type="block">/* failed subxact, ROLLBACK received */</comment>
	<decl><name>TBLOCK_SUBABORT_PENDING</name></decl>,	<comment type="block">/* live subxact, ROLLBACK received */</comment>
	<decl><name>TBLOCK_SUBRESTART</name></decl>,			<comment type="block">/* live subxact, ROLLBACK TO received */</comment>
	<decl><name>TBLOCK_SUBABORT_RESTART</name></decl>		<comment type="block">/* failed subxact, ROLLBACK TO received */</comment>
}</block></enum></type> <name>TBlockState</name>;</typedef>

<comment type="block">/*
 *	transaction state structure
 */</comment>
<typedef>typedef <type><struct>struct <name>TransactionStateData</name>
<block>{
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>transactionId</name></decl>;</decl_stmt>	<comment type="block">/* my XID, or Invalid if none */</comment>
	<decl_stmt><decl><type><name>SubTransactionId</name></type> <name>subTransactionId</name></decl>;</decl_stmt>	<comment type="block">/* my subxact ID */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* savepoint name, if any */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>savepointLevel</name></decl>;</decl_stmt> <comment type="block">/* savepoint level */</comment>
	<decl_stmt><decl><type><name>TransState</name></type>	<name>state</name></decl>;</decl_stmt>			<comment type="block">/* low-level state */</comment>
	<decl_stmt><decl><type><name>TBlockState</name></type> <name>blockState</name></decl>;</decl_stmt>		<comment type="block">/* high-level state */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestingLevel</name></decl>;</decl_stmt>	<comment type="block">/* transaction nesting depth */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>gucNestLevel</name></decl>;</decl_stmt>	<comment type="block">/* GUC context nesting depth */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>curTransactionContext</name></decl>;</decl_stmt>	<comment type="block">/* my xact-lifetime context */</comment>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>curTransactionOwner</name></decl>;</decl_stmt>	<comment type="block">/* my query resources */</comment>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>childXids</name></decl>;</decl_stmt>	<comment type="block">/* subcommitted child XIDs, in XID order */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nChildXids</name></decl>;</decl_stmt>		<comment type="block">/* # of subcommitted child XIDs */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxChildXids</name></decl>;</decl_stmt>	<comment type="block">/* allocated size of childXids[] */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prevUser</name></decl>;</decl_stmt>		<comment type="block">/* previous CurrentUserId setting */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>prevSecContext</name></decl>;</decl_stmt> <comment type="block">/* previous SecurityRestrictionContext */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prevXactReadOnly</name></decl>;</decl_stmt>	<comment type="block">/* entry-time xact r/o state */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>startedInRecovery</name></decl>;</decl_stmt>	<comment type="block">/* did we start in recovery? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>didLogXid</name></decl>;</decl_stmt>		<comment type="block">/* has xid been included in WAL record? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>parallelModeLevel</name></decl>;</decl_stmt>	<comment type="block">/* Enter/ExitParallelMode counter */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>TransactionStateData</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>	<comment type="block">/* back link to parent */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ybDataSent</name></decl>;</decl_stmt> <comment type="block">/* Whether some tuples have been transmitted to
				             * frontend as part of this execution */</comment>
  <decl_stmt><decl><type><name>bool</name></type>		<name>ybDataSentForCurrQuery</name></decl>;</decl_stmt> <comment type="block">/* Whether any data has been sent to frontend
																	 * as part of current query's execution */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isYBTxnWithPostgresRel</name></decl>;</decl_stmt> <comment type="block">/* does the current transaction
				                         * operate on a postgres table? */</comment>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>YBPostponedDdlOps</name></decl>;</decl_stmt> <comment type="block">/* We postpone execution of non-revertable
				                     * DocDB operations (e.g. drop table/index)
				                     * until the rest of the txn succeeds */</comment>
}</block></struct></type> <name>TransactionStateData</name>;</typedef>

<typedef>typedef <type><name>TransactionStateData</name> <modifier>*</modifier></type><name>TransactionState</name>;</typedef>

<comment type="block">/*
 * CurrentTransactionState always points to the current transaction state
 * block.  It will point to TopTransactionStateData when not in a
 * transaction at all, or when in a top-level transaction.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionStateData</name></type> <name>TopTransactionStateData</name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* transaction id */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* subtransaction id */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* savepoint name */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* savepoint level */</comment>
	<expr><name>TRANS_DEFAULT</name></expr>,				<comment type="block">/* transaction state */</comment>
	<expr><name>TBLOCK_DEFAULT</name></expr>,				<comment type="block">/* transaction block state from the client
								 * perspective */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* transaction nesting depth */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* GUC context nesting depth */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* cur transaction context */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* cur transaction resource owner */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* subcommitted child Xids */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* # of subcommitted child Xids */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* allocated size of childXids[] */</comment>
	<expr><name>InvalidOid</name></expr>,					<comment type="block">/* previous CurrentUserId setting */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* previous SecurityRestrictionContext */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* entry-time xact r/o state */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* startedInRecovery */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* didLogXid */</comment>
	<expr><literal type="number">0</literal></expr>,							<comment type="block">/* parallelModeLevel */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* link to parent state block */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* ybDataSent */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* ybDataSentForCurrQuery */</comment>
	<expr><name>false</name></expr>,						<comment type="block">/* isYBTxnWithPostgresRel */</comment>
	<expr><name>NULL</name></expr>,						<comment type="block">/* YBPostponedDdlOps */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * unreportedXids holds XIDs of all subtransactions that have not yet been
 * reported in an XLOG_XACT_ASSIGNMENT record.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nUnreportedXids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name><name>unreportedXids</name><index>[<expr><name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionState</name></type> <name>CurrentTransactionState</name> <init>= <expr><operator>&amp;</operator><name>TopTransactionStateData</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * The subtransaction ID and command ID assignment counters are global
 * to a whole transaction, so we do not keep them in the state stack.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SubTransactionId</name></type> <name>currentSubTransactionId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>currentCommandId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>currentCommandIdUsed</name></decl>;</decl_stmt>

<comment type="block">/*
 * xactStartTimestamp is the value of transaction_timestamp().
 * stmtStartTimestamp is the value of statement_timestamp().
 * xactStopTimestamp is the time at which we log a commit or abort WAL record.
 * These do not change as we enter and exit subtransactions, so we don't
 * keep them inside the TransactionState stack.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>xactStartTimestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>stmtStartTimestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>xactStopTimestamp</name></decl>;</decl_stmt>

<comment type="block">/*
 * GID to be used for preparing the current transaction.  This is also
 * global to a whole transaction, so we don't keep it in the state stack.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl>;</decl_stmt>

<comment type="block">/*
 * Some commands want to force synchronous commit.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>forceSyncCommit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Private context for transaction-abort work --- we reserve space for this
 * at startup to ensure that AbortTransaction and AbortSubTransaction can work
 * when we've run out of memory.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>TransactionAbortContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of add-on start- and end-of-xact callbacks
 */</comment>
<typedef>typedef <type><struct>struct <name>XactCallbackItem</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>XactCallbackItem</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XactCallback</name></type> <name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
}</block></struct></type> <name>XactCallbackItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>XactCallbackItem</name> <modifier>*</modifier></type><name>Xact_callbacks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * List of add-on start- and end-of-subxact callbacks
 */</comment>
<typedef>typedef <type><struct>struct <name>SubXactCallbackItem</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>SubXactCallbackItem</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubXactCallback</name></type> <name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
}</block></struct></type> <name>SubXactCallbackItem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>SubXactCallbackItem</name> <modifier>*</modifier></type><name>SubXact_callbacks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssignTransactionId</name><parameter_list>(<parameter><decl><type><name>TransactionState</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AbortTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtAbort_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtCleanup_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtAbort_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtCCI_LocalCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtCommit_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtStart_Cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtStart_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtStart_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CallXactCallbacks</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CallSubXactCallbacks</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>,
					 <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					 <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throwError</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CommitTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>RecordTransactionAbort</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CommitSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AbortSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CleanupSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PushTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PopTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubAbort_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubCleanup_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubAbort_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubCommit_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubStart_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtSubStart_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowTransactionState</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowTransactionStateRec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>TransactionState</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>BlockStateAsString</name><parameter_list>(<parameter><decl><type><name>TBlockState</name></type> <name>blockState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>TransStateAsString</name><parameter_list>(<parameter><decl><type><name>TransState</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *	transaction state accessors
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	IsTransactionState
 *
 *	This returns true if we are inside a valid transaction; that is,
 *	it is safe to initiate database access, take heavyweight locks, etc.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTransactionState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * TRANS_DEFAULT and TRANS_ABORT are obviously unsafe states.  However, we
	 * also reject the startup/shutdown states TRANS_START, TRANS_COMMIT,
	 * TRANS_PREPARE since it might be too soon or too late within those
	 * transition states to do anything interesting.  Hence, the only "valid"
	 * state is TRANS_INPROGRESS.
	 */</comment>
	<return>return <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_INPROGRESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	IsAbortedTransactionBlockState
 *
 *	This returns true if we are within an aborted transaction block.
 */</comment>
<function><type><name>bool</name></type>
<name>IsAbortedTransactionBlockState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_ABORT</name> <operator>||</operator>
		<name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBABORT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	GetTopTransactionId
 *
 * This will return the XID of the main transaction, assigning one if
 * it's not yet set.  Be careful to call this only inside a valid xact.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetTopTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>XactTopTransactionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AssignTransactionId</name><argument_list>(<argument><expr><operator>&amp;</operator><name>TopTransactionStateData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>XactTopTransactionId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	GetTopTransactionIdIfAny
 *
 * This will return the XID of the main transaction, if one is assigned.
 * It will return InvalidTransactionId if we are not currently inside a
 * transaction, or inside a transaction that hasn't yet been assigned an XID.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetTopTransactionIdIfAny</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>XactTopTransactionId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentTransactionId
 *
 * This will return the XID of the current transaction (main or sub
 * transaction), assigning one if it's not yet set.  Be careful to call this
 * only inside a valid xact.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetCurrentTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AssignTransactionId</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentTransactionIdIfAny
 *
 * This will return the XID of the current sub xact, if one is assigned.
 * It will return InvalidTransactionId if we are not currently inside a
 * transaction, or inside a transaction that hasn't been assigned an XID yet.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetCurrentTransactionIdIfAny</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	MarkCurrentTransactionIdLoggedIfAny
 *
 * Remember that the current xid - if it is assigned - now has been wal logged.
 */</comment>
<function><type><name>void</name></type>
<name>MarkCurrentTransactionIdLoggedIfAny</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>didLogXid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	GetStableLatestTransactionId
 *
 * Get the transaction's XID if it has one, else read the next-to-be-assigned
 * XID.  Once we have a value, return that same value for the remainder of the
 * current transaction.  This is meant to provide the reference point for the
 * age(xid) function, but might be useful for other maintenance tasks as well.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetStableLatestTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>LocalTransactionId</name></type> <name>lxid</name> <init>= <expr><name>InvalidLocalTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>stablexid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lxid</name> <operator>!=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lxid</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stablexid</name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>stablexid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stablexid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>stablexid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stablexid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AssignTransactionId
 *
 * Assigns a new permanent XID to the given TransactionState.
 * We do not assign XIDs to transactions until/unless this is called.
 * Also, any parent TransactionStates that don't yet have XIDs are assigned
 * one; this maintains the invariant that a child transaction has an XID
 * following its parent's.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssignTransactionId</name><parameter_list>(<parameter><decl><type><name>TransactionState</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSubXact</name> <init>= <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>currentOwner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>log_unknown_top</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assert that caller didn't screw up */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for new XIDs at this point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign XIDs during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure parent(s) have XIDs, so that a child always has an XID later
	 * than its parent.  Musn't recurse here, or we might get a stack overflow
	 * if we're at the bottom of a huge stack of subtransactions none of which
	 * have XIDs yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isSubXact</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionState</name></type> <name>p</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionState</name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>parentOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parents</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parents</name><index>[<expr><name>parentOffset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * This is technically a recursive call, but the recursion will never
		 * be more than one layer deep.
		 */</comment>
		<while>while <condition>(<expr><name>parentOffset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AssignTransactionId</name><argument_list>(<argument><expr><name><name>parents</name><index>[<expr><operator>--</operator><name>parentOffset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>parents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When wal_level=logical, guarantee that a subtransaction's xid can only
	 * be seen in the WAL stream if its toplevel xid has been logged before.
	 * If necessary we log an xact_assignment record with fewer than
	 * PGPROC_MAX_CACHED_SUBXIDS. Note that it is fine if didLogXid isn't set
	 * for a transaction even though it appears in a WAL record, we just might
	 * superfluously log something. That can happen when an xid is included
	 * somewhere inside a wal record, but not in XLogRecord-&gt;xl_xid, like in
	 * xl_standby_locks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isSubXact</name> <operator>&amp;&amp;</operator> <call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>TopTransactionStateData</name><operator>.</operator><name>didLogXid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>log_unknown_top</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Generate a new Xid and record it in PG_PROC and pg_subtrans.
	 *
	 * NB: we must make the subtrans entry BEFORE the Xid appears anywhere in
	 * shared storage other than PG_PROC; because if there's no room for it in
	 * PG_PROC, the subtrans entry is needed to ensure that other backends see
	 * the Xid as "running".  See GetNewTransactionId.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <call><name>GetNewTransactionId</name><argument_list>(<argument><expr><name>isSubXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>XactTopTransactionId</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SubTransSetParent</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If it's a top-level transaction, the predicate locking system needs to
	 * be told about it too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RegisterPredicateLockingXid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Acquire lock on the transaction XID.  (We assume this cannot block.) We
	 * have to ensure that the lock is assigned to the transaction's own
	 * ResourceOwner.
	 */</comment>
	<expr_stmt><expr><name>currentOwner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XactLockTableInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>currentOwner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Every PGPROC_MAX_CACHED_SUBXIDS assigned transaction ids within each
	 * top-level transaction we issue a WAL record for the assignment. We
	 * include the top-level xid and all the subxids that have not yet been
	 * reported using XLOG_XACT_ASSIGNMENT records.
	 *
	 * This is required to limit the amount of shared memory required in a hot
	 * standby server to keep track of in-progress XIDs. See notes for
	 * RecordKnownAssignedTransactionIds().
	 *
	 * We don't keep track of the immediate parent of each subxid, only the
	 * top-level transaction that each subxact belongs to. This is correct in
	 * recovery only because aborted subtransactions are separately WAL
	 * logged.
	 *
	 * This is correct even for the case where several levels above us didn't
	 * have an xid assigned as we recursed up to them beforehand.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isSubXact</name> <operator>&amp;&amp;</operator> <call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>unreportedXids</name><index>[<expr><name>nUnreportedXids</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nUnreportedXids</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * ensure this test matches similar one in
		 * RecoverPreparedTransactions()
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nUnreportedXids</name> <operator>&gt;=</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name> <operator>||</operator>
			<name>log_unknown_top</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_xact_assignment</name></type> <name>xlrec</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * xtop is always set by now because we recurse up transaction
			 * stack to the highest unassigned xid and then come back down
			 */</comment>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xtop</name></name> <operator>=</operator> <call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>xtop</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nsubxacts</name></name> <operator>=</operator> <name>nUnreportedXids</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>MinSizeOfXactAssignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>unreportedXids</name></expr></argument>,
							 <argument><expr><name>nUnreportedXids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XACT_ID</name></expr></argument>, <argument><expr><name>XLOG_XACT_ASSIGNMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>nUnreportedXids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* mark top, not current xact as having been logged */</comment>
			<expr_stmt><expr><name><name>TopTransactionStateData</name><operator>.</operator><name>didLogXid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentSubTransactionId
 */</comment>
<function><type><name>SubTransactionId</name></type>
<name>GetCurrentSubTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	SubTransactionIsActive
 *
 * Test if the specified subxact ID is still active.  Note caller is
 * responsible for checking whether this ID is relevant to the current xact.
 */</comment>
<function><type><name>bool</name></type>
<name>SubTransactionIsActive</name><parameter_list>(<parameter><decl><type><name>SubTransactionId</name></type> <name>subxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>==</operator> <name>subxid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	GetCurrentCommandId
 *
 * "used" must be true if the caller intends to use the command ID to mark
 * inserted/updated/deleted tuples.  false means the ID is being fetched
 * for read-only purposes (ie, as a snapshot validity cutoff).  See
 * CommandCounterIncrement() for discussion.
 */</comment>
<function><type><name>CommandId</name></type>
<name>GetCurrentCommandId</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* this is global to a transaction, not subtransaction-local */</comment>
	<if_stmt><if>if <condition>(<expr><name>used</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Forbid setting currentCommandIdUsed in a parallel worker, because
		 * we have no provision for communicating this back to the master.  We
		 * could relax this restriction when currentCommandIdUsed was already
		 * true at the start of the parallel operation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentCommandIdUsed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>currentCommandId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	SetParallelStartTimestamps
 *
 * In a parallel worker, we should inherit the parent transaction's
 * timestamps rather than setting our own.  The parallel worker
 * infrastructure must call this to provide those values before
 * calling StartTransaction() or SetCurrentStatementStartTimestamp().
 */</comment>
<function><type><name>void</name></type>
<name>SetParallelStartTimestamps</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>xact_ts</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>stmt_ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xactStartTimestamp</name> <operator>=</operator> <name>xact_ts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>stmtStartTimestamp</name> <operator>=</operator> <name>stmt_ts</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentTransactionStartTimestamp
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetCurrentTransactionStartTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>xactStartTimestamp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentStatementStartTimestamp
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetCurrentStatementStartTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>stmtStartTimestamp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentTransactionStopTimestamp
 *
 * We return current time if the transaction stop time hasn't been set
 * (which can happen if we decide we don't need to log an XLOG record).
 */</comment>
<function><type><name>TimestampTz</name></type>
<name>GetCurrentTransactionStopTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>xactStopTimestamp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>xactStopTimestamp</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	SetCurrentStatementStartTimestamp
 *
 * In a parallel worker, this should already have been provided by a call
 * to SetParallelStartTimestamps().
 */</comment>
<function><type><name>void</name></type>
<name>SetCurrentStatementStartTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stmtStartTimestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmtStartTimestamp</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	SetCurrentTransactionStopTimestamp
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>SetCurrentTransactionStopTimestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>xactStopTimestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	GetCurrentTransactionNestLevel
 *
 * Note: this will return zero when not inside any transaction, one when
 * inside a top-level transaction, etc.
 */</comment>
<function><type><name>int</name></type>
<name>GetCurrentTransactionNestLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>GetCurrentTransactionName</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	TransactionIdIsCurrentTransactionId
 */</comment>
<function><type><name>bool</name></type>
<name>TransactionIdIsCurrentTransactionId</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We always say that BootstrapTransactionId is "not my transaction ID"
	 * even when it is (ie, during bootstrap).  Along with the fact that
	 * transam.c always treats BootstrapTransactionId as already committed,
	 * this causes the tqual.c routines to see all tuples as committed, which
	 * is what we need during bootstrap.  (Bootstrap mode only inserts tuples,
	 * it never updates or deletes them, so all tuples can be presumed good
	 * immediately.)
	 *
	 * Likewise, InvalidTransactionId and FrozenTransactionId are certainly
	 * not my transaction ID, so we can just return "false" immediately for
	 * any non-normal XID.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In parallel workers, the XIDs we must consider as current are stored in
	 * ParallelCurrentXids rather than the transaction-state stack.  Note that
	 * the XIDs in this array are sorted numerically rather than according to
	 * transactionIdPrecedes order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nParallelCurrentXids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>low</name></decl>,
					<decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>high</name> <operator>=</operator> <name>nParallelCurrentXids</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>middle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>probe</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>probe</name> <operator>=</operator> <name><name>ParallelCurrentXids</name><index>[<expr><name>middle</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>probe</name> <operator>==</operator> <name>xid</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>probe</name> <operator>&lt;</operator> <name>xid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We will return true for the Xid of the current subtransaction, any of
	 * its subcommitted children, any of its parents, or any of their
	 * previously subcommitted children.  However, a transaction being aborted
	 * is no longer "current", even though it may still have an entry on the
	 * state stack.
	 */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>low</name></decl>,
					<decl><type ref="prev"/><name>high</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* it can't have any child XIDs either */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* As the childXids array is ordered, we can use binary search */</comment>
		<expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>high</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>middle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>probe</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>middle</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>probe</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>childXids</name><index>[<expr><name>middle</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>probe</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>probe</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	TransactionStartedDuringRecovery
 *
 * Returns true if the current transaction started while recovery was still
 * in progress. Recovery might have ended since so RecoveryInProgress() might
 * return false already.
 */</comment>
<function><type><name>bool</name></type>
<name>TransactionStartedDuringRecovery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>startedInRecovery</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	EnterParallelMode
 */</comment>
<function><type><name>void</name></type>
<name>EnterParallelMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>++</operator><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	ExitParallelMode
 */</comment>
<function><type><name>void</name></type>
<name>ExitParallelMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>ParallelContextActive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>--</operator><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	IsInParallelMode
 *
 * Are we in a parallel operation, as either the master or a worker?  Check
 * this to prohibit operations that change backend-local state expected to
 * match across all workers.  Mere caches usually don't require such a
 * restriction.  State modified in a strict push/pop fashion, such as the
 * active snapshot stack, is often fine.
 */</comment>
<function><type><name>bool</name></type>
<name>IsInParallelMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	CommandCounterIncrement
 */</comment>
<function><type><name>void</name></type>
<name>CommandCounterIncrement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the current value of the command counter hasn't been "used" to mark
	 * tuples, we need not increment it, since there's no need to distinguish
	 * a read-only command from others.  This helps postpone command counter
	 * overflow, and keeps no-op CommandCounterIncrement operations cheap.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentCommandIdUsed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Workers synchronize transaction state at the beginning of each
		 * parallel operation, so we can't account for new commands after that
		 * point.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot start commands during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>currentCommandId</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>currentCommandId</name> <operator>==</operator> <name>InvalidCommandId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>currentCommandId</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than 2^32-2 commands in a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>currentCommandIdUsed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Propagate new command ID into static snapshots */</comment>
		<expr_stmt><expr><call><name>SnapshotSetCommandId</name><argument_list>(<argument><expr><name>currentCommandId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make any catalog changes done by the just-completed command visible
		 * in the local syscache.  We obviously don't need to do this after a
		 * read-only command.  (But see hacks in inval.c to make real sure we
		 * don't think a command that queued inval messages was read-only.)
		 */</comment>
		<expr_stmt><expr><call><name>AtCCI_LocalCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ForceSyncCommit
 *
 * Interface routine to allow commands to force a synchronous commit of the
 * current top-level transaction
 */</comment>
<function><type><name>void</name></type>
<name>ForceSyncCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>forceSyncCommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark current transaction as having sent some data back to the client.
 * This prevents automatic transaction restart.
 */</comment>
<function><type><name>void</name></type> <name>YBMarkDataSent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark current transaction as having no data sent to the client.
 */</comment>
<function><type><name>void</name></type> <name>YBMarkDataNotSent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBMarkDataNotSentForCurrQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Whether some data has been transmitted to frontend as part of this transaction.
 */</comment>
<function><type><name>bool</name></type> <name>YBIsDataSent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Note: we don't support nested transactions (savepoints) yet,</comment>
	<comment type="line">// but once we do - we have to make sure this works as intended.</comment>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Ignoring "idle" transaction state, a leftover from a previous transaction</comment>
	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_DEFAULT</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>ybDataSent</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Whether some data has been transmitted to frontend as part of this query.
 */</comment>
<function><type><name>bool</name></type> <name>YBIsDataSentForCurrQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						StartTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	AtStart_Cache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtStart_Cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	AtStart_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtStart_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is the first time through, create a private context for
	 * AbortTransaction to work in.  By reserving some space now, we can
	 * insulate AbortTransaction from out-of-memory scenarios.  Like
	 * ErrorContext, we set it up with slow growth rate and a nonzero minimum
	 * size, so that space will be reserved immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TransactionAbortContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>TransactionAbortContext</name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"TransactionAbortContext"</literal></expr></argument>,
								  <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
								  <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>,
								  <argument><expr><literal type="number">32</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We shouldn't have a transaction context already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TopTransactionContext</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a toplevel context for the transaction.
	 */</comment>
	<expr_stmt><expr><name>TopTransactionContext</name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"TopTransactionContext"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a top-level transaction, CurTransactionContext is the same as
	 * TopTransactionContext.
	 */</comment>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>CurTransactionContext</name></expr>;</expr_stmt>

	<comment type="block">/* Make the CurTransactionContext active. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	AtStart_ResourceOwner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtStart_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We shouldn't have a transaction resource owner already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a toplevel resource owner for the transaction.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"TopTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>TopTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						StartSubTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * AtSubStart_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubStart_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurTransactionContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a CurTransactionContext, which will be used to hold data that
	 * survives subtransaction commit but disappears on subtransaction abort.
	 * We make it a child of the immediate parent's CurTransactionContext.
	 */</comment>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>,
												  <argument><expr><literal type="string">"CurTransactionContext"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>CurTransactionContext</name></expr>;</expr_stmt>

	<comment type="block">/* Make the CurTransactionContext active. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubStart_ResourceOwner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubStart_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a resource owner for the subtransaction.  We make it a child of
	 * the immediate parent's resource owner.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator>
		<call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
							<argument><expr><literal type="string">"SubTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						CommitTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	RecordTransactionCommit
 *
 * Returns latest XID among xact and its children, or InvalidTransactionId
 * if the xact has no XID.  (We compute that here just because it's easier.)
 *
 * If you change this function, see RecordTransactionCommitPrepared also.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>RecordTransactionCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>markXidCommitted</name> <init>= <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchildren</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmsgs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>invalMessages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>RelcacheInitFileInval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wrote_xlog</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsCurrentTxnWithPGRel</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>latestXid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Get data needed for commit record */</comment>
	<expr_stmt><expr><name>nrels</name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nchildren</name> <operator>=</operator> <call><name>xactGetCommittedChildren</name><argument_list>(<argument><expr><operator>&amp;</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>XLogStandbyInfoActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nmsgs</name> <operator>=</operator> <call><name>xactGetCommittedInvalidationMessages</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalMessages</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>RelcacheInitFileInval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>wrote_xlog</name> <operator>=</operator> <operator>(</operator><name>XactLastRecEnd</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we haven't been assigned an XID yet, we neither can, nor do we want
	 * to write a COMMIT record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>markXidCommitted</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We expect that every smgrscheduleunlink is followed by a catalog
		 * update, and hence XID assignment, so we shouldn't get here with any
		 * pending deletes.  Use a real test not just an Assert to check this,
		 * since it's a bit fragile.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot commit a transaction that deleted files but has no xid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Can't have child XIDs either; AssignTransactionId enforces this */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchildren</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Transactions without an assigned xid can contain invalidation
		 * messages (e.g. explicit relcache invalidations or catcache
		 * invalidations for inplace updates); standbys need to process those.
		 * We can't emit a commit record without an xid, and we don't want to
		 * force assigning an xid, because that'd be problematic for e.g.
		 * vacuum.  Hence we emit a bespoke record for the invalidations. We
		 * don't want to use that in case a commit record is emitted, so they
		 * happen synchronously with commits (besides not wanting to emit more
		 * WAL records).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nmsgs</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LogStandbyInvalidations</name><argument_list>(<argument><expr><name>nmsgs</name></expr></argument>, <argument><expr><name>invalMessages</name></expr></argument>,
									<argument><expr><name>RelcacheInitFileInval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>wrote_xlog</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* not strictly necessary */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we didn't create XLOG entries, we're done here; otherwise we
		 * should trigger flushing those entries the same as a commit record
		 * would.  This will primarily happen for HOT pruning and the like; we
		 * want these to be flushed to disk in due time.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wrote_xlog</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>replorigin</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Are we using the replication origins feature?  Or, in other words,
		 * are we replaying remote actions?
		 */</comment>
		<expr_stmt><expr><name>replorigin</name> <operator>=</operator> <operator>(</operator><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name> <operator>&amp;&amp;</operator>
					  <name>replorigin_session_origin</name> <operator>!=</operator> <name>DoNotReplicateId</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Begin commit critical section and insert the commit XLOG record.
		 */</comment>
		<comment type="block">/* Tell bufmgr and smgr to prepare for commit */</comment>
		<expr_stmt><expr><call><name>BufmgrCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark ourselves as within our "commit critical section".  This
		 * forces any concurrent checkpoint to wait until we've updated
		 * pg_xact.  Without this, it is possible for the checkpoint to set
		 * REDO after the XLOG record but fail to flush the pg_xact update to
		 * disk, leading to loss of the transaction commit if the system
		 * crashes a little later.
		 *
		 * Note: we could, but don't bother to, set this flag in
		 * RecordTransactionAbort.  That's because loss of a transaction abort
		 * is noncritical; the presumption would be that it aborted, anyway.
		 *
		 * It's safe to change the delayChkpt flag of our own backend without
		 * holding the ProcArrayLock, since we're the only one modifying it.
		 * This makes checkpoint's determination of which xacts are delayChkpt
		 * a bit fuzzy, but it doesn't matter.
		 */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetCurrentTransactionStopTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XactLogCommitRecord</name><argument_list>(<argument><expr><name>xactStopTimestamp</name></expr></argument>,
							<argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
							<argument><expr><name>nmsgs</name></expr></argument>, <argument><expr><name>invalMessages</name></expr></argument>,
							<argument><expr><name>RelcacheInitFileInval</name></expr></argument>, <argument><expr><name>forceSyncCommit</name></expr></argument>,
							<argument><expr><name>MyXactFlags</name></expr></argument>,
							<argument><expr><name>InvalidTransactionId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* plain commit */</comment> )</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>replorigin</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Move LSNs forward for this replication origin */</comment>
			<expr_stmt><expr><call><name>replorigin_session_advance</name><argument_list>(<argument><expr><name>replorigin_session_origin_lsn</name></expr></argument>,
									   <argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Record commit timestamp.  The value comes from plain commit
		 * timestamp if there's no replication origin; otherwise, the
		 * timestamp was already set in replorigin_session_origin_timestamp by
		 * replication.
		 *
		 * We don't need to WAL-log anything here, as the commit record
		 * written above already contains the data.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replorigin</name> <operator>||</operator> <name>replorigin_session_origin_timestamp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>replorigin_session_origin_timestamp</name> <operator>=</operator> <name>xactStopTimestamp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TransactionTreeSetCommitTsData</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
									   <argument><expr><name>replorigin_session_origin_timestamp</name></expr></argument>,
									   <argument><expr><name>replorigin_session_origin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check if we want to commit asynchronously.  We can allow the XLOG flush
	 * to happen asynchronously if synchronous_commit=off, or if the current
	 * transaction has not performed any WAL-logged operation or didn't assign
	 * an xid.  The transaction can end up not writing any WAL, even if it has
	 * an xid, if it only wrote to temporary and/or unlogged tables.  It can
	 * end up having written WAL without an xid if it did HOT pruning.  In
	 * case of a crash, the loss of such a transaction will be irrelevant;
	 * temp tables will be lost anyway, unlogged tables will be truncated and
	 * HOT pruning will be done again later. (Given the foregoing, you might
	 * think that it would be unnecessary to emit the XLOG record at all in
	 * this case, but we don't currently try to do that.  It would certainly
	 * cause problems at least in Hot Standby mode, where the
	 * KnownAssignedXids machinery requires tracking every XID assignment.  It
	 * might be OK to skip it only when wal_level &lt; replica, but for now we
	 * don't.)
	 *
	 * However, if we're doing cleanup of any non-temp rels or committing any
	 * command that wanted to force sync commit, then we must flush XLOG
	 * immediately.  (We must not allow asynchronous commit if there are any
	 * non-temp tables to be deleted, because we might delete the files before
	 * the COMMIT record is flushed to disk.  We do allow asynchronous commit
	 * if all to-be-deleted tables are temporary though, since they are lost
	 * anyway if we crash.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wrote_xlog</name> <operator>&amp;&amp;</operator> <name>markXidCommitted</name> <operator>&amp;&amp;</operator>
		 <name>synchronous_commit</name> <operator>&gt;</operator> <name>SYNCHRONOUS_COMMIT_OFF</name><operator>)</operator> <operator>||</operator>
		<name>forceSyncCommit</name> <operator>||</operator> <name>nrels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we may update the CLOG, if we wrote a COMMIT record above
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>markXidCommitted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TransactionIdCommitTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Asynchronous commit case:
		 *
		 * This enables possible committed transaction loss in the case of a
		 * postmaster crash because WAL buffers are left unwritten. Ideally we
		 * could issue the WAL write without the fsync, but some
		 * wal_sync_methods do not allow separate write/fsync.
		 *
		 * Report the latest async commit LSN, so that the WAL writer knows to
		 * flush this commit.
		 */</comment>
		<expr_stmt><expr><call><name>XLogSetAsyncXactLSN</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must not immediately update the CLOG, since we didn't flush the
		 * XLOG. Instead, we store the LSN up to which the XLOG must be
		 * flushed before the CLOG may be updated.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>markXidCommitted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>TransactionIdAsyncCommitTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we entered a commit critical section, leave it now, and let
	 * checkpoints proceed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>markXidCommitted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Compute latestXid while we have the child XIDs handy */</comment>
	<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait for synchronous replication, if required. Similar to the decision
	 * above about using committing asynchronously we only want to wait if
	 * this backend assigned an xid and wrote WAL.  No need to wait if an xid
	 * was assigned due to temporary/unlogged tables or due to HOT pruning.
	 *
	 * Note that at this stage we have marked clog, but still show as running
	 * in the procarray and continue to hold locks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>wrote_xlog</name> <operator>&amp;&amp;</operator> <name>markXidCommitted</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SyncRepWaitForLSN</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* remember end of last commit record */</comment>
	<expr_stmt><expr><name>XactLastCommitEnd</name> <operator>=</operator> <name>XactLastRecEnd</name></expr>;</expr_stmt>

	<comment type="block">/* Reset XactLastRecEnd until the next transaction writes something */</comment>
	<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
	<comment type="block">/* Clean up local data */</comment>
	<if_stmt><if>if <condition>(<expr><name>rels</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>latestXid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	AtCCI_LocalCache
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtCCI_LocalCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Make any pending relation map changes visible.  We must do this before
	 * processing local sinval messages, so that the map changes will get
	 * reflected into the relcache when relcache invals are processed.
	 */</comment>
	<expr_stmt><expr><call><name>AtCCI_RelationMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make catalog changes visible to me for the next command.
	 */</comment>
	<expr_stmt><expr><call><name>CommandEndInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	AtCommit_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtCommit_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Now that we're "out" of a transaction, have the system allocate things
	 * in the top memory context instead of per-transaction contexts.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release all transaction-local memory.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TopTransactionContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						CommitSubTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * AtSubCommit_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubCommit_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return to parent transaction level's memory context. */</comment>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ordinarily we cannot throw away the child's CurTransactionContext,
	 * since the data it contains will be needed at upper commit.  However, if
	 * there isn't actually anything in it, we can throw it away.  This avoids
	 * a small memory leak in the common case of "trivial" subxacts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MemoryContextIsEmpty</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubCommit_childXids
 *
 * Pass my own XID and my child XIDs up to my parent as committed children.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubCommit_childXids</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_nChildXids</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The parent childXids array will need to hold my XID and all my
	 * childXids, in addition to the XIDs already there.
	 */</comment>
	<expr_stmt><expr><name>new_nChildXids</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Allocate or enlarge the parent array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>&lt;</operator> <name>new_nChildXids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_maxChildXids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>new_childXids</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make it 2x what's needed right now, to avoid having to enlarge it
		 * repeatedly. But we can't go above MaxAllocSize.  (The latter limit
		 * is what ensures that we don't need to worry about integer overflow
		 * here or in the calculation of new_nChildXids.)
		 */</comment>
		<expr_stmt><expr><name>new_maxChildXids</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>new_nChildXids</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_maxChildXids</name> <operator>&lt;</operator> <name>new_nChildXids</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"maximum number of committed subtransactions (%d) exceeded"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>MaxAllocSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We keep the child-XID arrays in TopTransactionContext; this avoids
		 * setting up child-transaction contexts for what might be just a few
		 * bytes of grandchild XIDs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childXids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_childXids</name> <operator>=</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
								   <argument><expr><name>new_maxChildXids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_childXids</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childXids</name></name></expr></argument>,
									 <argument><expr><name>new_maxChildXids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>new_childXids</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <name>new_maxChildXids</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy all my XIDs to parent's array.
	 *
	 * Note: We rely on the fact that the XID of a child always follows that
	 * of its parent.  By copying the XID of this subtransaction before the
	 * XIDs of its children, we ensure that the array stays ordered. Likewise,
	 * all XIDs already in the array belong to subtransactions started and
	 * subcommitted before us, so their XIDs must precede ours.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childXids</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>nChildXids</name></name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childXids</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
			   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name></expr></argument>,
			   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <name>new_nChildXids</name></expr>;</expr_stmt>

	<comment type="block">/* Release child's array to avoid leakage */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* We must reset these to avoid double-free if fail later in commit */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						AbortTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	RecordTransactionAbort
 *
 * Returns latest XID among xact and its children, or InvalidTransactionId
 * if the xact has no XID.  (We compute that here just because it's easier.)
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>RecordTransactionAbort</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchildren</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xact_time</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we haven't been assigned an XID, nobody will care whether we aborted
	 * or not.  Hence, we're done in that case.  It does not matter if we have
	 * rels to delete (note that this routine is not responsible for actually
	 * deleting 'em).  We cannot have any child XIDs, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reset XactLastRecEnd until the next transaction writes something */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a valid XID, so we should write an ABORT record for it.
	 *
	 * We do not flush XLOG to disk here, since the default assumption after a
	 * crash would be that we aborted, anyway.  For the same reason, we don't
	 * need to worry about interlocking against checkpoint start.
	 */</comment>

	<comment type="block">/*
	 * Check that we haven't aborted halfway through RecordTransactionCommit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot abort transaction %u, it was already committed"</literal></expr></argument>,
			 <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch the data we need for the abort record */</comment>
	<expr_stmt><expr><name>nrels</name> <operator>=</operator> <call><name>smgrGetPendingDeletes</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nchildren</name> <operator>=</operator> <call><name>xactGetCommittedChildren</name><argument_list>(<argument><expr><operator>&amp;</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX do we really need a critical section here? */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write the ABORT record */</comment>
	<if_stmt><if>if <condition>(<expr><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xact_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetCurrentTransactionStopTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xact_time</name> <operator>=</operator> <name>xactStopTimestamp</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>XactLogAbortRecord</name><argument_list>(<argument><expr><name>xact_time</name></expr></argument>,
					   <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>,
					   <argument><expr><name>nrels</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>,
					   <argument><expr><name>MyXactFlags</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Report the latest async abort LSN, so that the WAL writer knows to
	 * flush this abort. There's nothing to be gained by delaying this, since
	 * WALWriter may as well do this when it can. This is important with
	 * streaming replication because if we don't flush WAL regularly we will
	 * find that large aborts leave us with a long backlog for when commits
	 * occur after the abort, increasing our window of data loss should
	 * problems occur at that point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogSetAsyncXactLSN</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark the transaction aborted in clog.  This is not absolutely necessary
	 * but we may as well do it while we are here; also, in the subxact case
	 * it is helpful because XactLockTableWait makes use of it to avoid
	 * waiting for already-aborted subtransactions.  It is OK to do it without
	 * having flushed the ABORT record to disk, because in event of a crash
	 * we'd be assumed to have aborted anyway.
	 */</comment>
	<expr_stmt><expr><call><name>TransactionIdAbortTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute latestXid while we have the child XIDs handy */</comment>
	<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're aborting a subtransaction, we can immediately remove failed
	 * XIDs from PGPROC's cache of running child XIDs.  We do that here for
	 * subxacts, because we already have the child XID array at hand.  For
	 * main xacts, the equivalent happens just after this function returns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XidCacheRemoveRunningXids</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>nchildren</name></expr></argument>, <argument><expr><name>children</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset XactLastRecEnd until the next transaction writes something */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And clean up local data */</comment>
	<if_stmt><if>if <condition>(<expr><name>rels</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>latestXid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	AtAbort_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtAbort_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Switch into TransactionAbortContext, which should have some free space
	 * even if nothing else does.  We'll work in this context until we've
	 * finished cleaning up.
	 *
	 * It is barely possible to get here when we've not been able to create
	 * TransactionAbortContext yet; if so use TopMemoryContext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TransactionAbortContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TransactionAbortContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubAbort_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubAbort_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TransactionAbortContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TransactionAbortContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	AtAbort_ResourceOwner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtAbort_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Make sure we have a valid ResourceOwner, if possible (else it will be
	 * NULL, which is OK)
	 */</comment>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtSubAbort_ResourceOwner
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubAbort_ResourceOwner</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure we have a valid ResourceOwner */</comment>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AtSubAbort_childXids
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubAbort_childXids</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We keep the child-XID arrays in TopTransactionContext (see
	 * AtSubCommit_childXids).  This means we'd better free the array
	 * explicitly at abort to avoid leakage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We could prune the unreportedXids array here. But we don't bother. That
	 * would potentially reduce number of XLOG_XACT_ASSIGNMENT records but it
	 * would likely introduce more CPU time into the more common paths, so we
	 * choose not to do that.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						CleanupTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	AtCleanup_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtCleanup_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we're "out" of a transaction, have the system allocate things
	 * in the top memory context instead of per-transaction contexts.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear the special abort context for next time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TransactionAbortContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>TransactionAbortContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Release all transaction-local memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TopTransactionContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>TopTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *						CleanupSubTransaction stuff
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * AtSubCleanup_Memory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtSubCleanup_Memory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we're not in an about-to-be-deleted context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clear the special abort context for next time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TransactionAbortContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>TransactionAbortContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Delete the subxact local memory contexts. Its CurTransactionContext can
	 * go too (note this also kills CurTransactionContexts from any children
	 * of the subxact).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						interface routines
 * ----------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBUpdateActiveSubTransaction</name><parameter_list>(<parameter><decl><type><name>TransactionState</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>YBCSetActiveSubTransaction</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Do a Yugabyte-specific initialization of transaction when it starts,
 * called as a part of StartTransaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>YBStartTransaction</name><parameter_list>(<parameter><decl><type><name>TransactionState</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>isYBTxnWithPostgresRel</name></name> <operator>=</operator> <operator>!</operator><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSent</name></name>             <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>YBPostponedDdlOps</name></name>      <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>YBInitializeTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The isolation level in Postgres code (i.e., XactIsoLevel) maps to a certain
 * isolation level as seen by pggate. This function returns the mapped isolation
 * level that pggate layer is supposed to see.
 */</comment>
<function><type><name>int</name></type> <name>YBGetEffectivePggateIsolationLevel</name><parameter_list>()</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>mapped_pg_isolation_level</name> <init>= <expr><name>XactIsoLevel</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// For the txn manager, logic for XACT_READ_UNCOMMITTED is same as</comment>
	<comment type="line">// XACT_READ_COMMITTED.</comment>
	<if_stmt><if>if <condition>(<expr><name>mapped_pg_isolation_level</name> <operator>==</operator> <name>XACT_READ_UNCOMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mapped_pg_isolation_level</name> <operator>=</operator> <name>XACT_READ_COMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// If READ COMMITTED mode is not on, XACT_READ_COMMITTED maps to</comment>
	<comment type="line">// XACT_REPEATABLE_READ.</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mapped_pg_isolation_level</name> <operator>==</operator> <name>XACT_READ_COMMITTED</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mapped_pg_isolation_level</name> <operator>=</operator> <name>XACT_REPEATABLE_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mapped_pg_isolation_level</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>YBInitializeTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>YBTransactionsEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgBeginTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(
			<argument><expr><call><name>YBCPgSetTransactionIsolationLevel</name><argument_list>(<argument><expr><call><name>YBGetEffectivePggateIsolationLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgEnableFollowerReads</name><argument_list>(<argument><expr><call><name>YBReadFromFollowersEnabled</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>YBFollowerReadStalenessMs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetTransactionReadOnly</name><argument_list>(<argument><expr><name>XactReadOnly</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetTransactionDeferrable</name><argument_list>(<argument><expr><name>XactDeferrable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	StartTransaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VirtualTransactionId</name></type> <name>vxid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Let's just make sure the state stack is empty
	 */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name>TopTransactionStateData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentTransactionState</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>XactTopTransactionId</name> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check the current transaction state */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the current transaction state information appropriately during
	 * start processing.  Note that once the transaction status is switched
	 * this process cannot fail until the user ID and the security context
	 * flags are fetched below.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_START</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>	<comment type="block">/* until assigned */</comment>

	<comment type="block">/*
	 * initialize current transaction state fields
	 *
	 * note: prevXactReadOnly is not used at the outermost level
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Once the current user ID and the security context flags are fetched,
	 * both will be properly reset even if transaction startup fails.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prevUser</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prevSecContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SecurityRestrictionContext should never be set outside a transaction */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prevSecContext</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure we've reset xact state variables
	 *
	 * If recovery is still in progress, mark this transaction as read-only.
	 * We have lower level defences in XLogInsert and elsewhere to stop us
	 * from modifying data during recovery, but this gives the normal
	 * indication to the user that the transaction is read-only.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>startedInRecovery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>startedInRecovery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name>DefaultXactReadOnly</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>XactDeferrable</name> <operator>=</operator> <name>DefaultXactDeferrable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XactIsoLevel</name> <operator>=</operator> <name>DefaultXactIsoLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>forceSyncCommit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyXactFlags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * reinitialize within-transaction counters
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>=</operator> <name>TopSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentSubTransactionId</name> <operator>=</operator> <name>TopSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentCommandId</name> <operator>=</operator> <name>FirstCommandId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentCommandIdUsed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize reported xid accounting
	 */</comment>
	<expr_stmt><expr><name>nUnreportedXids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>didLogXid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * must initialize resource-management stuff first
	 */</comment>
	<expr_stmt><expr><call><name>AtStart_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtStart_ResourceOwner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign a new LocalTransactionId, and combine it with the backendId to
	 * form a virtual transaction id.
	 */</comment>
	<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>backendId</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name> <operator>=</operator> <call><name>GetNextLocalTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock the virtual transaction id before we announce it in the proc array
	 */</comment>
	<expr_stmt><expr><call><name>VirtualXactLockTableInsert</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advertise it in the proc array.  We assume assignment of
	 * LocalTransactionID is atomic, and the backendId should be set already.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>==</operator> <name><name>vxid</name><operator>.</operator><name>backendId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name> <operator>=</operator> <name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_TRANSACTION_START</name><argument_list>(<argument><expr><name><name>vxid</name><operator>.</operator><name>localTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * set transaction_timestamp() (a/k/a now()).  Normally, we want this to
	 * be the same as the first command's statement_timestamp(), so don't do a
	 * fresh GetCurrentTimestamp() call (which'd be expensive anyway).  But
	 * for transactions started inside procedures (i.e., nonatomic SPI
	 * contexts), we do need to advance the timestamp.  Also, in a parallel
	 * worker, the timestamp should already have been provided by a call to
	 * SetParallelStartTimestamps().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPI_inside_nonatomic_context</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>xactStartTimestamp</name> <operator>=</operator> <name>stmtStartTimestamp</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>xactStartTimestamp</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xactStartTimestamp</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_xact_timestamp</name><argument_list>(<argument><expr><name>xactStartTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Mark xactStopTimestamp as unset. */</comment>
	<expr_stmt><expr><name>xactStopTimestamp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize other subsystems for new transaction
	 */</comment>
	<expr_stmt><expr><call><name>AtStart_GUC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtStart_Cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AfterTriggerBeginXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * done with start processing, set current transaction state to "in
	 * progress"
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_INPROGRESS</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YBStartTransaction</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"StartTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recreates the state required to restart the write that received a transaction
 * conflict.
 */</comment>
<function><type><name>void</name></type>
<name>YBCRestartWriteTransaction</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Presence of triggers pushes additional snapshots. Pop all of them. Given
	 * that we restart the writes only when we haven't sent any data back to the
	 * user, removing all snapshots is safe.
	 */</comment>
	<expr_stmt><expr><call><name>PopAllActiveSnapshots</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtEOXact_SPI</name><argument_list>(<argument><expr><name>false</name></expr></argument> <comment type="block">/* isCommit */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recreate the global state present for triggers that would have changed
	 * during the execution of the failed write.
	 */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndXact</name><argument_list>(<argument><expr><name>false</name></expr></argument> <comment type="block">/* isCommit */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AfterTriggerBeginXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	CommitTransaction
 *
 * NB: if you change this routine, better look at PrepareTransaction too!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CommitTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_parallel_worker</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>is_parallel_worker</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_PARALLEL_INPROGRESS</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Enforce parallel mode restrictions during parallel worker commit. */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_parallel_worker</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"CommitTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check the current transaction state
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"CommitTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do pre-commit processing that involves calling user-defined code, such
	 * as triggers.  SECURITY_RESTRICTED_OPERATION contexts must not queue an
	 * action that would run here, because that would bypass the sandbox.
	 * Since closing cursors could queue trigger actions, triggers could open
	 * cursors, etc, we have to keep looping until there's nothing left to do.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Fire all currently pending deferred triggers.
		 */</comment>
		<expr_stmt><expr><call><name>AfterTriggerFireDeferred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close open portals (converting holdable ones into static portals).
		 * If there weren't any, we are done ... otherwise loop back to check
		 * if they queued deferred triggers.  Lather, rinse, repeat.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PreCommit_Portals</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Firing the triggers may abort current transaction.
	 * At this point all the them has been fired already.
	 * It is time to commit YB transaction.
	 * Postgres transaction can be aborted at this point without an issue
	 * in case of YBCCommitTransaction failure.
	 */</comment>
	<expr_stmt><expr><call><name>YBCCommitTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The remaining actions cannot call any user-defined code, so it's safe
	 * to start shutting down within-transaction services.  But note that most
	 * of this stuff could still throw an error, which would switch us into
	 * the transaction-abort path.
	 */</comment>

	<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_parallel_worker</name></expr> ?</condition><then> <expr><name>XACT_EVENT_PARALLEL_PRE_COMMIT</name></expr>
					  </then><else>: <expr><name>XACT_EVENT_PRE_COMMIT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we might have parallel workers, clean them up now. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AtEOXact_Parallel</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Shut down the deferred-trigger manager */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndXact</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let ON COMMIT management do its thing (must happen after closing
	 * cursors, to avoid dangling-reference problems)
	 */</comment>
	<expr_stmt><expr><call><name>PreCommit_on_commit_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close large objects before lower-level cleanup */</comment>
	<expr_stmt><expr><call><name>AtEOXact_LargeObject</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark serializable transaction as complete for predicate locking
	 * purposes.  This should be done as late as we can put it and still allow
	 * errors to be raised for failure patterns found at commit.
	 */</comment>
	<expr_stmt><expr><call><name>PreCommit_CheckForSerializationFailure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert notifications sent by NOTIFY commands into the queue.  This
	 * should be late in the pre-commit sequence to minimize time spent
	 * holding the notify-insertion lock.
	 */</comment>
	<expr_stmt><expr><call><name>PreCommit_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prevent cancel/die interrupt while cleaning up */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Commit updates to the relation map --- do this as late as possible */</comment>
	<expr_stmt><expr><call><name>AtEOXact_RelationMap</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * set the current transaction state information appropriately during
	 * commit processing
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_COMMIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_parallel_worker</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to mark our XIDs as committed in pg_xact.  This is where we
		 * durably commit.
		 */</comment>
		<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>RecordTransactionCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We must not mark our XID committed; the parallel master is
		 * responsible for that.
		 */</comment>
		<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure the master will know about any WAL we wrote before it
		 * commits.
		 */</comment>
		<expr_stmt><expr><call><name>ParallelWorkerReportLastRecEnd</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_TRANSACTION_COMMIT</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let others know about no transaction in progress by me. Note that this
	 * must be done _before_ releasing locks we hold and _after_
	 * RecordTransactionCommit.
	 */</comment>
	<expr_stmt><expr><call><name>ProcArrayEndTransaction</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is all post-commit cleanup.  Note that if an error is raised here,
	 * it's too late to abort the transaction.  This should be just
	 * noncritical resource releasing.
	 *
	 * The ordering of operations is not entirely random.  The idea is:
	 * release resources visible to other backends (eg, files, buffer pins);
	 * then release locks; then release backend-local resources. We want to
	 * release locks at the point where any backend waiting for us will see
	 * our transaction as being fully cleaned up.
	 *
	 * Resources that can be associated with individual queries are handled by
	 * the ResourceOwner mechanism.  The other calls here are for backend-wide
	 * state.
	 */</comment>

	<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_parallel_worker</name></expr> ?</condition><then> <expr><name>XACT_EVENT_PARALLEL_COMMIT</name></expr>
					  </then><else>: <expr><name>XACT_EVENT_COMMIT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we've released all buffer pins */</comment>
	<expr_stmt><expr><call><name>AtEOXact_Buffers</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up the relation cache */</comment>
	<expr_stmt><expr><call><name>AtEOXact_RelationCache</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make catalog changes visible to all backends.  This has to happen after
	 * relcache references are dropped (see comments for
	 * AtEOXact_RelationCache), but before locks are released (if anyone is
	 * waiting for lock on a relation we've modified, we want them to know
	 * about the catalog change before they start using the relation).
	 */</comment>
	<expr_stmt><expr><call><name>AtEOXact_Inval</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtEOXact_MultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise, dropping of files deleted during the transaction is best done
	 * after releasing relcache and buffer pins.  (This is not strictly
	 * necessary during commit, since such pins should have been released
	 * already, but this ordering is definitely critical during abort.)  Since
	 * this may take many seconds, also delay until after releasing locks.
	 * Other backends will observe the attendant catalog changes and not
	 * attempt to access affected files.
	 */</comment>
	<expr_stmt><expr><call><name>smgrDoPendingDeletes</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtCommit_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_SPI</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Enum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_on_commit_actions</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Namespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_parallel_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_SMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Files</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_ComboCid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_HashTables</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_PgStat</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Snapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_ApplyLauncher</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_xact_timestamp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtCommit_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactTopTransactionId</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nParallelCurrentXids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * done with commit processing, set current transaction state back to
	 * default
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	PrepareTransaction
 *
 * NB: if you change this routine, better look at CommitTransaction too!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrepareTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GlobalTransaction</name></type> <name>gxact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>prepared_at</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"PrepareTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check the current transaction state
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"PrepareTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do pre-commit processing that involves calling user-defined code, such
	 * as triggers.  Since closing cursors could queue trigger actions,
	 * triggers could open cursors, etc, we have to keep looping until there's
	 * nothing left to do.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Fire all currently pending deferred triggers.
		 */</comment>
		<expr_stmt><expr><call><name>AfterTriggerFireDeferred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close open portals (converting holdable ones into static portals).
		 * If there weren't any, we are done ... otherwise loop back to check
		 * if they queued deferred triggers.  Lather, rinse, repeat.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PreCommit_Portals</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><name>XACT_EVENT_PRE_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The remaining actions cannot call any user-defined code, so it's safe
	 * to start shutting down within-transaction services.  But note that most
	 * of this stuff could still throw an error, which would switch us into
	 * the transaction-abort path.
	 */</comment>

	<comment type="block">/* Shut down the deferred-trigger manager */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndXact</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let ON COMMIT management do its thing (must happen after closing
	 * cursors, to avoid dangling-reference problems)
	 */</comment>
	<expr_stmt><expr><call><name>PreCommit_on_commit_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* close large objects before lower-level cleanup */</comment>
	<expr_stmt><expr><call><name>AtEOXact_LargeObject</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark serializable transaction as complete for predicate locking
	 * purposes.  This should be done as late as we can put it and still allow
	 * errors to be raised for failure patterns found at commit.
	 */</comment>
	<expr_stmt><expr><call><name>PreCommit_CheckForSerializationFailure</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NOTIFY will be handled below */</comment>

	<comment type="block">/*
	 * Don't allow PREPARE TRANSACTION if we've accessed a temporary table in
	 * this transaction.  Having the prepared xact hold locks on another
	 * backend's temp table seems a bad idea --- for instance it would prevent
	 * the backend from exiting.  There are other problems too, such as how to
	 * clean up the source backend's local buffers and ON COMMIT state if the
	 * prepared xact includes a DROP of a temp table.
	 *
	 * We must check this after executing any ON COMMIT actions, because they
	 * might still access a temp relation.
	 *
	 * XXX In principle this could be relaxed to allow some useful special
	 * cases, such as a temp table created and dropped all within the
	 * transaction.  That seems to require much more bookkeeping though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPREL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has operated on temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, PREPARE TRANSACTION is not allowed if the temporary
	 * namespace has been involved in this transaction as we cannot allow it
	 * to create, lock, or even drop objects within the temporary namespace
	 * as this can mess up with this session or even a follow-up session
	 * trying to use the same temporary namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPNAMESPACE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has operated on temporary objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, don't allow PREPARE after pg_export_snapshot.  This could be
	 * supported if we added cleanup logic to twophase.c, but for now it
	 * doesn't seem worth the trouble.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XactHasExportedSnapshots</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has exported snapshots"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow PREPARE but for transaction that has/might kill logical
	 * replication workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XactManipulatesLogicalReplicationWorkers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot PREPARE a transaction that has manipulated logical replication workers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent cancel/die interrupt while cleaning up */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * set the current transaction state information appropriately during
	 * prepare processing
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_PREPARE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>prepared_at</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell bufmgr and smgr to prepare for commit */</comment>
	<expr_stmt><expr><call><name>BufmgrCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reserve the GID for this transaction. This could fail if the requested
	 * GID is invalid or already in use.
	 */</comment>
	<expr_stmt><expr><name>gxact</name> <operator>=</operator> <call><name>MarkAsPreparing</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>prepared_at</name></expr></argument>,
							<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prepareGID</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect data for the 2PC state file.  Note that in general, no actual
	 * state change should happen in the called modules during this step,
	 * since it's still possible to fail before commit, and in that case we
	 * want transaction abort to be able to clean up.  (In particular, the
	 * AtPrepare routines may error out if they find cases they cannot
	 * handle.)  State cleanup should happen in the PostPrepare routines
	 * below.  However, some modules can go ahead and clear state here because
	 * they wouldn't do anything with it during abort anyway.
	 *
	 * Note: because the 2PC state file records will be replayed in the same
	 * order they are made, the order of these calls has to match the order in
	 * which we want things to happen during COMMIT PREPARED or ROLLBACK
	 * PREPARED; in particular, pay attention to whether things should happen
	 * before or after releasing the transaction's locks.
	 */</comment>
	<expr_stmt><expr><call><name>StartPrepare</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtPrepare_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>YBIsPgLockingEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AtPrepare_Locks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtPrepare_PredicateLocks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>AtPrepare_PgStat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtPrepare_MultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtPrepare_RelationMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here is where we really truly prepare.
	 *
	 * We have to record transaction prepares even if we didn't make any
	 * updates, because the transaction manager might get confused if we lose
	 * a global transaction.
	 */</comment>
	<expr_stmt><expr><call><name>EndPrepare</name><argument_list>(<argument><expr><name>gxact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we clean up backend-internal state and release internal resources.
	 */</comment>

	<comment type="block">/* Reset XactLastRecEnd until the next transaction writes something */</comment>
	<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let others know about no transaction in progress by me.  This has to be
	 * done *after* the prepared transaction has been marked valid, else
	 * someone may think it is unlocked and recyclable.
	 */</comment>
	<expr_stmt><expr><call><name>ProcArrayClearTransaction</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In normal commit-processing, this is all non-critical post-transaction
	 * cleanup.  When the transaction is prepared, however, it's important
	 * that the locks and other per-backend resources are transferred to the
	 * prepared transaction's PGPROC entry.  Note that if an error is raised
	 * here, it's too late to abort the transaction. XXX: This probably should
	 * be in a critical section, to force a PANIC if any of this fails, but
	 * that cure could be worse than the disease.
	 */</comment>

	<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><name>XACT_EVENT_PREPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check we've released all buffer pins */</comment>
	<expr_stmt><expr><call><name>AtEOXact_Buffers</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up the relation cache */</comment>
	<expr_stmt><expr><call><name>AtEOXact_RelationCache</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* notify doesn't need a postprepare call */</comment>

	<expr_stmt><expr><call><name>PostPrepare_PgStat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PostPrepare_Inval</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PostPrepare_smgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PostPrepare_MultiXact</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsPgLockingEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>PostPrepare_Locks</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PostPrepare_PredicateLocks</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allow another backend to finish the transaction.  After
	 * PostPrepare_Twophase(), the transaction is completely detached from our
	 * backend.  The rest is just non-critical cleanup of backend-local state.
	 */</comment>
	<expr_stmt><expr><call><name>PostPrepare_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PREPARE acts the same as COMMIT as far as GUC is concerned */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_SPI</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Enum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_on_commit_actions</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Namespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_SMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_Files</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_ComboCid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_HashTables</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't call AtEOXact_PgStat here; we fixed pgstat state above */</comment>
	<expr_stmt><expr><call><name>AtEOXact_Snapshot</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_xact_timestamp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtCommit_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactTopTransactionId</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nParallelCurrentXids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * done with 1st phase commit processing, set current transaction state
	 * back to default
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	AbortTransaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AbortTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>latestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_parallel_worker</name></decl>;</decl_stmt>

	<comment type="block">/* Prevent cancel/die interrupt while cleaning up */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we have a valid memory context and resource owner */</comment>
	<expr_stmt><expr><call><name>AtAbort_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtAbort_ResourceOwner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsPgLockingEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		* Release any LW locks we might be holding as quickly as possible.
		* (Regular locks, however, must be held till we finish aborting.)
		* Releasing LW locks is critical since we might try to grab them again
		* while cleaning up!
		*/</comment>
		<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clear wait information and command progress indicator */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up buffer I/O and buffer context locks, too */</comment>
	<expr_stmt><expr><call><name>AbortBufferIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset WAL record construction state */</comment>
	<expr_stmt><expr><call><name>XLogResetInsertion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel condition variable sleep */</comment>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>YBIsPgLockingEnabled</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		* Also clean up any open wait for lock, since the lock manager will choke
		* if we try to wait for another lock before doing this.
		*/</comment>
		<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If any timeout events are still active, make sure the timeout interrupt
	 * is scheduled.  This covers possible loss of a timeout interrupt due to
	 * longjmp'ing out of the SIGINT handler (see notes in handle_sig_alarm).
	 * We delay this till after LockErrorCleanup so that we don't uselessly
	 * reschedule lock or deadlock check timeouts.
	 */</comment>
	<expr_stmt><expr><call><name>reschedule_timeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-enable signals, in case we got here by longjmp'ing out of a signal
	 * handler.  We do this fairly early in the sequence so that the timeout
	 * infrastructure will be functional if needed while aborting.
	 */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check the current transaction state
	 */</comment>
	<expr_stmt><expr><name>is_parallel_worker</name> <operator>=</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_PARALLEL_INPROGRESS</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_INPROGRESS</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_PREPARE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"AbortTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * set the current transaction state information appropriately during the
	 * abort processing
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_ABORT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset user ID which might have been changed transiently.  We need this
	 * to clean up in case control escaped out of a SECURITY DEFINER function
	 * or other local change of CurrentUserId; therefore, the prior value of
	 * SecurityRestrictionContext also needs to be restored.
	 *
	 * (Note: it is not necessary to restore session authorization or role
	 * settings here because those can only be changed via GUC, and GUC will
	 * take care of rolling them back if need be.)
	 */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prevUser</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prevSecContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If in parallel mode, clean up workers and exit parallel mode. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AtEOXact_Parallel</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * do abort processing
	 */</comment>
	<expr_stmt><expr><call><name>AfterTriggerEndXact</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 'false' means it's abort */</comment>
	<expr_stmt><expr><call><name>AtAbort_Portals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_LargeObject</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtAbort_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOXact_RelationMap</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtAbort_Twophase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advertise the fact that we aborted in pg_xact (assuming that we got as
	 * far as assigning an XID to advertise).  But if we're inside a parallel
	 * worker, skip this; the user backend must be the one to write the abort
	 * record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_parallel_worker</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <call><name>RecordTransactionAbort</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>latestXid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since the parallel master won't get our value of XactLastRecEnd in
		 * this case, we nudge WAL-writer ourselves in this case.  See related
		 * comments in RecordTransactionAbort for why this matters.
		 */</comment>
		<expr_stmt><expr><call><name>XLogSetAsyncXactLSN</name><argument_list>(<argument><expr><name>XactLastRecEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_TRANSACTION_ABORT</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let others know about no transaction in progress by me. Note that this
	 * must be done _before_ releasing locks we hold and _after_
	 * RecordTransactionAbort.
	 */</comment>
	<expr_stmt><expr><call><name>ProcArrayEndTransaction</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>, <argument><expr><name>latestXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post-abort cleanup.  See notes in CommitTransaction() concerning
	 * ordering.  We can skip all of it if the transaction failed before
	 * creating a resource owner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TopTransactionResourceOwner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_parallel_worker</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CallXactCallbacks</name><argument_list>(<argument><expr><name>XACT_EVENT_ABORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Buffers</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_RelationCache</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Inval</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_MultiXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrDoPendingDeletes</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_SPI</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Enum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_on_commit_actions</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Namespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_parallel_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_SMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Files</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_ComboCid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_HashTables</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_PgStat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_ApplyLauncher</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_xact_timestamp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBCAbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * State remains TRANS_ABORT until CleanupTransaction().
	 */</comment>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	CleanupTransaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * State should still be TRANS_ABORT from AbortTransaction().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"CleanupTransaction: unexpected state %s"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * do abort cleanup processing
	 */</comment>
	<expr_stmt><expr><call><name>AtCleanup_Portals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* now safe to release portal memory */</comment>
	<expr_stmt><expr><call><name>AtEOXact_Snapshot</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* and release the transaction's snapshots */</comment>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* and resource owner */</comment>
	<if_stmt><if>if <condition>(<expr><name>TopTransactionResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name>TopTransactionResourceOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>TopTransactionResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtCleanup_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* and transaction memory */</comment>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>maxChildXids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactTopTransactionId</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nParallelCurrentXids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * done with abort processing, set current transaction state back to
	 * default
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	StartTransactionCommandInternal
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartTransactionCommandInternal</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>yb_skip_read_committed_handling</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * if we aren't in a transaction block, we just do our usual start
			 * transaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
			<expr_stmt><expr><call><name>StartTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_STARTED</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are somewhere in a transaction block or subtransaction and
			 * about to start a new command.  For now we do nothing, but
			 * someday we may do command-local resource initialization. (Note
			 * that any needed CommandCounterIncrement was done by the
			 * previous CommitTransactionCommand.)
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<comment type="block">/*
			 * YB specific logic.
			 *
			 * For READ COMMITTED isolation, we want to reset the read point to current ht time so that
			 * the query works on a newer snapshot that will include all txns committed before this
			 * command.
			 *
			 * Read restart handling per statement
			 * -----------------------------------
			 * Note that by "all txns committed before this command" we intend to include any txn that
			 * might have been committed before the statement was issued, as per real time (i.e., as
			 * perceived by any client).
			 *
			 * Since there might be clock skew, during a read, if a txn participant finds committed
			 * records with ht after the chosen read ht and is unsure if the records were committed before
			 * the client issued read (as per real time), a kReadRestart will be received by postgres.
			 *
			 * Read restart retries are handled transparently for every statement in the txn in
			 * yb_attempt_to_restart_on_error().
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>YBTransactionsEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsYBReadCommitted</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>yb_skip_read_committed_handling</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Reset field ybDataSentForCurrQuery (indicates whether any data was sent as part of the
				 * current query). This helps track if automatic restart of a query is possible in
				 * READ COMMITTED isolation level.
				 */</comment>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Create a new internal sub txn before any execution. This aids in rolling back any changes
				 * before restarting the statement.
				 *
				 * We don't rely on the name of the internal sub transaction for rolling back to it in
				 * yb_attempt_to_restart_on_error(). We just assert that the name of the current sub txn
				 * matches before calling RollbackAndReleaseCurrentSubTransaction() to restart the
				 * statement.
				 *
				 * Instead of calling BeginInternalSubTransaction(), we have copy-pasted necessary logic
				 * into a new function since BeginInternalSubTransaction() again calls
				 * CommitTransactionCommand() and StartTransactionCommand() which will result in recursion.
				 * We could have solved the recursion problem by plumbing a flag to skip calling
				 * BeginInternalSubTransaction() again, but it is simpler and less error-prone to just copy
				 * the minimal required logic.
				 */</comment>
				<expr_stmt><expr><call><name>BeginInternalSubTransactionForReadCommittedStatement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>

			<comment type="block">/*
			 * Here we are in a failed transaction block (one of the commands
			 * caused an abort) so we do nothing but remain in the abort
			 * state.  Eventually we will get a ROLLBACK command which will
			 * get us out of this state.  (It is up to other code to ensure
			 * that no commands other than ROLLBACK will be processed in these
			 * states.)
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"StartTransactionCommand: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * We must switch to CurTransactionContext before returning. This is
	 * already done if we called StartTransaction, otherwise not.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurTransactionContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	StartTransactionCommand
 */</comment>
<function><type><name>void</name></type>
<name>StartTransactionCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartTransactionCommandInternal</name><argument_list>(<argument><expr><name>false</name></expr></argument> <comment type="block">/* yb_skip_read_committed_handling */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetTxnWithPGRel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	 * YB doesn't support subtransactions for now and only top level transaction is committed.
	 * So the isYBTxnWithPostgresRel flag must be set on current and all top level transactions.
	 */</comment>
	<while>while <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>isYBTxnWithPostgresRel</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>isYBTxnWithPostgresRel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsCurrentTxnWithPGRel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>isYBTxnWithPostgresRel</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	CommitTransactionCommand
 */</comment>
<function><type><name>void</name></type>
<name>CommitTransactionCommand</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * These shouldn't happen.  TBLOCK_DEFAULT means the previous
			 * StartTransactionCommand didn't set the STARTED state
			 * appropriately, while TBLOCK_PARALLEL_INPROGRESS should be ended
			 * by EndParallelWorkerTransaction(), not this function.
			 */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"CommitTransactionCommand: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * If we aren't in a transaction block, just do our usual
			 * transaction commit, and return to the idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are completing a "BEGIN TRANSACTION" command, so we change
			 * to the "transaction block in progress" state and return.  (We
			 * assume the BEGIN did nothing to the database, so we need no
			 * CommandCounterIncrement.)
			 */</comment>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_INPROGRESS</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * This is the case when we have finished executing a command
			 * someplace within a transaction block.  We increment the command
			 * counter and return.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are completing a "COMMIT" command.  Do it and return to the
			 * idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
			<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Here we are in the middle of a transaction block but one of the
			 * commands caused an abort so we do nothing but remain in the
			 * abort state.  Eventually we will get a ROLLBACK command.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/*
			 * Here we were in an aborted transaction block and we just got
			 * the ROLLBACK command from the user, so clean up the
			 * already-aborted transaction and return to the idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Here we were in a perfectly good transaction block but the user
			 * told us to ROLLBACK anyway.  We have to abort the transaction
			 * and then clean up.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are completing a "PREPARE TRANSACTION" command.  Do it and
			 * return to the idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>PrepareTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We were just issued a SAVEPOINT inside a transaction block.
			 * Start a subtransaction.  (DefineSavepoint already did
			 * PushTransaction, so as to have someplace to put the SUBBEGIN
			 * state.)
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
			<expr_stmt><expr><call><name>StartSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We were issued a RELEASE command, so we end the current
			 * subtransaction and return to the parent transaction. The parent
			 * might be ended too, so repeat till we find an INPROGRESS
			 * transaction or subtransaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><call><name>CommitSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
			</block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBRELEASE</name></expr>)</condition>;</do>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name> <operator>||</operator>
				   <name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We were issued a COMMIT, so we end the current subtransaction
			 * hierarchy and perform final commit. We do this by rolling up
			 * any subtransactions into their parent, which leads to O(N^2)
			 * operations with respect to resource owners - this isn't that
			 * bad until we approach a thousands of savepoints but is
			 * necessary for correctness should after triggers create new
			 * resource owners.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><call><name>CommitSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
			</block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBCOMMIT</name></expr>)</condition>;</do>
			<comment type="block">/* If we had a COMMIT command, finish off the main xact too */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_END</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_PREPARE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PrepareTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CommitTransactionCommand: unexpected state %s"</literal></expr></argument>,
					 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The current already-failed subtransaction is ending due to a
			 * ROLLBACK or ROLLBACK TO command, so pop it and recursively
			 * examine the parent (which could be in any of several states).
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
			<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * As above, but it's not dead yet, so abort first.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The current subtransaction is the target of a ROLLBACK TO
			 * command.  Abort and pop it, then start a new subtransaction
			 * with the same name.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>savepointLevel</name></decl>;</decl_stmt>

				<comment type="block">/* save name and keep Cleanup from freeing it */</comment>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>savepointLevel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>DefineSavepoint</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by push */</comment>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name> <operator>=</operator> <name>savepointLevel</name></expr>;</expr_stmt>

				<comment type="block">/* This is the same as TBLOCK_SUBBEGIN case */</comment>
				<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>StartSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

			<comment type="block">/*
			 * Same as above, but the subtransaction had already failed, so we
			 * don't need AbortSubTransaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>savepointLevel</name></decl>;</decl_stmt>

				<comment type="block">/* save name and keep Cleanup from freeing it */</comment>
				<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>savepointLevel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>DefineSavepoint</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by push */</comment>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name> <operator>=</operator> <name>savepointLevel</name></expr>;</expr_stmt>

				<comment type="block">/* This is the same as TBLOCK_SUBBEGIN case */</comment>
				<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBBEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>StartSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	AbortCurrentTransaction
 */</comment>
<function><type><name>void</name></type>
<name>AbortCurrentTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_DEFAULT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we are idle, so nothing to do */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We can get here after an error during transaction start
				 * (state will be TRANS_START).  Need to clean up the
				 * incompletely started transaction.  First, adjust the
				 * low-level state to suppress warning message from
				 * AbortTransaction.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_START</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * If we aren't in a transaction block, we just do the basic abort
			 * &amp; cleanup transaction.  For this purpose, we treat an implicit
			 * transaction block as if it were a simple statement.
			 */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * If we are in TBLOCK_BEGIN it means something screwed up right
			 * after reading "BEGIN TRANSACTION".  We assume that the user
			 * will interpret the error as meaning the BEGIN failed to get him
			 * into a transaction block, so we should abort and return to idle
			 * state.
			 */</comment>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are somewhere in a transaction block and we've gotten a
			 * failure, so we abort the transaction and set up the persistent
			 * ABORT state.  We will stay in ABORT until we get a ROLLBACK.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT</name></expr>;</expr_stmt>
			<comment type="block">/* CleanupTransaction happens when we exit TBLOCK_ABORT_END */</comment>
			<break>break;</break>

			<comment type="block">/*
			 * Here, we failed while trying to COMMIT.  Clean up the
			 * transaction and return to idle state (we do not want to stay in
			 * the transaction).
			 */</comment>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Here, we are already in an aborted transaction state and are
			 * waiting for a ROLLBACK, but for some reason we failed again! So
			 * we just remain in the abort state.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/*
			 * We are in a failed transaction and we got the ROLLBACK command.
			 * We have already aborted, we just need to cleanup and go to idle
			 * state.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are in a live transaction and we got a ROLLBACK command.
			 * Abort, cleanup, go to idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Here, we failed while trying to PREPARE.  Clean up the
			 * transaction and return to idle state (we do not want to stay in
			 * the transaction).
			 */</comment>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We got an error inside a subtransaction.  Abort just the
			 * subtransaction, and go to the persistent SUBABORT state until
			 * we get ROLLBACK.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * If we failed while trying to create a subtransaction, clean up
			 * the broken subtransaction and abort the parent.  The same
			 * applies if we get a failure while ending a subtransaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
			<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Same as above, except the Abort() was already done.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
			<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	PreventInTransactionBlock
 *
 *	This routine is to be called by statements that must not run inside
 *	a transaction block, typically because they have non-rollback-able
 *	side effects or do internal commits.
 *
 *	If we have already started a transaction block, issue an error; also issue
 *	an error if we appear to be running inside a user-defined function (which
 *	could issue more commands and possibly cause a failure after the statement
 *	completes).  Subtransactions are verboten too.
 *
 *	isTopLevel: passed down from ProcessUtility to determine whether we are
 *	inside a function.  (We will always fail if this is false, but it's
 *	convenient to centralize the check here instead of making callers do it.)
 *	stmtType: statement type name, for error messages.
 */</comment>
<function><type><name>void</name></type>
<name>PreventInTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * xact block already started?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s represents an SQL statement name */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot run inside a transaction block"</literal></expr></argument>,
						<argument><expr><name>stmtType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * subtransaction?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s represents an SQL statement name */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot run inside a subtransaction"</literal></expr></argument>,
						<argument><expr><name>stmtType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * inside a function call?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isTopLevel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s represents an SQL statement name */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be executed from a function"</literal></expr></argument>, <argument><expr><name>stmtType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we got past IsTransactionBlock test, should be in default state */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_DEFAULT</name> <operator>&amp;&amp;</operator>
		<name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"cannot prevent transaction chain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* all okay */</comment>
</block_content>}</block></function>

<comment type="block">/*
 *	WarnNoTranactionBlock
 *	RequireTransactionBlock
 *
 *	These two functions allow for warnings or errors if a command is executed
 *	outside of a transaction block.  This is useful for commands that have no
 *	effects that persist past transaction end (and so calling them outside a
 *	transaction block is presumably an error).  DECLARE CURSOR is an example.
 *	While top-level transaction control commands (BEGIN/COMMIT/ABORT) and SET
 *	that have no effect issue warnings, all other no-effect commands generate
 *	errors.
 *
 *	If we appear to be running inside a user-defined function, we do not
 *	issue anything, since the function could issue more commands that make
 *	use of the current statement's results.  Likewise subtransactions.
 *	Thus these are inverses for PreventInTransactionBlock.
 *
 *	isTopLevel: passed down from ProcessUtility to determine whether we are
 *	inside a function.
 *	stmtType: statement type name, for warning or error messages.
 */</comment>
<function><type><name>void</name></type>
<name>WarnNoTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>stmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RequireTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is the implementation of the above two.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>throwError</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * xact block already started?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * subtransaction?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * inside a function call?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isTopLevel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>throwError</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
	<comment type="block">/* translator: %s represents an SQL statement name */</comment>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be used in transaction blocks"</literal></expr></argument>,
					<argument><expr><name>stmtType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	IsInTransactionBlock
 *
 *	This routine is for statements that need to behave differently inside
 *	a transaction block than when running as single commands.  ANALYZE is
 *	currently the only example.
 *
 *	isTopLevel: passed down from ProcessUtility to determine whether we are
 *	inside a function.
 */</comment>
<function><type><name>bool</name></type>
<name>IsInTransactionBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Return true on same conditions that would make
	 * PreventInTransactionBlock error out
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSubTransaction</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isTopLevel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_DEFAULT</name> <operator>&amp;&amp;</operator>
		<name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Register or deregister callback functions for start- and end-of-xact
 * operations.
 *
 * These functions are intended for use by dynamically loaded modules.
 * For built-in modules we generally just hardwire the appropriate calls
 * (mainly because it's easier to control the order that way, where needed).
 *
 * At transaction end, the callback occurs post-commit or post-abort, so the
 * callback functions can only do noncritical cleanup.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterXactCallback</name><parameter_list>(<parameter><decl><type><name>XactCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>XactCallbackItem</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XactCallbackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>Xact_callbacks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>Xact_callbacks</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UnregisterXactCallback</name><parameter_list>(<parameter><decl><type><name>XactCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XactCallbackItem</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>Xact_callbacks</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>prev</name> <operator>=</operator> <name>item</name></expr><operator>,</operator> <expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>==</operator> <name>callback</name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>arg</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>Xact_callbacks</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CallXactCallbacks</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>Xact_callbacks</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Register or deregister callback functions for start- and end-of-subxact
 * operations.
 *
 * Pretty much same as above, but for subtransaction events.
 *
 * At subtransaction end, the callback occurs post-subcommit or post-subabort,
 * so the callback functions can only do noncritical cleanup.  At
 * subtransaction start, the callback is called when the subtransaction has
 * finished initializing.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterSubXactCallback</name><parameter_list>(<parameter><decl><type><name>SubXactCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubXactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>SubXactCallbackItem</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubXactCallbackItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>SubXact_callbacks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SubXact_callbacks</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UnregisterSubXactCallback</name><parameter_list>(<parameter><decl><type><name>SubXactCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubXactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubXactCallbackItem</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>SubXact_callbacks</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>prev</name> <operator>=</operator> <name>item</name></expr><operator>,</operator> <expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>==</operator> <name>callback</name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>arg</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>SubXact_callbacks</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CallSubXactCallbacks</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>,
					 <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					 <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubXactCallbackItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>SubXact_callbacks</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>mySubid</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *					   transaction block support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 *	BeginTransactionBlock
 *		This executes a BEGIN command.
 */</comment>
<function><type><name>void</name></type>
<name>BeginTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We are not inside a transaction block, so allow one to begin.
			 */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_BEGIN</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * BEGIN converts an implicit transaction block to a regular one.
			 * (Note that we allow this even if we've already done some
			 * commands, which is a bit odd but matches historical practice.)
			 */</comment>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_BEGIN</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Already a transaction block in progress.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is already a transaction in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"BeginTransactionBlock: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 *	PrepareTransactionBlock
 *		This executes a PREPARE command.
 *
 * Since PREPARE may actually do a ROLLBACK, the result indicates what
 * happened: true for PREPARE, false for ROLLBACK.
 *
 * Note that we don't actually do anything here except change blockState.
 * The real work will be done in the upcoming PrepareTransaction().
 * We do it this way because it's not convenient to change memory context,
 * resource owner, etc while executing inside a Portal.
 */</comment>
<function><type><name>bool</name></type>
<name>PrepareTransactionBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Set up to commit the current transaction */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>EndTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If successful, change outer tblock state to PREPARE */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_END</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Save GID where PrepareTransaction can find it again */</comment>
			<expr_stmt><expr><name>prepareGID</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_PREPARE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * ignore case where we are not in a transaction;
			 * EndTransactionBlock already issued a warning.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_STARTED</name> <operator>||</operator>
				   <name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_IMPLICIT_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Don't send back a PREPARE result tag... */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	EndTransactionBlock
 *		This executes a COMMIT command.
 *
 * Since COMMIT may actually do a ROLLBACK, the result indicates what
 * happened: true for COMMIT, false for ROLLBACK.
 *
 * Note that we don't actually do anything here except change blockState.
 * The real work will be done in the upcoming CommitTransactionCommand().
 * We do it this way because it's not convenient to change memory context,
 * resource owner, etc while executing inside a Portal.
 */</comment>
<function><type><name>bool</name></type>
<name>EndTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We are in a transaction block, so tell CommitTransactionCommand
			 * to COMMIT.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_END</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * In an implicit transaction block, commit, but issue a warning
			 * because there was no explicit BEGIN before this.
			 */</comment>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no transaction in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_END</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are in a failed transaction block.  Tell
			 * CommitTransactionCommand it's time to exit the block.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_END</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are in a live subtransaction block.  Set up to subcommit all
			 * open subtransactions and then commit the main transaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBCOMMIT</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"EndTransactionBlock: unexpected state %s"</literal></expr></argument>,
						 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_END</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"EndTransactionBlock: unexpected state %s"</literal></expr></argument>,
					 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Here we are inside an aborted subtransaction.  Treat the COMMIT
			 * as ROLLBACK: set up to abort everything and exit the main
			 * transaction.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_PENDING</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBABORT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_END</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"EndTransactionBlock: unexpected state %s"</literal></expr></argument>,
						 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_PENDING</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_END</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"EndTransactionBlock: unexpected state %s"</literal></expr></argument>,
					 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The user issued COMMIT when not inside a transaction.  Issue a
			 * WARNING, staying in TBLOCK_STARTED state.  The upcoming call to
			 * CommitTransactionCommand() will then close the transaction and
			 * put us back into the default state.
			 */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no transaction in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The user issued a COMMIT that somehow ran inside a parallel
			 * worker.  We can't cope with that.
			 */</comment>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot commit during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"EndTransactionBlock: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	UserAbortTransactionBlock
 *		This executes a ROLLBACK command.
 *
 * As above, we don't actually do anything here except change blockState.
 */</comment>
<function><type><name>void</name></type>
<name>UserAbortTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We are inside a transaction block and we got a ROLLBACK command
			 * from the user, so tell CommitTransactionCommand to abort and
			 * exit the transaction block.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_PENDING</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are inside a failed transaction block and we got a ROLLBACK
			 * command from the user.  Abort processing is already done, so
			 * CommitTransactionCommand just has to cleanup and go back to
			 * idle state.
			 */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_END</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are inside a subtransaction.  Mark everything up to top
			 * level as exitable.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<while>while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_PENDING</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBABORT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_END</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"UserAbortTransactionBlock: unexpected state %s"</literal></expr></argument>,
						 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_PENDING</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_END</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"UserAbortTransactionBlock: unexpected state %s"</literal></expr></argument>,
					 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The user issued ABORT when not inside a transaction. Issue a
			 * WARNING and go to abort state.  The upcoming call to
			 * CommitTransactionCommand() will then put us back into the
			 * default state.
			 *
			 * We do the same thing with ABORT inside an implicit transaction,
			 * although in this case we might be rolling back actual database
			 * state changes.  (It's debatable whether we should issue a
			 * WARNING in this case, but we have done so historically.)
			 */</comment>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no transaction in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_ABORT_PENDING</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * The user issued an ABORT that somehow ran inside a parallel
			 * worker.  We can't cope with that.
			 */</comment>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot abort during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"UserAbortTransactionBlock: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * BeginImplicitTransactionBlock
 *		Start an implicit transaction block if we're not already in one.
 *
 * Unlike BeginTransactionBlock, this is called directly from the main loop
 * in postgres.c, not within a Portal.  So we can just change blockState
 * without a lot of ceremony.  We do not expect caller to do
 * CommitTransactionCommand/StartTransactionCommand.
 */</comment>
<function><type><name>void</name></type>
<name>BeginImplicitTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are in STARTED state (that is, no transaction block is open),
	 * switch to IMPLICIT_INPROGRESS state, creating an implicit transaction
	 * block.
	 *
	 * For caller convenience, we consider all other transaction states as
	 * legal here; otherwise the caller would need its own state check, which
	 * seems rather pointless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EndImplicitTransactionBlock
 *		End an implicit transaction block, if we're in one.
 *
 * Like EndTransactionBlock, we just make any needed blockState change here.
 * The real work will be done in the upcoming CommitTransactionCommand().
 */</comment>
<function><type><name>void</name></type>
<name>EndImplicitTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are in IMPLICIT_INPROGRESS state, switch back to STARTED state,
	 * allowing CommitTransactionCommand to commit whatever happened during
	 * the implicit transaction block as though it were a single statement.
	 *
	 * For caller convenience, we consider all other transaction states as
	 * legal here; otherwise the caller would need its own state check, which
	 * seems rather pointless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_STARTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DefineSavepoint
 *		This executes a SAVEPOINT command.
 */</comment>
<function><type><name>void</name></type>
<name>DefineSavepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for new subtransactions after that
	 * point.  (Note that this check will certainly error out if s-&gt;blockState
	 * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case
	 * below.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot define savepoints during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<comment type="block">/* Normal subtransaction start */</comment>
			<expr_stmt><expr><call><name>PushTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by push */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"new sub txn created by savepoint, subtxn_id: %d"</literal></expr></argument>,
					 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Savepoint names, like the TransactionState block itself, live
			 * in TopTransactionContext.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We disallow savepoint commands in implicit transaction blocks.
			 * There would be no great difficulty in allowing them so far as
			 * this module is concerned, but a savepoint seems inconsistent
			 * with exec_simple_query's behavior of abandoning the whole query
			 * string upon error.  Also, the point of an implicit transaction
			 * block (as opposed to a regular one) is to automatically close
			 * after an error, so it's hard to see how a savepoint would fit
			 * into that.
			 *
			 * The error messages for this are phrased as if there were no
			 * active transaction block at all, which is historical but
			 * perhaps could be improved.
			 */</comment>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s represents an SQL statement name */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be used in transaction blocks"</literal></expr></argument>,
							<argument><expr><literal type="string">"SAVEPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"DefineSavepoint: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseSavepoint
 *		This executes a RELEASE command.
 *
 * As above, we don't actually do anything here except change blockState.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseSavepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>target</name></decl>,
				<decl><type ref="prev"/><name>xact</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for transaction state change after that
	 * point.  (Note that this check will certainly error out if s-&gt;blockState
	 * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case
	 * below.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot release savepoints during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We can't release a savepoint if there is no savepoint defined.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<comment type="block">/* See comment about implicit transactions in DefineSavepoint */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s represents an SQL statement name */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be used in transaction blocks"</literal></expr></argument>,
							<argument><expr><literal type="string">"RELEASE SAVEPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * We are in a non-aborted subtransaction.  This is the only valid
			 * case.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"ReleaseSavepoint: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>target</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* disallow crossing savepoint level boundaries */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>savepointLevel</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist within current savepoint level"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark "commit pending" all subtransactions up to the target
	 * subtransaction.  The actual commits will happen when control gets to
	 * CommitTransactionCommand.
	 */</comment>
	<expr_stmt><expr><name>xact</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBRELEASE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>xact</name> <operator>==</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>xact</name> <operator>=</operator> <name><name>xact</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>xact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * RollbackToSavepoint
 *		This executes a ROLLBACK TO &lt;savepoint&gt; command.
 *
 * As above, we don't actually do anything here except change blockState.
 */</comment>
<function><type><name>void</name></type>
<name>RollbackToSavepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>target</name></decl>,
				<decl><type ref="prev"/><name>xact</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for transaction state change after that
	 * point.  (Note that this check will certainly error out if s-&gt;blockState
	 * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case
	 * below.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot rollback to savepoints during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * We can't rollback to a savepoint if there is no savepoint
			 * defined.
			 */</comment>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<comment type="block">/* See comment about implicit transactions in DefineSavepoint */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NO_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: %s represents an SQL statement name */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s can only be used in transaction blocks"</literal></expr></argument>,
							<argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * There is at least one savepoint, so proceed.
			 */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RollbackToSavepoint: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>target</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>target</name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* disallow crossing savepoint level boundaries */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>savepointLevel</name></name> <operator>!=</operator> <name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_S_E_INVALID_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"savepoint \"%s\" does not exist within current savepoint level"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark "abort pending" all subtransactions up to the target
	 * subtransaction.  The actual aborts will happen when control gets to
	 * CommitTransactionCommand.
	 */</comment>
	<expr_stmt><expr><name>xact</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>xact</name> <operator>==</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_PENDING</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBABORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_END</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RollbackToSavepoint: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>xact</name> <operator>=</operator> <name><name>xact</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>xact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* And mark the target as "restart pending" */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBRESTART</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBABORT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBABORT_RESTART</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RollbackToSavepoint: unexpected state %s"</literal></expr></argument>,
			 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>xact</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>YBCRollbackToSubTransaction</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BeginInternalSubTransaction
 *		This is the same as DefineSavepoint except it allows TBLOCK_STARTED,
 *		TBLOCK_IMPLICIT_INPROGRESS, TBLOCK_END, and TBLOCK_PREPARE states,
 *		and therefore it can safely be used in functions that might be called
 *		when not inside a BEGIN block or when running deferred triggers at
 *		COMMIT/PREPARE time.  Also, it automatically does
 *		CommitTransactionCommand/StartTransactionCommand instead of expecting
 *		the caller to do it.
 */</comment>
<function><type><name>void</name></type>
<name>BeginInternalSubTransaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The subtransaction corresponding to the buffered operations must be
	 * current and in the INPROGRESS state for correct error handling.
	 * An error thrown while/after switching over to a new subtransaction
	 * would lead to a fatal error or unpredictable behavior.
	 */</comment>
	<expr_stmt><expr><call><name>YBFlushBufferedOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for new subtransactions after that
	 * point. We might be able to make an exception for the type of
	 * subtransaction established by this function, which is typically used in
	 * contexts where we're going to release or roll back the subtransaction
	 * before proceeding further, so that no enduring change to the
	 * transaction state occurs. For now, however, we prohibit this case along
	 * with all the others.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot start subtransactions during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<comment type="block">/* Normal subtransaction start */</comment>
			<expr_stmt><expr><call><name>PushTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by push */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"new sub txn created internally, subtxn_id: %d"</literal></expr></argument>,
					 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Savepoint names, like the TransactionState block itself, live
			 * in TopTransactionContext.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"BeginInternalSubTransaction: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommandInternal</name><argument_list>(<argument><expr><name>true</name></expr></argument> <comment type="block">/* yb_skip_read_committed_handling */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BeginInternalSubTransactionForReadCommittedStatement
 *		This is similar to BeginInternalSubTransaction() but doesn't call CommitTransactionCommand()
 *    and StartTransactionCommand(). It is okay to not call those since this method is called only
 *    in 2 specific cases (i.e., when starting a new statement in an already existing txn in
 *    READ COMMITED mode, or when rolling back to the internal sub txn while restarting a
 *    statement) and both cases satisfy the following property -
 *      CurrentTransactionState-&gt;blockState is TBLOCK_INPROGRESS, TBLOCK_IMPLICIT_INPROGRESS or
 *			TBLOCK_SUBINPROGRESS.
 */</comment>
<function><type><name>void</name></type>
<name>BeginInternalSubTransactionForReadCommittedStatement</name><parameter_list>()</parameter_list> <block>{<block_content>

	<expr_stmt><expr><call><name>YBFlushBufferedOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name> <operator>||</operator>
				 <name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_IMPLICIT_INPROGRESS</name> <operator>||</operator>
				 <name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot start subtransactions during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Normal subtransaction start */</comment>
	<expr_stmt><expr><call><name>PushTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by push */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"new internal sub txn in READ COMMITTED subtxn_id: %d"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>, <argument><expr><name>YB_READ_COMMITTED_INTERNAL_SUB_TXN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseCurrentSubTransaction
 *
 * RELEASE (ie, commit) the innermost subtransaction, regardless of its
 * savepoint name (if any).
 * NB: do NOT use CommitTransactionCommand/StartTransactionCommand with this.
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseCurrentSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The subtransaction corresponding to the buffered operations must be
	 * current and in the INPROGRESS state for correct error handling.
	 * An error thrown while/after commiting/releasing it would lead to a
	 * fatal error or unpredictable behavior.
	 */</comment>
	<expr_stmt><expr><call><name>YBFlushBufferedOperations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for commit of subtransactions after that
	 * point.  This should not happen anyway.  Code calling this would
	 * typically have called BeginInternalSubTransaction() first, failing
	 * there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot commit subtransactions during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ReleaseCurrentSubTransaction: unexpected state %s"</literal></expr></argument>,
			 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RollbackAndReleaseCurrentSubTransaction
 *
 * ROLLBACK and RELEASE (ie, abort) the innermost subtransaction, regardless
 * of its savepoint name (if any).
 * NB: do NOT use CommitTransactionCommand/StartTransactionCommand with this.
 */</comment>
<function><type><name>void</name></type>
<name>RollbackAndReleaseCurrentSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unlike ReleaseCurrentSubTransaction(), this is nominally permitted
	 * during parallel operations.  That's because we may be in the master,
	 * recovering from an error thrown while we were in parallel mode.  We
	 * won't reach here in a worker, because BeginInternalSubTransaction()
	 * will have failed.
	 */</comment>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* Must be in a subtransaction */</comment>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<break>break;</break>

			<comment type="block">/* These cases are invalid. */</comment>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RollbackAndReleaseCurrentSubTransaction: unexpected state %s"</literal></expr></argument>,
				 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Abort the current subtransaction, if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And clean it up, too */</comment>
	<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_SUBINPROGRESS</name> <operator>||</operator>
				<name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_INPROGRESS</name> <operator>||</operator>
				<name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_IMPLICIT_INPROGRESS</name> <operator>||</operator>
				<name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	AbortOutOfAnyTransaction
 *
 *	This routine is provided for error recovery purposes.  It aborts any
 *	active transaction or transaction block, leaving the system in a known
 *	idle state.
 */</comment>
<function><type><name>void</name></type>
<name>AbortOutOfAnyTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure we're not running in a doomed memory context */</comment>
	<expr_stmt><expr><call><name>AtAbort_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get out of any transaction or nested transaction
	 */</comment>
	<do>do
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Not in a transaction, do nothing */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We can get here after an error during transaction start
					 * (state will be TRANS_START).  Need to clean up the
					 * incompletely started transaction.  First, adjust the
					 * low-level state to suppress warning message from
					 * AbortTransaction.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TRANS_START</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_INPROGRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
			<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
			<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<case>case <expr><name>TBLOCK_END</name></expr>:</case>
			<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
			<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
				<comment type="block">/* In a transaction, so clean up */</comment>
				<expr_stmt><expr><call><name>AbortTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
			<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>

				<comment type="block">/*
				 * AbortTransaction is already done, still need Cleanup.
				 * However, if we failed partway through running ROLLBACK,
				 * there will be an active portal running that command, which
				 * we need to shut down before doing CleanupTransaction.
				 */</comment>
				<expr_stmt><expr><call><name>AtAbort_Portals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CleanupTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/*
				 * In a subtransaction, so clean it up and abort parent too
				 */</comment>
			<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
				<expr_stmt><expr><call><name>AbortSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
				<break>break;</break>

			<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
			<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
				<comment type="block">/* As above, but AbortSubTransaction already done */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* As in TBLOCK_ABORT, might have a live portal to zap */</comment>
					<expr_stmt><expr><call><name>AtSubAbort_Portals</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
									   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
									   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
									   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>CleanupSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</expr_stmt>	<comment type="block">/* changed by pop */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block> while <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>!=</operator> <name>TBLOCK_DEFAULT</name></expr>)</condition>;</do>

	<comment type="block">/* Should be out of all subxacts now */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we didn't actually have anything to do, revert to TopMemoryContext */</comment>
	<expr_stmt><expr><call><name>AtCleanup_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IsTransactionBlock --- are we within a transaction block?
 */</comment>
<function><type><name>bool</name></type>
<name>IsTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_DEFAULT</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsTransactionOrTransactionBlock --- are we within either a transaction
 * or a transaction block?	(The backend is only really "idle" when this
 * returns false.)
 *
 * This should match up with IsTransactionBlock and IsTransactionState.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTransactionOrTransactionBlock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TransactionBlockStatusCode - return status code to send in ReadyForQuery
 */</comment>
<function><type><name>char</name></type>
<name>TransactionBlockStatusCode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<return>return <expr><literal type="char">'I'</literal></expr>;</return>			<comment type="block">/* idle --- not in transaction */</comment>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<return>return <expr><literal type="char">'T'</literal></expr>;</return>			<comment type="block">/* in transaction */</comment>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
			<return>return <expr><literal type="char">'E'</literal></expr>;</return>			<comment type="block">/* in failed transaction */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* should never get here */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid transaction block state: %s"</literal></expr></argument>,
		 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * IsSubTransaction
 */</comment>
<function><type><name>bool</name></type>
<name>IsSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StartSubTransaction
 *
 * If you're wondering why this is separate from PushTransaction: it's because
 * we can't conveniently do this stuff right inside DefineSavepoint.  The
 * SAVEPOINT utility command will be executed inside a Portal, and if we
 * muck with GetCurrentMemoryContext() or CurrentResourceOwner then exit from
 * the Portal will undo those settings.  So we make DefineSavepoint just
 * push a dummy transaction block, and when control returns to the main
 * idle loop, CommitTransactionCommand will be called, and we'll come here
 * to finish starting the subtransaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"StartSubTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_START</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize subsystems for new subtransaction
	 *
	 * must initialize resource-management stuff first
	 */</comment>
	<expr_stmt><expr><call><name>AtSubStart_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubStart_ResourceOwner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubStart_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AfterTriggerBeginSubXact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_INPROGRESS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call start-of-subxact callbacks
	 */</comment>
	<expr_stmt><expr><call><name>CallSubXactCallbacks</name><argument_list>(<argument><expr><name>SUBXACT_EVENT_START_SUB</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"StartSubTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CommitSubTransaction
 *
 *	The caller has to make sure to always reassign CurrentTransactionState
 *	if it has a local pointer to it after calling this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CommitSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"CommitSubTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"CommitSubTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Pre-commit processing goes here */</comment>

	<expr_stmt><expr><call><name>CallSubXactCallbacks</name><argument_list>(<argument><expr><name>SUBXACT_EVENT_PRE_COMMIT_SUB</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If in parallel mode, clean up workers and exit parallel mode. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AtEOSubXact_Parallel</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do the actual "commit", such as it is */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_COMMIT</name></expr>;</expr_stmt>

	<comment type="block">/* Must CCI to ensure commands of subtransaction are seen as done */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prior to 8.4 we marked subcommit in clog at this point.  We now only
	 * perform that step, if required, as part of the atomic update of the
	 * whole transaction tree at top level commit or abort.
	 */</comment>

	<comment type="block">/* Post-commit cleanup */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AtSubCommit_childXids</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>AfterTriggerEndSubXact</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubCommit_Portals</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_LargeObject</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
							<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubCommit_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CallSubXactCallbacks</name><argument_list>(<argument><expr><name>SUBXACT_EVENT_COMMIT_SUB</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_RelationCache</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
							  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_Inval</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubCommit_smgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The only lock we actually release here is the subtransaction XID lock.
	 */</comment>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XactLockTableDelete</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Other locks should get transferred to their parent resource owner.
	 */</comment>
	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
						 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
						 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_SPI</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_on_commit_actions</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
								  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_Namespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_Files</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
					  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_HashTables</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_PgStat</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubCommit_Snapshot</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtEOSubXact_ApplyLauncher</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to restore the upper transaction's read-only state, in case the
	 * upper is read-write while the child is read-only; GUC will incorrectly
	 * think it should leave the child state in place.
	 */</comment>
	<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prevXactReadOnly</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtSubCommit_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AbortSubTransaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AbortSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Prevent cancel/die interrupt while cleaning up */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we have a valid memory context and resource owner */</comment>
	<expr_stmt><expr><call><name>AtSubAbort_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AtSubAbort_ResourceOwner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release any LW locks we might be holding as quickly as possible.
	 * (Regular locks, however, must be held till we finish aborting.)
	 * Releasing LW locks is critical since we might try to grab them again
	 * while cleaning up!
	 *
	 * FIXME This may be incorrect --- Are there some locks we should keep?
	 * Buffer locks, for example?  I don't think so but I'm not sure.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AbortBufferIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset WAL record construction state */</comment>
	<expr_stmt><expr><call><name>XLogResetInsertion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cancel condition variable sleep */</comment>
	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also clean up any open wait for lock, since the lock manager will choke
	 * if we try to wait for another lock before doing this.
	 */</comment>
	<expr_stmt><expr><call><name>LockErrorCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any timeout events are still active, make sure the timeout interrupt
	 * is scheduled.  This covers possible loss of a timeout interrupt due to
	 * longjmp'ing out of the SIGINT handler (see notes in handle_sig_alarm).
	 * We delay this till after LockErrorCleanup so that we don't uselessly
	 * reschedule lock or deadlock check timeouts.
	 */</comment>
	<expr_stmt><expr><call><name>reschedule_timeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-enable signals, in case we got here by longjmp'ing out of a signal
	 * handler.  We do this fairly early in the sequence so that the timeout
	 * infrastructure will be functional if needed while aborting.
	 */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check the current transaction state
	 */</comment>
	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"AbortSubTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_INPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"AbortSubTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_ABORT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset user ID which might have been changed transiently.  (See notes in
	 * AbortTransaction.)
	 */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>prevUser</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>prevSecContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Exit from parallel mode, if necessary. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AtEOSubXact_Parallel</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can skip all this stuff if the subxact failed before creating a
	 * ResourceOwner...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AfterTriggerEndSubXact</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtSubAbort_Portals</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
						   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_LargeObject</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
								<argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtSubAbort_Notify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Advertise the fact that we aborted in pg_xact. */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RecordTransactionAbort</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Post-abort cleanup */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AtSubAbort_childXids</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CallSubXactCallbacks</name><argument_list>(<argument><expr><name>SUBXACT_EVENT_ABORT_SUB</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
							 <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_RelationCache</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
								  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_Inval</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>,
							 <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtSubAbort_smgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_SPI</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_on_commit_actions</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
									  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_Namespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
							  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_Files</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
						  <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_HashTables</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_PgStat</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtSubAbort_Snapshot</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOSubXact_ApplyLauncher</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>YBCRollbackToSubTransaction</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore the upper transaction's read-only state, too.  This should be
	 * redundant with GUC's cleanup but we may as well do it for consistency
	 * with the commit case.
	 */</comment>
	<expr_stmt><expr><name>XactReadOnly</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>prevXactReadOnly</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CleanupSubTransaction
 *
 *	The caller has to make sure to always reassign CurrentTransactionState
 *	if it has a local pointer to it after calling this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CleanupSubTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ShowTransactionState</name><argument_list>(<argument><expr><literal type="string">"CleanupSubTransaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"CleanupSubTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AtSubCleanup_Portals</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResourceOwnerDelete</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>curTransactionOwner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AtSubCleanup_Memory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PushTransaction
 *		Create transaction state stack entry for a subtransaction
 *
 *	The caller has to make sure to always reassign CurrentTransactionState
 *	if it has a local pointer to it after calling this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PushTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>p</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We keep subtransaction state nodes in TopTransactionContext.
	 */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>TransactionState</name><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign a subtransaction ID, watching out for counter wraparound.
	 */</comment>
	<expr_stmt><expr><name>currentSubTransactionId</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentSubTransactionId</name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentSubTransactionId</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have more than 2^32-1 subtransactions in a transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can now stack a minimally valid subtransaction without fear of
	 * failure.
	 */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>	<comment type="block">/* until assigned */</comment>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name> <operator>=</operator> <name>currentSubTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>gucNestLevel</name></name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>savepointLevel</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>savepointLevel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TRANS_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_SUBBEGIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prevUser</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>prevSecContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>prevXactReadOnly</name></name> <operator>=</operator> <name>XactReadOnly</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>parallelModeLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentTransactionState</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBUpdateActiveSubTransaction</name><argument_list>(<argument><expr><name>CurrentTransactionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * AbortSubTransaction and CleanupSubTransaction have to be able to cope
	 * with the subtransaction from here on out; in particular they should not
	 * assume that it necessarily has a transaction context, resource owner,
	 * or XID.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * PopTransaction
 *		Pop back to parent transaction state
 *
 *	The caller has to make sure to always reassign CurrentTransactionState
 *	if it has a local pointer to it after calling this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>TRANS_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"PopTransaction while in %s state"</literal></expr></argument>,
			 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"PopTransaction with no parent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>CurrentTransactionState</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>YBUpdateActiveSubTransaction</name><argument_list>(<argument><expr><name>CurrentTransactionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let's just make sure CurTransactionContext is good */</comment>
	<expr_stmt><expr><name>CurTransactionContext</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ditto for ResourceOwner links */</comment>
	<expr_stmt><expr><name>CurTransactionResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>curTransactionOwner</name></name></expr>;</expr_stmt>

	<comment type="block">/* Free the old child structure */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EstimateTransactionStateSpace
 *		Estimate the amount of space that will be needed by
 *		SerializeTransactionState.  It would be OK to overestimate slightly,
 *		but it's simple for us to work out the precise value, so we do.
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateTransactionStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nxids</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* iso level, deferrable, top &amp; current XID,
								 * command counter, XID count */</comment>

	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><name>nParallelCurrentXids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SerializeTransactionState
 *		Write out relevant details of our transaction state that will be
 *		needed by a parallel worker.
 *
 * We need to save and restore XactDeferrable, XactIsoLevel, and the XIDs
 * associated with this transaction.  The first eight bytes of the result
 * contain XactDeferrable and XactIsoLevel; the next twelve bytes contain the
 * XID of the top-level transaction, the XID of the current transaction
 * (or, in each case, InvalidTransactionId if none), and the current command
 * counter.  After that, the next 4 bytes contain a count of how many
 * additional XIDs follow; this is followed by all of those XIDs one after
 * another.  We emit the XIDs in sorted order for the convenience of the
 * receiving process.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeTransactionState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nxids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>start_address</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <name>XactIsoLevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <name>XactDeferrable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>XactTopTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <name>currentCommandId</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxsize</name> <operator>&gt;=</operator> <name>c</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're running in a parallel worker and launching a parallel worker
	 * of our own, we can just pass along the information that was passed to
	 * us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nParallelCurrentXids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>nParallelCurrentXids</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxsize</name> <operator>&gt;=</operator> <operator>(</operator><name>nParallelCurrentXids</name> <operator>+</operator> <name>c</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name>ParallelCurrentXids</name></expr></argument>,
			   <argument><expr><name>nParallelCurrentXids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, we need to generate a sorted list of XIDs that our workers should
	 * view as current.  First, figure out how many there are.
	 */</comment>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nxids</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>nxids</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nxids</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>maxsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy them to our scratch space. */</comment>
	<expr_stmt><expr><name>workspace</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>CurrentTransactionState</name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workspace</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name></name></expr></argument>,
			   <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>nxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort them. */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>nxids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>xidComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy data into output area. */</comment>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>TransactionId</name><operator>)</operator> <name>nxids</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>nxids</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * StartParallelWorkerTransaction
 *		Start a parallel worker transaction, restoring the relevant
 *		transaction state serialized by SerializeTransactionState.
 */</comment>
<function><type><name>void</name></type>
<name>StartParallelWorkerTransaction</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tstatespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>tstate</name> <init>= <expr><operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator> <name>tstatespace</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>XactIsoLevel</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>tstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XactDeferrable</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator> <name><name>tstate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>XactTopTransactionId</name> <operator>=</operator> <name><name>tstate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name><name>tstate</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentCommandId</name> <operator>=</operator> <name><name>tstate</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nParallelCurrentXids</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>tstate</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ParallelCurrentXids</name> <operator>=</operator> <operator>&amp;</operator><name><name>tstate</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_PARALLEL_INPROGRESS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EndParallelWorkerTransaction
 *		End a parallel worker transaction.
 */</comment>
<function><type><name>void</name></type>
<name>EndParallelWorkerTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>==</operator> <name>TBLOCK_PARALLEL_INPROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>blockState</name></name> <operator>=</operator> <name>TBLOCK_DEFAULT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ShowTransactionState
 *		Debug support
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowTransactionState</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* skip work if message will definitely not be printed */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name> <operator>||</operator> <name>client_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowTransactionStateRec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>CurrentTransactionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ShowTransactionStateRec
 *		Recursive subroutine for ShowTransactionState
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowTransactionStateRec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>TransactionState</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", children: %u"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>childXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowTransactionStateRec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* use ereport to suppress computation if msg will not be printed */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s(%d) name: %s; blockState: %s; "</literal>
							 <literal type="string">"state: %s, ybDataSent: %s, ybDataSentForCurrQuery: %s, "</literal>
							 <literal type="string">"xid/subid/cid: %u/%u/%u%s%s"</literal></expr></argument>,
							 <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"unnamed"</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><call><name>BlockStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>blockState</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>TransStateAsString</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSent</name></name></expr> ?</condition><then> <expr><literal type="string">"Y"</literal></expr> </then><else>: <expr><literal type="string">"N"</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>ybDataSentForCurrQuery</name></name></expr> ?</condition><then> <expr><literal type="string">"Y"</literal></expr> </then><else>: <expr><literal type="string">"N"</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>s</name><operator>-&gt;</operator><name>transactionId</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>s</name><operator>-&gt;</operator><name>subTransactionId</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>currentCommandId</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>currentCommandIdUsed</name></expr> ?</condition><then> <expr><literal type="string">" (used)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BlockStateAsString
 *		Debug support
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>BlockStateAsString</name><parameter_list>(<parameter><decl><type><name>TBlockState</name></type> <name>blockState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>blockState</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TBLOCK_DEFAULT</name></expr>:</case>
			<return>return <expr><literal type="string">"DEFAULT"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_STARTED</name></expr>:</case>
			<return>return <expr><literal type="string">"STARTED"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_BEGIN</name></expr>:</case>
			<return>return <expr><literal type="string">"BEGIN"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_INPROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"INPROGRESS"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_IMPLICIT_INPROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"IMPLICIT_INPROGRESS"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_PARALLEL_INPROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"PARALLEL_INPROGRESS"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_END</name></expr>:</case>
			<return>return <expr><literal type="string">"END"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_ABORT</name></expr>:</case>
			<return>return <expr><literal type="string">"ABORT"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_ABORT_END</name></expr>:</case>
			<return>return <expr><literal type="string">"ABORT_END"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_ABORT_PENDING</name></expr>:</case>
			<return>return <expr><literal type="string">"ABORT_PENDING"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_PREPARE</name></expr>:</case>
			<return>return <expr><literal type="string">"PREPARE"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBBEGIN</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBBEGIN"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBINPROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBINPROGRESS"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBRELEASE</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBRELEASE"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBCOMMIT</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBCOMMIT"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBABORT</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBABORT"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBABORT_END</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBABORT_END"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBABORT_PENDING</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBABORT_PENDING"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBRESTART</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBRESTART"</literal></expr>;</return>
		<case>case <expr><name>TBLOCK_SUBABORT_RESTART</name></expr>:</case>
			<return>return <expr><literal type="string">"SUBABORT_RESTART"</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"UNRECOGNIZED"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TransStateAsString
 *		Debug support
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>TransStateAsString</name><parameter_list>(<parameter><decl><type><name>TransState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TRANS_DEFAULT</name></expr>:</case>
			<return>return <expr><literal type="string">"DEFAULT"</literal></expr>;</return>
		<case>case <expr><name>TRANS_START</name></expr>:</case>
			<return>return <expr><literal type="string">"START"</literal></expr>;</return>
		<case>case <expr><name>TRANS_INPROGRESS</name></expr>:</case>
			<return>return <expr><literal type="string">"INPROGRESS"</literal></expr>;</return>
		<case>case <expr><name>TRANS_COMMIT</name></expr>:</case>
			<return>return <expr><literal type="string">"COMMIT"</literal></expr>;</return>
		<case>case <expr><name>TRANS_ABORT</name></expr>:</case>
			<return>return <expr><literal type="string">"ABORT"</literal></expr>;</return>
		<case>case <expr><name>TRANS_PREPARE</name></expr>:</case>
			<return>return <expr><literal type="string">"PREPARE"</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"UNRECOGNIZED"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * xactGetCommittedChildren
 *
 * Gets the list of committed children of the current transaction.  The return
 * value is the number of child transactions.  *ptr is set to point to an
 * array of TransactionIds.  The array is allocated in TopTransactionContext;
 * the caller should *not* pfree() it (this is a change from pre-8.4 code!).
 * If there are no subxacts, *ptr is set to NULL.
 */</comment>
<function><type><name>int</name></type>
<name>xactGetCommittedChildren</name><parameter_list>(<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionState</name></type> <name>s</name> <init>= <expr><name>CurrentTransactionState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>childXids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>nChildXids</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	XLOG support routines
 */</comment>


<comment type="block">/*
 * Log the commit record for a plain or twophase transaction commit.
 *
 * A 2pc commit will be emitted when twophase_xid is valid, a plain one
 * otherwise.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XactLogCommitRecord</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>commit_time</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nsubxacts</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxacts</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>nmsgs</name></decl></parameter>, <parameter><decl><type><name>SharedInvalidationMessage</name> <modifier>*</modifier></type><name>msgs</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>relcacheInval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forceSync</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>xactflags</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>twophase_xid</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>twophase_gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_xact_commit</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_xinfo</name></type> <name>xl_xinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_dbinfo</name></type> <name>xl_dbinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_subxacts</name></type> <name>xl_subxacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_relfilenodes</name></type> <name>xl_relfilenodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_invals</name></type> <name>xl_invals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_twophase</name></type> <name>xl_twophase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_origin</name></type> <name>xl_origin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* decide between a plain and 2pc commit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_XACT_COMMIT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* First figure out and collect all the information needed */</comment>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xact_time</name></name> <operator>=</operator> <name>commit_time</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>relcacheInval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_COMPLETION_UPDATE_RELCACHE_FILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>forceSyncCommit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_COMPLETION_FORCE_SYNC_COMMIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>xactflags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_AE_LOCKS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check if the caller would like to ask standbys for immediate feedback
	 * once this commit is applied.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>synchronous_commit</name> <operator>&gt;=</operator> <name>SYNCHRONOUS_COMMIT_REMOTE_APPLY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_COMPLETION_APPLY_FEEDBACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Relcache invalidations requires information about the current database
	 * and so does logical decoding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nmsgs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_DBINFO</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_dbinfo</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_dbinfo</name><operator>.</operator><name>tsId</name></name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_SUBXACTS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_subxacts</name><operator>.</operator><name>nsubxacts</name></name> <operator>=</operator> <name>nsubxacts</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_RELFILENODES</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_relfilenodes</name><operator>.</operator><name>nrels</name></name> <operator>=</operator> <name>nrels</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmsgs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_INVALS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_invals</name><operator>.</operator><name>nmsgs</name></name> <operator>=</operator> <name>nmsgs</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_TWOPHASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_twophase</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>twophase_xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>twophase_gid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_GID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dump transaction origin information */</comment>
	<if_stmt><if>if <condition>(<expr><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xl_origin</name><operator>.</operator><name>origin_lsn</name></name> <operator>=</operator> <name>replorigin_session_origin_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_origin</name><operator>.</operator><name>origin_timestamp</name></name> <operator>=</operator> <name>replorigin_session_origin_timestamp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLOG_XACT_HAS_INFO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Then include all the collected data into the commit record. */</comment>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xact_commit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_DBINFO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_dbinfo</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_dbinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_SUBXACTS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_subxacts</name><operator>)</operator></expr></argument>,
						 <argument><expr><name>MinSizeOfXactSubxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>subxacts</name></expr></argument>,
						 <argument><expr><name>nsubxacts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_RELFILENODES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_relfilenodes</name><operator>)</operator></expr></argument>,
						 <argument><expr><name>MinSizeOfXactRelfilenodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rels</name></expr></argument>,
						 <argument><expr><name>nrels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_INVALS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_invals</name><operator>)</operator></expr></argument>, <argument><expr><name>MinSizeOfXactInvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>msgs</name></expr></argument>,
						 <argument><expr><name>nmsgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedInvalidationMessage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_TWOPHASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_twophase</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xact_twophase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_GID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>twophase_gid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>twophase_gid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_origin</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xact_origin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we allow filtering by xacts */</comment>
	<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XACT_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Log the commit record for a plain or twophase transaction abort.
 *
 * A 2pc abort will be emitted when twophase_xid is valid, a plain one
 * otherwise.
 */</comment>
<function><type><name>XLogRecPtr</name></type>
<name>XactLogAbortRecord</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>abort_time</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nsubxacts</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>subxacts</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nrels</name></decl></parameter>, <parameter><decl><type><name>RelFileNode</name> <modifier>*</modifier></type><name>rels</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>xactflags</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>twophase_xid</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>twophase_gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>xl_xact_abort</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_xinfo</name></type> <name>xl_xinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_subxacts</name></type> <name>xl_subxacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_relfilenodes</name></type> <name>xl_relfilenodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_twophase</name></type> <name>xl_twophase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_dbinfo</name></type> <name>xl_dbinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_xact_origin</name></type> <name>xl_origin</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* decide between a plain and 2pc abort */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_XACT_ABORT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>=</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<comment type="block">/* First figure out and collect all the information needed */</comment>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>xact_time</name></name> <operator>=</operator> <name>abort_time</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>xactflags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_AE_LOCKS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nsubxacts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_SUBXACTS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_subxacts</name><operator>.</operator><name>nsubxacts</name></name> <operator>=</operator> <name>nsubxacts</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nrels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_RELFILENODES</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_relfilenodes</name><operator>.</operator><name>nrels</name></name> <operator>=</operator> <name>nrels</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_TWOPHASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_twophase</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>twophase_xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>twophase_gid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_GID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_DBINFO</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_dbinfo</name><operator>.</operator><name>dbId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_dbinfo</name><operator>.</operator><name>tsId</name></name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dump transaction origin information only for abort prepared */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>replorigin_session_origin</name> <operator>!=</operator> <name>InvalidRepOriginId</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>XLogLogicalInfoActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>|=</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>xl_origin</name><operator>.</operator><name>origin_lsn</name></name> <operator>=</operator> <name>replorigin_session_origin_lsn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xl_origin</name><operator>.</operator><name>origin_timestamp</name></name> <operator>=</operator> <name>replorigin_session_origin_timestamp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>info</name> <operator>|=</operator> <name>XLOG_XACT_HAS_INFO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Then include all the collected data into the abort record. */</comment>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><name>MinSizeOfXactAbort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_xinfo</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_DBINFO</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_dbinfo</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_dbinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_SUBXACTS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_subxacts</name><operator>)</operator></expr></argument>,
						 <argument><expr><name>MinSizeOfXactSubxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>subxacts</name></expr></argument>,
						 <argument><expr><name>nsubxacts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_RELFILENODES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_relfilenodes</name><operator>)</operator></expr></argument>,
						 <argument><expr><name>MinSizeOfXactRelfilenodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rels</name></expr></argument>,
						 <argument><expr><name>nrels</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_TWOPHASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_twophase</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xact_twophase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_GID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>twophase_gid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>twophase_gid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>xl_xinfo</name><operator>.</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xl_origin</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_xact_origin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>twophase_xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogSetRecordFlags</name><argument_list>(<argument><expr><name>XLOG_INCLUDE_ORIGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_XACT_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Before 9.0 this was a fairly short function, but now it performs many
 * actions for which the order of execution is critical.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xact_redo_commit</name><parameter_list>(<parameter><decl><type><name>xl_xact_parsed_commit</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>,
				 <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>,
				 <parameter><decl><type><name>XLogRecPtr</name></type> <name>lsn</name></decl></parameter>,
				 <parameter><decl><type><name>RepOriginId</name></type> <name>origin_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>max_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>commit_time</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_xid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure nextXid is beyond any XID mentioned in the record.
	 *
	 * We don't expect anyone else to modify nextXid, hence we don't need to
	 * hold a lock while checking this. We still acquire the lock to modify
	 * it, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>,
									 <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>max_xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator>
		   <operator>(</operator><name>origin_id</name> <operator>==</operator> <name>InvalidRepOriginId</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>commit_time</name> <operator>=</operator> <name><name>parsed</name><operator>-&gt;</operator><name>origin_timestamp</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>commit_time</name> <operator>=</operator> <name><name>parsed</name><operator>-&gt;</operator><name>xact_time</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set the transaction commit timestamp and metadata */</comment>
	<expr_stmt><expr><call><name>TransactionTreeSetCommitTsData</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>,
								   <argument><expr><name>commit_time</name></expr></argument>, <argument><expr><name>origin_id</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Mark the transaction committed in pg_xact.
		 */</comment>
		<expr_stmt><expr><call><name>TransactionIdCommitTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If a transaction completion record arrives that has as-yet
		 * unobserved subtransactions then this will not have been fully
		 * handled by the call to RecordKnownAssignedTransactionIds() in the
		 * main recovery loop in xlog.c. So we need to do bookkeeping again to
		 * cover that case. This is confusing and it is easy to think this
		 * call is irrelevant, which has happened three times in development
		 * already. Leave it in.
		 */</comment>
		<expr_stmt><expr><call><name>RecordKnownAssignedTransactionIds</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark the transaction committed in pg_xact. We use async commit
		 * protocol during recovery to provide information on database
		 * consistency for when users try to set hint bits. It is important
		 * that we do not set hint bits until the minRecoveryPoint is past
		 * this commit record. This ensures that if we crash we don't see hint
		 * bits set on changes made by transactions that haven't yet
		 * recovered. It's unlikely but it's good to be safe.
		 */</comment>
		<expr_stmt><expr><call><name>TransactionIdAsyncCommitTree</name><argument_list>(
									 <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must mark clog before we update the ProcArray.
		 */</comment>
		<expr_stmt><expr><call><name>ExpireTreeKnownAssignedTransactionIds</name><argument_list>(
											  <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>, <argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Send any cache invalidations attached to the commit. We must
		 * maintain the same order of invalidation then release locks as
		 * occurs in CommitTransaction().
		 */</comment>
		<expr_stmt><expr><call><name>ProcessCommittedInvalidationMessages</name><argument_list>(
											 <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>msgs</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nmsgs</name></name></expr></argument>,
											 <argument><expr><call><name>XactCompletionRelcacheInitFileInval</name><argument_list>(<argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>tsId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release locks, if any. We do this for both two phase and normal one
		 * phase transactions. In effect we are ignoring the prepare phase and
		 * just going straight to lock release.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_AE_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StandbyReleaseLockTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_ORIGIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* recover apply progress */</comment>
		<expr_stmt><expr><call><name>replorigin_advance</name><argument_list>(<argument><expr><name>origin_id</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>origin_lsn</name></name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument> <comment type="block">/* backward */</comment> , <argument><expr><name>false</name></expr></argument> <comment type="block">/* WAL */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure files supposed to be dropped are dropped */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>nrels</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First update minimum recovery point to cover this WAL record. Once
		 * a relation is deleted, there's no going back. The buffer manager
		 * enforces the WAL-first rule for normal updates to relation files,
		 * so that the minimum recovery point is always updated before the
		 * corresponding change in the data file is flushed to disk, but we
		 * have to do the same here since we're bypassing the buffer manager.
		 *
		 * Doing this before deleting the files means that if a deletion fails
		 * for some reason, you cannot start up the system even after restart,
		 * until you fix the underlying situation so that the deletion will
		 * succeed. Alternatively, we could update the minimum recovery point
		 * after deletion, but that would leave a small window where the
		 * WAL-first rule would be violated.
		 */</comment>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure files supposed to be dropped are dropped */</comment>
		<expr_stmt><expr><call><name>DropRelationFiles</name><argument_list>(<argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>xnodes</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We issue an XLogFlush() for the same reason we emit ForceSyncCommit()
	 * in normal operation. For example, in CREATE DATABASE, we copy all files
	 * from the template database, and then commit the transaction. If we
	 * crash after all the files have been copied but before the commit, you
	 * have files in the data directory without an entry in pg_database. To
	 * minimize the window for that, we use ForceSyncCommit() to rush the
	 * commit record to disk as quick as possible. We have the same window
	 * during recovery, and forcing an XLogFlush() (which updates
	 * minRecoveryPoint during recovery) helps to reduce that problem window,
	 * for any user that requested ForceSyncCommit().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XactCompletionForceSyncCommit</name><argument_list>(<argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If asked by the primary (because someone is waiting for a synchronous
	 * commit = remote_apply), we will need to ask walreceiver to send a reply
	 * immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XactCompletionApplyFeedback</name><argument_list>(<argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogRequestWalReceiverReply</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Be careful with the order of execution, as with xact_redo_commit().
 * The two functions are similar but differ in key places.
 *
 * Note also that an abort can be for a subtransaction and its children,
 * not just for a top level abort. That means we have to consider
 * topxid != xid, whereas in commit we would find topxid == xid always
 * because subtransaction commit is never WAL logged.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xact_redo_abort</name><parameter_list>(<parameter><decl><type><name>xl_xact_parsed_abort</name> <modifier>*</modifier></type><name>parsed</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>max_xid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure nextXid is beyond any XID mentioned in the record.
	 *
	 * We don't expect anyone else to modify nextXid, hence we don't need to
	 * hold a lock while checking this. We still acquire the lock to modify
	 * it, though.
	 */</comment>
	<expr_stmt><expr><name>max_xid</name> <operator>=</operator> <call><name>TransactionIdLatest</name><argument_list>(<argument><expr><name>xid</name></expr></argument>,
								  <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>,
								  <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>,
									 <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>max_xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>==</operator> <name>STANDBY_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Mark the transaction aborted in pg_xact, no need for async stuff */</comment>
		<expr_stmt><expr><call><name>TransactionIdAbortTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If a transaction completion record arrives that has as-yet
		 * unobserved subtransactions then this will not have been fully
		 * handled by the call to RecordKnownAssignedTransactionIds() in the
		 * main recovery loop in xlog.c. So we need to do bookkeeping again to
		 * cover that case. This is confusing and it is easy to think this
		 * call is irrelevant, which has happened three times in development
		 * already. Leave it in.
		 */</comment>
		<expr_stmt><expr><call><name>RecordKnownAssignedTransactionIds</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the transaction aborted in pg_xact, no need for async stuff */</comment>
		<expr_stmt><expr><call><name>TransactionIdAbortTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must update the ProcArray after we have marked clog.
		 */</comment>
		<expr_stmt><expr><call><name>ExpireTreeKnownAssignedTransactionIds</name><argument_list>(
											  <argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>, <argument><expr><name>max_xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There are no flat files that need updating, nor invalidation
		 * messages to send or undo.
		 */</comment>

		<comment type="block">/*
		 * Release locks, if any. There are no invalidations to send.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsed</name><operator>-&gt;</operator><name>xinfo</name></name> <operator>&amp;</operator> <name>XACT_XINFO_HAS_AE_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>StandbyReleaseLockTree</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>subxacts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Make sure files supposed to be dropped are dropped */</comment>
	<expr_stmt><expr><call><name>DropRelationFiles</name><argument_list>(<argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>xnodes</name></name></expr></argument>, <argument><expr><name><name>parsed</name><operator>-&gt;</operator><name>nrels</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>xact_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>XLOG_XACT_OPMASK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Backup blocks are not used in xact records */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_commit</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_commit</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ParseCommitRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xact_redo_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_COMMIT_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_commit</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_commit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_commit</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ParseCommitRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xact_redo_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>,
						 <argument><expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>, <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Delete TwoPhaseState gxact entry and/or 2PC file. */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_ABORT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_abort</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_abort</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ParseAbortRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xact_redo_abort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_ABORT_PREPARED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_abort</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_abort</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_xact_parsed_abort</name></type> <name>parsed</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ParseAbortRecord</name><argument_list>(<argument><expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>xlrec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xact_redo_abort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parsed</name></expr></argument>, <argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Delete TwoPhaseState gxact entry and/or 2PC file. */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PrepareRedoRemove</name><argument_list>(<argument><expr><name><name>parsed</name><operator>.</operator><name>twophase_xid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_PREPARE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store xid and start/end pointers of the WAL record in TwoPhaseState
		 * gxact entry.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PrepareRedoAdd</name><argument_list>(<argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>,
					   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></argument>,
					   <argument><expr><call><name>XLogRecGetOrigin</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwoPhaseStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_XACT_ASSIGNMENT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_xact_assignment</name> <modifier>*</modifier></type><name>xlrec</name> <init>= <expr><operator>(</operator><name>xl_xact_assignment</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>standbyState</name> <operator>&gt;=</operator> <name>STANDBY_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ProcArrayApplyXidAssignment</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xtop</name></name></expr></argument>,
										<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nsubxacts</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>xsub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"xact_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBSaveDdlHandle</name><parameter_list>(<parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>YBPostponedDdlOps</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>YBPostponedDdlOps</name></name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>List</name><modifier>*</modifier></type> <name>YBGetDdlHandles</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>YBPostponedDdlOps</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YBClearDdlHandles</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>YBPostponedDdlOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>YbClearCurrentTransactionId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>CurrentTransactionState</name><operator>-&gt;</operator><name>transactionId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
