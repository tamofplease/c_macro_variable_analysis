<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/varsup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * varsup.c
 *	  postgres OID &amp; XID variables support routines
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/access/transam/varsup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* YB includes. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/ybccmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>

<comment type="block">/* Number of OIDs to prefetch (preallocate) per XLOG write */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_OID_PREFETCH</name></cpp:macro>		<cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/*
 * Number of OIDs to prefetch (preallocate) in YugabyteDB setup.
 * Given there are multiple Postgres nodes, each node should prefetch
 * in smaller chunks.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YB_OID_PREFETCH</name></cpp:macro>	        <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* pointer to "variable cache" in shared memory (set up by shmem.c) */</comment>
<decl_stmt><decl><type><name>VariableCache</name></type> <name>ShmemVariableCache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* next OID to assign during YSQL upgrade */</comment>
<decl_stmt><decl><type><name>Oid</name></type> <name>ysql_upgrade_next_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Allocate the next XID for a new transaction or subtransaction.
 *
 * The new XID is also stored into MyPgXact before returning.
 *
 * Note: when this is called, we are actually already inside a valid
 * transaction, since XIDs are now not allocated until the transaction
 * does something.  So it is safe to do a database lookup if we want to
 * issue a warning about XID wrap.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>GetNewTransactionId</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSubXact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize transaction state at the beginning of each parallel
	 * operation, so we can't account for new XIDs after that point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During bootstrap initialization, we return the special bootstrap
	 * transaction id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isSubXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>BootstrapTransactionId</name></expr>;</expr_stmt>
		<return>return <expr><name>BootstrapTransactionId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign TransactionIds during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Check to see if it's safe to assign another XID.  This protects against
	 * catastrophic data loss due to XID wraparound.  The basic rules are:
	 *
	 * If we're past xidVacLimit, start trying to force autovacuum cycles.
	 * If we're past xidWarnLimit, start issuing warnings.
	 * If we're past xidStopLimit, refuse to execute transactions, unless
	 * we are running in single-user mode (which gives an escape hatch
	 * to the DBA who somehow got past the earlier defenses).
	 *
	 * Note that this coding also appears in GetNewMultiXactId.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For safety's sake, we release XidGenLock while sending signals,
		 * warnings, etc.  This is not so much because we care about
		 * preserving concurrency in this situation, as to avoid any
		 * possibility of deadlock while doing get_database_name(). First,
		 * copy all the shared values we'll need in this path.
		 */</comment>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldest_datoid</name> <init>= <expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To avoid swamping the postmaster with signals, we issue the autovac
		 * request only once per 64K transaction starts.  This still gives
		 * plenty of chances before we get into real trouble.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xid</name> <operator>%</operator> <literal type="number">65536</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidStopLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database \"%s\""</literal></expr></argument>,
								<argument><expr><name>oldest_datname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Stop the postmaster and vacuum that database in single-user mode.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands to avoid wraparound data loss in database with OID %u"</literal></expr></argument>,
								<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Stop the postmaster and vacuum that database in single-user mode.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
								<argument><expr><name>oldest_datname</name></expr></argument>,
								<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
								<argument><expr><name>oldest_datoid</name></expr></argument>,
								<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Re-acquire lock and start over */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are allocating the first XID of a new page of the commit log,
	 * zero out that commit-log page before returning. We must do this while
	 * holding XidGenLock, else another xact could acquire and commit a later
	 * XID before we zero the page.  Fortunately, a page of the commit log
	 * holds 32K or more transactions, so we don't have to do this very often.
	 *
	 * Extend pg_subtrans and pg_commit_ts too.
	 */</comment>
	<expr_stmt><expr><call><name>ExtendCLOG</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtendCommitTs</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtendSUBTRANS</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now advance the nextXid counter.  This must not happen until after we
	 * have successfully completed ExtendCLOG() --- if that routine fails, we
	 * want the next incoming transaction to try it again.  We cannot assign
	 * more XIDs until there is CLOG space for them.
	 */</comment>
	<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must store the new XID into the shared ProcArray before releasing
	 * XidGenLock.  This ensures that every active XID older than
	 * latestCompletedXid is present in the ProcArray, which is essential for
	 * correct OldestXmin tracking; see src/backend/access/transam/README.
	 *
	 * XXX by storing xid into MyPgXact without acquiring ProcArrayLock, we
	 * are relying on fetch/store of an xid to be atomic, else other backends
	 * might see a partially-set xid here.  But holding both locks at once
	 * would be a nasty concurrency hit.  So for now, assume atomicity.
	 *
	 * Note that readers of PGXACT xid fields should be careful to fetch the
	 * value only once, rather than assume they can read a value multiple
	 * times and get the same answer each time.
	 *
	 * The same comments apply to the subxact xid count and overflow fields.
	 *
	 * A solution to the atomic-store problem would be to give each PGXACT its
	 * own spinlock used only for fetching/storing that PGXACT's xid and
	 * related fields.
	 *
	 * If there's no room to fit a subtransaction XID into PGPROC, set the
	 * cache-overflowed flag instead.  This forces readers to look in
	 * pg_subtrans to map subtransaction XIDs up to top-level XIDs. There is a
	 * race-condition window, in that the new XID will not appear as running
	 * until its parent link has been placed into pg_subtrans. However, that
	 * will happen before anyone could possibly have a reason to inquire about
	 * the status of the XID, so it seems OK.  (Snapshots taken during this
	 * window *will* include the parent XID, so they will deliver the correct
	 * answer later on when someone does have a reason to inquire.)
	 */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * Use volatile pointer to prevent code rearrangement; other backends
		 * could be examining my subxids info concurrently, and we don't want
		 * them to see an invalid intermediate state, such as incrementing
		 * nxids before filling the array entry.  Note we are assuming that
		 * TransactionId and int fetch/store are atomic.
		 */</comment>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>myproc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>PGXACT</name> <modifier>*</modifier></type><name>mypgxact</name> <init>= <expr><name>MyPgXact</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSubXact</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nxids</name> <init>= <expr><name><name>mypgxact</name><operator>-&gt;</operator><name>nxids</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>nxids</name> <operator>&lt;</operator> <name>PGPROC_MAX_CACHED_SUBXIDS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>myproc</name><operator>-&gt;</operator><name>subxids</name><operator>.</operator><name>xids</name><index>[<expr><name>nxids</name></expr>]</index></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>nxids</name></name> <operator>=</operator> <name>nxids</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>mypgxact</name><operator>-&gt;</operator><name>overflowed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read nextXid but don't allocate it.
 */</comment>
<function><type><name>TransactionId</name></type>
<name>ReadNewTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Advance the cluster-wide value for the oldest valid clog entry.
 *
 * We must acquire CLogTruncationLock to advance the oldestClogXid. It's not
 * necessary to hold the lock during the actual clog truncation, only when we
 * advance the limit, as code looking up arbitrary xids is required to hold
 * CLogTruncationLock from when it tests oldestClogXid through to when it
 * completes the clog lookup.
 */</comment>
<function><type><name>void</name></type>
<name>AdvanceOldestClogXid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name></expr></argument>,
							  <argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the last safe XID to allocate using the currently oldest
 * datfrozenxid (ie, the oldest XID that might exist in any database
 * of our cluster), and the OID of the (or a) database with that value.
 */</comment>
<function><type><name>void</name></type>
<name>SetTransactionIdLimit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>oldest_datfrozenxid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldest_datoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWarnLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidStopLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidWrapLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>curXid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldest_datfrozenxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The place where we actually get into deep trouble is halfway around
	 * from the oldest potentially-existing XID.  (This calculation is
	 * probably off by one or two counts, because the special XIDs reduce the
	 * size of the loop a little bit.  But we throw in plenty of slop below,
	 * so it doesn't matter.)
	 */</comment>
	<expr_stmt><expr><name>xidWrapLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <operator>(</operator><name>MaxTransactionId</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidWrapLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidWrapLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll refuse to continue assigning XIDs in interactive mode once we get
	 * within 1M transactions of data loss.  This leaves lots of room for the
	 * DBA to fool around fixing things in a standalone backend, while not
	 * being significant compared to total XID space. (Note that since
	 * vacuuming requires one transaction per table cleaned, we had better be
	 * sure there's lots of XIDs left...)
	 */</comment>
	<expr_stmt><expr><name>xidStopLimit</name> <operator>=</operator> <name>xidWrapLimit</name> <operator>-</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidStopLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidStopLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start complaining loudly when we get within 10M transactions of
	 * the stop point.  This is kind of arbitrary, but if you let your gas
	 * gauge get down to 1% of full, would you be looking for the next gas
	 * station?  We need to be fairly liberal about this number because there
	 * are lots of scenarios where most transactions are done by automatic
	 * clients that won't pay attention to warnings. (No, we're not gonna make
	 * this configurable.  If you know enough to configure it, you know enough
	 * to not get in this kind of trouble in the first place.)
	 */</comment>
	<expr_stmt><expr><name>xidWarnLimit</name> <operator>=</operator> <name>xidStopLimit</name> <operator>-</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidWarnLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidWarnLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start trying to force autovacuums when oldest_datfrozenxid gets
	 * to be more than autovacuum_freeze_max_age transactions old.
	 *
	 * Note: guc.c ensures that autovacuum_freeze_max_age is in a sane range,
	 * so that xidVacLimit will be well before xidWarnLimit.
	 *
	 * Note: autovacuum_freeze_max_age is a PGC_POSTMASTER parameter so that
	 * we don't have to worry about dealing with on-the-fly changes in its
	 * value.  It doesn't look practical to update shared state from a GUC
	 * assign hook (too many processes would try to execute the hook,
	 * resulting in race conditions as well as crashes of those not connected
	 * to shared memory).  Perhaps this can be improved someday.  See also
	 * SetMultiXactIdLimit.
	 */</comment>
	<expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name>oldest_datfrozenxid</name> <operator>+</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidVacLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidVacLimit</name> <operator>+=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Grab lock for just long enough to set the new limit values */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name> <operator>=</operator> <name>oldest_datfrozenxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name> <operator>=</operator> <name>xidVacLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWarnLimit</name></name> <operator>=</operator> <name>xidWarnLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidStopLimit</name></name> <operator>=</operator> <name>xidStopLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidWrapLimit</name></name> <operator>=</operator> <name>xidWrapLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name> <operator>=</operator> <name>oldest_datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the info */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction ID wrap limit is %u, limited by database with OID %u"</literal></expr></argument>,
					<argument><expr><name>xidWrapLimit</name></expr></argument>, <argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If past the autovacuum force point, immediately signal an autovac
	 * request.  The reason for this is that autovac only processes one
	 * database per invocation.  Once it's finished cleaning up the oldest
	 * database, it'll call here, and we'll signal the postmaster to start
	 * another iteration immediately if there are still any old databases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Give an immediate warning if past the wrap warn point */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>curXid</name></expr></argument>, <argument><expr><name>xidWarnLimit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can be called when not inside a transaction, for example during
		 * StartupXLOG().  In such a case we cannot do database access, so we
		 * must just report the oldest DB's OID.
		 *
		 * Note: it's also possible that get_database_name fails and returns
		 * NULL, for example because the database just got dropped.  We'll
		 * still warn, even though the warning might now be unnecessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed within %u transactions"</literal></expr></argument>,
							<argument><expr><name>oldest_datname</name></expr></argument>,
							<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed within %u transactions"</literal></expr></argument>,
							<argument><expr><name>oldest_datoid</name></expr></argument>,
							<argument><expr><name>xidWrapLimit</name> <operator>-</operator> <name>curXid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ForceTransactionIdLimitUpdate -- does the XID wrap-limit data need updating?
 *
 * We primarily check whether oldestXidDB is valid.  The cases we have in
 * mind are that that database was dropped, or the field was reset to zero
 * by pg_resetwal.  In either case we should force recalculation of the
 * wrap limit.  Also do it if oldestXid is old enough to be forcing
 * autovacuums or other actions; this ensures we update our state as soon
 * as possible once extra overhead is being incurred.
 */</comment>
<function><type><name>bool</name></type>
<name>ForceTransactionIdLimitUpdate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>nextXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldestXidDB</name></decl>;</decl_stmt>

	<comment type="block">/* Locking is probably not really necessary, but let's be careful */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xidVacLimit</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>xidVacLimit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestXid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestXidDB</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestXidDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>oldestXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* shouldn't happen, but just in case */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* this shouldn't happen anymore either */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>nextXid</name></expr></argument>, <argument><expr><name>xidVacLimit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* past VacLimit, don't delay updating */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oldestXidDB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* could happen, per comments above */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan all system tables with OIDs to determine the maximum
 * system-allocated OID.
 * Naturally, this function is expensive.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>YbGetMaxAllocatedSystemOid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type>		<name>pg_class</name></decl>,
					<decl><type ref="prev"/><name>sys_rel</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type>		<name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>sys_rel_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SELECT * FROM pg_class
	 * WHERE relnamespace = 'pg_catalog'::regnamespace
	 * AND relhasoids = true
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relnamespace</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relhasoids</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>,
				<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sys_rel_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>sys_rel_oids</name></expr></argument>, <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sys_rel_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* SELECT * FROM x WHERE oid &gt;= 10000 AND oid &lt; 16384 */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDGE</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTLessStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDLT</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sys_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>sys_rel</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>oid</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <name>oid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>sys_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewObjectId -- allocate a new OID
 *
 * OIDs are generated by a cluster-wide counter.  Since they are only 32 bits
 * wide, counter wraparound will occur eventually, and therefore it is unwise
 * to assume they are unique unless precautions are taken to make them so.
 * Hence, this routine should generally not be used directly.  The only
 * direct callers should be GetNewOid() and GetNewRelFileNode() in
 * catalog/catalog.c.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewObjectId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign OIDs during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In YSQL upgrade mode, we continue OID sequence where initdb left off.
	 * We don't expect concurrent upgrade, so we don't need to reserve OIDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsYsqlUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ysql_upgrade_next_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ysql_upgrade_next_oid</name> <operator>=</operator> <call><name>YbGetMaxAllocatedSystemOid</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ysql_upgrade_next_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ysql_upgrade_next_oid</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for wraparound of the OID counter.  We *must* not return 0
	 * (InvalidOid); and as long as we have to check that, it seems a good
	 * idea to skip over everything below FirstNormalObjectId too. (This
	 * basically just avoids lots of collisions with bootstrap-assigned OIDs
	 * right after a wrap occurs, so as to avoid a possibly large number of
	 * iterations in GetNewOid.)  Note we are relying on unsigned comparison.
	 *
	 * During initdb, we start the OID generator at FirstBootstrapObjectId, so
	 * we only wrap if before that point when in bootstrap or standalone mode.
	 * The first time through this routine after normal postmaster start, the
	 * counter will be forced up to FirstNormalObjectId.  This mechanism
	 * leaves the OIDs between FirstBootstrapObjectId and FirstNormalObjectId
	 * available for automatic assignment during initdb, while ensuring they
	 * will never conflict with user-assigned OIDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstNormalObjectId</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* wraparound, or first post-initdb assignment, in normal mode */</comment>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we may be bootstrapping, so don't enforce the full range */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* wraparound in standalone mode (unlikely but possible) */</comment>
				<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>=</operator> <name>FirstNormalObjectId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we run out of logged for use oids then we must log more */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsYugaByteEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>begin_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>end_oid</name>   <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>YBCReserveOids</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>,
			               <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name></expr></argument>,
			               <argument><expr><name>YB_OID_PREFETCH</name></expr></argument>,
			               <argument><expr><operator>&amp;</operator><name>begin_oid</name></expr></argument>,
			               <argument><expr><operator>&amp;</operator><name>end_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name>  <operator>=</operator> <name>begin_oid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <name>end_oid</name> <operator>-</operator> <name>begin_oid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogPutNextOid</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name> <operator>+</operator> <name>VAR_OID_PREFETCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name> <operator>=</operator> <name>VAR_OID_PREFETCH</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextOid</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oidCount</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>OidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
