<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/xlogarchive.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * xlogarchive.c
 *		Functions for archiving WAL files and restoring from the archive.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/xlogarchive.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Attempt to retrieve the specified file from off-line archival storage.
 * If successful, fill "path" with its complete path (note that this will be
 * a temp file name that doesn't follow the normal naming convention), and
 * return true.
 *
 * If not successful, fill "path" with the name of the normal on-line file
 * (which may or may not actually exist, but we'll try to use it), and return
 * false.
 *
 * For fixed-size files, the caller may pass the expected size as an
 * additional crosscheck on successful recovery.  If the file size is not
 * known, set expectedSize = 0.
 *
 * When 'cleanupEnabled' is false, refrain from deleting any old WAL segments
 * in the archive. This is used when fetching the initial checkpoint record,
 * when we are not yet sure how far back we need the WAL.
 */</comment>
<function><type><name>bool</name></type>
<name>RestoreArchivedFile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlogfname</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>recovername</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>expectedSize</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>cleanupEnabled</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogRestoreCmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastRestartPointFname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>restartSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>restartRedoPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>restartTli</name></decl>;</decl_stmt>

	<comment type="block">/* In standby mode, restore_command might not be supplied */</comment>
	<if_stmt><if>if <condition>(<expr><name>recoveryRestoreCommand</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>not_available</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When doing archive recovery, we always prefer an archived log file even
	 * if a file of the same name exists in XLOGDIR.  The reason is that the
	 * file in XLOGDIR could be an old, un-filled or partly-filled version
	 * that was copied and restored as part of backing up $PGDATA.
	 *
	 * We could try to optimize this slightly by checking the local copy
	 * lastchange timestamp against the archived copy, but we have no API to
	 * do this, nor can we guarantee that the lastchange timestamp was
	 * preserved correctly when we copied to archive. Our aim is robustness,
	 * so we elect not to do this.
	 *
	 * If we cannot obtain the log file from the archive, however, we will try
	 * to use the XLOGDIR file if it exists.  This is so that we can make use
	 * of log segments that weren't yet transferred to the archive.
	 *
	 * Notice that we don't actually overwrite any files when we copy back
	 * from archive because the restore_command may inadvertently restore
	 * inappropriate xlogs, or they may be corrupt, so we may wish to fallback
	 * to the segments remaining in current XLOGDIR later. The
	 * copy-from-archive filename is always the same, ensuring that we don't
	 * run out of disk space on long recoveries.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xlogpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>recovername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure there is no existing file named recovername.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>xlogpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>xlogpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>xlogpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>xlogpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Calculate the archive file cutoff point for use during log shipping
	 * replication. All files earlier than this point can be deleted from the
	 * archive, though there is no requirement to do so.
	 *
	 * If cleanup is not enabled, initialise this with the filename of
	 * InvalidXLogRecPtr, which will prevent the deletion of any WAL files
	 * from the archive because of the alphabetic sorting property of WAL
	 * filenames.
	 *
	 * Once we have successfully located the redo pointer of the checkpoint
	 * from which we start recovery we never request a file prior to the redo
	 * pointer of the last restartpoint. When redo begins we know that we have
	 * successfully located it, so there is no need for additional status
	 * flags to signify the point when we can begin deleting WAL files from
	 * the archive.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cleanupEnabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetOldestRestartPoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>restartRedoPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restartTli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>restartRedoPtr</name></expr></argument>, <argument><expr><name>restartSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><name>restartTli</name></expr></argument>, <argument><expr><name>restartSegNo</name></expr></argument>,
					 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we shouldn't need anything earlier than last restart point */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * construct the command to be executed
	 */</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>xlogRestoreCmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>xlogRestoreCmd</name> <operator>+</operator> <name>MAXPGPATH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>recoveryRestoreCommand</name></expr>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'p'</literal></expr>:</case>
					<comment type="block">/* %p: relative path of target file */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>xlogpath</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>make_native_path</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'f'</literal></expr>:</case>
					<comment type="block">/* %f: filename of desired file */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'r'</literal></expr>:</case>
					<comment type="block">/* %r: filename of last restartpoint */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'%'</literal></expr>:</case>
					<comment type="block">/* convert %% to a single % */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* otherwise treat the % as not special */</comment>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"executing restore command \"%s\""</literal></expr></argument>,
							 <argument><expr><name>xlogRestoreCmd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check signals before restore command and reset afterwards.
	 */</comment>
	<expr_stmt><expr><call><name>PreRestoreCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy xlog from archival storage to XLOGDIR
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>xlogRestoreCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PostRestoreCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * command apparently succeeded, but let's make sure the file is
		 * really there now and has the correct size.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>xlogpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>expectedSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>!=</operator> <name>expectedSize</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we find a partial file in standby mode, we assume it's
				 * because it's just being copied to the archive, and keep
				 * trying.
				 *
				 * Otherwise treat a wrong-sized file as FATAL to ensure the
				 * DBA would notice it, but is that too strong? We could try
				 * to plow ahead with a local copy of the file ... but the
				 * problem is that there probably isn't one, and we'd
				 * incorrectly conclude we've reached the end of WAL and we're
				 * done recovering ...
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>StandbyMode</name> <operator>&amp;&amp;</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name> <operator>&lt;</operator> <name>expectedSize</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>FATAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"archive file \"%s\" has wrong size: %lu instead of %lu"</literal></expr></argument>,
								<argument><expr><name>xlogfname</name></expr></argument>,
								<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>stat_buf</name><operator>.</operator><name>st_size</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>expectedSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"restored log file \"%s\" from archive"</literal></expr></argument>,
								<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xlogpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* stat failed */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>xlogpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remember, we rollforward UNTIL the restore fails so failure here is
	 * just part of the process... that makes it difficult to determine
	 * whether the restore failed because there isn't an archive to restore,
	 * or because the administrator has specified the restore program
	 * incorrectly.  We have to assume the former.
	 *
	 * However, if the failure was due to any sort of signal, it's best to
	 * punt and abort recovery.  (If we "return false" here, upper levels will
	 * assume that recovery is complete and start up the database!) It's
	 * essential to abort on child SIGINT and SIGQUIT, because per spec
	 * system() ignores SIGINT and SIGQUIT while waiting; if we see one of
	 * those it's a good bet we should have gotten it too.
	 *
	 * On SIGTERM, assume we have received a fast shutdown request, and exit
	 * cleanly. It's pure chance whether we receive the SIGTERM first, or the
	 * child process. If we receive it first, the signal handler will call
	 * proc_exit, otherwise we do it here. If we or the child process received
	 * SIGTERM for any other reason than a fast shutdown request, postmaster
	 * will perform an immediate shutdown when it sees us exiting
	 * unexpectedly.
	 *
	 * We treat hard shell errors such as "command not found" as fatal, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>wait_result_is_signal</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>wait_result_is_any_signal</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FATAL</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not restore file \"%s\" from archive: %s"</literal></expr></argument>,
					<argument><expr><name>xlogfname</name></expr></argument>, <argument><expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>not_available</name>:</label>

	<comment type="block">/*
	 * if an archived file is not available, there might still be a version of
	 * this file in XLOGDIR, so return that as the filename to open.
	 *
	 * In many recovery scenarios we expect this to fail also, but if so that
	 * just means we've reached the end of WAL.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to execute an external shell command during recovery.
 *
 * 'command' is the shell command to be executed, 'commandName' is a
 * human-readable name describing the command emitted in the logs. If
 * 'failOnSignal' is true and the command is killed by a signal, a FATAL
 * error is thrown. Otherwise a WARNING is emitted.
 *
 * This is currently used for recovery_end_command and archive_cleanup_command.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteRecoveryCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>failOnSignal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogRecoveryCmd</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lastRestartPointFname</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogSegNo</name></type>	<name>restartSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>restartRedoPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeLineID</name></type>	<name>restartTli</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>command</name> <operator>&amp;&amp;</operator> <name>commandName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the archive file cutoff point for use during log shipping
	 * replication. All files earlier than this point can be deleted from the
	 * archive, though there is no requirement to do so.
	 */</comment>
	<expr_stmt><expr><call><name>GetOldestRestartPoint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>restartRedoPtr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>restartTli</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLByteToSeg</name><argument_list>(<argument><expr><name>restartRedoPtr</name></expr></argument>, <argument><expr><name>restartSegNo</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><name>restartTli</name></expr></argument>, <argument><expr><name>restartSegNo</name></expr></argument>,
				 <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * construct the command to be executed
	 */</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>xlogRecoveryCmd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>xlogRecoveryCmd</name> <operator>+</operator> <name>MAXPGPATH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>command</name></expr>;</init> <condition><expr><operator>*</operator><name>sp</name></expr>;</condition> <incr><expr><name>sp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>sp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'r'</literal></expr>:</case>
					<comment type="block">/* %r: filename of last restartpoint */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>lastRestartPointFname</name></expr></argument>, <argument><expr><name>endp</name> <operator>-</operator> <name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dp</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'%'</literal></expr>:</case>
					<comment type="block">/* convert %% to a single % */</comment>
					<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* otherwise treat the % as not special */</comment>
					<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>dp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>dp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"executing %s \"%s\""</literal></expr></argument>, <argument><expr><name>commandName</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * execute the constructed command
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>xlogRecoveryCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the failure was due to any sort of signal, it's best to punt and
		 * abort recovery.  See comments in RestoreArchivedFile().
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>failOnSignal</name> <operator>&amp;&amp;</operator> <call><name>wait_result_is_any_signal</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>FATAL</name></expr> </then><else>: <expr><name>WARNING</name></expr></else></ternary></expr></argument>,
		<comment type="block">/*------
		   translator: First %s represents a recovery.conf parameter name like
		  "recovery_end_command", the 2nd is the value of that parameter, the
		  third an already translated error message. */</comment>
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s \"%s\": %s"</literal></expr></argument>, <argument><expr><name>commandName</name></expr></argument>,
						<argument><expr><name>command</name></expr></argument>, <argument><expr><call><name>wait_result_to_str</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * A file was restored from the archive under a temporary filename (path),
 * and now we want to keep it. Rename it under the permanent filename in
 * in pg_wal (xlogfname), replacing any existing file with the same name.
 */</comment>
<function><type><name>void</name></type>
<name>KeepFileRestoredFromArchive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlogfname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlogfpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>reload</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>oldpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>deletedcounter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * On Windows, if another process (e.g a walsender process) holds the
		 * file open in FILE_SHARE_DELETE mode, unlink will succeed, but the
		 * file will still show up in directory listing until the last handle
		 * is closed, and we cannot rename the new file in its place until
		 * that. To avoid that problem, rename the old file to a temporary
		 * name first. Use a counter to create a unique filename, because the
		 * same file might be restored from the archive multiple times, and a
		 * walsender could still be holding onto an old deleted version of it.
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>oldpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.deleted%u"</literal></expr></argument>,
				 <argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>deletedcounter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>oldpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>oldpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* same-size buffers, so this never truncates */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>oldpath</name></expr></argument>, <argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>oldpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>xlogfpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>reload</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>xlogfpath</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create .done file forcibly to prevent the restored segment from being
	 * archived again later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>XLogArchiveMode</name> <operator>!=</operator> <name>ARCHIVE_MODE_ALWAYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogArchiveForceDone</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlogfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the existing file was replaced, since walsenders might have it open,
	 * request them to reload a currently-open segment. This is only required
	 * for WAL segments, walsenders don't hold other files open, but there's
	 * no harm in doing this too often, and we don't know what kind of a file
	 * we're dealing with here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reload</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WalSndRqstFileReload</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Signal walsender that new WAL has arrived. Again, this isn't necessary
	 * if we restored something other than a WAL segment, but it does no harm
	 * either.
	 */</comment>
	<expr_stmt><expr><call><name>WalSndWakeup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveNotify
 *
 * Create an archive notification file
 *
 * The name of the notification file is the message that will be picked up
 * by the archiver, e.g. we write 0000000100000001000000C6.ready
 * and the archiver then knows to archive XLOGDIR/0000000100000001000000C6,
 * then when complete, rename it to 0000000100000001000000C6.done
 */</comment>
<function><type><name>void</name></type>
<name>XLogArchiveNotify</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* insert an otherwise empty file called &lt;XLOG&gt;.ready */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create archive status file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>archiveStatusPath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write archive status file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>archiveStatusPath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Notify archiver that it's got something to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_ARCHIVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience routine to notify using segment number representation of filename
 */</comment>
<function><type><name>void</name></type>
<name>XLogArchiveNotifySeg</name><parameter_list>(<parameter><decl><type><name>XLogSegNo</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>xlog</name><index>[<expr><name>MAXFNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogFileName</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>, <argument><expr><name>ThisTimeLineID</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveForceDone
 *
 * Emit notification forcibly that an XLOG segment file has been successfully
 * archived, by creating &lt;XLOG&gt;.done regardless of whether &lt;XLOG&gt;.ready
 * exists or not.
 */</comment>
<function><type><name>void</name></type>
<name>XLogArchiveForceDone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveReady</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveDone</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

	<comment type="block">/* Exit if already known done */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveDone</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveDone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If .ready exists, rename it to .done */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveReady</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveReady</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>durable_rename</name><argument_list>(<argument><expr><name>archiveReady</name></expr></argument>, <argument><expr><name>archiveDone</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* insert an otherwise empty file called &lt;XLOG&gt;.done */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>archiveDone</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create archive status file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>archiveDone</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write archive status file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>archiveDone</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveCheckDone
 *
 * This is called when we are ready to delete or recycle an old XLOG segment
 * file or backup history file.  If it is okay to delete it then return true.
 * If it is not time to delete it, make sure a .ready file exists, and return
 * false.
 *
 * If &lt;XLOG&gt;.done exists, then return true; else if &lt;XLOG&gt;.ready exists,
 * then return false; else create &lt;XLOG&gt;.ready and return false.
 *
 * The reason we do things this way is so that if the original attempt to
 * create &lt;XLOG&gt;.ready fails, we'll retry during subsequent checkpoints.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogArchiveCheckDone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inRecovery</name> <init>= <expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The file is always deletable if archive_mode is "off".  On standbys
	 * archiving is disabled if archive_mode is "on", and enabled with
	 * "always".  On a primary, archiving is enabled if archive_mode is "on"
	 * or "always".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>inRecovery</name><operator>)</operator> <operator>||</operator>
		  <operator>(</operator><call><name>XLogArchivingAlways</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>inRecovery</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* First check for .done --- this means archiver is done with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for .ready --- this means archiver is still busy with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Race condition --- maybe archiver just finished, so recheck */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Retry creation of the .ready file */</comment>
	<expr_stmt><expr><call><name>XLogArchiveNotify</name><argument_list>(<argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveIsBusy
 *
 * Check to see if an XLOG segment file is still unarchived.
 * This is almost but not quite the inverse of XLogArchiveCheckDone: in
 * the first place we aren't chartered to recreate the .ready file, and
 * in the second place we should consider that if the file is already gone
 * then it's not busy.  (This check is needed to handle the race condition
 * that a checkpoint already deleted the no-longer-needed file.)
 */</comment>
<function><type><name>bool</name></type>
<name>XLogArchiveIsBusy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* First check for .done --- this means archiver is done with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for .ready --- this means archiver is still busy with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Race condition --- maybe archiver just finished, so recheck */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check to see if the WAL file has been removed by checkpoint, which
	 * implies it has already been archived, and explains why we can't see a
	 * status file for it.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>XLOGDIR</name> <literal type="string">"/%s"</literal></expr></argument>, <argument><expr><name>xlog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveIsReadyOrDone
 *
 * Check to see if an XLOG segment file has a .ready or .done file.
 * This is similar to XLogArchiveIsBusy(), but returns true if the file
 * is already archived or is about to be archived.
 *
 * This is currently only used at recovery.  During normal operation this
 * would be racy: the file might get removed or marked with .ready as we're
 * checking it, or immediately after we return.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogArchiveIsReadyOrDone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* First check for .done --- this means archiver is done with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* check for .ready --- this means archiver is still busy with it */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Race condition --- maybe archiver just finished, so recheck */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveIsReady
 *
 * Check to see if an XLOG segment file has an archive notification (.ready)
 * file.
 */</comment>
<function><type><name>bool</name></type>
<name>XLogArchiveIsReady</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * XLogArchiveCleanup
 *
 * Cleanup archive notification file(s) for a particular xlog segment
 */</comment>
<function><type><name>void</name></type>
<name>XLogArchiveCleanup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>archiveStatusPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Remove the .done file */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* should we complain about failure? */</comment>

	<comment type="block">/* Remove the .ready file if present --- normally it shouldn't be */</comment>
	<expr_stmt><expr><call><name>StatusFilePath</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>, <argument><expr><name>xlog</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>archiveStatusPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* should we complain about failure? */</comment>
</block_content>}</block></function>
</unit>
