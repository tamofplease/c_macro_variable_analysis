<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/ybgin/ybginget.c"><comment type="block">/*--------------------------------------------------------------------------
 *
 * ybginget.c
 *	  fetch tuples from a Yugabyte GIN scan.
 *
 * Copyright (c) YugaByte, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * IDENTIFICATION
 *			src/backend/access/ybgin/ybginget.c
 *--------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ybgin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ybgin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_yb_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"yb/yql/pggate/ybc_pggate.h"</cpp:file></cpp:include>

<comment type="block">/* Copied from ginget.c. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GinIsVoidRes</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>( ((GinScanOpaque) scan-&gt;opaque)-&gt;isVoidRes )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSVECTOR_GIN_FAM_OID</name></cpp:macro>	<cpp:value>((Oid) 3659)</cpp:value></cpp:define>

<comment type="block">/*
 * Parts copied from ginget.c.  Take the code right under label
 * restartScanEntry that initializes entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScanEntry</name><parameter_list>(<parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchBitmap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>matchResult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>reduceResult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>predictNumberResult</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for scan entry indexes. Sorts by predictNumberResult,
 * least frequent items first.
 *
 * Copied from ginget.c.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>entryIndexByFrequencyCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a2</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>GinScanKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>GinScanKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a2</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>n1</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i1</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>n2</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name>i2</name></expr>]</index></name><operator>-&gt;</operator><name>predictNumberResult</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n1</name> <operator>&lt;</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>n1</name> <operator>==</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copied from ginget.c with the only difference being the lack of parameter
 * ginstate, which isn't used there either.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScanKey</name><parameter_list>(<parameter><decl><type><name>GinScanOpaque</name></type> <name>so</name></decl></parameter>, <parameter><decl><type><name>GinScanKey</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name> <init>= <expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>entryIndexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>curItem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>curItemMatches</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>recheckCurItem</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>isFinished</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Divide the entries into two distinct sets: required and additional.
	 * Additional entries are not enough for a match alone, without any items
	 * from the required set, but are needed by the consistent function to
	 * decide if an item matches. When scanning, we can skip over items from
	 * additional entries that have no corresponding matches in any of the
	 * required entries. That speeds up queries like "frequent &amp; rare"
	 * considerably, if the frequent term can be put in the additional set.
	 *
	 * There can be many legal ways to divide them entries into these two
	 * sets. A conservative division is to just put everything in the required
	 * set, but the more you can put in the additional set, the more you can
	 * skip during the scan. To maximize skipping, we try to put as many
	 * frequent items as possible into additional, and less frequent ones into
	 * required. To do that, sort the entries by frequency
	 * (predictNumberResult), and put entries into the required set in that
	 * order, until the consistent function says that none of the remaining
	 * entries can form a match, without any items from the required set. The
	 * rest go to the additional set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>entryIndexes</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entryIndexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>entryIndexes</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>entryIndexByFrequencyCmp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Pass all entries &lt;= i as FALSE, and the rest as MAYBE */</comment>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt></block_content></block></for>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>entryRes</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>GIN_MAYBE</name></expr>;</expr_stmt></block_content></block></for>

			<if_stmt><if>if <condition>(<expr><call><name><name>key</name><operator>-&gt;</operator><name>triConsistentFn</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_FALSE</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="block">/* i is now the last required entry. */</comment>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>nentries</name></name> <operator>-</operator> <name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>additionalEntries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><name><name>entryIndexes</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* clean up after consistentFn calls (also frees entryIndexes) */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>tempCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>keyCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>nadditional</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GinScanEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>scanEntry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parts copied from ginget.c.  Don't bother copying GinFuzzySearchLimit code
 * since it's not supported.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>startScan</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>totalentries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>startScanEntry</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Don't support GinFuzzySearchLimit. */</comment>

	<comment type="block">/*
	 * Now that we have the estimates for the entry frequencies, finish
	 * initializing the scan keys.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>startScanKey</name><argument_list>(<argument><expr><name>so</name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>keys</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the scan keys, and check for unsatisfiable query.
 *
 * Parts copied from ginget.c gingetbitmap.  Since ybgin does not use bitmap
 * scan, things are much different.  gingetbitmap iterates over the resulting
 * tuples, but ybgingettuple will be called once for each result tuple.  Only
 * take the setup part of gingetbitmap.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ybginGetScanKeys</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ginFreeScanKeys</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* there should be no keys yet, but just to be
								 * sure */</comment>
	<expr_stmt><expr><call><name>ginNewScanKey</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinIsVoidRes</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Categorize scan entries to required and additional.
	 */</comment>
	<expr_stmt><expr><call><name>startScan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Const node of text type from a C string.
 *
 * Parts copied from string_to_const.
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>text_to_const</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>conval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datatype</name> <init>= <expr><name>TEXTOID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>constlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>colloid</name></expr></argument>, <argument><expr><name>constlen</name></expr></argument>,
					 <argument><expr><name>conval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to generate a string to serve as an exclusive upperbound for matching
 * strings with the given prefix.  If successful, return a palloc'd string in
 * the form of a Const node; else, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>get_greaterstr</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>prefix_const</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>ltproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oproid</name></decl>;</decl_stmt>

	<comment type="block">/* make_greater_string cannot accurately handle non-C collations. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot handle ybgin scans with prefix on non-C collation %u"</literal></expr></argument>,
						<argument><expr><name>colloid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For now, hardcode to assume type is text.  This is true for the four
	 * native postgres ybgin opclasses, but it may no longer be true when
	 * supporting extensions like btree_gin.  This assumption makes finding
	 * opfamily and operator easier.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot handle ybgin scans with prefix on key type %u"</literal></expr></argument>,
						<argument><expr><name>datatype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name>TEXT_LSM_FAM_OID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oproid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>datatype</name></expr></argument>, <argument><expr><name>datatype</name></expr></argument>,
								 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oproid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no &lt; operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prefix_const</name> <operator>=</operator> <call><name>text_to_const</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>make_greater_string</name><argument_list>(<argument><expr><name>prefix_const</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltproc</name></expr></argument>, <argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginSetupBindsForPrefix</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name></decl></parameter>,
						 <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>greaterstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name>ybso</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>colloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr_start</name></decl>,
				<decl><type ref="prev"/><name>expr_end</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>colloid</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>supportCollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr_start</name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
								<argument><expr><name>typoid</name></expr></argument>,
								<argument><expr><name>colloid</name></expr></argument>,
								<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
								<argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>greaterstr</name> <operator>=</operator> <call><name>get_greaterstr</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
								<argument><expr><name>typoid</name></expr></argument>,
								<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>greaterstr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>expr_end</name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
								  <argument><expr><name>typoid</name></expr></argument>,
								  <argument><expr><name>colloid</name></expr></argument>,
								  <argument><expr><name><name>greaterstr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumnCondBetween</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* attr_num */</comment>,
													 <argument><expr><name>expr_start</name></expr></argument>,
													 <argument><expr><name>true</name></expr></argument>,
													 <argument><expr><name>expr_end</name></expr></argument>,
													 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>greaterstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumnCondBetween</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* attr_num */</comment>,
													 <argument><expr><name>expr_start</name></expr></argument>,
													 <argument><expr><name>true</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* attr_value_end */</comment>,
													 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginSetupBindsForPartialMatch</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name></decl></parameter>,
							   <parameter><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name>ybso</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For now, assume partial match always means prefix match.  In the
	 * future, this should be handled by a new support function, similar to
	 * the existing support function comparePartial.
	 *
	 * TODO(jason): don't assume one column when multicolumn is supported.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>TSVECTOR_GIN_FAM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ybgin index scan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partial match with ybgin index method"</literal>
						   <literal type="string">" currently only supports opfamily %u: got %u."</literal></expr></argument>,
						   <argument><expr><name>TSVECTOR_GIN_FAM_OID</name></expr></argument>,
						   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Turn off index scan using"</literal>
						 <literal type="string">" \"SET enable_indexscan TO false\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ybginSetupBindsForPrefix</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>ybso</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add binds for the select.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginSetupBinds</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinScanEntry</name></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinScanKey</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GinScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For now, only handle single-key scans.  Multiple keys are possible even
	 * if multicolumn is disabled by specifiying the same column in multiple
	 * conditions (e.g. v @@ 'abc' and v @@ 'bcd').
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ybgin index scan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ybgin index method cannot use"</literal>
						   <literal type="string">" more than one scan key: got %d."</literal></expr></argument>,
						   <argument><expr><name><name>so</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider rewriting the query with INTERSECT and"</literal>
						 <literal type="string">" UNION."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name><name>so</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, only handle the default search mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>searchMode</name></name> <operator>!=</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ybgin index scan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ybgin index method does not support"</literal>
						   <literal type="string">" non-default search mode: %s."</literal></expr></argument>,
						   <argument><expr><call><name>ybginSearchModeToString</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>searchMode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For now, only handle the case where there's one required scan entry
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ybgin index scan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ybgin index method cannot use"</literal>
						   <literal type="string">" more than one required scan entry: got %d."</literal></expr></argument>,
						   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>nrequired</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>requiredEntries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>


	<comment type="block">/* For now, don't handle null entries. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name> <operator>!=</operator> <name>GIN_CAT_NORM_KEY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ybgin index scan"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"ybgin index method does not support"</literal>
						   <literal type="string">" non-normal null category: %s."</literal></expr></argument>,
						   <argument><expr><call><name>ybginNullCategoryToString</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryCategory</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Bind to the index because why else would we do an index scan? */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>isPartialMatch</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ybginSetupBindsForPartialMatch</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>ybso</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr</name></decl>;</decl_stmt>

		<comment type="block">/* Bind the one scan entry to the index column. */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>YBCNewConstant</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
							  <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
							  <argument><expr><name><name>so</name><operator>-&gt;</operator><name>ginstate</name><operator>.</operator><name>supportCollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
							  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>queryKey</name></name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument> <comment type="block">/* is_null */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlBindColumn</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
										  <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* attr_num */</comment>,
										  <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a system column as target to the given statement handle.
 *
 * See related ybcAddTargetColumn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addTargetSystemColumn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name></decl>;</decl_stmt>

	<comment type="block">/* System columns don't use typmod. */</comment>
	<expr_stmt><expr><name><name>type_attrs</name><operator>.</operator><name>typmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
						   <argument><expr><name>attnum</name></expr></argument>,
						   <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* attr_typid */</comment>,
						   <argument><expr><name>InvalidOid</name></expr></argument> <comment type="block">/* attr_collation */</comment>,
						   <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a regular column as target to the given statement handle.  Assume
 * tupdesc's relation is the same as handle's target relation.
 *
 * See related ybcAddTargetColumn.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addTargetRegularColumn</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>YBCPgStatement</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This can possibly be &gt;= 0. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgExpr</name></type>	<name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgTypeAttrs</name></type> <name>type_attrs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>type_attrs</name><operator>.</operator><name>typmod</name></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>YBCNewColumnRef</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
						   <argument><expr><name>attnum</name></expr></argument>,
						   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>type_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlAppendTarget</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add targets for the select.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginSetupTargets</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't support IndexOnlyScan, which would directly target the index
	 * table.  Therefore, as an IndexScan, target the base table.  Change this
	 * if we ever support ybgin IndexOnlyScan.
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * IndexScan needs to get base ctids from the index table to pass as binds
	 * to the base table.  This is handled in the pggate layer.
	 */</comment>
	<expr_stmt><expr><call><name>addTargetSystemColumn</name><argument_list>(<argument><expr><name>YBIdxBaseTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * For scans that touch the base table, we seem to always query for the
	 * ybctid, even if the table may have explicit primary keys.  A lower layer
	 * probably filters this out when not applicable.
	 */</comment>
	<expr_stmt><expr><call><name>addTargetSystemColumn</name><argument_list>(<argument><expr><name>YBTupleIdAttributeNumber</name></expr></argument>, <argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * For now, target all non-system columns of the base table.  This can be
	 * very inefficient.  The lsm index access method avoids this using
	 * filtering (see ybcAddTargetColumnIfRequired).
	 *
	 * TODO(jason): don't target unnecessary columns.
	 */</comment>
	<for>for <control>(<init><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addTargetRegularColumn</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * With select prepared, ask pggate to execute it for the first time.  This
 * will prefetch some rows.  Later fetches should not use this.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ybginExecSelect</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_forward_scan</name> <init>= <expr><operator>(</operator><name>dir</name> <operator>==</operator> <name>ForwardScanDirection</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgSetForwardScan</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>is_forward_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgExecSelect</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* exec_params */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare and request the initial execution of select to pggate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ybginDoFirstExec</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ybginGetScanKeys</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* binds */</comment>
	<expr_stmt><expr><call><name>ybginSetupBinds</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* targets */</comment>
	<expr_stmt><expr><call><name>ybginSetupTargets</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>YbSetCatalogCacheVersion</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><call><name>YbGetCatalogCacheVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* execute select */</comment>
	<expr_stmt><expr><call><name>ybginExecSelect</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next tuple from pggate.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>ybginFetchNextHeapTuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YBCPgSysColumns</name></type> <name>syscols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * As an IndexScan, target the base table.  Change this if we ever support
	 * ybgin IndexOnlyScan.
	 */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HandleYBStatus</name><argument_list>(<argument><expr><call><name>YBCPgDmlFetch</name><argument_list>(<argument><expr><name><name>ybso</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>,
								 <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator> <name>values</name></expr></argument>,
								 <argument><expr><name>nulls</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>syscols</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>has_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_data</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_ybctid</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>syscols</name><operator>.</operator><name>ybctid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>syscols</name><operator>.</operator><name>oid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>HeapTupleSetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>syscols</name><operator>.</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ybgingettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>YbginScanOpaque</name></type> <name>ybso</name> <init>= <expr><operator>(</operator><name>YbginScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Sanity check: amcanbackward. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dir</name> <operator>==</operator> <name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ybso</name><operator>-&gt;</operator><name>is_exec_done</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ybginDoFirstExec</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ybso</name><operator>-&gt;</operator><name>is_exec_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fetch */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>ybginFetchNextHeapTuple</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>true</name></expr>)</condition>				<comment type="block">/* TODO(jason): don't assume a match. */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>=</operator> <name><name>tup</name><operator>-&gt;</operator><name>t_ybctid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>tup</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitupdesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>heapRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* TODO(jason): don't assume that recheck is needed. */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_ybctid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
