<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/spgist/spgutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgutils.c
 *	  various support functions for SP-GiST
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/spgist/spgutils.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/index_selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * SP-GiST handler function: return IndexAmRoutine with access method parameters
 * and callbacks.
 */</comment>
<function><type><name>Datum</name></type>
<name>spghandler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexAmRoutine</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstrategies</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsupport</name></name> <operator>=</operator> <name>SPGISTNProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorderbyop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanmulticol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptionalkey</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearcharray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amsearchnulls</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amstorage</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amclusterable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ampredlocks</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanparallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcaninclude</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuild</name></name> <operator>=</operator> <name>spgbuild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name> <operator>=</operator> <name>spgbuildempty</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminsert</name></name> <operator>=</operator> <name>spginsert</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambulkdelete</name></name> <operator>=</operator> <name>spgbulkdelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvacuumcleanup</name></name> <operator>=</operator> <name>spgvacuumcleanup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanreturn</name></name> <operator>=</operator> <name>spgcanreturn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcostestimate</name></name> <operator>=</operator> <name>spgcostestimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amoptions</name></name> <operator>=</operator> <name>spgoptions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amproperty</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amvalidate</name></name> <operator>=</operator> <name>spgvalidate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ambeginscan</name></name> <operator>=</operator> <name>spgbeginscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrescan</name></name> <operator>=</operator> <name>spgrescan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgettuple</name></name> <operator>=</operator> <name>spggettuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amgetbitmap</name></name> <operator>=</operator> <name>spggetbitmap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amendscan</name></name> <operator>=</operator> <name>spgendscan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>ammarkpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amrestrpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amestimateparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>aminitparallelscan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>amroutine</name><operator>-&gt;</operator><name>amparallelrescan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Fill in a SpGistTypeDesc struct with info about the specified data type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fillTypeDesc</name><parameter_list>(<parameter><decl><type><name>SpGistTypeDesc</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>desc</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>desc</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch local cache of AM-specific info about the index, initializing it
 * if necessary
 */</comment>
<function><type><name>SpGistCache</name> <modifier>*</modifier></type>
<name>spgGetCache</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>spgConfigIn</name></type> <name>in</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>procinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpGistMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indexcxt</name></name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* SPGiST doesn't support multi-column indexes */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the actual data type of the indexed column from the index
		 * tupdesc.  We pass this to the opclass config function so that
		 * polymorphic opclasses are possible.
		 */</comment>
		<expr_stmt><expr><name>atttype</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

		<comment type="block">/* Call the config function to get config info for the opclass */</comment>
		<expr_stmt><expr><name><name>in</name><operator>.</operator><name>attType</name></name> <operator>=</operator> <name>atttype</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>procinfo</name> <operator>=</operator> <call><name>index_getprocinfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_CONFIG_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>procinfo</name></expr></argument>,
						  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_indcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the information we need about each relevant datatype */</comment>
		<expr_stmt><expr><call><name>fillTypeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>attType</name></name></expr></argument>, <argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>leafType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>leafType</name></name> <operator>!=</operator> <name>atttype</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SPGIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compress method must be defined when leaf type is different from input type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>fillTypeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>attLeafType</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>leafType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>attLeafType</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>attType</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>fillTypeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>attPrefixType</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>prefixType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fillTypeDesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>attLabelType</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>config</name><operator>.</operator><name>labelType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Last, get the lastUsedPages data from the metapage */</comment>
		<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>SpGistPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>metadata</name><operator>-&gt;</operator><name>magicNumber</name></name> <operator>!=</operator> <name>SPGIST_MAGIC_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" is not an SP-GiST index"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>lastUsedPages</name></name> <operator>=</operator> <name><name>metadata</name><operator>-&gt;</operator><name>lastUsedPages</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>rd_amcache</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>cache</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* assume it's up to date */</comment>
		<expr_stmt><expr><name>cache</name> <operator>=</operator> <operator>(</operator><name>SpGistCache</name> <operator>*</operator><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>cache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize SpGistState for working with the given index */</comment>
<function><type><name>void</name></type>
<name>initSpGistState</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>

	<comment type="block">/* Get cached static information about index */</comment>
	<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>config</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>config</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attType</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>attType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>attLeafType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attPrefixType</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>attPrefixType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>attLabelType</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>attLabelType</name></name></expr>;</expr_stmt>

	<comment type="block">/* Make workspace for constructing dead tuples */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deadTupleStorage</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>SGDTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set XID to use in redirection tuples */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myXid</name></name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume we're not in an index build (spgbuild will override) */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new page (either by recycling, or by extending the index file).
 *
 * The returned buffer is already pinned and exclusive-locked.
 * Caller is responsible for initializing the page by calling SpGistInitBuffer.
 */</comment>
<function><type><name>Buffer</name></type>
<name>SpGistNewBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needLock</name></decl>;</decl_stmt>

	<comment type="block">/* First, try to get a page from FSM */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>GetFreeIndexPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* nothing known to FSM */</comment>

		<comment type="block">/*
		 * The fixed pages shouldn't ever be listed in FSM, but just in case
		 * one is, ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsFixed</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to guard against the possibility that someone else already
		 * recycled this page; the buffer may be locked if so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK to use, if never initialized */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>SpGistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>buffer</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* OK to use */</comment>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Can't use it, so release buffer and try again */</comment>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Must extend the file */</comment>
	<expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update index metapage's lastUsedPages info from local cache, if possible
 *
 * Updating meta page isn't critical for index working, so
 * 1 use ConditionalLockBuffer to improve concurrency
 * 2 don't WAL-log metabuffer changes to decrease WAL traffic
 */</comment>
<function><type><name>void</name></type>
<name>SpGistUpdateMetaPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><operator>(</operator><name>SpGistCache</name> <operator>*</operator><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_amcache</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SpGistMetaPageData</name> <modifier>*</modifier></type><name>metadata</name> <init>= <expr><call><name>SpGistPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>lastUsedPages</name></name> <operator>=</operator> <name><name>cache</name><operator>-&gt;</operator><name>lastUsedPages</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set pd_lower just past the end of the metadata.  This is
			 * essential, because without doing so, metadata will be lost if
			 * xlog.c compresses the page.  (We must do this here because
			 * pre-v11 versions of PG did not set the metapage's pd_lower
			 * correctly, so a pg_upgraded index might contain the wrong
			 * value.)
			 */</comment>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>metapage</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
				<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metadata</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SpGistMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metapage</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Macro to select proper element of lastUsedPages cache depending on flags */</comment>
<comment type="block">/* Masking flags with SPGIST_CACHED_PAGES is just for paranoia's sake */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LUP</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(&amp;(c)-&gt;lastUsedPages.cachedPage[((unsigned int) (f)) % SPGIST_CACHED_PAGES])</cpp:value></cpp:define>

<comment type="block">/*
 * Allocate and initialize a new buffer of the type and parity specified by
 * flags.  The returned buffer is already pinned and exclusive-locked.
 *
 * When requesting an inner page, if we get one with the wrong parity,
 * we just release the buffer and try again.  We will get a different page
 * because GetFreeIndexPage will have marked the page used in FSM.  The page
 * is entered in our local lastUsedPages cache, so there's some hope of
 * making use of it later in this session, but otherwise we rely on VACUUM
 * to eventually re-enter the page in FSM, making it available for recycling.
 * Note that such a page does not get marked dirty here, so unless it's used
 * fairly soon, the buffer will just get discarded and the page will remain
 * as it was on disk.
 *
 * When we return a buffer to the caller, the page is *not* entered into
 * the lastUsedPages cache; we expect the caller will do so after it's taken
 * whatever space it will use.  This is because after the caller has used up
 * some space, the page might have less space than whatever was cached already
 * so we'd rather not trash the old cache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>allocNewBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>pageflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GBUF_REQ_LEAF</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pageflags</name> <operator>|=</operator> <name>SPGIST_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GBUF_REQ_NULLS</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pageflags</name> <operator>|=</operator> <name>SPGIST_NULLS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>SpGistNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pageflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pageflags</name> <operator>&amp;</operator> <name>SPGIST_LEAF</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Leaf pages have no parity concerns, so just use it */</comment>
			<return>return <expr><name>buffer</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>blkFlags</name> <init>= <expr><call><name>GBUF_INNER_PARITY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GBUF_PARITY_MASK</name><operator>)</operator> <operator>==</operator> <name>blkFlags</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Page has right parity, use it */</comment>
				<return>return <expr><name>buffer</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Page has wrong parity, record it in cache and try again */</comment>
				<if_stmt><if>if <condition>(<expr><name>pageflags</name> <operator>&amp;</operator> <name>SPGIST_NULLS</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>blkFlags</name> <operator>|=</operator> <name>GBUF_NULLS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>lastUsedPages</name><operator>.</operator><name>cachedPage</name><index>[<expr><name>blkFlags</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>lastUsedPages</name><operator>.</operator><name>cachedPage</name><index>[<expr><name>blkFlags</name></expr>]</index></name><operator>.</operator><name>freeSpace</name> <operator>=</operator>
					<call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Get a buffer of the type and parity specified by flags, having at least
 * as much free space as indicated by needSpace.  We use the lastUsedPages
 * cache to assign the same buffer previously requested when possible.
 * The returned buffer is already pinned and exclusive-locked.
 *
 * *isNew is set true if the page was initialized here, false if it was
 * already valid.
 */</comment>
<function><type><name>Buffer</name></type>
<name>SpGistGetBuffer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>needSpace</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNew</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLastUsedPage</name> <modifier>*</modifier></type><name>lup</name></decl>;</decl_stmt>

	<comment type="block">/* Bail out if even an empty page wouldn't meet the demand */</comment>
	<if_stmt><if>if <condition>(<expr><name>needSpace</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"desired SPGiST tuple size is too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If possible, increase the space request to include relation's
	 * fillfactor.  This ensures that when we add unrelated tuples to a page,
	 * we try to keep 100-fillfactor% available for adding tuples that are
	 * related to the ones already on it.  But fillfactor mustn't cause an
	 * error for requests that would otherwise be legal.
	 */</comment>
	<expr_stmt><expr><name>needSpace</name> <operator>+=</operator> <call><name>RelationGetTargetPageFreeSpace</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
												<argument><expr><name>SPGIST_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>needSpace</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>needSpace</name></expr></argument>, <argument><expr><name>SPGIST_PAGE_CAPACITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the cache entry for this flags setting */</comment>
	<expr_stmt><expr><name>lup</name> <operator>=</operator> <call><name>GET_LUP</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we have nothing cached, just turn it over to allocNewBuffer */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><call><name>allocNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fixed pages should never be in cache */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>SpGistBlockIsFixed</name><argument_list>(<argument><expr><name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If cached freeSpace isn't enough, don't bother looking at the page */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lup</name><operator>-&gt;</operator><name>freeSpace</name></name> <operator>&gt;=</operator> <name>needSpace</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * buffer is locked by another process, so return a new buffer
			 */</comment>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><call><name>allocNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SpGistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK to initialize the page */</comment>
			<decl_stmt><decl><type><name>uint16</name></type>		<name>pageflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GBUF_REQ_LEAF</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pageflags</name> <operator>|=</operator> <name>SPGIST_LEAF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>GBUF_REQ_NULLS</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pageflags</name> <operator>|=</operator> <name>SPGIST_NULLS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pageflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lup</name><operator>-&gt;</operator><name>freeSpace</name></name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>needSpace</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check that page is of right type and has enough space.  We must
		 * recheck this since our cache isn't necessarily up to date.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><call><name>GBUF_REQ_LEAF</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>!</operator><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><ternary><condition><expr><call><name>GBUF_REQ_NULLS</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>!</operator><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>freeSpace</name> <init>= <expr><call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>freeSpace</name> <operator>&gt;=</operator> <name>needSpace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Success, update freespace info and return the buffer */</comment>
				<expr_stmt><expr><name><name>lup</name><operator>-&gt;</operator><name>freeSpace</name></name> <operator>=</operator> <name>freeSpace</name> <operator>-</operator> <name>needSpace</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return <expr><name>buffer</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * fallback to allocation of new buffer
		 */</comment>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No success with cache, so return a new buffer */</comment>
	<expr_stmt><expr><operator>*</operator><name>isNew</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><call><name>allocNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update lastUsedPages cache when done modifying a page.
 *
 * We update the appropriate cache entry if it already contained this page
 * (its freeSpace is likely obsolete), or if this page has more space than
 * whatever we had cached.
 */</comment>
<function><type><name>void</name></type>
<name>SpGistSetLastUsedPage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>spgGetCache</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLastUsedPage</name> <modifier>*</modifier></type><name>lup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>freeSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>

	<comment type="block">/* Never enter fixed pages (root pages) in cache, though */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsFixed</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>GBUF_LEAF</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>GBUF_INNER_PARITY</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SpGistPageStoresNulls</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GBUF_NULLS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lup</name> <operator>=</operator> <call><name>GET_LUP</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>freeSpace</name> <operator>=</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator> <name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name>blkno</name> <operator>||</operator>
		<name><name>lup</name><operator>-&gt;</operator><name>freeSpace</name></name> <operator>&lt;</operator> <name>freeSpace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lup</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lup</name><operator>-&gt;</operator><name>freeSpace</name></name> <operator>=</operator> <name>freeSpace</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize an SPGiST page to empty, with specified flags
 */</comment>
<function><type><name>void</name></type>
<name>SpGistInitPage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>spgist_page_id</name></name> <operator>=</operator> <name>SPGIST_PAGE_ID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a buffer's page to empty, with specified flags
 */</comment>
<function><type><name>void</name></type>
<name>SpGistInitBuffer</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpGistInitPage</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize metadata page
 */</comment>
<function><type><name>void</name></type>
<name>SpGistInitMetapage</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistMetaPageData</name> <modifier>*</modifier></type><name>metadata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpGistInitPage</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>SPGIST_META</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>SpGistPageGetMeta</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>magicNumber</name></name> <operator>=</operator> <name>SPGIST_MAGIC_NUMBER</name></expr>;</expr_stmt>

	<comment type="block">/* initialize last-used-page cache to empty */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPGIST_CACHED_PAGES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>metadata</name><operator>-&gt;</operator><name>lastUsedPages</name><operator>.</operator><name>cachedPage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Set pd_lower just past the end of the metadata.  This is essential,
	 * because without doing so, metadata will be lost if xlog.c compresses
	 * the page.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name><operator>)</operator><operator>-&gt;</operator><name>pd_lower</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>metadata</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SpGistMetaPageData</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>page</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * reloptions processing for SPGiST
 */</comment>
<function><type><name>bytea</name> <modifier>*</modifier></type>
<name>spgoptions</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>validate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>validate</name></expr></argument>, <argument><expr><name>RELOPT_KIND_SPGIST</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the space needed to store a non-null datum of the indicated type.
 * Note the result is already rounded up to a MAXALIGN boundary.
 * Also, we follow the SPGiST convention that pass-by-val types are
 * just stored in their Datum representation (compare memcpyDatum).
 */</comment>
<function><type><name>unsigned</name> <name>int</name></type>
<name>SpGistGetTypeSize</name><parameter_list>(<parameter><decl><type><name>SpGistTypeDesc</name> <modifier>*</modifier></type><name>att</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the given non-null datum to *target
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>memcpyDatum</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>SpGistTypeDesc</name> <modifier>*</modifier></type><name>att</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr> </then><else>: <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a leaf tuple containing the given heap TID and datum value
 */</comment>
<function><type><name>SpGistLeafTuple</name></type>
<name>spgFormLeafTuple</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>heapPtr</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

	<comment type="block">/* compute space needed (note result is already maxaligned) */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SGLTHDRSZ</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>SpGistGetTypeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ensure that we can replace the tuple with a dead tuple later.  This
	 * test is unnecessary when !isnull, but let's be safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>SGDTSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SGDTSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, form the tuple */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>heapPtr</name></name> <operator>=</operator> <operator>*</operator><name>heapPtr</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpyDatum</name><argument_list>(<argument><expr><call><name>SGLTDATAPTR</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLeafType</name></name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a node (to go into an inner tuple) containing the given label
 *
 * Note that the node's downlink is just set invalid here.  Caller will fill
 * it in later.
 */</comment>
<function><type><name>SpGistNodeTuple</name></type>
<name>spgFormNodeTuple</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>label</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>infomask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* compute space needed (note result is already maxaligned) */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SGNTHDRSZ</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>SpGistGetTypeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLabelType</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Here we make sure that the size will fit in the field reserved for it
	 * in t_info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <name>INDEX_SIZE_MASK</name><operator>)</operator> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row requires %zu bytes, maximum size is %zu"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>SpGistNodeTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>INDEX_NULL_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* we don't bother setting the INDEX_VAR_MASK bit */</comment>
	<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>t_info</name></name> <operator>=</operator> <name>infomask</name></expr>;</expr_stmt>

	<comment type="block">/* The TID field will be filled in later */</comment>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpyDatum</name><argument_list>(<argument><expr><call><name>SGNTDATAPTR</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attLabelType</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an inner tuple containing the given prefix and node array
 */</comment>
<function><type><name>SpGistInnerTuple</name></type>
<name>spgFormInnerTuple</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasPrefix</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>prefix</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>nNodes</name></decl></parameter>, <parameter><decl><type><name>SpGistNodeTuple</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prefixSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/* Compute size needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasPrefix</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prefixSize</name> <operator>=</operator> <call><name>SpGistGetTypeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attPrefixType</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>prefixSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SGITHDRSZ</name> <operator>+</operator> <name>prefixSize</name></expr>;</expr_stmt>

	<comment type="block">/* Note: we rely on node tuple sizes to be maxaligned already */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Ensure that we can replace the tuple with a dead tuple later.  This
	 * test is unnecessary given current tuple layouts, but let's be safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>SGDTSIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SGDTSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Inner tuple should be small enough to fit on a page
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>SPGIST_PAGE_CAPACITY</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SP-GiST inner tuple size %zu exceeds maximum %zu"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>size</name></expr></argument>,
						<argument><expr><name>SPGIST_PAGE_CAPACITY</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than a buffer page cannot be indexed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for overflow of header fields --- probably can't fail if the
	 * above succeeded, but let's be paranoid
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>SGITMAXSIZE</name> <operator>||</operator>
		<name>prefixSize</name> <operator>&gt;</operator> <name>SGITMAXPREFIXSIZE</name> <operator>||</operator>
		<name>nNodes</name> <operator>&gt;</operator> <name>SGITMAXNNODES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPGiST inner tuple header field is too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, form the tuple */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <name>nNodes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>prefixSize</name></name> <operator>=</operator> <name>prefixSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tup</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasPrefix</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpyDatum</name><argument_list>(<argument><expr><call><name>SGITDATAPTR</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>attPrefixType</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>SGITNODEPTR</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name> <init>= <expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>tup</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a "dead" tuple to replace a tuple being deleted.
 *
 * The state can be SPGIST_REDIRECT, SPGIST_DEAD, or SPGIST_PLACEHOLDER.
 * For a REDIRECT tuple, a pointer (blkno+offset) must be supplied, and
 * the xid field is filled in automatically.
 *
 * This is called in critical sections, so we don't use palloc; the tuple
 * is built in preallocated storage.  It should be copied before another
 * call with different parameters can occur.
 */</comment>
<function><type><name>SpGistDeadTuple</name></type>
<name>spgFormDeadTuple</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupstate</name></decl></parameter>,
				 <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>tuple</name> <init>= <expr><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>deadTupleStorage</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>=</operator> <name>tupstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>SGDTSIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tupstate</name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>myXid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>xid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract the label datums of the nodes within innerTuple
 *
 * Returns NULL if label datums are NULLs
 */</comment>
<function><type><name>Datum</name> <modifier>*</modifier></type>
<name>spgExtractNodeLabels</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>nodeLabels</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>

	<comment type="block">/* Either all the labels must be NULL, or none. */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>SGITNODEPTR</name><argument_list>(<argument><expr><name>innerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"some but not all node labels are null in SPGiST inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* They're all null, so just return NULL */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nodeLabels</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>innerTuple</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IndexTupleHasNulls</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"some but not all node labels are null in SPGiST inner tuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>nodeLabels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>SGNTDATUM</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<return>return <expr><name>nodeLabels</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new item to the page, replacing a PLACEHOLDER item if possible.
 * Return the location it's inserted at, or InvalidOffsetNumber on failure.
 *
 * If startOffset isn't NULL, we start searching for placeholders at
 * *startOffset, and update that to the next place to search.  This is just
 * an optimization for repeated insertions.
 *
 * If errorOK is false, we throw error when there's not enough room,
 * rather than returning InvalidOffsetNumber.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>SpGistPageAddNewItem</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Item</name></type> <name>item</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>,
					 <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>errorOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SpGistPageOpaque</name></type> <name>opaque</name> <init>= <expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>offnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>SGDTSIZE</name> <operator>&gt;=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try to replace a placeholder */</comment>
		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>startOffset</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>startOffset</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><name>startOffset</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>it</name> <init>= <expr><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
																   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_PLACEHOLDER</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Done if we found a placeholder */</comment>
			<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>startOffset</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>startOffset</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Hint was no good, re-search from beginning */</comment>
				<expr_stmt><expr><operator>*</operator><name>startOffset</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Hmm, no placeholder found? */</comment>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Replace the placeholder tuple */</comment>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We should not have failed given the size check at the top of
			 * the function, but test anyway.  If we did fail, we must PANIC
			 * because we've already deleted the placeholder tuple, and
			 * there's no other way to keep the damage from getting to disk.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>startOffset</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>startOffset</name> <operator>=</operator> <name>offnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<return>return <expr><name>offnum</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No luck in replacing a placeholder, so just add it to the page */</comment>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
						 <argument><expr><name>InvalidOffsetNumber</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>==</operator> <name>InvalidOffsetNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>errorOK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>offnum</name></expr>;</return>
</block_content>}</block></function>
</unit>
