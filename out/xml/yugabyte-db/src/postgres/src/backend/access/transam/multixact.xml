<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/transam/multixact.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multixact.c
 *		PostgreSQL multi-transaction-log manager
 *
 * The pg_multixact manager is a pg_xact-like manager that stores an array of
 * MultiXactMember for each MultiXactId.  It is a fundamental part of the
 * shared-row-lock implementation.  Each MultiXactMember is comprised of a
 * TransactionId and a set of flag bits.  The name is a bit historical:
 * originally, a MultiXactId consisted of more than one TransactionId (except
 * in rare corner cases), hence "multi".  Nowadays, however, it's perfectly
 * legitimate to have MultiXactIds that only include a single Xid.
 *
 * The meaning of the flag bits is opaque to this module, but they are mostly
 * used in heapam.c to identify lock modes that each of the member transactions
 * is holding on any given tuple.  This module just contains support to store
 * and retrieve the arrays.
 *
 * We use two SLRU areas, one for storing the offsets at which the data
 * starts for each MultiXactId in the other one.  This trick allows us to
 * store variable length arrays of TransactionIds.  (We could alternatively
 * use one area containing counts and TransactionIds, with valid MultiXactId
 * values pointing at slots containing counts; but that way seems less robust
 * since it would get completely confused if someone inquired about a bogus
 * MultiXactId that pointed to an intermediate slot containing an XID.)
 *
 * XLOG interactions: this module generates a record whenever a new OFFSETs or
 * MEMBERs page is initialized to zeroes, as well as an
 * XLOG_MULTIXACT_CREATE_ID record whenever a new MultiXactId is defined.
 * This module ignores the WAL rule "write xlog before data," because it
 * suffices that actions recording a MultiXactId in a heap xmax do follow that
 * rule.  The only way for the MXID to be referenced from any data page is for
 * heap_lock_tuple() or heap_update() to have put it there, and each generates
 * an XLOG record that must follow ours.  The normal LSN interlock between the
 * data page and that XLOG record will ensure that our XLOG record reaches
 * disk first.  If the SLRU members/offsets data reaches disk sooner than the
 * XLOG records, we do not care; after recovery, no xmax will refer to it.  On
 * the flip side, to ensure that all referenced entries _do_ reach disk, this
 * module's XLOG records completely rebuild the data entered since the last
 * checkpoint.  We flush and sync all dirty OFFSETs and MEMBERs pages to disk
 * before each checkpoint is considered complete.
 *
 * Like clog.c, and unlike subtrans.c, we have to preserve state across
 * crashes and ensure that MXID and offset numbering increases monotonically
 * across a crash.  We do this in the same way as it's done for transaction
 * IDs: the WAL record is guaranteed to contain evidence of every MXID we
 * could need to worry about, and we just make sure that at the end of
 * replay, the next-MXID and next-offset counters are at least as large as
 * anything we saw during replay.
 *
 * We are able to remove segments no longer necessary by carefully tracking
 * each table's used values: during vacuum, any multixact older than a certain
 * value is removed; the cutoff value is stored in pg_class.  The minimum value
 * across all tables in each database is stored in pg_database, and the global
 * minimum across all databases is part of pg_control and is kept in shared
 * memory.  Whenever that minimum is advanced, the SLRUs are truncated.
 *
 * When new multixactid values are to be created, care is taken that the
 * counter does not fall within the wraparound horizon considering the global
 * minimum value.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/multixact.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_trace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Defines for MultiXactOffset page sizes.  A page is the same BLCKSZ as is
 * used everywhere else in Postgres.
 *
 * Note: because MultiXactOffsets are 32 bits and wrap around at 0xFFFFFFFF,
 * MultiXact page numbering also wraps around at
 * 0xFFFFFFFF/MULTIXACT_OFFSETS_PER_PAGE, and segment numbering at
 * 0xFFFFFFFF/MULTIXACT_OFFSETS_PER_PAGE/SLRU_PAGES_PER_SEGMENT.  We need
 * take no explicit notice of that fact in this module, except when comparing
 * segment and page numbers in TruncateMultiXact (see
 * MultiXactOffsetPagePrecedes).
 */</comment>

<comment type="block">/* We need four bytes per offset */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_OFFSETS_PER_PAGE</name></cpp:macro> <cpp:value>(BLCKSZ / sizeof(MultiXactOffset))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MultiXactIdToOffsetPage</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((xid) / (MultiXactOffset) MULTIXACT_OFFSETS_PER_PAGE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MultiXactIdToOffsetEntry</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((xid) % (MultiXactOffset) MULTIXACT_OFFSETS_PER_PAGE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MultiXactIdToOffsetSegment</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(MultiXactIdToOffsetPage(xid) / SLRU_PAGES_PER_SEGMENT)</cpp:value></cpp:define>

<comment type="block">/*
 * The situation for members is a bit more complex: we store one byte of
 * additional flag bits for each TransactionId.  To do this without getting
 * into alignment issues, we store four bytes of flags, and then the
 * corresponding 4 Xids.  Each such 5-word (20-byte) set we call a "group", and
 * are stored as a whole in pages.  Thus, with 8kB BLCKSZ, we keep 409 groups
 * per page.  This wastes 12 bytes per page, but that's OK -- simplicity (and
 * performance) trumps space efficiency here.
 *
 * Note that the "offset" macros work with byte offset, not array indexes, so
 * arithmetic must be done using "char *" pointers.
 */</comment>
<comment type="block">/* We need eight bits per xact, so one xact fits in a byte */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXACT_MEMBER_BITS_PER_XACT</name></cpp:macro>			<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXACT_MEMBER_FLAGS_PER_BYTE</name></cpp:macro>			<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXACT_MEMBER_XACT_BITMASK</name></cpp:macro>	<cpp:value>((1 &lt;&lt; MXACT_MEMBER_BITS_PER_XACT) - 1)</cpp:value></cpp:define>

<comment type="block">/* how many full bytes of flags are there in a group? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_FLAGBYTES_PER_GROUP</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBERS_PER_MEMBERGROUP</name></cpp:macro>	\
	<cpp:value>(MULTIXACT_FLAGBYTES_PER_GROUP * MXACT_MEMBER_FLAGS_PER_BYTE)</cpp:value></cpp:define>
<comment type="block">/* size in bytes of a complete group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBERGROUP_SIZE</name></cpp:macro> \
	<cpp:value>(sizeof(TransactionId) * MULTIXACT_MEMBERS_PER_MEMBERGROUP + MULTIXACT_FLAGBYTES_PER_GROUP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBERGROUPS_PER_PAGE</name></cpp:macro> <cpp:value>(BLCKSZ / MULTIXACT_MEMBERGROUP_SIZE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBERS_PER_PAGE</name></cpp:macro>	\
	<cpp:value>(MULTIXACT_MEMBERGROUPS_PER_PAGE * MULTIXACT_MEMBERS_PER_MEMBERGROUP)</cpp:value></cpp:define>

<comment type="block">/*
 * Because the number of items per page is not a divisor of the last item
 * number (member 0xFFFFFFFF), the last segment does not use the maximum number
 * of pages, and moreover the last used page therein does not use the same
 * number of items as previous pages.  (Another way to say it is that the
 * 0xFFFFFFFF member is somewhere in the middle of the last page, so the page
 * has some empty space after that item.)
 *
 * This constant is the number of members in the last page of the last segment.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MEMBERS_IN_LAST_MEMBERS_PAGE</name></cpp:macro> \
		<cpp:value>((uint32) ((0xFFFFFFFF % MULTIXACT_MEMBERS_PER_PAGE) + 1))</cpp:value></cpp:define>

<comment type="block">/* page in which a member is to be found */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXOffsetToMemberPage</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((xid) / (TransactionId) MULTIXACT_MEMBERS_PER_PAGE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXOffsetToMemberSegment</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(MXOffsetToMemberPage(xid) / SLRU_PAGES_PER_SEGMENT)</cpp:value></cpp:define>

<comment type="block">/* Location (byte offset within page) of flag word for a given member */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXOffsetToFlagsOffset</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((((xid) / (TransactionId) MULTIXACT_MEMBERS_PER_MEMBERGROUP) % \
	  (TransactionId) MULTIXACT_MEMBERGROUPS_PER_PAGE) * \
	 (TransactionId) MULTIXACT_MEMBERGROUP_SIZE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXOffsetToFlagsBitShift</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(((xid) % (TransactionId) MULTIXACT_MEMBERS_PER_MEMBERGROUP) * \
	 MXACT_MEMBER_BITS_PER_XACT)</cpp:value></cpp:define>

<comment type="block">/* Location (byte offset within page) of TransactionId of given member */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MXOffsetToMemberOffset</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(MXOffsetToFlagsOffset(xid) + MULTIXACT_FLAGBYTES_PER_GROUP + \
	 ((xid) % MULTIXACT_MEMBERS_PER_MEMBERGROUP) * sizeof(TransactionId))</cpp:value></cpp:define>

<comment type="block">/* Multixact members wraparound thresholds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name></cpp:macro>		<cpp:value>(MaxMultiXactOffset / 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULTIXACT_MEMBER_DANGER_THRESHOLD</name></cpp:macro>	\
	<cpp:value>(MaxMultiXactOffset - MaxMultiXactOffset / 4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PreviousMultiXactId</name><parameter_list>(<parameter><type><name>xid</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((xid) == FirstMultiXactId ? MaxMultiXactId : (xid) - 1)</cpp:value></cpp:define>

<comment type="block">/*
 * Links to shared-memory data structures for MultiXact control
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SlruCtlData</name></type> <name>MultiXactOffsetCtlData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SlruCtlData</name></type> <name>MultiXactMemberCtlData</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MultiXactOffsetCtl</name></cpp:macro>	<cpp:value>(&amp;MultiXactOffsetCtlData)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MultiXactMemberCtl</name></cpp:macro>	<cpp:value>(&amp;MultiXactMemberCtlData)</cpp:value></cpp:define>

<comment type="block">/*
 * MultiXact state shared across all backends.  All this state is protected
 * by MultiXactGenLock.  (We also use MultiXactOffsetControlLock and
 * MultiXactMemberControlLock to guard accesses to the two sets of SLRU
 * buffers.  For concurrency's sake, we avoid holding more than one of these
 * locks at a time.)
 */</comment>
<typedef>typedef <type><struct>struct <name>MultiXactStateData</name>
<block>{
	<comment type="block">/* next-to-be-assigned MultiXactId */</comment>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>

	<comment type="block">/* next-to-be-assigned offset */</comment>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>

	<comment type="block">/* Have we completed multixact startup? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>finishedStartup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Oldest multixact that is still potentially referenced by a relation.
	 * Anything older than this should not be consulted.  These values are
	 * updated by vacuum.
	 */</comment>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMultiXactId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldestMultiXactDB</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Oldest multixact offset that is potentially referenced by a multixact
	 * referenced by a relation.  We don't always know this value, so there's
	 * a flag here to indicate whether or not we currently do.
	 */</comment>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>oldestOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>oldestOffsetKnown</name></decl>;</decl_stmt>

	<comment type="block">/* support for anti-wraparound measures */</comment>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWarnLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiStopLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWrapLimit</name></decl>;</decl_stmt>

	<comment type="block">/* support for members anti-wraparound measures */</comment>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offsetStopLimit</name></decl>;</decl_stmt>	<comment type="block">/* known if oldestOffsetKnown */</comment>

	<comment type="block">/*
	 * Per-backend data starts here.  We have two arrays stored in the area
	 * immediately following the MultiXactStateData struct. Each is indexed by
	 * BackendId.
	 *
	 * In both arrays, there's a slot for all normal backends (1..MaxBackends)
	 * followed by a slot for max_prepared_xacts prepared transactions. Valid
	 * BackendIds start from 1; element zero of each array is never used.
	 *
	 * OldestMemberMXactId[k] is the oldest MultiXactId each backend's current
	 * transaction(s) could possibly be a member of, or InvalidMultiXactId
	 * when the backend has no live transaction that could possibly be a
	 * member of a MultiXact.  Each backend sets its entry to the current
	 * nextMXact counter just before first acquiring a shared lock in a given
	 * transaction, and clears it at transaction end. (This works because only
	 * during or after acquiring a shared lock could an XID possibly become a
	 * member of a MultiXact, and that MultiXact would have to be created
	 * during or after the lock acquisition.)
	 *
	 * OldestVisibleMXactId[k] is the oldest MultiXactId each backend's
	 * current transaction(s) think is potentially live, or InvalidMultiXactId
	 * when not in a transaction or not in a transaction that's paid any
	 * attention to MultiXacts yet.  This is computed when first needed in a
	 * given transaction, and cleared at transaction end.  We can compute it
	 * as the minimum of the valid OldestMemberMXactId[] entries at the time
	 * we compute it (using nextMXact if none are valid).  Each backend is
	 * required not to attempt to access any SLRU data for MultiXactIds older
	 * than its own OldestVisibleMXactId[] setting; this is necessary because
	 * the checkpointer could truncate away such data at any instant.
	 *
	 * The oldest valid value among all of the OldestMemberMXactId[] and
	 * OldestVisibleMXactId[] entries is considered by vacuum as the earliest
	 * possible value still having any live member transaction.  Subtracting
	 * vacuum_multixact_freeze_min_age from that value we obtain the freezing
	 * point for multixacts for that table.  Any value older than that is
	 * removed from tuple headers (or "frozen"; see FreezeMultiXactId.  Note
	 * that multis that have member xids that are older than the cutoff point
	 * for xids must also be frozen, even if the multis themselves are newer
	 * than the multixid cutoff point).  Whenever a full table vacuum happens,
	 * the freezing point so computed is used as the new pg_class.relminmxid
	 * value.  The minimum of all those values in a database is stored as
	 * pg_database.datminmxid.  In turn, the minimum of all of those values is
	 * stored in pg_control and used as truncation point for pg_multixact.  At
	 * checkpoint or restartpoint, unneeded segments are removed.
	 */</comment>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name><name>perBackendXactIds</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>MultiXactStateData</name>;</typedef>

<comment type="block">/*
 * Last element of OldestMemberMXactID and OldestVisibleMXactId arrays.
 * Valid elements are (1..MaxOldestSlot); element 0 is never used.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MaxOldestSlot</name></cpp:macro>	<cpp:value>(MaxBackends + max_prepared_xacts)</cpp:value></cpp:define>

<comment type="block">/* Pointers to the state data in shared memory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactStateData</name> <modifier>*</modifier></type><name>MultiXactState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactId</name> <modifier>*</modifier></type><name>OldestMemberMXactId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactId</name> <modifier>*</modifier></type><name>OldestVisibleMXactId</name></decl>;</decl_stmt>


<comment type="block">/*
 * Definitions for the backend-local MultiXactId cache.
 *
 * We use this cache to store known MultiXacts, so we don't need to go to
 * SLRU areas every time.
 *
 * The cache lasts for the duration of a single transaction, the rationale
 * for this being that most entries will contain our own TransactionId and
 * so they will be uninteresting by the time our next transaction starts.
 * (XXX not clear that this is correct --- other members of the MultiXact
 * could hang around longer than we did.  However, it's not clear what a
 * better policy for flushing old cache entries would be.)	FIXME actually
 * this is plain wrong now that multixact's may contain update Xids.
 *
 * We allocate the cache entries in a memory context that is deleted at
 * transaction end, so we don't need to do retail freeing of entries.
 */</comment>
<typedef>typedef <type><struct>struct <name>mXactCacheEnt</name>
<block>{
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name></type> <name><name>members</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>mXactCacheEnt</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CACHE_ENTRIES</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>MXactCache</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>MXactCache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>MXactCacheMembers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>MXactContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MULTIXACT_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elog(a,b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elog(a,b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elog(a,b,c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog5</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elog(a,b,c,d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog6</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elog(a,b,c,d,e,f)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog3</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog4</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog5</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug_elog6</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* internal MultiXactId management */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MultiXactIdSetOldestVisible</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordNewMultiXact</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiXactId</name></type> <name>GetNewMultiXactId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* MultiXact cache management */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>mxactMemberComparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiXactId</name></type> <name>mXactCacheGetBySet</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>mXactCacheGetById</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier><modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mXactCachePut</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>,
			  <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>mxstatus_to_string</name><parameter_list>(<parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* management of SLRU infrastructure */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ZeroMultiXactOffsetPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ZeroMultiXactMemberPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MultiXactOffsetPagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MultiXactMemberPagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MultiXactOffsetPrecedes</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>offset1</name></decl></parameter>,
						<parameter><decl><type><name>MultiXactOffset</name></type> <name>offset2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtendMultiXactOffset</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtendMultiXactMember</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MultiXactOffsetWouldWrap</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>boundary</name></decl></parameter>,
						 <parameter><decl><type><name>MultiXactOffset</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>distance</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetOffsetVacuumLimit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_startup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>find_multixact_start</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteMZeroPageXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteMTruncateXlogRec</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldestMultiDB</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactId</name></type> <name>startOff</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>endOff</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactOffset</name></type> <name>startMemb</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>endMemb</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * MultiXactIdCreate
 *		Construct a MultiXactId representing two TransactionIds.
 *
 * The two XIDs must be different, or be requesting different statuses.
 *
 * NB - we don't worry about our local MultiXactId cache here, because that
 * is handled by the lower-level routines.
 */</comment>
<function><type><name>MultiXactId</name></type>
<name>MultiXactIdCreate</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid1</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status1</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>xid2</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>newMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name></type> <name><name>members</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>xid1</name></expr></argument>, <argument><expr><name>xid2</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>status1</name> <operator>!=</operator> <name>status2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MultiXactIdSetOldestMember() must have been called already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: unlike MultiXactIdExpand, we don't bother to check that both XIDs
	 * are still running.  In typical usage, xid2 will be our own XID and the
	 * caller just did a check on xid1, so it'd be wasted effort.
	 */</comment>

	<expr_stmt><expr><name><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name>xid1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>status1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>members</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name>xid2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>members</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>status2</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newMulti</name> <operator>=</operator> <call><name>MultiXactIdCreateFromMembers</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Create: %s"</literal></expr></argument>,
				<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>newMulti</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newMulti</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdExpand
 *		Add a TransactionId to a pre-existing MultiXactId.
 *
 * If the TransactionId is already a member of the passed MultiXactId with the
 * same status, just return it as-is.
 *
 * Note that we do NOT actually modify the membership of a pre-existing
 * MultiXactId; instead we create a new one.  This is necessary to avoid
 * a race condition against code trying to wait for one MultiXactId to finish;
 * see notes in heapam.c.
 *
 * NB - we don't worry about our local MultiXactId cache here, because that
 * is handled by the lower-level routines.
 *
 * Note: It is critical that MultiXactIds that come from an old cluster (i.e.
 * one upgraded by pg_upgrade from a cluster older than this feature) are not
 * passed in.
 */</comment>
<function><type><name>MultiXactId</name></type>
<name>MultiXactIdExpand</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>newMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>newMembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MultiXactIdSetOldestMember() must have been called already. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog5</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Expand: received multi %u, xid %u status %s"</literal></expr></argument>,
				<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>mxstatus_to_string</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we don't allow for old multis here.  The reason is that the only
	 * caller of this function does a check that the multixact is no longer
	 * running.
	 */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactMember</name></type> <name>member</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The MultiXactId is obsolete.  This can only happen if all the
		 * MultiXactId members stop running between the caller checking and
		 * passing it to us.  It would be better to return that fact to the
		 * caller, but it would complicate the API and it's unlikely to happen
		 * too often, so just deal with it by creating a singleton MultiXact.
		 */</comment>
		<expr_stmt><expr><name><name>member</name><operator>.</operator><name>xid</name></name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>member</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newMulti</name> <operator>=</operator> <call><name>MultiXactIdCreateFromMembers</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Expand: %u has no members, create singleton %u"</literal></expr></argument>,
					<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>newMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>newMulti</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the TransactionId is already a member of the MultiXactId with the
	 * same status, just return the existing MultiXactId.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>status</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Expand: %u is already a member of %u"</literal></expr></argument>,
						<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>multi</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Determine which of the members of the MultiXactId are still of
	 * interest. This is any running transaction, and also any transaction
	 * that grabbed something stronger than just a lock and was committed. (An
	 * update that aborted is of no interest here; and having more than one
	 * update Xid in a multixact would cause errors elsewhere.)
	 *
	 * Removing dead members is not just an optimization: freezing of tuples
	 * whose Xmax are multis depends on this behavior.
	 *
	 * Note we have the same race condition here as above: j could be 0 at the
	 * end of the loop.
	 */</comment>
	<expr_stmt><expr><name>newMembers</name> <operator>=</operator> <operator>(</operator><name>MultiXactMember</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>nmembers</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>(</operator><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newMembers</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMembers</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>newMembers</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newMembers</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newMulti</name> <operator>=</operator> <call><name>MultiXactIdCreateFromMembers</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>newMembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newMembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Expand: returning new multi %u"</literal></expr></argument>, <argument><expr><name>newMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newMulti</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdIsRunning
 *		Returns whether a MultiXactId is "running".
 *
 * We return true if at least one member of the given MultiXactId is still
 * running.  Note that a "false" result is certain not to change,
 * because it is not legal to add members to an existing MultiXactId.
 *
 * Caller is expected to have verified that the multixact does not come from
 * a pg_upgraded share-locked tuple.
 */</comment>
<function><type><name>bool</name></type>
<name>MultiXactIdIsRunning</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isLockOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IsRunning %u?"</literal></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * "false" here means we assume our callers have checked that the given
	 * multi cannot possibly come from a pg_upgraded database.
	 */</comment>
	<expr_stmt><expr><name>nmembers</name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isLockOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IsRunning: no members"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Checking for myself is cheap compared to looking in shared memory;
	 * return true if any live subtransaction of the current top-level
	 * transaction is a member.
	 *
	 * This is not needed for correctness, it's just a fast path.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IsRunning: I (%d) am running!"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * This could be made faster by having another entry point in procarray.c,
	 * walking the PGPROC array only once for all the members.  But in most
	 * cases nmembers should be small enough that it doesn't much matter.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IsRunning: member %d (%u) is running"</literal></expr></argument>,
						<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"IsRunning: %u is not running"</literal></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdSetOldestMember
 *		Save the oldest MultiXactId this transaction could be a member of.
 *
 * We set the OldestMemberMXactId for a given transaction the first time it's
 * going to do some operation that might require a MultiXactId (tuple lock,
 * update or delete).  We need to do this even if we end up using a
 * TransactionId instead of a MultiXactId, because there is a chance that
 * another transaction would add our XID to a MultiXactId.
 *
 * The value to set is the next-to-be-assigned MultiXactId, so this is meant to
 * be called just before doing any such possibly-MultiXactId-able operation.
 */</comment>
<function><type><name>void</name></type>
<name>MultiXactIdSetOldestMember</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * You might think we don't need to acquire a lock here, since
		 * fetching and storing of TransactionIds is probably atomic, but in
		 * fact we do: suppose we pick up nextMXact and then lose the CPU for
		 * a long time.  Someone else could advance nextMXact, and then
		 * another someone else could compute an OldestVisibleMXactId that
		 * would be after the value we are going to store when we get control
		 * back.  Which would be wrong.
		 *
		 * Note that a shared lock is sufficient, because it's enough to stop
		 * someone from advancing nextMXact; and nobody else could be trying
		 * to write to our OldestMember entry, only reading (and we assume
		 * storing it is atomic.)
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to beware of the possibility that nextMXact is in the
		 * wrapped-around state.  We don't fix the counter itself here, but we
		 * must be sure to store a valid value in our array entry.
		 */</comment>
		<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nextMXact</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>nextMXact</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"MultiXact: setting OldestMember[%d] = %u"</literal></expr></argument>,
					<argument><expr><name>MyBackendId</name></expr></argument>, <argument><expr><name>nextMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdSetOldestVisible
 *		Save the oldest MultiXactId this transaction considers possibly live.
 *
 * We set the OldestVisibleMXactId for a given transaction the first time
 * it's going to inspect any MultiXactId.  Once we have set this, we are
 * guaranteed that the checkpointer won't truncate off SLRU data for
 * MultiXactIds at or after our OldestVisibleMXactId.
 *
 * The value to set is the oldest of nextMXact and all the valid per-backend
 * OldestMemberMXactId[] entries.  Because of the locking we do, we can be
 * certain that no subsequent call to MultiXactIdSetOldestMember can set
 * an OldestMemberMXactId[] entry older than what we compute here.  Therefore
 * there is no live transaction, now or later, that can be a member of any
 * MultiXactId older than the OldestVisibleMXactId we compute here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MultiXactIdSetOldestVisible</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>OldestVisibleMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMXact</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to beware of the possibility that nextMXact is in the
		 * wrapped-around state.  We don't fix the counter itself here, but we
		 * must be sure to store a valid value in our array entry.
		 */</comment>
		<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldestMXact</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MaxOldestSlot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiXactId</name></type> <name>thisoldest</name> <init>= <expr><name><name>OldestMemberMXactId</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>, <argument><expr><name>oldestMXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name>thisoldest</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>OldestVisibleMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>oldestMXact</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"MultiXact: setting OldestVisible[%d] = %u"</literal></expr></argument>,
					<argument><expr><name>MyBackendId</name></expr></argument>, <argument><expr><name>oldestMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadNextMultiXactId
 *		Return the next MultiXactId to be assigned, but don't allocate it
 */</comment>
<function><type><name>MultiXactId</name></type>
<name>ReadNextMultiXactId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxid</name></decl>;</decl_stmt>

	<comment type="block">/* XXX we could presumably do this without a lock. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mxid</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mxid</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>mxid</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>mxid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdCreateFromMembers
 *		Make a new MultiXactId from the specified set of members
 *
 * Make XLOG, SLRU and cache entries for a new MultiXactId, recording the
 * given TransactionIds as members.  Returns the newly created MultiXactId.
 *
 * NB: the passed members[] array will be sorted in-place.
 */</comment>
<function><type><name>MultiXactId</name></type>
<name>MultiXactIdCreateFromMembers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_multixact_create</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Create: %s"</literal></expr></argument>,
				<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>InvalidMultiXactId</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if the same set of members already exists in our cache; if so, just
	 * re-use that MultiXactId.  (Note: it might seem that looking in our
	 * cache is insufficient, and we ought to search disk to see if a
	 * duplicate definition already exists.  But since we only ever create
	 * MultiXacts containing our own XID, in most cases any such MultiXacts
	 * were in fact created by us, and so will be in our cache.  There are
	 * corner cases where someone else added us to a MultiXact without our
	 * knowledge, but it's not worth checking for.)
	 */</comment>
	<expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>mXactCacheGetBySet</name><argument_list>(<argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Create: in cache!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>multi</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Verify that there is a single update Xid among the given members. */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_update</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ISUPDATE_from_mxstatus</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>has_update</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"new multixact has more than one updating member"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>has_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/*
	 * Assign the MXID and offsets range to use, and make sure there is space
	 * in the OFFSETs and MEMBERs files.  NB: this routine does
	 * START_CRIT_SECTION().
	 *
	 * Note: unlike MultiXactIdCreate and MultiXactIdExpand, we do not check
	 * that we've called MultiXactIdSetOldestMember here.  This is because
	 * this routine is used in some places to create new MultiXactIds of which
	 * the current backend is not a member, notably during freezing of multis
	 * in vacuum.  During vacuum, in particular, it would be unacceptable to
	 * keep OldestMulti set, in case it runs for long.
	 */</comment>
	<expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>GetNewMultiXactId</name><argument_list>(<argument><expr><name>nmembers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make an XLOG entry describing the new MXID. */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>mid</name></name> <operator>=</operator> <name>multi</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>moff</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nmembers</name></name> <operator>=</operator> <name>nmembers</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX Note: there's a lot of padding space in MultiXactMember.  We could
	 * find a more compact representation of this Xlog record -- perhaps all
	 * the status flags in one XLogRecData, then all the xids in another one?
	 * Not clear that it's worth the trouble though.
	 */</comment>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><name>SizeOfMultiXactCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>members</name></expr></argument>, <argument><expr><name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_MULTIXACT_ID</name></expr></argument>, <argument><expr><name>XLOG_MULTIXACT_CREATE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now enter the information into the OFFSETs and MEMBERs logs */</comment>
	<expr_stmt><expr><call><name>RecordNewMultiXact</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with critical section */</comment>
	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store the new MultiXactId in the local cache, too */</comment>
	<expr_stmt><expr><call><name>mXactCachePut</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Create: all done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>multi</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RecordNewMultiXact
 *		Write info about a new multixact into the offsets and members files
 *
 * This is broken out of MultiXactIdCreateFromMembers so that xlog replay can
 * use it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecordNewMultiXact</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prev_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we pass the MultiXactId to SimpleLruReadPage as the "transaction"
	 * to complain about if there's any I/O error.  This is kinda bogus, but
	 * since the errors will always give the full pathname, it should be clear
	 * enough that a MultiXactId is really involved.  Perhaps someday we'll
	 * take the trouble to generalize the slru.c error reporting code.
	 */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactOffset</name> <operator>*</operator><operator>)</operator> <name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>offptr</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Exchange our lock */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prev_pageno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>offset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>memberptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>flagsptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>flagsval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bshift</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flagsoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>memberoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>&lt;=</operator> <name>MultiXactStatusUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>memberoff</name> <operator>=</operator> <call><name>MXOffsetToMemberOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flagsoff</name> <operator>=</operator> <call><name>MXOffsetToFlagsOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bshift</name> <operator>=</operator> <call><name>MXOffsetToFlagsBitShift</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>!=</operator> <name>prev_pageno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_pageno</name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>memberptr</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>memberoff</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>memberptr</name> <operator>=</operator> <name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>flagsptr</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>flagsoff</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>flagsval</name> <operator>=</operator> <operator>*</operator><name>flagsptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flagsval</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>MXACT_MEMBER_BITS_PER_XACT</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>bshift</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>flagsval</name> <operator>|=</operator> <operator>(</operator><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>&lt;&lt;</operator> <name>bshift</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>flagsptr</name> <operator>=</operator> <name>flagsval</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewMultiXactId
 *		Get the next MultiXactId.
 *
 * Also, reserve the needed amount of space in the "members" area.  The
 * starting offset of the reserved space is returned in *offset.
 *
 * This may generate XLOG records for expansion of the offsets and/or members
 * files.  Unfortunately, we have to do that while holding MultiXactGenLock
 * to avoid race conditions --- the XLOG record for zeroing a page must appear
 * before any backend can possibly try to store data in that page!
 *
 * We start a critical section before advancing the shared counters.  The
 * caller must end the critical section after writing SLRU data.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiXactId</name></type>
<name>GetNewMultiXactId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetNew: for %d xids"</literal></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* safety check, we should never get this far in a HS standby */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign MultiXactIds during recovery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle wraparound of the nextMXact counter */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Assign the MXID */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Check to see if it's safe to assign another MultiXactId.  This protects
	 * against catastrophic data loss due to multixact wraparound.  The basic
	 * rules are:
	 *
	 * If we're past multiVacLimit or the safe threshold for member storage
	 * space, or we don't know what the safe threshold for member storage is,
	 * start trying to force autovacuum cycles.
	 * If we're past multiWarnLimit, start issuing warnings.
	 * If we're past multiStopLimit, refuse to create new MultiXactIds.
	 *
	 * Note these are pretty much the same protections in GetNewTransactionId.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiVacLimit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For safety's sake, we release MultiXactGenLock while sending
		 * signals, warnings, etc.  This is not so much because we care about
		 * preserving concurrency in this situation, as to avoid any
		 * possibility of deadlock while doing get_database_name(). First,
		 * copy all the shared values we'll need in this path.
		 */</comment>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWarnLimit</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiWarnLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiStopLimit</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiStopLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWrapLimit</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiWrapLimit</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oldest_datoid</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>multiStopLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Immediately kick autovacuum into action as we're already in
			 * ERROR territory.
			 */</comment>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands that generate new MultiXactIds to avoid wraparound data loss in database \"%s\""</literal></expr></argument>,
								<argument><expr><name>oldest_datname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database is not accepting commands that generate new MultiXactIds to avoid wraparound data loss in database with OID %u"</literal></expr></argument>,
								<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To avoid swamping the postmaster with signals, we issue the autovac
		 * request only once per 64K multis generated.  This still gives
		 * plenty of chances before we get into real trouble.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>result</name> <operator>%</operator> <literal type="number">65536</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>multiWarnLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* complain even if that DB has disappeared */</comment>
			<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed before %u more MultiXactId is used"</literal></expr></argument>,
									   <argument><expr><literal type="string">"database \"%s\" must be vacuumed before %u more MultiXactIds are used"</literal></expr></argument>,
									   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>result</name></expr></argument>,
									   <argument><expr><name>oldest_datname</name></expr></argument>,
									   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>result</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed before %u more MultiXactId is used"</literal></expr></argument>,
									   <argument><expr><literal type="string">"database with OID %u must be vacuumed before %u more MultiXactIds are used"</literal></expr></argument>,
									   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>result</name></expr></argument>,
									   <argument><expr><name>oldest_datoid</name></expr></argument>,
									   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>result</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in that database.\n"</literal>
								 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Re-acquire lock and start over */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make sure there is room for the MXID in the file.  */</comment>
	<expr_stmt><expr><call><name>ExtendMultiXactOffset</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reserve the members space, similarly to above.  Also, be careful not to
	 * return zero as the starting offset for any multixact. See
	 * GetMultiXactIdMembers() for motivation.
	 */</comment>
	<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmembers</name><operator>++</operator></expr>;</expr_stmt>				<comment type="block">/* allocate member slot 0 too */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name>nextOffset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*----------
	 * Protect against overrun of the members space as well, with the
	 * following rules:
	 *
	 * If we're past offsetStopLimit, refuse to generate more multis.
	 * If we're close to offsetStopLimit, emit a warning.
	 *
	 * Arbitrarily, we start emitting warnings when we're 20 segments or less
	 * from offsetStopLimit.
	 *
	 * Note we haven't updated the shared state yet, so if we fail at this
	 * point, the multixact ID we grabbed can still be used by the next guy.
	 *
	 * Note that there is no point in forcing autovacuum runs here: the
	 * multixact freeze settings would have to be reduced for that to have any
	 * effect.
	 *----------
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET_WARN_SEGMENTS</name></cpp:macro>	<cpp:value>20</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name> <operator>&amp;&amp;</operator>
		<call><name>MultiXactOffsetWouldWrap</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name></expr></argument>, <argument><expr><name>nextOffset</name></expr></argument>,
								 <argument><expr><name>nmembers</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* see comment in the corresponding offsets wraparound case */</comment>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multixact \"members\" limit exceeded"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"This command would create a multixact with %u members, but the remaining space is only enough for %u member."</literal></expr></argument>,
								  <argument><expr><literal type="string">"This command would create a multixact with %u members, but the remaining space is only enough for %u members."</literal></expr></argument>,
								  <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name> <operator>-</operator> <name>nextOffset</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>nmembers</name></expr></argument>,
								  <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name> <operator>-</operator> <name>nextOffset</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in database with OID %u with reduced vacuum_multixact_freeze_min_age and vacuum_multixact_freeze_table_age settings."</literal></expr></argument>,
						 <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check whether we should kick autovacuum into action, to prevent members
	 * wraparound. NB we use a much larger window to trigger autovacuum than
	 * just the warning limit. The warning is just a measure of last resort -
	 * this is in line with GetNewTransactionId's behaviour.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name> <operator>||</operator>
		<operator>(</operator><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>-</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffset</name></name>
		 <operator>&gt;</operator> <name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To avoid swamping the postmaster with signals, we issue the autovac
		 * request only when crossing a segment boundary. With default
		 * compilation settings that's roughly after 50k members.  This still
		 * gives plenty of chances before we get into real trouble.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>nextOffset</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name><operator>)</operator> <operator>!=</operator>
			<operator>(</operator><call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>nextOffset</name> <operator>+</operator> <name>nmembers</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name> <operator>&amp;&amp;</operator>
		<call><name>MultiXactOffsetWouldWrap</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name></expr></argument>,
								 <argument><expr><name>nextOffset</name></expr></argument>,
								 <argument><expr><name>nmembers</name> <operator>+</operator> <name>MULTIXACT_MEMBERS_PER_PAGE</name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name> <operator>*</operator> <name>OFFSET_WARN_SEGMENTS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed before %d more multixact member is used"</literal></expr></argument>,
							   <argument><expr><literal type="string">"database with OID %u must be vacuumed before %d more multixact members are used"</literal></expr></argument>,
							   <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name> <operator>-</operator> <name>nextOffset</name> <operator>+</operator> <name>nmembers</name></expr></argument>,
							   <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name></expr></argument>,
							   <argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name> <operator>-</operator> <name>nextOffset</name> <operator>+</operator> <name>nmembers</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Execute a database-wide VACUUM in that database with reduced vacuum_multixact_freeze_min_age and vacuum_multixact_freeze_table_age settings."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExtendMultiXactMember</name><argument_list>(<argument><expr><name>nextOffset</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Critical section from here until caller has written the data into the
	 * just-reserved SLRU space; we don't want to error out with a partly
	 * written MultiXact structure.  (In particular, failing to write our
	 * start offset after advancing nextMXact would effectively corrupt the
	 * previous MultiXact.)
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance counters.  As in GetNewTransactionId(), this must not happen
	 * until after file extension has succeeded!
	 *
	 * We don't care about MultiXactId wraparound here; it will be handled by
	 * the next iteration.  But note that nextMXact may be InvalidMultiXactId
	 * or the first value on a segment-beginning page after this routine
	 * exits, so anyone else looking at the variable must be prepared to deal
	 * with either case.  Similarly, nextOffset may be zero, but we won't use
	 * that as the actual start offset of the next multixact.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>+=</operator> <name>nmembers</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetNew: returning %u offset %u"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetMultiXactIdMembers
 *		Return the set of MultiXactMembers that make up a MultiXactId
 *
 * Return value is the number of members found, or -1 if there are none,
 * and *members is set to a newly palloc'ed array of members.  It's the
 * caller's responsibility to free it when done with it.
 *
 * from_pgupgrade must be passed as true if and only if only the multixact
 * corresponds to a value from a tuple that was locked in a 9.2-or-older
 * installation and later pg_upgrade'd (that is, the infomask is
 * HEAP_LOCKED_UPGRADED).  In this case, we know for certain that no members
 * can still be running, so we return -1 just like for an empty multixact
 * without any further checking.  It would be wrong to try to resolve such a
 * multixact: either the multixact is within the current valid multixact
 * range, in which case the returned result would be bogus, or outside that
 * range, in which case an error would be raised.
 *
 * In all other cases, the passed multixact must be within the known valid
 * range, that is, greater to or equal than oldestMultiXactId, and less than
 * nextMXact.  Otherwise, an error is raised.
 *
 * onlyLock must be set to true if caller is certain that the given multi
 * is used only to lock tuples; can be false without loss of correctness,
 * but passing a true means we can return quickly without checking for
 * old updates.
 */</comment>
<function><type><name>int</name></type>
<name>GetMultiXactIdMembers</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier><modifier>*</modifier></type><name>members</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>from_pgupgrade</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>onlyLock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prev_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>truelength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>tmpMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetMembers: asked for %u"</literal></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>from_pgupgrade</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* See if the MultiXactId is in the local cache */</comment>
	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>mXactCacheGetById</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetMembers: found %s in the cache"</literal></expr></argument>,
					<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>*</operator><name>members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>length</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set our OldestVisibleMXactId[] entry if we didn't already */</comment>
	<expr_stmt><expr><call><name>MultiXactIdSetOldestVisible</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we know the multi is used only for locking and not for updates, then
	 * we can skip checking if the value is older than our oldest visible
	 * multi.  It cannot possibly still be running.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>onlyLock</name> <operator>&amp;&amp;</operator>
		<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name><name>OldestVisibleMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetMembers: a locker-only multi is too old"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>members</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check known limits on MultiXact before resorting to the SLRU area.
	 *
	 * An ID older than MultiXactState-&gt;oldestMultiXactId cannot possibly be
	 * useful; it has already been removed, or will be removed shortly, by
	 * truncation.  If one is passed, an error is raised.
	 *
	 * Also, an ID &gt;= nextMXact shouldn't ever be seen here; if it is seen, it
	 * implies undetected ID wraparound has occurred.  This raises a hard
	 * error.
	 *
	 * Shared lock is enough here since we aren't modifying any global state.
	 * Acquire it just long enough to grab the current counter values.  We may
	 * need both nextMXact and nextOffset; see below.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>oldestMXact</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXactId %u does no longer exist -- apparent wraparound"</literal></expr></argument>,
						<argument><expr><name>multi</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>nextMXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXactId %u has not been created yet -- apparent wraparound"</literal></expr></argument>,
						<argument><expr><name>multi</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find out the offset at which we need to start reading MultiXactMembers
	 * and the number of members in the multixact.  We determine the latter as
	 * the difference between this multixact's starting offset and the next
	 * one's.  However, there are some corner cases to worry about:
	 *
	 * 1. This multixact may be the latest one created, in which case there is
	 * no next one to look at.  In this case the nextOffset value we just
	 * saved is the correct endpoint.
	 *
	 * 2. The next multixact may still be in process of being filled in: that
	 * is, another process may have done GetNewMultiXactId but not yet written
	 * the offset entry for that ID.  In that scenario, it is guaranteed that
	 * the offset entry for that multixact exists (because GetNewMultiXactId
	 * won't release MultiXactGenLock until it does) but contains zero
	 * (because we are careful to pre-zero offset pages). Because
	 * GetNewMultiXactId will never return zero as the starting offset for a
	 * multixact, when we read zero as the next multixact's offset, we know we
	 * have this case.  We sleep for a bit and try again.
	 *
	 * 3. Because GetNewMultiXactId increments offset zero to offset one to
	 * handle case #2, there is an ambiguity near the point of offset
	 * wraparound.  If we see next multixact's offset is one, is that our
	 * multixact's actual endpoint, or did it end at zero with a subsequent
	 * increment?  We handle this using the knowledge that if the zero'th
	 * member slot wasn't filled, it'll contain zero, and zero isn't a valid
	 * transaction ID so it can't be a multixact member.  Therefore, if we
	 * read a zero from the members array, just ignore it.
	 *
	 * This is all pretty messy, but the mess occurs only in infrequent corner
	 * cases, so it seems better than holding the MultiXactGenLock for a long
	 * time on every multixact creation.
	 */</comment>
<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactOffset</name> <operator>*</operator><operator>)</operator> <name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>*</operator><name>offptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the same increment rule as GetNewMultiXactId(), that is, don't
	 * handle wraparound explicitly until needed.
	 */</comment>
	<expr_stmt><expr><name>tmpMXact</name> <operator>=</operator> <name>multi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nextMXact</name> <operator>==</operator> <name>tmpMXact</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Corner case 1: there is no next multixact */</comment>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <name>nextOffset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextMXOffset</name></decl>;</decl_stmt>

		<comment type="block">/* handle wraparound if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>tmpMXact</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmpMXact</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>prev_pageno</name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>tmpMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>tmpMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>!=</operator> <name>prev_pageno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tmpMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>offptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactOffset</name> <operator>*</operator><operator>)</operator> <name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextMXOffset</name> <operator>=</operator> <operator>*</operator><name>offptr</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nextMXOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Corner case 2: next multixact is still being filled in */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>length</name> <operator>=</operator> <name>nextMXOffset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>members</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

	<comment type="block">/* Now get the members themselves. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>truelength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_pageno</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>offset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xactptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>flagsptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flagsoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bshift</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>memberoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>memberoff</name> <operator>=</operator> <call><name>MXOffsetToMemberOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pageno</name> <operator>!=</operator> <name>prev_pageno</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_pageno</name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>xactptr</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>memberoff</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>xactptr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Corner case 3: we must be looking at unused slot zero */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>flagsoff</name> <operator>=</operator> <call><name>MXOffsetToFlagsOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bshift</name> <operator>=</operator> <call><name>MXOffsetToFlagsBitShift</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flagsptr</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>flagsoff</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>truelength</name></expr>]</index></name><operator>.</operator><name>xid</name> <operator>=</operator> <operator>*</operator><name>xactptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>truelength</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>flagsptr</name> <operator>&gt;&gt;</operator> <name>bshift</name><operator>)</operator> <operator>&amp;</operator> <name>MXACT_MEMBER_XACT_BITMASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>truelength</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the result into the local cache.
	 */</comment>
	<expr_stmt><expr><call><name>mXactCachePut</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>truelength</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"GetMembers: no cache for %s"</literal></expr></argument>,
				<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>truelength</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>truelength</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mxactMemberComparator
 *		qsort comparison function for MultiXactMember
 *
 * We can't use wraparound comparison for XIDs because that does not respect
 * the triangle inequality!  Any old sort order will do.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mxactMemberComparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactMember</name></type> <name>member1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>MultiXactMember</name> <operator>*</operator><operator>)</operator> <name>arg1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactMember</name></type> <name>member2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>MultiXactMember</name> <operator>*</operator><operator>)</operator> <name>arg2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>member1</name><operator>.</operator><name>xid</name></name> <operator>&gt;</operator> <name><name>member2</name><operator>.</operator><name>xid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>member1</name><operator>.</operator><name>xid</name></name> <operator>&lt;</operator> <name><name>member2</name><operator>.</operator><name>xid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>member1</name><operator>.</operator><name>status</name></name> <operator>&gt;</operator> <name><name>member2</name><operator>.</operator><name>status</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>member1</name><operator>.</operator><name>status</name></name> <operator>&lt;</operator> <name><name>member2</name><operator>.</operator><name>status</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mXactCacheGetBySet
 *		returns a MultiXactId from the cache based on the set of
 *		TransactionIds that compose it, or InvalidMultiXactId if
 *		none matches.
 *
 * This is helpful, for example, if two transactions want to lock a huge
 * table.  By using the cache, the second will use the same MultiXactId
 * for the majority of tuples, thus keeping MultiXactId usage low (saving
 * both I/O and wraparound issues).
 *
 * NB: the passed members array will be sorted in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiXactId</name></type>
<name>mXactCacheGetBySet</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: looking for %s"</literal></expr></argument>,
				<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>InvalidMultiXactId</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort the array so comparison is easy */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>members</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>mxactMemberComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;MXactCache</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mXactCacheEnt</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>mXactCacheEnt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>nmembers</name></name> <operator>!=</operator> <name>nmembers</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We assume the cache entries are sorted, and that the unused bits in
		 * "status" are zeroed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>members</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>members</name></name></expr></argument>, <argument><expr><name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: found %u"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_move_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>multi</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: not found :-("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>InvalidMultiXactId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mXactCacheGetById
 *		returns the composing MultiXactMember set from the cache for a
 *		given MultiXactId, if present.
 *
 * If successful, *xids is set to the address of a palloc'd copy of the
 * MultiXactMember set.  Return value is number of members, or -1 on failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mXactCacheGetById</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier><modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: looking for %u"</literal></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;MXactCache</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>mXactCacheEnt</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>mXactCacheEnt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>multi</name></name> <operator>==</operator> <name>multi</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>nmembers</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactMember</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>members</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>members</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: found %s"</literal></expr></argument>,
						<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>multi</name></expr></argument>,
									   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nmembers</name></name></expr></argument>,
									   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>members</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note we modify the list while not using a modifiable iterator.
			 * This is acceptable only because we exit the iteration
			 * immediately afterwards.
			 */</comment>
			<expr_stmt><expr><call><name>dlist_move_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>nmembers</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CacheGet: not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * mXactCachePut
 *		Add a new MultiXactId and its composing set into the local cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mXactCachePut</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mXactCacheEnt</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CachePut: storing %s"</literal></expr></argument>,
				<argument><expr><call><name>mxid_to_string</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MXactContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The cache only lives as long as the current transaction */</comment>
		<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CachePut: initializing memory context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MXactContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
											 <argument><expr><literal type="string">"MultiXact cache context"</literal></expr></argument>,
											 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>mXactCacheEnt</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>MXactContext</name></expr></argument>,
						   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>mXactCacheEnt</name></expr></argument>, <argument><expr><name>members</name></expr></argument>)</argument_list></call> <operator>+</operator>
						   <name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>multi</name></name> <operator>=</operator> <name>multi</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nmembers</name></name> <operator>=</operator> <name>nmembers</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>members</name></name></expr></argument>, <argument><expr><name>members</name></expr></argument>, <argument><expr><name>nmembers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mXactCacheGetBySet assumes the entries are sorted, so sort them */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>members</name></name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactMember</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>mxactMemberComparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MXactCacheMembers</name><operator>++</operator> <operator>&gt;=</operator> <name>MAX_CACHE_ENTRIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mXactCacheEnt</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>dlist_tail_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MXactCacheMembers</name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>mXactCacheEnt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"CachePut: pruning cached multi %u"</literal></expr></argument>,
					<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>mxstatus_to_string</name><parameter_list>(<parameter><decl><type><name>MultiXactStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>status</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>MultiXactStatusForKeyShare</name></expr>:</case>
			<return>return <expr><literal type="string">"keysh"</literal></expr>;</return>
		<case>case <expr><name>MultiXactStatusForShare</name></expr>:</case>
			<return>return <expr><literal type="string">"sh"</literal></expr>;</return>
		<case>case <expr><name>MultiXactStatusForNoKeyUpdate</name></expr>:</case>
			<return>return <expr><literal type="string">"fornokeyupd"</literal></expr>;</return>
		<case>case <expr><name>MultiXactStatusForUpdate</name></expr>:</case>
			<return>return <expr><literal type="string">"forupd"</literal></expr>;</return>
		<case>case <expr><name>MultiXactStatusNoKeyUpdate</name></expr>:</case>
			<return>return <expr><literal type="string">"nokeyupd"</literal></expr>;</return>
		<case>case <expr><name>MultiXactStatusUpdate</name></expr>:</case>
			<return>return <expr><literal type="string">"upd"</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized multixact status %d"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>mxid_to_string</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>, <parameter><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u %d[%u (%s)"</literal></expr></argument>, <argument><expr><name>multi</name></expr></argument>, <argument><expr><name>nmembers</name></expr></argument>, <argument><expr><name><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>,
					 <argument><expr><call><name>mxstatus_to_string</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", %u (%s)"</literal></expr></argument>, <argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>,
						 <argument><expr><call><name>mxstatus_to_string</name><argument_list>(<argument><expr><name><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_MultiXact
 *		Handle transaction end for MultiXact
 *
 * This is called at top transaction commit or abort (we don't care which).
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_MultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Reset our OldestMemberMXactId and OldestVisibleMXactId values, both of
	 * which should only be valid while within a transaction.
	 *
	 * We assume that storing a MultiXactId is atomic and so we need not take
	 * MultiXactGenLock to do this.
	 */</comment>
	<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>OldestVisibleMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Discard the local MultiXactId cache.  Since MXactContext was created as
	 * a child of TopTransactionContext, we needn't delete it explicitly.
	 */</comment>
	<expr_stmt><expr><name>MXactContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MXactCacheMembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtPrepare_MultiXact
 *		Save multixact state at 2PC transaction prepare
 *
 * In this phase, we only store our OldestMemberMXactId value in the two-phase
 * state file.
 */</comment>
<function><type><name>void</name></type>
<name>AtPrepare_MultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>myOldestMember</name> <init>= <expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>myOldestMember</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RegisterTwoPhaseRecord</name><argument_list>(<argument><expr><name>TWOPHASE_RM_MULTIXACT_ID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>myOldestMember</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PostPrepare_MultiXact
 *		Clean up after successful PREPARE TRANSACTION
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_MultiXact</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>myOldestMember</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transfer our OldestMemberMXactId value to the slot reserved for the
	 * prepared transaction.
	 */</comment>
	<expr_stmt><expr><name>myOldestMember</name> <operator>=</operator> <name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>myOldestMember</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BackendId</name></type>	<name>dummyBackendId</name> <init>= <expr><call><name>TwoPhaseGetDummyBackendId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Even though storing MultiXactId is atomic, acquire lock to make
		 * sure others see both changes, not just the reset of the slot of the
		 * current backend. Using a volatile pointer might suffice, but this
		 * isn't a hot spot.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>dummyBackendId</name></expr>]</index></name> <operator>=</operator> <name>myOldestMember</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to transfer OldestVisibleMXactId value, because the
	 * transaction is not going to be looking at any more multixacts once it's
	 * prepared.
	 *
	 * We assume that storing a MultiXactId is atomic and so we need not take
	 * MultiXactGenLock to do this.
	 */</comment>
	<expr_stmt><expr><name><name>OldestVisibleMXactId</name><index>[<expr><name>MyBackendId</name></expr>]</index></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Discard the local MultiXactId cache like in AtEOX_MultiXact
	 */</comment>
	<expr_stmt><expr><name>MXactContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>MXactCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MXactCacheMembers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * multixact_twophase_recover
 *		Recover the state of a prepared transaction at startup
 */</comment>
<function><type><name>void</name></type>
<name>multixact_twophase_recover</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>dummyBackendId</name> <init>= <expr><call><name>TwoPhaseGetDummyBackendId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMember</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the oldest member XID from the state file record, and set it in the
	 * OldestMemberMXactId slot reserved for this prepared transaction.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMember</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>MultiXactId</name> <operator>*</operator><operator>)</operator> <name>recdata</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>dummyBackendId</name></expr>]</index></name> <operator>=</operator> <name>oldestMember</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * multixact_twophase_postcommit
 *		Similar to AtEOX_MultiXact but for COMMIT PREPARED
 */</comment>
<function><type><name>void</name></type>
<name>multixact_twophase_postcommit</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
							  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>dummyBackendId</name> <init>= <expr><call><name>TwoPhaseGetDummyBackendId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>OldestMemberMXactId</name><index>[<expr><name>dummyBackendId</name></expr>]</index></name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * multixact_twophase_postabort
 *		This is actually just the same as the COMMIT case.
 */</comment>
<function><type><name>void</name></type>
<name>multixact_twophase_postabort</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>info</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>recdata</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>multixact_twophase_postcommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>recdata</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialization of shared memory for MultiXact.  We use two SLRU areas,
 * thus double memory.  Also, reserve space for the shared MultiXactState
 * struct and the per-backend MultiXactId arrays (two of those, too).
 */</comment>
<function><type><name>Size</name></type>
<name>MultiXactShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* We need 2*MaxOldestSlot + 1 perBackendXactIds[] entries */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_MULTIXACT_STATE_SIZE</name></cpp:macro> \
	<cpp:value>add_size(offsetof(MultiXactStateData, perBackendXactIds) + sizeof(MultiXactId), \
			 mul_size(sizeof(MultiXactId) * 2, MaxOldestSlot))</cpp:value></cpp:define>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>SHARED_MULTIXACT_STATE_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>NUM_MXACTOFFSET_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>SimpleLruShmemSize</name><argument_list>(<argument><expr><name>NUM_MXACTMEMBER_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>MultiXactShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>debug_elog2</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Shared Memory Init for MultiXact"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>MultiXactOffsetPagePrecedes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>PagePrecedes</name></name> <operator>=</operator> <name>MultiXactMemberPagePrecedes</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>,
				  <argument><expr><literal type="string">"multixact_offset"</literal></expr></argument>, <argument><expr><name>NUM_MXACTOFFSET_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><literal type="string">"pg_multixact/offsets"</literal></expr></argument>,
				  <argument><expr><name>LWTRANCHE_MXACTOFFSET_BUFFERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruInit</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>,
				  <argument><expr><literal type="string">"multixact_member"</literal></expr></argument>, <argument><expr><name>NUM_MXACTMEMBER_BUFFERS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				  <argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><literal type="string">"pg_multixact/members"</literal></expr></argument>,
				  <argument><expr><name>LWTRANCHE_MXACTMEMBER_BUFFERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize our shared state struct */</comment>
	<expr_stmt><expr><name>MultiXactState</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Shared MultiXact State"</literal></expr></argument>,
									 <argument><expr><name>SHARED_MULTIXACT_STATE_SIZE</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure we zero out the per-backend state */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>MultiXactState</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_MULTIXACT_STATE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set up array pointers.  Note that perBackendXactIds[0] is wasted space
	 * since we only use indexes 1..MaxOldestSlot in each array.
	 */</comment>
	<expr_stmt><expr><name>OldestMemberMXactId</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>perBackendXactIds</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>OldestVisibleMXactId</name> <operator>=</operator> <name>OldestMemberMXactId</name> <operator>+</operator> <name>MaxOldestSlot</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This func must be called ONCE on system install.  It creates the initial
 * MultiXact segments.  (The MultiXacts directories are assumed to have been
 * created by initdb, and MultiXactShmemInit must have been called already.)
 */</comment>
<function><type><name>void</name></type>
<name>BootStrapMultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create and zero the first page of the offsets log */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>ZeroMultiXactOffsetPage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure it's written out */</comment>
	<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create and zero the first page of the members log */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>ZeroMultiXactMemberPage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure it's written out */</comment>
	<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (or reinitialize) a page of MultiXactOffset to zeroes.
 * If writeXlog is true, also emit an XLOG record saying we did this.
 *
 * The page is not actually written, just set up in shared memory.
 * The slot number of the new page is returned.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ZeroMultiXactOffsetPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writeXlog</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteMZeroPageXlogRec</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>XLOG_MULTIXACT_ZERO_OFF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ditto, for MultiXactMember
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ZeroMultiXactMemberPage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writeXlog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruZeroPage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>writeXlog</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteMZeroPageXlogRec</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>XLOG_MULTIXACT_ZERO_MEM_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MaybeExtendOffsetSlru
 *		Extend the offsets SLRU area, if necessary
 *
 * After a binary upgrade from &lt;= 9.2, the pg_multixact/offsets SLRU area might
 * contain files that are shorter than necessary; this would occur if the old
 * installation had used multixacts beyond the first page (files cannot be
 * copied, because the on-disk representation is different).  pg_upgrade would
 * update pg_control to set the next offset value to be at that position, so
 * that tuples marked as locked by such MultiXacts would be seen as visible
 * without having to consult multixact.  However, trying to create and use a
 * new MultiXactId would result in an error because the page on which the new
 * value would reside does not exist.  This routine is in charge of creating
 * such pages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MaybeExtendOffsetSlru</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SimpleLruDoesPhysicalPageExist</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Fortunately for us, SimpleLruWritePage is already prepared to deal
		 * with creating a new segment file even if the page we're writing is
		 * not the first in it, so this is enough.
		 */</comment>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>ZeroMultiXactOffsetPage</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend startup.
 *
 * StartupXLOG has already established nextMXact/nextOffset by calling
 * MultiXactSetNextMXact and/or MultiXactAdvanceNextMXact, and the oldestMulti
 * info from pg_control and/or MultiXactAdvanceOldest, but we haven't yet
 * replayed WAL.
 */</comment>
<function><type><name>void</name></type>
<name>StartupMultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset</name> <init>= <expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize offset's idea of the latest page number.
	 */</comment>
	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize member's idea of the latest page number.
	 */</comment>
	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE at the end of startup/recovery.
 */</comment>
<function><type><name>void</name></type>
<name>TrimMultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldestMXactDB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flagsoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMXactDB</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up offsets state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (Re-)Initialize our idea of the latest page number for offsets.
	 */</comment>
	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>nextMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zero out the remainder of the current offsets page.  See notes in
	 * TrimCLOG() for background.  Unlike CLOG, some WAL record covers every
	 * pg_multixact SLRU mutation.  Since, also unlike CLOG, we ignore the WAL
	 * rule "write xlog before data," nextMXact successors may carry obsolete,
	 * nonzero offset values.  Zero those so case 2 of GetMultiXactIdMembers()
	 * operates normally.
	 */</comment>
	<expr_stmt><expr><name>entryno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>nextMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entryno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nextMXact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactOffset</name> <operator>*</operator><operator>)</operator> <name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>offptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <operator>(</operator><name>entryno</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiXactOffset</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And the same for members */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (Re-)Initialize our idea of the latest page number for members.
	 */</comment>
	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zero out the remainder of the current members page.  See notes in
	 * TrimCLOG() for motivation.
	 */</comment>
	<expr_stmt><expr><name>flagsoff</name> <operator>=</operator> <call><name>MXOffsetToFlagsOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flagsoff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xidptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>memberoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>memberoff</name> <operator>=</operator> <call><name>MXOffsetToMemberOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xidptr</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator>
			<operator>(</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>+</operator> <name>memberoff</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>xidptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name>memberoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we don't need to zero out the flag bits in the remaining
		 * members of the current group, because they are always reset before
		 * writing.
		 */</comment>

		<expr_stmt><expr><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* signal that we're officially up */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>finishedStartup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now compute how far away the next members wraparound is. */</comment>
	<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name>oldestMXact</name></expr></argument>, <argument><expr><name>oldestMXactDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This must be called ONCE during postmaster or standalone-backend shutdown
 */</comment>
<function><type><name>void</name></type>
<name>ShutdownMultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Flush dirty MultiXact pages to disk */</comment>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the MultiXact data to save in a checkpoint record
 */</comment>
<function><type><name>void</name></type>
<name>MultiXactGetCheckptMulti</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_shutdown</name></decl></parameter>,
						 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>nextMulti</name></decl></parameter>,
						 <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>nextMultiOffset</name></decl></parameter>,
						 <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>oldestMulti</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldestMultiDB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nextMulti</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nextMultiOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>oldestMulti</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>oldestMultiDB</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>debug_elog6</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
				<argument><expr><literal type="string">"MultiXact: checkpoint is nextMulti %u, nextOffset %u, oldestMulti %u in DB %u"</literal></expr></argument>,
				<argument><expr><operator>*</operator><name>nextMulti</name></expr></argument>, <argument><expr><operator>*</operator><name>nextMultiOffset</name></expr></argument>, <argument><expr><operator>*</operator><name>oldestMulti</name></expr></argument>, <argument><expr><operator>*</operator><name>oldestMultiDB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a checkpoint --- either during shutdown, or on-the-fly
 */</comment>
<function><type><name>void</name></type>
<name>CheckPointMultiXact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flush dirty MultiXact pages to disk */</comment>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the next-to-be-assigned MultiXactId and offset
 *
 * This is used when we can determine the correct next ID/offset exactly
 * from a checkpoint record.  Although this is only called during bootstrap
 * and XLog replay, we take the lock in case any hot-standby backends are
 * examining the values.
 */</comment>
<function><type><name>void</name></type>
<name>MultiXactSetNextMXact</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>nextMulti</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactOffset</name></type> <name>nextMultiOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>debug_elog4</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"MultiXact: setting next multi to %u offset %u"</literal></expr></argument>,
				<argument><expr><name>nextMulti</name></expr></argument>, <argument><expr><name>nextMultiOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name> <operator>=</operator> <name>nextMulti</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>nextMultiOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During a binary upgrade, make sure that the offsets SLRU is large
	 * enough to contain the next value that would be created.
	 *
	 * We need to do this pretty early during the first startup in binary
	 * upgrade mode: before StartupMultiXact() in fact, because this routine
	 * is called even before that by StartupXLOG().  And we can't do it
	 * earlier than at this point, because during that first call of this
	 * routine we determine the MultiXactState-&gt;nextMXact value that
	 * MaybeExtendOffsetSlru needs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MaybeExtendOffsetSlru</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the last safe MultiXactId to allocate given the currently oldest
 * datminmxid (ie, the oldest MultiXactId that might exist in any database
 * of our cluster), and the OID of the (or a) database with that value.
 *
 * is_startup is true when we are just starting the cluster, false when we
 * are updating state in a running cluster.  This only affects log messages.
 */</comment>
<function><type><name>void</name></type>
<name>SetMultiXactIdLimit</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>oldest_datminmxid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldest_datoid</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>is_startup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiVacLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWarnLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiStopLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiWrapLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>curMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_offset_vacuum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>oldest_datminmxid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We pretend that a wrap will happen halfway through the multixact ID
	 * space, but that's not really true, because multixacts wrap differently
	 * from transaction IDs.  Note that, separately from any concern about
	 * multixact IDs wrapping, we must ensure that multixact members do not
	 * wrap.  Limits for that are set in DetermineSafeOldestOffset, not here.
	 */</comment>
	<expr_stmt><expr><name>multiWrapLimit</name> <operator>=</operator> <name>oldest_datminmxid</name> <operator>+</operator> <operator>(</operator><name>MaxMultiXactId</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>multiWrapLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>multiWrapLimit</name> <operator>+=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll refuse to continue assigning MultiXactIds once we get within 100
	 * multi of data loss.
	 *
	 * Note: This differs from the magic number used in
	 * SetTransactionIdLimit() since vacuum itself will never generate new
	 * multis.  XXX actually it does, if it needs to freeze old multis.
	 */</comment>
	<expr_stmt><expr><name>multiStopLimit</name> <operator>=</operator> <name>multiWrapLimit</name> <operator>-</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>multiStopLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>multiStopLimit</name> <operator>-=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start complaining loudly when we get within 10M multis of the
	 * stop point.   This is kind of arbitrary, but if you let your gas gauge
	 * get down to 1% of full, would you be looking for the next gas station?
	 * We need to be fairly liberal about this number because there are lots
	 * of scenarios where most transactions are done by automatic clients that
	 * won't pay attention to warnings. (No, we're not gonna make this
	 * configurable.  If you know enough to configure it, you know enough to
	 * not get in this kind of trouble in the first place.)
	 */</comment>
	<expr_stmt><expr><name>multiWarnLimit</name> <operator>=</operator> <name>multiStopLimit</name> <operator>-</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>multiWarnLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>multiWarnLimit</name> <operator>-=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We'll start trying to force autovacuums when oldest_datminmxid gets to
	 * be more than autovacuum_multixact_freeze_max_age mxids old.
	 *
	 * Note: autovacuum_multixact_freeze_max_age is a PGC_POSTMASTER parameter
	 * so that we don't have to worry about dealing with on-the-fly changes in
	 * its value.  See SetTransactionIdLimit.
	 */</comment>
	<expr_stmt><expr><name>multiVacLimit</name> <operator>=</operator> <name>oldest_datminmxid</name> <operator>+</operator> <name>autovacuum_multixact_freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>multiVacLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>multiVacLimit</name> <operator>+=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Grab lock for just long enough to set the new limit values */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name> <operator>=</operator> <name>oldest_datminmxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name> <operator>=</operator> <name>oldest_datoid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiVacLimit</name></name> <operator>=</operator> <name>multiVacLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiWarnLimit</name></name> <operator>=</operator> <name>multiWarnLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiStopLimit</name></name> <operator>=</operator> <name>multiStopLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>multiWrapLimit</name></name> <operator>=</operator> <name>multiWrapLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curMulti</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the info */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXactId wrap limit is %u, limited by database with OID %u"</literal></expr></argument>,
					<argument><expr><name>multiWrapLimit</name></expr></argument>, <argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Computing the actual limits is only possible once the data directory is
	 * in a consistent state. There's no need to compute the limits while
	 * still replaying WAL - no decisions about new multis are made even
	 * though multixact creations might be replayed. So we'll only do further
	 * checks after TrimMultiXact() has been called.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MultiXactState</name><operator>-&gt;</operator><name>finishedStartup</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>InRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set limits for offset vacuum. */</comment>
	<expr_stmt><expr><name>needs_offset_vacuum</name> <operator>=</operator> <call><name>SetOffsetVacuumLimit</name><argument_list>(<argument><expr><name>is_startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If past the autovacuum force point, immediately signal an autovac
	 * request.  The reason for this is that autovac only processes one
	 * database per invocation.  Once it's finished cleaning up the oldest
	 * database, it'll call here, and we'll signal the postmaster to start
	 * another iteration immediately if there are still any old databases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multiVacLimit</name></expr></argument>, <argument><expr><name>curMulti</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <name>needs_offset_vacuum</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Give an immediate warning if past the wrap warn point */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multiWarnLimit</name></expr></argument>, <argument><expr><name>curMulti</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldest_datname</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We can be called when not inside a transaction, for example during
		 * StartupXLOG().  In such a case we cannot do database access, so we
		 * must just report the oldest DB's OID.
		 *
		 * Note: it's also possible that get_database_name fails and returns
		 * NULL, for example because the database just got dropped.  We'll
		 * still warn, even though the warning might now be unnecessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>oldest_datoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest_datname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldest_datname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" must be vacuumed before %u more MultiXactId is used"</literal></expr></argument>,
								   <argument><expr><literal type="string">"database \"%s\" must be vacuumed before %u more MultiXactIds are used"</literal></expr></argument>,
								   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>curMulti</name></expr></argument>,
								   <argument><expr><name>oldest_datname</name></expr></argument>,
								   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>curMulti</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"database with OID %u must be vacuumed before %u more MultiXactId is used"</literal></expr></argument>,
								   <argument><expr><literal type="string">"database with OID %u must be vacuumed before %u more MultiXactIds are used"</literal></expr></argument>,
								   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>curMulti</name></expr></argument>,
								   <argument><expr><name>oldest_datoid</name></expr></argument>,
								   <argument><expr><name>multiWrapLimit</name> <operator>-</operator> <name>curMulti</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To avoid a database shutdown, execute a database-wide VACUUM in that database.\n"</literal>
							 <literal type="string">"You might also need to commit or roll back old prepared transactions, or drop stale replication slots."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure the next-to-be-assigned MultiXactId is at least minMulti,
 * and similarly nextOffset is at least minMultiOffset.
 *
 * This is used when we can determine minimum safe values from an XLog
 * record (either an on-line checkpoint or an mxact creation log entry).
 * Although this is only called during XLog replay, we take the lock in case
 * any hot-standby backends are examining the values.
 */</comment>
<function><type><name>void</name></type>
<name>MultiXactAdvanceNextMXact</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>minMulti</name></decl></parameter>,
						  <parameter><decl><type><name>MultiXactOffset</name></type> <name>minMultiOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr></argument>, <argument><expr><name>minMulti</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"MultiXact: setting next multi to %u"</literal></expr></argument>, <argument><expr><name>minMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name> <operator>=</operator> <name>minMulti</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactOffsetPrecedes</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr></argument>, <argument><expr><name>minMultiOffset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>debug_elog3</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"MultiXact: setting next offset to %u"</literal></expr></argument>,
					<argument><expr><name>minMultiOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name>minMultiOffset</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update our oldestMultiXactId value, but only if it's more recent than what
 * we had.
 *
 * This may only be called during WAL replay.
 */</comment>
<function><type><name>void</name></type>
<name>MultiXactAdvanceOldest</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>oldestMulti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldestMultiDB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>InRecovery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr></argument>, <argument><expr><name>oldestMulti</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>oldestMultiDB</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure that MultiXactOffset has room for a newly-allocated MultiXactId.
 *
 * NB: this is called while holding MultiXactGenLock.  We want it to be very
 * fast most of the time; even when it's not so fast, no actual I/O need
 * happen unless we're forced to write out a dirty log or xlog page to make
 * room in shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtendMultiXactOffset</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * No work except at first MultiXactId of a page.  But beware: just after
	 * wraparound, the first MultiXactId of page zero is FirstMultiXactId.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>multi</name> <operator>!=</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero the page and make an XLOG entry about it */</comment>
	<expr_stmt><expr><call><name>ZeroMultiXactOffsetPage</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure that MultiXactMember has room for the members of a newly-
 * allocated MultiXactId.
 *
 * Like the above routine, this is called while holding MultiXactGenLock;
 * same comments apply.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtendMultiXactMember</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nmembers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * It's possible that the members span more than one page of the members
	 * file, so we loop to ensure we consider each page.  The coding is not
	 * optimal if the members span several pages, but that seems unusual
	 * enough to not worry much about.
	 */</comment>
	<while>while <condition>(<expr><name>nmembers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>flagsoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flagsbit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>difference</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Only zero when at first entry of a page.
		 */</comment>
		<expr_stmt><expr><name>flagsoff</name> <operator>=</operator> <call><name>MXOffsetToFlagsOffset</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flagsbit</name> <operator>=</operator> <call><name>MXOffsetToFlagsBitShift</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flagsoff</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>flagsbit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MXOffsetToMemberPage</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Zero the page and make an XLOG entry about it */</comment>
			<expr_stmt><expr><call><name>ZeroMultiXactMemberPage</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Compute the number of items till end of current page.  Careful: if
		 * addition of unsigned ints wraps around, we're at the last page of
		 * the last segment; since that page holds a different number of items
		 * than other pages, we need to do it differently.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>MAX_MEMBERS_IN_LAST_MEMBERS_PAGE</name> <operator>&lt;</operator> <name>offset</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is the last page of the last segment; we can compute the
			 * number of items left to allocate in it without modulo
			 * arithmetic.
			 */</comment>
			<expr_stmt><expr><name>difference</name> <operator>=</operator> <name>MaxMultiXactOffset</name> <operator>-</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>difference</name> <operator>=</operator> <name>MULTIXACT_MEMBERS_PER_PAGE</name> <operator>-</operator> <name>offset</name> <operator>%</operator> <name>MULTIXACT_MEMBERS_PER_PAGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Advance to next page, taking care to properly handle the wraparound
		 * case.  OK if nmembers goes negative.
		 */</comment>
		<expr_stmt><expr><name>nmembers</name> <operator>-=</operator> <name>difference</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>difference</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * GetOldestMultiXactId
 *
 * Return the oldest MultiXactId that's still possibly still seen as live by
 * any running transaction.  Older ones might still exist on disk, but they no
 * longer have any running member transaction.
 *
 * It's not safe to truncate MultiXact SLRU segments on the value returned by
 * this function; however, it can be used by a full-table vacuum to set the
 * point at which it will be possible to truncate SLRU for that table.
 */</comment>
<function><type><name>MultiXactId</name></type>
<name>GetOldestMultiXactId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is the oldest valid value among all the OldestMemberMXactId[] and
	 * OldestVisibleMXactId[] entries, or nextMXact if none are valid.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to beware of the possibility that nextMXact is in the
	 * wrapped-around state.  We don't fix the counter itself here, but we
	 * must be sure to use a valid value in our calculation.
	 */</comment>
	<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextMXact</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name>nextMXact</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MaxOldestSlot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiXactId</name></type> <name>thisoldest</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>thisoldest</name> <operator>=</operator> <name><name>OldestMemberMXactId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>, <argument><expr><name>oldestMXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name>thisoldest</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>thisoldest</name> <operator>=</operator> <name><name>OldestVisibleMXactId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>thisoldest</name></expr></argument>, <argument><expr><name>oldestMXact</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldestMXact</name> <operator>=</operator> <name>thisoldest</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oldestMXact</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine how aggressively we need to vacuum in order to prevent member
 * wraparound.
 *
 * To do so determine what's the oldest member offset and install the limit
 * info in MultiXactState, where it can be used to prevent overrun of old data
 * in the members SLRU area.
 *
 * The return value is true if emergency autovacuum is required and false
 * otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetOffsetVacuumLimit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_startup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMultiXactId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMXact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>oldestOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* placate compiler */</comment>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>prevOldestOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>oldestOffsetKnown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prevOldestOffsetKnown</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offsetStopLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>prevOffsetStopLimit</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * NB: Have to prevent concurrent truncation, we might otherwise try to
	 * lookup an oldestMulti that's concurrently getting truncated away.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read relevant fields from shared memory. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMultiXactId</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextMXact</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevOldestOffsetKnown</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevOldestOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevOffsetStopLimit</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>finishedStartup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the offset of the oldest multixact.  Normally, we can read
	 * the offset from the multixact itself, but there's an important special
	 * case: if there are no multixacts in existence at all, oldestMXact
	 * obviously can't point to one.  It will instead point to the multixact
	 * ID that will be assigned the next time one is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldestMultiXactId</name> <operator>==</operator> <name>nextMXact</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When the next multixact gets created, it will be stored at the next
		 * offset.
		 */</comment>
		<expr_stmt><expr><name>oldestOffset</name> <operator>=</operator> <name>nextOffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldestOffsetKnown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Figure out where the oldest existing multixact's offsets are
		 * stored. Due to bugs in early release of PostgreSQL 9.3.X and 9.4.X,
		 * the supposedly-earliest multixact might not really exist.  We are
		 * careful not to fail in that case.
		 */</comment>
		<expr_stmt><expr><name>oldestOffsetKnown</name> <operator>=</operator>
			<call><name>find_multixact_start</name><argument_list>(<argument><expr><name>oldestMultiXactId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldestOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldestOffsetKnown</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest MultiXactId member is at offset %u"</literal></expr></argument>,
							<argument><expr><name>oldestOffset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXact member wraparound protections are disabled because oldest checkpointed MultiXact %u does not exist on disk"</literal></expr></argument>,
							<argument><expr><name>oldestMultiXactId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we can, compute limits (and install them MultiXactState) to prevent
	 * overrun of old data in the members SLRU area. We can only do so if the
	 * oldest offset is known though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldestOffsetKnown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* move back to start of the corresponding segment */</comment>
		<expr_stmt><expr><name>offsetStopLimit</name> <operator>=</operator> <name>oldestOffset</name> <operator>-</operator> <operator>(</operator><name>oldestOffset</name> <operator>%</operator>
										  <operator>(</operator><name>MULTIXACT_MEMBERS_PER_PAGE</name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* always leave one segment before the wraparound point */</comment>
		<expr_stmt><expr><name>offsetStopLimit</name> <operator>-=</operator> <operator>(</operator><name>MULTIXACT_MEMBERS_PER_PAGE</name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prevOldestOffsetKnown</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_startup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXact member wraparound protections are now enabled"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MultiXact member stop limit is now %u based on MultiXact %u"</literal></expr></argument>,
						<argument><expr><name>offsetStopLimit</name></expr></argument>, <argument><expr><name>oldestMultiXactId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>prevOldestOffsetKnown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we failed to get the oldest offset this time, but we have a
		 * value from a previous pass through this function, use the old
		 * values rather than automatically forcing an emergency autovacuum
		 * cycle again.
		 */</comment>
		<expr_stmt><expr><name>oldestOffset</name> <operator>=</operator> <name>prevOldestOffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldestOffsetKnown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offsetStopLimit</name> <operator>=</operator> <name>prevOffsetStopLimit</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Install the computed values */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffset</name></name> <operator>=</operator> <name>oldestOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name> <operator>=</operator> <name>oldestOffsetKnown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>offsetStopLimit</name></name> <operator>=</operator> <name>offsetStopLimit</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do we need an emergency autovacuum?	If we're not sure, assume yes.
	 */</comment>
	<return>return <expr><operator>!</operator><name>oldestOffsetKnown</name> <operator>||</operator>
		<operator>(</operator><name>nextOffset</name> <operator>-</operator> <name>oldestOffset</name> <operator>&gt;</operator> <name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether adding "distance" to "start" would move past "boundary".
 *
 * We use this to determine whether the addition is "wrapping around" the
 * boundary point, hence the name.  The reason we don't want to use the regular
 * 2^31-modulo arithmetic here is that we want to be able to use the whole of
 * the 2^32-1 space here, allowing for more multixacts that would fit
 * otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MultiXactOffsetWouldWrap</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>boundary</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>start</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name></type> <name>distance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>finish</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that offset number 0 is not used (see GetMultiXactIdMembers), so
	 * if the addition wraps around the UINT_MAX boundary, skip that value.
	 */</comment>
	<expr_stmt><expr><name>finish</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>distance</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>finish</name> <operator>&lt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>finish</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*-----------------------------------------------------------------------
	 * When the boundary is numerically greater than the starting point, any
	 * value numerically between the two is not wrapped:
	 *
	 *	&lt;----S----B----&gt;
	 *	[---)			 = F wrapped past B (and UINT_MAX)
	 *		 [---)		 = F not wrapped
	 *			  [----] = F wrapped past B
	 *
	 * When the boundary is numerically less than the starting point (i.e. the
	 * UINT_MAX wraparound occurs somewhere in between) then all values in
	 * between are wrapped:
	 *
	 *	&lt;----B----S----&gt;
	 *	[---)			 = F not wrapped past B (but wrapped past UINT_MAX)
	 *		 [---)		 = F wrapped past B (and UINT_MAX)
	 *			  [----] = F not wrapped
	 *-----------------------------------------------------------------------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>boundary</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>finish</name> <operator>&gt;=</operator> <name>boundary</name> <operator>||</operator> <name>finish</name> <operator>&lt;</operator> <name>start</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>finish</name> <operator>&gt;=</operator> <name>boundary</name> <operator>&amp;&amp;</operator> <name>finish</name> <operator>&lt;</operator> <name>start</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the starting offset of the given MultiXactId.
 *
 * Returns false if the file containing the multi does not exist on disk.
 * Otherwise, returns true and sets *result to the starting member offset.
 *
 * This function does not prevent concurrent truncation, so if that's
 * required, the caller has to protect against that.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_multixact_start</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>entryno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>offptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>finishedStartup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entryno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetEntry</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush out dirty data, so PhysicalPageExists can work correctly.
	 * SimpleLruFlush() is a pretty big hammer for that.  Alternatively we
	 * could add an in-memory version of page exists, but find_multixact_start
	 * is called infrequently, and it doesn't seem bad to flush buffers to
	 * disk before truncation.
	 */</comment>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SimpleLruFlush</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SimpleLruDoesPhysicalPageExist</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* lock is acquired by SimpleLruReadPage_ReadOnly */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage_ReadOnly</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>=</operator> <operator>(</operator><name>MultiXactOffset</name> <operator>*</operator><operator>)</operator> <name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offptr</name> <operator>+=</operator> <name>entryno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>*</operator><name>offptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine how many multixacts, and how many multixact members, currently
 * exist.  Return false if unable to determine.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReadMultiXactCounts</name><parameter_list>(<parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>multixacts</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>oldestOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMultiXactId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMultiXactId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>oldestOffsetKnown</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMultiXactId</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextMultiXactId</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestOffsetKnown</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestOffsetKnown</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldestOffsetKnown</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>members</name> <operator>=</operator> <name>nextOffset</name> <operator>-</operator> <name>oldestOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>multixacts</name> <operator>=</operator> <name>nextMultiXactId</name> <operator>-</operator> <name>oldestMultiXactId</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Multixact members can be removed once the multixacts that refer to them
 * are older than every datminxmid.  autovacuum_multixact_freeze_max_age and
 * vacuum_multixact_freeze_table_age work together to make sure we never have
 * too many multixacts; we hope that, at least under normal circumstances,
 * this will also be sufficient to keep us from using too many offsets.
 * However, if the average multixact has many members, we might exhaust the
 * members space while still using few enough members that these limits fail
 * to trigger full table scans for relminmxid advancement.  At that point,
 * we'd have no choice but to start failing multixact-creating operations
 * with an error.
 *
 * To prevent that, if more than a threshold portion of the members space is
 * used, we effectively reduce autovacuum_multixact_freeze_max_age and
 * to a value just less than the number of multixacts in use.  We hope that
 * this will quickly trigger autovacuuming on the table or tables with the
 * oldest relminmxid, thus allowing datminmxid values to advance and removing
 * some members.
 *
 * As the fraction of the member space currently in use grows, we become
 * more aggressive in clamping this value.  That not only causes autovacuum
 * to ramp up, but also makes any manual vacuums the user issues more
 * aggressive.  This happens because vacuum_set_xid_limits() clamps the
 * freeze table and the minimum freeze age based on the effective
 * autovacuum_multixact_freeze_max_age this function returns.  In the worst
 * case, we'll claim the freeze_max_age to zero, and every vacuum of any
 * table will try to freeze every multixact.
 *
 * It's possible that these thresholds should be user-tunable, but for now
 * we keep it simple.
 */</comment>
<function><type><name>int</name></type>
<name>MultiXactMemberFreezeThreshold</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>members</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>multixacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>victim_multixacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fraction</name></decl>;</decl_stmt>

	<comment type="block">/* If we can't determine member space utilization, assume the worst. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadMultiXactCounts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>multixacts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If member space utilization is low, no special action is required. */</comment>
	<if_stmt><if>if <condition>(<expr><name>members</name> <operator>&lt;=</operator> <name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>autovacuum_multixact_freeze_max_age</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute a target for relminmxid advancement.  The number of multixacts
	 * we try to eliminate from the system is based on how far we are past
	 * MULTIXACT_MEMBER_SAFE_THRESHOLD.
	 */</comment>
	<expr_stmt><expr><name>fraction</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>members</name> <operator>-</operator> <name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name><operator>)</operator> <operator>/</operator>
		<operator>(</operator><name>MULTIXACT_MEMBER_DANGER_THRESHOLD</name> <operator>-</operator> <name>MULTIXACT_MEMBER_SAFE_THRESHOLD</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>victim_multixacts</name> <operator>=</operator> <name>multixacts</name> <operator>*</operator> <name>fraction</name></expr>;</expr_stmt>

	<comment type="block">/* fraction could be &gt; 1.0, but lowest possible freeze age is zero */</comment>
	<if_stmt><if>if <condition>(<expr><name>victim_multixacts</name> <operator>&gt;</operator> <name>multixacts</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>multixacts</name> <operator>-</operator> <name>victim_multixacts</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>mxtruncinfo</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>earliestExistingPage</name></decl>;</decl_stmt>
}</block></struct></type> <name>mxtruncinfo</name>;</typedef>

<comment type="block">/*
 * SlruScanDirectory callback
 *		This callback determines the earliest existing page number.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruScanDirCbFindEarliest</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mxtruncinfo</name> <modifier>*</modifier></type><name>trunc</name> <init>= <expr><operator>(</operator><name>mxtruncinfo</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>trunc</name><operator>-&gt;</operator><name>earliestExistingPage</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
		<call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>segpage</name></expr></argument>, <argument><expr><name><name>trunc</name><operator>-&gt;</operator><name>earliestExistingPage</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>trunc</name><operator>-&gt;</operator><name>earliestExistingPage</name></name> <operator>=</operator> <name>segpage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Delete members segments [oldest, newOldest)
 *
 * The members SLRU can, in contrast to the offsets one, be filled to almost
 * the full range at once. This means SimpleLruTruncate() can't trivially be
 * used - instead the to-be-deleted range is computed using the offsets
 * SLRU. C.f. TruncateMultiXact().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PerformMembersTruncation</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>oldestOffset</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>newOldestOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type>	<name>maxsegment</name> <init>= <expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name>MaxMultiXactOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>startsegment</name> <init>= <expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name>oldestOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>endsegment</name> <init>= <expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name>newOldestOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segment</name> <init>= <expr><name>startsegment</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Delete all the segments but the last one. The last segment can still
	 * contain, possibly partially, valid data.
	 */</comment>
	<while>while <condition>(<expr><name>segment</name> <operator>!=</operator> <name>endsegment</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"truncating multixact members segment %x"</literal></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SlruDeleteSegment</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* move to next segment, handling wraparound correctly */</comment>
		<if_stmt><if>if <condition>(<expr><name>segment</name> <operator>==</operator> <name>maxsegment</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segment</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segment</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Delete offsets segments [oldest, newOldest)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PerformOffsetsTruncation</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>oldestMulti</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>newOldestMulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We step back one multixact to avoid passing a cutoff page that hasn't
	 * been created yet in the rare case that oldestMulti would be the first
	 * item on a page and oldestMulti == nextMulti.  In that case, if we
	 * didn't subtract one, we'd trigger SimpleLruTruncate's wraparound
	 * detection.
	 */</comment>
	<expr_stmt><expr><call><name>SimpleLruTruncate</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>,
					  <argument><expr><call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><call><name>PreviousMultiXactId</name><argument_list>(<argument><expr><name>newOldestMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all MultiXactOffset and MultiXactMember segments before the oldest
 * ones still of interest.
 *
 * This is only called on a primary as part of vacuum (via
 * vac_truncate_clog()). During recovery truncation is done by replaying
 * truncation WAL records logged here.
 *
 * newOldestMulti is the oldest currently required multixact, newOldestMultiDB
 * is one of the databases preventing newOldestMulti from increasing.
 */</comment>
<function><type><name>void</name></type>
<name>TruncateMultiXact</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>newOldestMulti</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOldestMultiDB</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>nextMulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>newOldestOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>oldestOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mxtruncinfo</name></type> <name>trunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>earliest</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>finishedStartup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can only allow one truncation to happen at once. Otherwise parts of
	 * members might vanish while we're doing lookups or similar. There's no
	 * need to have an interlock with creating new multis or such, since those
	 * are constrained by the limits (which only grow, never shrink).
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextMulti</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextMXact</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldestMulti</name> <operator>=</operator> <name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure to only attempt truncation if there's values to truncate
	 * away. In normal processing values shouldn't go backwards, but there's
	 * some corner cases (due to bugs) where that's possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>newOldestMulti</name></expr></argument>, <argument><expr><name>oldestMulti</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note we can't just plow ahead with the truncation; it's possible that
	 * there are no segments to truncate, which is a problem because we are
	 * going to attempt to read the offsets page to determine where to
	 * truncate the members SLRU.  So we first scan the directory to determine
	 * the earliest offsets page number that we can read without error.
	 *
	 * NB: It's also possible that the page that oldestMulti is on has already
	 * been truncated away, and we crashed before updating oldestMulti.
	 */</comment>
	<expr_stmt><expr><name><name>trunc</name><operator>.</operator><name>earliestExistingPage</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SlruScanDirectory</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>SlruScanDirCbFindEarliest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>earliest</name> <operator>=</operator> <name><name>trunc</name><operator>.</operator><name>earliestExistingPage</name></name> <operator>*</operator> <name>MULTIXACT_OFFSETS_PER_PAGE</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>earliest</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>earliest</name> <operator>=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If there's nothing to remove, we can bail out early. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>earliest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * First, compute the safe truncation point for MultiXactMember. This is
	 * the starting offset of the oldest multixact.
	 *
	 * Hopefully, find_multixact_start will always work here, because we've
	 * already checked that it doesn't precede the earliest MultiXact on disk.
	 * But if it fails, don't truncate anything, and log a message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldestMulti</name> <operator>==</operator> <name>nextMulti</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there are NO MultiXacts */</comment>
		<expr_stmt><expr><name>oldestOffset</name> <operator>=</operator> <name>nextOffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>find_multixact_start</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldestOffset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oldest MultiXact %u not found, earliest MultiXact %u, skipping truncation"</literal></expr></argument>,
						<argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>earliest</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Secondly compute up to where to truncate. Lookup the corresponding
	 * member offset for newOldestMulti for that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newOldestMulti</name> <operator>==</operator> <name>nextMulti</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there are NO MultiXacts */</comment>
		<expr_stmt><expr><name>newOldestOffset</name> <operator>=</operator> <name>nextOffset</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>find_multixact_start</name><argument_list>(<argument><expr><name>newOldestMulti</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newOldestOffset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate up to MultiXact %u because it does not exist on disk, skipping truncation"</literal></expr></argument>,
						<argument><expr><name>newOldestMulti</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"performing multixact truncation: "</literal>
		 <literal type="string">"offsets [%u, %u), offsets segments [%x, %x), "</literal>
		 <literal type="string">"members [%u, %u), members segments [%x, %x)"</literal></expr></argument>,
		 <argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>newOldestMulti</name></expr></argument>,
		 <argument><expr><call><name>MultiXactIdToOffsetSegment</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>MultiXactIdToOffsetSegment</name><argument_list>(<argument><expr><name>newOldestMulti</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><name>oldestOffset</name></expr></argument>, <argument><expr><name>newOldestOffset</name></expr></argument>,
		 <argument><expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name>oldestOffset</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name>newOldestOffset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do truncation, and the WAL logging of the truncation, in a critical
	 * section. That way offsets/members cannot get out of sync anymore, i.e.
	 * once consistent the newOldestMulti will always exist in members, even
	 * if we crashed in the wrong moment.
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent checkpoints from being scheduled concurrently. This is critical
	 * because otherwise a truncation record might not be replayed after a
	 * crash/basebackup, even though the state of the data directory would
	 * require it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* WAL log truncation */</comment>
	<expr_stmt><expr><call><name>WriteMTruncateXlogRec</name><argument_list>(<argument><expr><name>newOldestMultiDB</name></expr></argument>,
						  <argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>newOldestMulti</name></expr></argument>,
						  <argument><expr><name>oldestOffset</name></expr></argument>, <argument><expr><name>newOldestOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update in-memory limits before performing the truncation, while inside
	 * the critical section: Have to do it before truncation, to prevent
	 * concurrent lookups of those values. Has to be inside the critical
	 * section as otherwise a future call to this function would error out,
	 * while looking up the oldest member in offsets, if our caller crashes
	 * before updating the limits.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactId</name></name> <operator>=</operator> <name>newOldestMulti</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MultiXactState</name><operator>-&gt;</operator><name>oldestMultiXactDB</name></name> <operator>=</operator> <name>newOldestMultiDB</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First truncate members */</comment>
	<expr_stmt><expr><call><name>PerformMembersTruncation</name><argument_list>(<argument><expr><name>oldestOffset</name></expr></argument>, <argument><expr><name>newOldestOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Then offsets */</comment>
	<expr_stmt><expr><call><name>PerformOffsetsTruncation</name><argument_list>(<argument><expr><name>oldestMulti</name></expr></argument>, <argument><expr><name>newOldestMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decide which of two MultiXactOffset page numbers is "older" for truncation
 * purposes.
 *
 * We need to use comparison of MultiXactId here in order to do the right
 * thing with wraparound.  However, if we are asked about page number zero, we
 * don't want to hand InvalidMultiXactId to MultiXactIdPrecedes: it'll get
 * weird.  So, offset both multis by FirstMultiXactId to avoid that.
 * (Actually, the current implementation doesn't do anything weird with
 * InvalidMultiXactId, but there's no harm in leaving this code like this.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MultiXactOffsetPagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multi2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>multi1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>page1</name><operator>)</operator> <operator>*</operator> <name>MULTIXACT_OFFSETS_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>multi1</name> <operator>+=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>multi2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MultiXactId</name><operator>)</operator> <name>page2</name><operator>)</operator> <operator>*</operator> <name>MULTIXACT_OFFSETS_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>multi2</name> <operator>+=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt>

	<return>return <expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name>multi1</name></expr></argument>, <argument><expr><name>multi2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decide which of two MultiXactMember page numbers is "older" for truncation
 * purposes.  There is no "invalid offset number" so use the numbers verbatim.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MultiXactMemberPagePrecedes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>page1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>page2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactOffset</name></type> <name>offset2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>offset1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MultiXactOffset</name><operator>)</operator> <name>page1</name><operator>)</operator> <operator>*</operator> <name>MULTIXACT_MEMBERS_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MultiXactOffset</name><operator>)</operator> <name>page2</name><operator>)</operator> <operator>*</operator> <name>MULTIXACT_MEMBERS_PER_PAGE</name></expr>;</expr_stmt>

	<return>return <expr><call><name>MultiXactOffsetPrecedes</name><argument_list>(<argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>offset2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decide which of two MultiXactIds is earlier.
 *
 * XXX do we need to do something special for InvalidMultiXactId?
 * (Doesn't look like it.)
 */</comment>
<function><type><name>bool</name></type>
<name>MultiXactIdPrecedes</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi1</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>multi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>diff</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>multi1</name> <operator>-</operator> <name>multi2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MultiXactIdPrecedesOrEquals -- is multi1 logically &lt;= multi2?
 *
 * XXX do we need to do something special for InvalidMultiXactId?
 * (Doesn't look like it.)
 */</comment>
<function><type><name>bool</name></type>
<name>MultiXactIdPrecedesOrEquals</name><parameter_list>(<parameter><decl><type><name>MultiXactId</name></type> <name>multi1</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>multi2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>diff</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>multi1</name> <operator>-</operator> <name>multi2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Decide which of two offsets is earlier.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MultiXactOffsetPrecedes</name><parameter_list>(<parameter><decl><type><name>MultiXactOffset</name></type> <name>offset1</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>offset2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>diff</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>offset1</name> <operator>-</operator> <name>offset2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write an xlog record reflecting the zeroing of either a MEMBERs or
 * OFFSETs page (info shows which)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteMZeroPageXlogRec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>pageno</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_MULTIXACT_ID</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a TRUNCATE xlog record
 *
 * We must flush the xlog record to disk before returning --- see notes in
 * TruncateCLOG().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteMTruncateXlogRec</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldestMultiDB</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactId</name></type> <name>startTruncOff</name></decl></parameter>, <parameter><decl><type><name>MultiXactId</name></type> <name>endTruncOff</name></decl></parameter>,
					  <parameter><decl><type><name>MultiXactOffset</name></type> <name>startTruncMemb</name></decl></parameter>, <parameter><decl><type><name>MultiXactOffset</name></type> <name>endTruncMemb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>xl_multixact_truncate</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>oldestMultiDB</name></name> <operator>=</operator> <name>oldestMultiDB</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>startTruncOff</name></name> <operator>=</operator> <name>startTruncOff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name> <operator>=</operator> <name>endTruncOff</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>startTruncMemb</name></name> <operator>=</operator> <name>startTruncMemb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>endTruncMemb</name></name> <operator>=</operator> <name>endTruncMemb</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>xlrec</name><operator>)</operator></expr></argument>, <argument><expr><name>SizeOfMultiXactTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_MULTIXACT_ID</name></expr></argument>, <argument><expr><name>XLOG_MULTIXACT_TRUNCATE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MULTIXACT resource manager's routines
 */</comment>
<function><type><name>void</name></type>
<name>multixact_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Backup blocks are not used in multixact records */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecHasAnyBlockRefs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_MULTIXACT_ZERO_OFF_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageno</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>ZeroMultiXactOffsetPage</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>MultiXactOffsetCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactOffsetControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_MULTIXACT_ZERO_MEM_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pageno</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>ZeroMultiXactMemberPage</name><argument_list>(<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SimpleLruWritePage</name><argument_list>(<argument><expr><name>MultiXactMemberCtl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>MultiXactMemberCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactMemberControlLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_MULTIXACT_CREATE_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_multixact_create</name> <modifier>*</modifier></type><name>xlrec</name> <init>=
		<expr><operator>(</operator><name>xl_multixact_create</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>max_xid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Store the data back into the SLRU files */</comment>
		<expr_stmt><expr><call><name>RecordNewMultiXact</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>mid</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>moff</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>nmembers</name></name></expr></argument>,
						   <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure nextMXact/nextOffset are beyond what this record has */</comment>
		<expr_stmt><expr><call><name>MultiXactAdvanceNextMXact</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>mid</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>moff</name></name> <operator>+</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nmembers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure nextXid is beyond any XID mentioned in the record. This
		 * should be unnecessary, since any XID found here ought to have other
		 * evidence in the XLOG, but let's be safe.
		 */</comment>
		<expr_stmt><expr><name>max_xid</name> <operator>=</operator> <call><name>XLogRecGetXid</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>nmembers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>max_xid</name> <operator>=</operator> <name><name>xlrec</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We don't expect anyone else to modify nextXid, hence startup
		 * process doesn't need to hold a lock while checking this. We still
		 * acquire the lock to modify it, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name>max_xid</name></expr></argument>,
										 <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name> <operator>=</operator> <name>max_xid</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TransactionIdAdvance</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>XidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>info</name> <operator>==</operator> <name>XLOG_MULTIXACT_TRUNCATE_ID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_multixact_truncate</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><name>SizeOfMultiXactTruncate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"replaying multixact truncation: "</literal>
			 <literal type="string">"offsets [%u, %u), offsets segments [%x, %x), "</literal>
			 <literal type="string">"members [%u, %u), members segments [%x, %x)"</literal></expr></argument>,
			 <argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncOff</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name></expr></argument>,
			 <argument><expr><call><name>MultiXactIdToOffsetSegment</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncOff</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>MultiXactIdToOffsetSegment</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncMemb</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncMemb</name></name></expr></argument>,
			 <argument><expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncMemb</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>MXOffsetToMemberSegment</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncMemb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* should not be required, but more than cheap enough */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Advance the horizon values, so they're current at the end of
		 * recovery.
		 */</comment>
		<expr_stmt><expr><call><name>SetMultiXactIdLimit</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>oldestMultiDB</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PerformMembersTruncation</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncMemb</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncMemb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * During XLOG replay, latest_page_number isn't necessarily set up
		 * yet; insert a suitable value to bypass the sanity test in
		 * SimpleLruTruncate.
		 */</comment>
		<expr_stmt><expr><name>pageno</name> <operator>=</operator> <call><name>MultiXactIdToOffsetPage</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MultiXactOffsetCtl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PerformOffsetsTruncation</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>startTruncOff</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>endTruncOff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>MultiXactTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"multixact_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_multixact_members</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<typedef>typedef <type><struct>struct
	<block>{
		<decl_stmt><decl><type><name>MultiXactMember</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nmembers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>iter</name></decl>;</decl_stmt>
	}</block></struct></type> <name>mxact</name>;</typedef>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxid</name> <init>= <expr><call><name>PG_GETARG_UINT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mxact</name>	   <modifier>*</modifier></type><name>multi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funccxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>mxid</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid MultiXactId: %u"</literal></expr></argument>, <argument><expr><name>mxid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funccxt</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funccxt</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>multi</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mxact</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no need to allow for old values here */</comment>
		<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>nmembers</name></name> <operator>=</operator> <call><name>GetMultiXactIdMembers</name><argument_list>(<argument><expr><name>mxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>members</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"xid"</literal></expr></argument>,
						   <argument><expr><name>XIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funccxt</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funccxt</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>multi</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funccxt</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>multi</name> <operator>=</operator> <operator>(</operator><name>mxact</name> <operator>*</operator><operator>)</operator> <name><name>funccxt</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>iter</name></name> <operator>&lt;</operator> <name><name>multi</name><operator>-&gt;</operator><name>nmembers</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>multi</name><operator>-&gt;</operator><name>iter</name></name></expr>]</index></name><operator>.</operator><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>mxstatus_to_string</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>multi</name><operator>-&gt;</operator><name>iter</name></name></expr>]</index></name><operator>.</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name><name>funccxt</name><operator>-&gt;</operator><name>attinmeta</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>iter</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funccxt</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>nmembers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>members</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funccxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
