<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/gin/ginbtree.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginbtree.c
 *	  page utilities routines for the postgres inverted index access method.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/ginbtree.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ginFindParents</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ginPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>childbuf</name></decl></parameter>, <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ginFinishSplit</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>freestack</name></decl></parameter>, <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Lock buffer by needed method for search.
 */</comment>
<function><type><name>int</name></type>
<name>ginTraverseLock</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>searchMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>access</name> <init>= <expr><name>GIN_SHARE</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>searchMode</name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we should relock our page */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* But root can become non-leaf during relock */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* restore old lock type (very rare) */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>access</name> <operator>=</operator> <name>GIN_EXCLUSIVE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>access</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Descend the tree to the leaf page that contains or would contain the key
 * we're searching for. The key should already be filled in 'btree', in
 * tree-type specific manner. If btree-&gt;fullScan is true, descends to the
 * leftmost leaf page.
 *
 * If 'searchmode' is false, on return stack-&gt;buffer is exclusively locked,
 * and the stack represents the full path to the root. Otherwise stack-&gt;buffer
 * is share-locked, and stack-&gt;parent is NULL.
 *
 * If 'rootConflictCheck' is true, tree root is checked for serialization
 * conflict.
 */</comment>
<function><type><name>GinBtreeStack</name> <modifier>*</modifier></type>
<name>ginFindLeafPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>searchMode</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>rootConflictCheck</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>GinBtreeStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>predictNumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rootConflictCheck</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>access</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>access</name> <operator>=</operator> <call><name>ginTraverseLock</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>searchMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're going to modify the tree, finish any incomplete splits we
		 * encounter on the way.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>searchMode</name> <operator>&amp;&amp;</operator> <call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * ok, page is correctly locked, we should check to move right ..,
		 * root never has a right link, so small optimization
		 */</comment>
		<while>while <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>!=</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name> <operator>&amp;&amp;</operator>
			   <call><name><name>btree</name><operator>-&gt;</operator><name>isMoveRight</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightlink</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rightlink</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* rightmost page */</comment>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>rightlink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>searchMode</name> <operator>&amp;&amp;</operator> <call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* we found, return locked page */</comment>
			<return>return <expr><name>stack</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* now we have correct buffer, try to find child */</comment>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>findChildPage</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>!=</operator> <name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>searchMode</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* in search mode we may forget path to leaf */</comment>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReleaseAndReadBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>GinBtreeStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>stack</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>predictNumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Step right from current page.
 *
 * The next page is locked first, before releasing the current page. This is
 * crucial to protect from concurrent page deletion (see comment in
 * ginDeletePage).
 */</comment>
<function><type><name>Buffer</name></type>
<name>ginStepRight</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>nextbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLeaf</name> <init>= <expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isData</name> <init>= <expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>nextbuffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>nextbuffer</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check that the page we stepped to is of similar kind. */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nextbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isLeaf</name> <operator>!=</operator> <call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isData</name> <operator>!=</operator> <call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"right sibling of GIN page is of different type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Given the proper lock sequence above, we should never land on a deleted
	 * page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"right sibling of GIN page was deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>nextbuffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>freeGinBtreeStack</name><parameter_list>(<parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>stack</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stack</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Try to find parent for current stack position. Returns correct parent and
 * child's offset in stack-&gt;parent. The root page is never released, to
 * to prevent conflict with vacuum process.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginFindParents</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>,
				<decl><type ref="prev"/><name>leftmostBlkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unwind the stack all the way up to the root, leaving only the root
	 * item.
	 *
	 * Be careful not to release the pin on the root page! The pin on root
	 * page is required to lock out concurrent vacuums on the tree.
	 */</comment>
	<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>blkno</name></name> <operator>==</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>GinBtreeStack</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Lost path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * parent may be wrong, but if so, the ginFinishSplit call will
			 * recurse to call ginFindParents again to fix it.
			 */</comment>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>leftmostBlkno</name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>getLeftMostChild</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>offset</name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>findChildPtr</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* finish any incomplete splits, as above */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>blkno</name> <operator>!=</operator> <name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt> <comment type="block">/* it may be wrong, but in next call we will
								 * correct */</comment>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Descend down to next level */</comment>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>leftmostBlkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a new item to a page.
 *
 * Returns true if the insertion was finished. On false, the page was split and
 * the parent needs to be updated. (A root split returns true as it doesn't
 * need any further action by the caller to complete.)
 *
 * When inserting a downlink to an internal page, 'childbuf' contains the
 * child page that was split. Its GIN_INCOMPLETE_SPLIT flag will be cleared
 * atomically with the insert. Also, the existing item at offset stack-&gt;off
 * in the target page is updated to point to updateblkno.
 *
 * stack-&gt;buffer is locked on entry, and is kept locked.
 * Likewise for childbuf, if given.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ginPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>childbuf</name></decl></parameter>, <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPlaceToPageRC</name></type> <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>xlflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>childpage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>newlpage</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				<decl><type ref="prev"/><name>newrpage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ptp_workspace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpCxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We do all the work of this function and its subfunctions in a temporary
	 * memory context.  This avoids leakages and simplifies APIs, since some
	 * subfunctions allocate storage that has to survive until we've finished
	 * the WAL insertion.
	 */</comment>
	<expr_stmt><expr><name>tmpCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><call><name>GetCurrentMemoryContext</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><literal type="string">"ginPlaceToPage temporary context"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xlflags</name> <operator>|=</operator> <name>GIN_INSERT_ISDATA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>xlflags</name> <operator>|=</operator> <name>GIN_INSERT_ISLEAF</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>updateblkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>updateblkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * See if the incoming tuple will fit on the page.  beginPlaceToPage will
	 * decide if the page needs to be split, and will compute the split
	 * contents if so.  See comments for beginPlaceToPage and execPlaceToPage
	 * functions for more details of the API here.
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>beginPlaceToPage</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
								 <argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>ptp_workspace</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>newlpage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>GPTP_NO_WORK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Nothing to do */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>GPTP_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It will fit, perform the insertion */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>childbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Perform the page update, and register any extra WAL data */</comment>
		<expr_stmt><expr><call><name><name>btree</name><operator>-&gt;</operator><name>execPlaceToPage</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
							   <argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>, <argument><expr><name>ptp_workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* An insert to an internal page finishes the split of the child. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GIN_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ginxlogInsert</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockIdData</name></type> <name><name>childblknos</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>xlflags</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogInsert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Log information about child if this was an insertion of a
			 * downlink.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BlockIdSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>childblknos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>BlockIdSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>childblknos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>childblknos</name></expr></argument>,
								 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockIdData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insertion is complete. */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>GPTP_SPLIT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Didn't fit, need to split.  The split has been computed in newlpage
		 * and newrpage, which are pointers to palloc'd pages, not associated
		 * with buffers.  stack-&gt;buffer is not touched yet.
		 */</comment>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>savedRightLink</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ginxlogSplit</name></type> <name>data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>lbuffer</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>newrootpg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get a new index page to become the right page */</comment>
		<expr_stmt><expr><name>rbuffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* During index build, count the new page */</comment>
		<if_stmt><if>if <condition>(<expr><name>buildStats</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>isData</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nDataPages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nEntryPages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>savedRightLink</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>

		<comment type="block">/* Begin setting up WAL record */</comment>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>btree</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_node</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>xlflags</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>leftChildBlkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>rightChildBlkno</name></name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>leftChildBlkno</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>rightChildBlkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * splitting the root, so we need to allocate new left page and
			 * place pointers to left and right page on root page.
			 */</comment>
			<expr_stmt><expr><name>lbuffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* During index build, count the new left page */</comment>
			<if_stmt><if>if <condition>(<expr><name>buildStats</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>isData</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nDataPages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nEntryPages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>rrlink</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>GIN_SPLIT_ROOT</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newrpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Construct a new root page containing downlinks to the new left
			 * and right pages.  (Do this in a temporary copy rather than
			 * overwriting the original page directly, since we're not in the
			 * critical section yet.)
			 */</comment>
			<expr_stmt><expr><name>newrootpg</name> <operator>=</operator> <call><name>PageGetTempPage</name><argument_list>(<argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>newrootpg</name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>GIN_LEAF</name> <operator>|</operator> <name>GIN_COMPRESSED</name><operator>)</operator></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name><name>btree</name><operator>-&gt;</operator><name>fillRoot</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>newrootpg</name></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newlpage</name></expr></argument>,
							<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>

				<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* splitting a non-root page */</comment>
			<expr_stmt><expr><name><name>data</name><operator>.</operator><name>rrlink</name></name> <operator>=</operator> <name>savedRightLink</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newrpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name>savedRightLink</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>GIN_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>newlpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>

				<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * OK, we have the new contents of the left page in a temporary copy
		 * now (newlpage), and likewise for the new contents of the
		 * newly-allocated right block. The original page is still unchanged.
		 *
		 * If this is a root split, we also have a temporary page containing
		 * the new contents of the root.
		 */</comment>

		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Restore the temporary copies over the real buffers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Splitting the root, three pages to update */</comment>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>newrootpg</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Normal split, only two pages to update */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* We also clear childbuf's INCOMPLETE_SPLIT flag, if passed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GIN_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* write WAL record */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We just take full page images of all the split pages. Splits
			 * are uncommon enough that it's not worth complicating the code
			 * to be more efficient.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lbuffer</name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rbuffer</name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rbuffer</name></expr></argument>, <argument><expr><name>REGBUF_FORCE_IMAGE</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>childbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogSplit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>childpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can release the locks/pins on the new pages now, but keep
		 * stack-&gt;buffer locked.  childbuf doesn't get unlocked either.
		 */</comment>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we split the root, we're done. Otherwise the split is not
		 * complete until the downlink for the new page has been inserted to
		 * the parent.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid return code from GIN placeToPage method: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Clean up temp context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finish a split by inserting the downlink for the new page to parent.
 *
 * On entry, stack-&gt;buffer is exclusively locked.
 *
 * If freestack is true, all the buffers are released and unlocked as we
 * crawl up the tree, and 'stack' is freed. Otherwise stack-&gt;buffer is kept
 * locked, and stack is unmodified, except for possibly moving right to find
 * the correct parent of page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginFinishSplit</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>freestack</name></decl></parameter>,
			   <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * freestack == false when we encounter an incompletely split page during
	 * a scan, while freestack == true is used in the normal scenario that a
	 * split is finished right after the initial insert.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>freestack</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"finishing incomplete split of block %u in gin index \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* this loop crawls up the stack until the insertion is complete */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>insertdata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl>;</decl_stmt>

		<comment type="block">/* search parent to lock */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the parent page was incompletely split, finish that split first,
		 * then continue with the current one.
		 *
		 * Note: we have to finish *all* incomplete splits we encounter, even
		 * if we have to move right. Otherwise we might choose as the target a
		 * page that has no downlink in the parent, and splitting it further
		 * would fail.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* move right if it's needed */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>findChildPtr</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * rightmost page, but we don't find parent, we should use
				 * plain search...
				 */</comment>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ginFindParents</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>ginStepRight</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>GIN_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/* insert the downlink */</comment>
		<expr_stmt><expr><name>insertdata</name> <operator>=</operator> <call><name><name>btree</name><operator>-&gt;</operator><name>prepareDownlink</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>updateblkno</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>ginPlaceToPage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
							  <argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>,
							  <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>insertdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the caller requested to free the stack, unlock and release the
		 * child buffer now. Otherwise keep it pinned and locked, but if we
		 * have to recurse up the tree, we can unlock the upper pages, only
		 * keeping the page at the bottom of the stack locked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name> <operator>||</operator> <name>freestack</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>freestack</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>stack</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<comment type="block">/* unlock the parent */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>freestack</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert a value to tree described by stack.
 *
 * The value to be inserted is given in 'insertdata'. Its format depends
 * on whether this is an entry or data tree, ginInsertValue just passes it
 * through to the tree-specific callback function.
 *
 * During an index build, buildStats is non-null and the counters it contains
 * are incremented as needed.
 *
 * NB: the passed-in stack is freed, as though by freeGinBtreeStack.
 */</comment>
<function><type><name>void</name></type>
<name>ginInsertValue</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>,
			   <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>

	<comment type="block">/* If the leaf page was incompletely split, finish the split first */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsIncompleteSplit</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>ginPlaceToPage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
						  <argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>,
						  <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>GIN_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freeGinBtreeStack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginFinishSplit</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
