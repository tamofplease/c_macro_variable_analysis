<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/yugabyte-db/src/postgres/src/backend/access/nbtree/nbtinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nbtinsert.c
 *	  Item insertion in Lehman and Yao btrees for Postgres.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/nbtree/nbtinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* Minimum tree height for application of fastpath optimization */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BTREE_FASTPATH_MIN_LEVEL</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* context data for _bt_checksplitloc */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>newitemsz</name></decl>;</decl_stmt>		<comment type="block">/* size of new item to be inserted */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>fillfactor</name></decl>;</decl_stmt>		<comment type="block">/* needed when splitting rightmost page */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_leaf</name></decl>;</decl_stmt>		<comment type="block">/* T if splitting a leaf page */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_rightmost</name></decl>;</decl_stmt>	<comment type="block">/* T if splitting a rightmost page */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl>;</decl_stmt>	<comment type="block">/* where the new item is to be inserted */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftspace</name></decl>;</decl_stmt>		<comment type="block">/* space available for items on left page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rightspace</name></decl>;</decl_stmt>		<comment type="block">/* space available for items on right page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>olddataitemstotal</name></decl>;</decl_stmt>	<comment type="block">/* space taken by old items */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name>have_split</name></decl>;</decl_stmt>		<comment type="block">/* found a valid split? */</comment>

	<comment type="block">/* these fields valid only if have_split is true */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemonleft</name></decl>;</decl_stmt>	<comment type="block">/* new item on left or right of best split */</comment>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstright</name></decl>;</decl_stmt>	<comment type="block">/* best split point */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>best_delta</name></decl>;</decl_stmt>		<comment type="block">/* best size delta so far */</comment>
}</block></struct></type> <name>FindSplitData</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>_bt_newroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>_bt_check_unique</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
				 <parameter><decl><type><name>ScanKey</name></type> <name>itup_scankey</name></decl></parameter>,
				 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_unique</name></decl></parameter>,
				 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>speculativeToken</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_findinsertloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>,
				  <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offsetptr</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>,
				  <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>,
				  <parameter><decl><type><name>IndexTuple</name></type> <name>newtup</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_insertonpg</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
			   <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>split_only_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>_bt_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
		  <parameter><decl><type><name>OffsetNumber</name></type> <name>firstright</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>,
		  <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_insert_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_only</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OffsetNumber</name></type> <name>_bt_findsplitloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newitemonleft</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_checksplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				  <parameter><decl><type><name>OffsetNumber</name></type> <name>firstoldonright</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>dataitemstoleft</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>firstoldonrightsz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_pgaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_bt_isequal</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	_bt_doinsert() -- Handle insertion of a single index tuple in the tree.
 *
 *		This routine is called by the public interface routine, btinsert.
 *		By here, itup is filled in, including the TID.
 *
 *		If checkUnique is UNIQUE_CHECK_NO or UNIQUE_CHECK_PARTIAL, this
 *		will allow duplicates.  Otherwise (UNIQUE_CHECK_YES or
 *		UNIQUE_CHECK_EXISTING) it will throw error for a duplicate.
 *		For UNIQUE_CHECK_EXISTING we merely run the duplicate check, and
 *		don't actually insert.
 *
 *		The result value is only significant for UNIQUE_CHECK_PARTIAL:
 *		it must be true if the entry is known unique, else false.
 *		(In the current implementation we'll also return true after a
 *		successful UNIQUE_CHECK_YES or UNIQUE_CHECK_EXISTING call, but
 *		that's just a coding artifact.)
 */</comment>
<function><type><name>bool</name></type>
<name>_bt_doinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_unique</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>itup_scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTStack</name></type>		<name>stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fastpath</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indnkeyatts</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we need an insertion scan key to do our search, so build one */</comment>
	<expr_stmt><expr><name>itup_scankey</name> <operator>=</operator> <call><name>_bt_mkscankey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's very common to have an index on an auto-incremented or
	 * monotonically increasing value. In such cases, every insertion happens
	 * towards the end of the index. We try to optimize that case by caching
	 * the right-most leaf of the index. If our cached block is still the
	 * rightmost leaf, has enough free space to accommodate a new entry and
	 * the insertion key is strictly greater than the first key in this page,
	 * then we can safely conclude that the new key will be inserted in the
	 * cached block. So we simply search within the cached block and insert
	 * the key at the appropriate location. We call it a fastpath.
	 *
	 * Testing has revealed, though, that the fastpath can result in increased
	 * contention on the exclusive-lock on the rightmost leaf page. So we
	 * conditionally check if the lock is available. If it's not available
	 * then we simply abandon the fastpath and take the regular path. This
	 * makes sense because unavailability of the lock also signals that some
	 * other backend might be concurrently inserting into the page, thus
	 * reducing our chances to finding an insertion place in this page.
	 */</comment>
<label><name>top</name>:</label>
	<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Conditionally acquire exclusive lock on the buffer before doing any
		 * checks. If we don't get the lock, we simply follow slowpath. If we
		 * do get the lock, this ensures that the index state cannot change,
		 * as far as the rightmost part of the index is concerned.
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* be safe, PageAddItem will do this
										 * but we need to be consistent */</comment>

			<comment type="block">/*
			 * Check if the page is still the rightmost leaf page, has enough
			 * free space to accommodate the new tuple, and the insertion scan
			 * key is strictly greater than the first key on the page.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>itemsz</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
							<argument><expr><call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The right-most block should never have an incomplete split.
				 * But be paranoid and check for it anyway.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fastpath</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Something did not work out. Just forget about the cached
				 * block and follow the normal path. It might be set again if
				 * the conditions are favourable.
				 */</comment>
				<expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If someone's holding a lock, it's likely to change anyway, so
			 * don't try again until we get an updated rightmost leaf.
			 */</comment>
			<expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fastpath</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* find the first page containing this key */</comment>
		<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>_bt_search</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* trade in our read lock for a write lock */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the page was split between the time that we surrendered our read
		 * lock and acquired our write lock, then this page may no longer be
		 * the right place for the key we want to insert.  In this case, we
		 * need to move right in the tree.  See Lehman and Yao for an
		 * excruciatingly precise description.
		 */</comment>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_moveright</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're not allowing duplicates, make sure the key isn't already in
	 * the index.
	 *
	 * NOTE: obviously, _bt_check_unique can only detect keys that are already
	 * in the index; so it cannot defend against concurrent insertions of the
	 * same key.  We protect against that by means of holding a write lock on
	 * the target page.  Any other would-be inserter of the same key must
	 * acquire a write lock on the same target page, so only one would-be
	 * inserter can be making the check at one time.  Furthermore, once we are
	 * past the check we hold write locks continuously until we have performed
	 * our insertion, so no later inserter can fail to see our insertion.
	 * (This requires some care in _bt_insertonpg.)
	 *
	 * If we must wait for another xact, we release the lock while waiting,
	 * and then must start over completely.
	 *
	 * For a partial uniqueness check, we don't wait for the other xact. Just
	 * let the tuple in and return false for possibly non-unique, or true for
	 * definitely unique.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>!=</operator> <name>UNIQUE_CHECK_NO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>speculativeToken</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>_bt_binsrch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>_bt_check_unique</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>,
								 <argument><expr><name>checkUnique</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_unique</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>speculativeToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Have to wait for the other guy ... */</comment>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it's a speculative insertion, wait for it to finish (ie. to
			 * go ahead with the insertion, or kill the tuple).  Otherwise
			 * wait for the transaction to finish as usual.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>speculativeToken</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SpeculativeInsertionWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>speculativeToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><name>XLTW_InsertIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* start over... */</comment>
			<if_stmt><if>if <condition>(<expr><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<goto>goto <name>top</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>!=</operator> <name>UNIQUE_CHECK_EXISTING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The only conflict predicate locking cares about for indexes is when
		 * an index tuple insert conflicts with an existing lock.  Since the
		 * actual location of the insert is hard to predict because of the
		 * random search used to prevent O(N^2) performance when there are
		 * many duplicate entries, we can just use the "first valid" page.
		 * This reasoning also applies to INCLUDE indexes, whose extra
		 * attributes are not considered part of the key space.
		 */</comment>
		<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* do the insertion */</comment>
		<expr_stmt><expr><call><name>_bt_findinsertloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>,
						  <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_insertonpg</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* just release the buffer */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_freestack</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>_bt_freeskey</name><argument_list>(<argument><expr><name>itup_scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>is_unique</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_check_unique() -- Check for violation of unique index constraint
 *
 * offset points to the first possible item that could conflict. It can
 * also point to end-of-page, which means that the first tuple to check
 * is the first tuple on the next page.
 *
 * Returns InvalidTransactionId if there is no conflict, else an xact ID
 * we must wait for to see if it commits a conflicting tuple.   If an actual
 * conflict is detected, no return --- just ereport().  If an xact ID is
 * returned, and the conflicting tuple still has a speculative insertion in
 * progress, *speculativeToken is set to non-zero, and the caller can wait for
 * the verdict on the insertion using SpeculativeInsertionWait().
 *
 * However, if checkUnique == UNIQUE_CHECK_PARTIAL, we always return
 * InvalidTransactionId because we don't want to wait.  In this case we
 * set *is_unique to false if there is a potential conflict, and the
 * core code must redo the uniqueness check later.
 */</comment>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>_bt_check_unique</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
				 <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>itup_scankey</name></decl></parameter>,
				 <parameter><decl><type><name>IndexUniqueCheck</name></type> <name>checkUnique</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_unique</name></decl></parameter>,
				 <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>speculativeToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>itupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotDirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>nbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume unique until we find a duplicate */</comment>
	<expr_stmt><expr><operator>*</operator><name>is_unique</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan over all equal tuples, looking for live conflicts.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>curitemid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>curitup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblkno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * make sure the offset points to an actual item before trying to
		 * examine it...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>curitemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We can skip items that are marked killed.
			 *
			 * Formerly, we applied _bt_isequal() before checking the kill
			 * flag, so as to fall out of the item loop as soon as possible.
			 * However, in the presence of heavy update activity an index may
			 * contain many killed items with the same key; running
			 * _bt_isequal() on each killed item gets expensive. Furthermore
			 * it is likely that the non-killed version of each key appears
			 * first, so that we didn't actually get to exit any sooner
			 * anyway. So now we just advance over killed items as quickly as
			 * we can. We only apply _bt_isequal() when we get to a non-killed
			 * item or the end of the page.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>htid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>all_dead</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * _bt_compare returns 0 for (1,NULL) and (1,NULL) - this's
				 * how we handling NULLs - and so we must not use _bt_compare
				 * in real comparison, but only for ordering/finding items on
				 * pages. - vadim 03/24/97
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_isequal</name><argument_list>(<argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* we're past all the equal tuples */</comment>

				<comment type="block">/* okay, we gotta fetch the heap tuple ... */</comment>
				<expr_stmt><expr><name>curitup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>htid</name> <operator>=</operator> <name><name>curitup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we are doing a recheck, we expect to find the tuple we
				 * are rechecking.  It's not a duplicate, but we have to keep
				 * scanning.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_EXISTING</name> <operator>&amp;&amp;</operator>
					<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * We check the whole HOT-chain to see if there is any tuple
				 * that satisfies SnapshotDirty.  This is necessary because we
				 * have just a single index entry for the entire chain.
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>heap_hot_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SnapshotDirty</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>all_dead</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * It is a duplicate. If we are only doing a partial
					 * check, then don't bother checking if the tuple is being
					 * updated in another transaction. Just return the fact
					 * that it is a potential conflict and leave the full
					 * check till later.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_PARTIAL</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><operator>*</operator><name>is_unique</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If this tuple is being updated by other transaction
					 * then we have to wait for its commit/abort.
					 */</comment>
					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
						<expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmin</name></name></expr> </then><else>: <expr><name><name>SnapshotDirty</name><operator>.</operator><name>xmax</name></name></expr></else></ternary></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<comment type="block">/* Tell _bt_doinsert to wait... */</comment>
						<expr_stmt><expr><operator>*</operator><name>speculativeToken</name> <operator>=</operator> <name><name>SnapshotDirty</name><operator>.</operator><name>speculativeToken</name></name></expr>;</expr_stmt>
						<return>return <expr><name>xwait</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Otherwise we have a definite conflict.  But before
					 * complaining, look to see if the tuple we want to insert
					 * is itself now committed dead --- if so, don't complain.
					 * This is a waste of time in normal scenarios but we must
					 * do it to support CREATE INDEX CONCURRENTLY.
					 *
					 * We must follow HOT-chains here because during
					 * concurrent index build, we insert the root TID though
					 * the actual tuple may be somewhere in the HOT-chain.
					 * While following the chain we might not stop at the
					 * exact tuple which triggered the insert, but that's OK
					 * because if we find a live tuple anywhere in this chain,
					 * we have a unique key conflict.  The other live tuple is
					 * not part of this chain because it had a different index
					 * entry.
					 */</comment>
					<expr_stmt><expr><name>htid</name> <operator>=</operator> <name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>heap_hot_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>htid</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Normal case --- it's still live */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * It's been deleted, so no error, and no need to
						 * continue searching
						 */</comment>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Check for a conflict-in as we would if we were going to
					 * write to this page.  We aren't actually going to write,
					 * but we want a chance to report SSI conflicts that would
					 * otherwise be masked by this unique constraint
					 * violation.
					 */</comment>
					<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * This is a definite conflict.  Break the tuple down into
					 * datums and report the error.  But first, make sure we
					 * release the buffer locks we're holding ---
					 * BuildIndexValueDescription could make catalog accesses,
					 * which in the worst case might touch this same index and
					 * cause deadlocks.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<block>{<block_content>
						<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key_desc</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>index_deform_tuple</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>key_desc</name> <operator>=</operator> <call><name>BuildIndexValueDescription</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
															  <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNIQUE_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate key value violates unique constraint \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <ternary><condition><expr><name>key_desc</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key %s already exists."</literal></expr></argument>,
													  <argument><expr><name>key_desc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
								 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
													<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>all_dead</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * The conflicting tuple (or whole HOT chain) is dead to
					 * everyone, so we may as well mark the index entry
					 * killed.
					 */</comment>
					<expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>curitemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_HAS_GARBAGE</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * Mark buffer with a dirty hint, since state is not
					 * crucial. Be sure to mark the proper buffer dirty.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Advance to next tuple to continue checking.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* If scankey == hikey we gotta check the next page too */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_isequal</name><argument_list>(<argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
							 <argument><expr><name>indnkeyatts</name></expr></argument>, <argument><expr><name>itup_scankey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* Advance to next non-dead page --- there must be one */</comment>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>nblkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>nblkno</name></expr></argument>, <argument><expr><name>BT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we are doing a recheck then we should have found the tuple we are
	 * checking.  Otherwise there's something very wrong --- probably, the
	 * index is on a non-immutable expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>checkUnique</name> <operator>==</operator> <name>UNIQUE_CHECK_EXISTING</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to re-find tuple within index \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This may be because of a non-immutable index expression."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>!=</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	_bt_findinsertloc() -- Finds an insert location for a tuple
 *
 *		If the new key is equal to one or more existing keys, we can
 *		legitimately place it anywhere in the series of equal keys --- in fact,
 *		if the new key is equal to the page's "high key" we can place it on
 *		the next page.  If it is equal to the high key, and there's not room
 *		to insert the new tuple on the current page without splitting, then
 *		we can move right hoping to find more free space and avoid a split.
 *		(We should not move right indefinitely, however, since that leads to
 *		O(N^2) insertion behavior in the presence of many equal keys.)
 *		Once we have chosen the page to put the key on, we'll insert it before
 *		any existing equal keys because of the way _bt_binsrch() works.
 *
 *		If there's not enough room in the space, we try to make room by
 *		removing any LP_DEAD tuples.
 *
 *		On entry, *bufptr and *offsetptr point to the first legal position
 *		where the new tuple could be inserted.  The caller should hold an
 *		exclusive lock on *bufptr.  *offsetptr can also be set to
 *		InvalidOffsetNumber, in which case the function will search for the
 *		right location within the page if needed.  On exit, they point to the
 *		chosen insert location.  If _bt_findinsertloc decides to move right,
 *		the lock and pin on the original page will be released and the new
 *		page returned to the caller is exclusively locked instead.
 *
 *		newtup is the new tuple we're inserting, and scankey is an insertion
 *		type scan key for it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_findinsertloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>bufptr</name></decl></parameter>,
				  <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>offsetptr</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>,
				  <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>,
				  <parameter><decl><type><name>IndexTuple</name></type> <name>newtup</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name> <init>= <expr><operator>*</operator><name>bufptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>movedright</name></decl>,
				<decl><type ref="prev"/><name>vacuumed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstlegaloff</name> <init>= <expr><operator>*</operator><name>offsetptr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* be safe, PageAddItem will do this but we
								 * need to be consistent */</comment>

	<comment type="block">/*
	 * Check whether the item can fit on a btree page at all. (Eventually, we
	 * ought to try to apply TOAST methods if not.) We actually need to be
	 * able to fit three items on every page, so restrict any one item to 1/3
	 * the per-page available space. Note that at this point, itemsz doesn't
	 * include the ItemId.
	 *
	 * NOTE: if you change this, see also the similar code in _bt_buildadd().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>itemsz</name> <operator>&gt;</operator> <call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds maximum %zu for index \"%s\""</literal></expr></argument>,
						<argument><expr><name>itemsz</name></expr></argument>, <argument><expr><call><name>BTMaxItemSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than 1/3 of a buffer page cannot be indexed.\n"</literal>
						 <literal type="string">"Consider a function index of an MD5 hash of the value, "</literal>
						 <literal type="string">"or use full text indexing."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * If we will need to split the page to put the item on this page,
	 * check whether we can put the tuple somewhere to the right,
	 * instead.  Keep scanning right until we
	 *		(a) find a page with enough free space,
	 *		(b) reach the last page where the tuple can legally go, or
	 *		(c) get tired of searching.
	 * (c) is not flippant; it is important because if there are many
	 * pages' worth of equal keys, it's better to split one of the early
	 * pages than to scan all the way to the end of the run of equal keys
	 * on every insert.  We implement "get tired" as a random choice,
	 * since stopping after scanning a fixed number of pages wouldn't work
	 * well (we'd never reach the right-hand side of previously split
	 * pages).  Currently the probability of moving right is set at 0.99,
	 * which may seem too high to change the behavior much, but it does an
	 * excellent job of preventing O(N^2) behavior with many equal keys.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>movedright</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>vacuumed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>itemsz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rblkno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * before considering moving right, see if we can obtain enough space
		 * by erasing LP_DEAD items
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_HAS_GARBAGE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_vacuum_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * remember that we vacuumed this page, because that makes the
			 * hint supplied by the caller invalid
			 */</comment>
			<expr_stmt><expr><name>vacuumed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>itemsz</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* OK, now we have enough space */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * nope, so check conditions (b) and (c) enumerated above
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>_bt_compare</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>random</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>MAX_RANDOM_VALUE</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * step right to next non-dead page
		 *
		 * must write-lock that page before releasing write lock on current
		 * page; else someone else's _bt_check_unique scan could fail to see
		 * our insertion.  write locks on intermediate dead pages won't do
		 * because we don't know when they will get de-linked from the tree.
		 */</comment>
		<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rblkno</name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_relandgetbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>rblkno</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If this page was incompletely split, finish the split now. We
			 * do this while holding a lock on the left sibling, which is not
			 * good because finishing the split could be a fairly lengthy
			 * operation.  But this should happen very seldom.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_bt_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fell off the end of index \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>rblkno</name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>rbuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>movedright</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacuumed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now we are on the right page, so find the insert position. If we moved
	 * right at all, we know we should insert at the start of the page. If we
	 * didn't move right, we can use the firstlegaloff hint if the caller
	 * supplied one, unless we vacuumed the page which might have moved tuples
	 * around making the hint invalid. If we didn't move right or can't use
	 * the hint, find the position by searching.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>movedright</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>firstlegaloff</name> <operator>!=</operator> <name>InvalidOffsetNumber</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>vacuumed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <name>firstlegaloff</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newitemoff</name> <operator>=</operator> <call><name>_bt_binsrch</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>keysz</name></expr></argument>, <argument><expr><name>scankey</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>bufptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>offsetptr</name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------
 *	_bt_insertonpg() -- Insert a tuple on a particular page in the index.
 *
 *		This recursive procedure does the following things:
 *
 *			+  if necessary, splits the target page (making sure that the
 *			   split is equitable as far as post-insert free space goes).
 *			+  inserts the tuple.
 *			+  if the page was split, pops the parent stack, and finds the
 *			   right place to insert the new child pointer (by walking
 *			   right using information stored in the parent stack).
 *			+  invokes itself with the appropriate tuple for the right
 *			   child page on the parent.
 *			+  updates the metapage if a true root or fast root is split.
 *
 *		On entry, we must have the correct buffer in which to do the
 *		insertion, and the buffer must be pinned and write-locked.  On return,
 *		we will have dropped both the pin and the lock on the buffer.
 *
 *		This routine only performs retail tuple insertions.  'itup' should
 *		always be either a non-highkey leaf item, or a downlink (new high
 *		key items are created indirectly, when a page is split).  When
 *		inserting to a non-leaf page, 'cbuf' is the left-sibling of the page
 *		we're inserting the downlink for.  This function will clear the
 *		INCOMPLETE_SPLIT flag on it, and release the buffer.
 *
 *		The locking interactions in this code are critical.  You should
 *		grok Lehman and Yao's paper before making any changes.  In addition,
 *		you need to understand how we disambiguate duplicate keys in this
 *		implementation, in order to be able to find our location using
 *		L&amp;Y "move right" operations.
 *----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_insertonpg</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
			   <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>,
			   <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
			   <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			   <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>split_only_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>firstright</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* child buffer must be given iff inserting on an internal page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* tuple must have appropriate number of attributes */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator>
		   <call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator>
		   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The caller should've finished any incomplete splits already. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert to incompletely split page %u"</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* be safe, PageAddItem will do this but we
								 * need to be consistent */</comment>

	<comment type="block">/*
	 * Do we need to split the page to fit the item on it?
	 *
	 * Note: PageGetFreeSpace() subtracts sizeof(ItemIdData) from its result,
	 * so this comparison is correct even though we appear to be accounting
	 * only for the item and not for its line pointer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>itemsz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_root</name> <init>= <expr><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_only</name> <init>= <expr><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>newitemonleft</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we're here then a pagesplit is needed. We should never reach
		 * here if we're using the fastpath since we should have checked for
		 * all the required conditions, including the fact that this page has
		 * enough freespace. Note that this routine can in theory deal with
		 * the situation where a NULL stack pointer is passed (that's what
		 * would happen if the fastpath is taken). But that path is much
		 * slower, defeating the very purpose of the optimization.  The
		 * following assertion should protect us from any future code changes
		 * that invalidate those assumptions.
		 *
		 * Note that whenever we fail to take the fastpath, we clear the
		 * cached block. Checking for a valid cached block at this point is
		 * enough to decide whether we're in a fastpath or not.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><call><name>RelationGetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Choose the split point */</comment>
		<expr_stmt><expr><name>firstright</name> <operator>=</operator> <call><name>_bt_findsplitloc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
									  <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>newitemonleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* split the buffer into left and right halves */</comment>
		<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>,
						 <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>newitemonleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
							   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*----------
		 * By here,
		 *
		 *		+  our target page has been split;
		 *		+  the original tuple has been inserted;
		 *		+  we have write locks on both the old (left half)
		 *		   and new (right half) buffers, after the split; and
		 *		+  we know the key we want to insert into the parent
		 *		   (it's the "high key" on the left child page).
		 *
		 * We're ready to do the parent insertion.  We need to hold onto the
		 * locks for the child pages until we locate the parent, but we can
		 * release them before doing the actual insertion (see Lehman and Yao
		 * for the reasoning).
		 *----------
		 */</comment>
		<expr_stmt><expr><call><name>_bt_insert_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>is_root</name></expr></argument>, <argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>itup_blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>cachedBlock</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>itup_off</name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup_blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are doing this insert because we split a page that was the
		 * only one on its tree level, but was not the root, it may have been
		 * the "fast root".  We need to ensure that the fast root link points
		 * at or above the current page.  We can safely acquire a lock on the
		 * metapage here --- see comments for _bt_newroot().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>split_only_page</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>&gt;=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no update wanted */</comment>
				<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Every internal page should have exactly one negative infinity item
		 * at all times.  Only _bt_split() and _bt_newroot() should add items
		 * that become negative infinity items through truncation, since
		 * they're the only routines that allocate new internal pages.  Do not
		 * allow a retail insertion of a new item at the negative infinity
		 * offset.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>newitemoff</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot insert second negative infinity item in block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>itup_blkno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Do the update.  No ereport(ERROR) until changes are logged */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to block %u in index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>itup_blkno</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* upgrade meta-page if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>itup_blkno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clear INCOMPLETE_SPLIT flag on child if inserting a downlink */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>cpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>cpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>cpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>cpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cpageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Cache the block information if we just inserted into the rightmost
		 * leaf page of the index and it's not the root page.  For very small
		 * index where root is also the leaf, there is no point trying for any
		 * optimization.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>P_ISROOT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cachedBlock</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_btree_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>xlmeta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint8</name></type>		<name>xlinfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>itup_off</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_LEAF</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Register the left child whose INCOMPLETE_SPLIT flag was
				 * cleared.
				 */</comment>
				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_UPPER</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlmeta</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator>
					<name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlmeta</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <name>XLOG_BTREE_INSERT_META</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>xlinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* release buffers */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we decided to cache the insertion target block, then set it now.
		 * But before that, check for the height of the tree and don't go for
		 * the optimization for small indexes. We defer that check to this
		 * point to ensure that we don't call _bt_getrootheight while holding
		 * lock on any other block.
		 *
		 * We do this after dropping locks on all buffers. So the information
		 * about whether the insertion block is still the rightmost block or
		 * not may have changed in between. But we will deal with that during
		 * next insert operation. No special care is required while setting
		 * it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>cachedBlock</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>_bt_getrootheight</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>BTREE_FASTPATH_MIN_LEVEL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationSetTargetBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cachedBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_split() -- split a page in the btree.
 *
 *		On entry, buf is the page to split, and is pinned and write-locked.
 *		firstright is the item index of the first item to be moved to the
 *		new right page.  newitemoff etc. tell us about the new item that
 *		must be inserted along with the data from the old page.
 *
 *		When splitting a non-leaf page, 'cbuf' is the left-sibling of the
 *		page we're inserting the downlink for.  This function will clear the
 *		INCOMPLETE_SPLIT flag on it, and release the buffer.
 *
 *		Returns the new right sibling of buf, pinned and write-locked.
 *		The pin and lock on buf are maintained.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>_bt_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>cbuf</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>firstright</name></decl></parameter>,
		  <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>newitem</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>origpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>leftpage</name></decl>,
				<decl><type ref="prev"/><name>rightpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>origpagenumber</name></decl>,
				<decl><type ref="prev"/><name>rightpagenumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>ropaque</name></decl>,
				<decl><type ref="prev"/><name>lopaque</name></decl>,
				<decl><type ref="prev"/><name>oopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>sbuf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>spage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>sopaque</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>leftoff</name></decl>,
				<decl><type ref="prev"/><name>rightoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isleaf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>lefthikey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name> <init>= <expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Acquire a new page to split into */</comment>
	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * origpage is the original page to be split.  leftpage is a temporary
	 * buffer that receives the left-sibling data, which will be copied back
	 * into origpage on success.  rightpage is the new page that receives the
	 * right-sibling data.  If we fail before reaching the critical section,
	 * origpage hasn't been modified and leftpage is only workspace. In
	 * principle we shouldn't need to worry about rightpage either, because it
	 * hasn't been linked into the btree page structure; but to avoid leaving
	 * possibly-confusing junk behind, we are careful to rewrite rightpage as
	 * zeroes before throwing any error.
	 */</comment>
	<expr_stmt><expr><name>origpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftpage</name> <operator>=</operator> <call><name>PageGetTempPage</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>origpagenumber</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightpagenumber</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_pageinit</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* rightpage was already initialized by _bt_getbuf */</comment>

	<comment type="block">/*
	 * Copy the original page's LSN into leftpage, which will become the
	 * updated version of the page.  We need this because XLogInsert will
	 * examine the LSN and possibly dump it in a page image.
	 */</comment>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><call><name>PageGetLSN</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* init btree private data */</comment>
	<expr_stmt><expr><name>oopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ropaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>isleaf</name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if we're splitting this page, it won't be the root when we're done */</comment>
	<comment type="block">/* also, clear the SPLIT_END and HAS_GARBAGE flags in both pages */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BTP_ROOT</name> <operator>|</operator> <name>BTP_SPLIT_END</name> <operator>|</operator> <name>BTP_HAS_GARBAGE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name></expr>;</expr_stmt>
	<comment type="block">/* set flag in left page indicating that the right page has no downlink */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>rightpagenumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>origpagenumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>oopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<comment type="block">/* Since we already have write-lock on both pages, ok to read cycleid */</comment>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <call><name>_bt_vacuum_cycleid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <name><name>lopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the page we're splitting is not the rightmost page at its level in
	 * the tree, then the first entry on the page is the high key for the
	 * page.  We need to copy that to the right half.  Otherwise (meaning the
	 * rightmost page case), all the items on the right half will be user
	 * data.
	 */</comment>
	<expr_stmt><expr><name>rightoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>item</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>rightoff</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add hikey to the right sibling"</literal>
				 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The "high key" for the new left page will be the first key that's going
	 * to go into the new right page.  This might be either the existing data
	 * item at position firstright, or the incoming tuple.
	 */</comment>
	<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <name>P_HIKEY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newitemonleft</name> <operator>&amp;&amp;</operator> <name>newitemoff</name> <operator>==</operator> <name>firstright</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* incoming tuple will become first on right page */</comment>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <name>newitemsz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* existing item at firstright will become first on right page */</comment>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>firstright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Truncate non-key (INCLUDE) attributes of the high key item before
	 * inserting it on the left page.  This only needs to happen at the leaf
	 * level, since in general all pivot tuple values originate from leaf
	 * level high keys.  This isn't just about avoiding unnecessary work,
	 * though; truncating unneeded key attributes (more aggressive suffix
	 * truncation) can only be performed at the leaf level anyway.  This is
	 * because a pivot tuple in a grandparent page must guide a search not
	 * only to the correct parent page, but also to the correct leaf page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>indnatts</name> <operator>!=</operator> <name>indnkeyatts</name> <operator>&amp;&amp;</operator> <name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lefthikey</name> <operator>=</operator> <call><name>_bt_nonkey_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>lefthikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lefthikey</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>lefthikey</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>lefthikey</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add hikey to the left sibling"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* be tidy */</comment>
	<if_stmt><if>if <condition>(<expr><name>lefthikey</name> <operator>!=</operator> <name>item</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lefthikey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now transfer all the data items to the appropriate page.
	 *
	 * Note: we *must* insert at least the right page's items in item-number
	 * order, for the benefit of _bt_restore_page().
	 */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* does new item belong before this one? */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>newitemoff</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>newitemonleft</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the left sibling"</literal>
						 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
						 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the right sibling"</literal>
						 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
						 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>rightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* decide which page to put it on */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>firstright</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to the left sibling"</literal>
					 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
					 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>leftoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>leftoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add old item to the right sibling"</literal>
					 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
					 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* cope with possibility that newitem goes at the end */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name>newitemoff</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Can't have newitemonleft here; that would imply we were told to put
		 * *everything* on the left page, which cannot fit (if it could, we'd
		 * not be splitting the page).
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>newitemonleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_bt_pgaddtup</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>newitemsz</name></expr></argument>, <argument><expr><name>newitem</name></expr></argument>, <argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add new item to the right sibling"</literal>
				 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
				 <argument><expr><name>origpagenumber</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rightoff</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>rightoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to grab the right sibling (if any) and fix the prev pointer
	 * there. We are guaranteed that this is deadlock-free since no other
	 * writer will be holding a lock on that page and trying to move left, and
	 * all readers release locks on a page before trying to fetch its
	 * neighbors.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>oopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>spage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>spage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>!=</operator> <name>origpagenumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BufferGetPageSize</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"right sibling's left-link doesn't match: "</literal>
				 <literal type="string">"block %u links to %u instead of expected %u in index \"%s\""</literal></expr></argument>,
				 <argument><expr><name><name>oopaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name></expr></argument>, <argument><expr><name>origpagenumber</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if we can set the SPLIT_END flag in the right-hand
		 * split page; this can save some I/O for vacuum since it need not
		 * proceed to the right sibling.  We can set the flag if the right
		 * sibling has a different cycleid: that means it could not be part of
		 * a group of pages that were all split off from the same ancestor
		 * page.  If you're confused, imagine that page A splits to A B and
		 * then again, yielding A C B, while vacuum is in progress.  Tuples
		 * originally in A could now be in either B or C, hence vacuum must
		 * examine both pages.  But if D, our right sibling, has a different
		 * cycleid then it could not contain any tuples that were in A when
		 * the vacuum started.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>!=</operator> <name><name>ropaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ropaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>|=</operator> <name>BTP_SPLIT_END</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Right sibling is locked, new siblings are prepared, but original page
	 * is not updated yet.
	 *
	 * NO EREPORT(ERROR) till right sibling is updated.  We can get away with
	 * not starting the critical section till here because we haven't been
	 * scribbling on the original page yet; see comments above.
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By here, the original data page has been split into two new halves, and
	 * these are correct.  The algorithm requires that the left page never
	 * move during a split, so we copy the new left page back on top of the
	 * original.  Note that this is not a waste of time, since we also require
	 * (in the page management code) that the center of a page always be
	 * clean, and the most efficient way to guarantee this is just to compact
	 * the data by reinserting it into a new left page.  (XXX the latter
	 * comment is probably obsolete; but in any case it's good to not scribble
	 * on the original page until we enter the critical section.)
	 *
	 * We need to do this before writing the WAL record, so that XLogInsert
	 * can WAL log an image of the page if necessary.
	 */</comment>
	<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>leftpage</name></expr></argument>, <argument><expr><name>origpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* leftpage, lopaque must not be used below here */</comment>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name>rightpagenumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clear INCOMPLETE_SPLIT flag on child if inserting the new item finishes
	 * a split.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>cpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>cpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>cpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cpageop</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_split</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>xlinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>loglhikey</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>ropaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>firstright</name></name> <operator>=</operator> <name>firstright</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newitemoff</name></name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Log the right sibling, because we've changed its prev-pointer. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Log the new item, if it was inserted on the left page. (If it was
		 * put on the right page, we don't need to explicitly WAL log it
		 * because it's included with all the other items on the right page.)
		 * Show the new item as belonging to the left page buffer, so that it
		 * is not stored if XLogInsert decides it needs a full-page image of
		 * the left page.  We store the offset anyway, though, to support
		 * archive compression of these records.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>newitemonleft</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>newitem</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>newitemsz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Log left page */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name> <operator>||</operator> <name>indnatts</name> <operator>!=</operator> <name>indnkeyatts</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We must also log the left page's high key.  There are two
			 * reasons for that: right page's leftmost key is suppressed on
			 * non-leaf levels and in covering indexes included columns are
			 * truncated from high keys.  Show it as belonging to the left
			 * page buffer, so that it is not stored if XLogInsert decides it
			 * needs a full-page image of the left page.
			 */</comment>
			<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>item</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>loglhikey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Log the contents of the right page in the format understood by
		 * _bt_restore_page(). We set lastrdata-&gt;buffer to InvalidBuffer,
		 * because we're going to recreate the whole page anyway, so it should
		 * never be stored by XLogInsert.
		 *
		 * Direct access to page is not good but faster - we should implement
		 * some new func in page API.  Note we only store the tuples
		 * themselves, knowing that they were inserted in item-number order
		 * and so the item pointers can be reconstructed.  See comments for
		 * _bt_restore_page().
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rightpage</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_special</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rightpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>xlinfo</name> <operator>=</operator> <ternary><condition><expr><name>newitemonleft</name></expr> ?</condition><then>
			<expr><operator>(</operator><ternary><condition><expr><name>loglhikey</name></expr> ?</condition><then> <expr><name>XLOG_BTREE_SPLIT_L_HIGHKEY</name></expr> </then><else>: <expr><name>XLOG_BTREE_SPLIT_L</name></expr></else></ternary><operator>)</operator></expr> </then><else>:
			<expr><operator>(</operator><ternary><condition><expr><name>loglhikey</name></expr> ?</condition><then> <expr><name>XLOG_BTREE_SPLIT_R_HIGHKEY</name></expr> </then><else>: <expr><name>XLOG_BTREE_SPLIT_R</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>xlinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>origpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rightpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>spage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release the old right sibling */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>ropaque</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* release the child */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isleaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* split's done */</comment>
	<return>return <expr><name>rbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_findsplitloc() -- find an appropriate place to split a page.
 *
 * The idea here is to equalize the free space that will be on each split
 * page, *after accounting for the inserted tuple*.  (If we fail to account
 * for it, we might find ourselves with too little room on the page that
 * it needs to go into!)
 *
 * If the page is the rightmost page on its level, we instead try to arrange
 * to leave the left split page fillfactor% full.  In this way, when we are
 * inserting successively increasing keys (consider sequences, timestamps,
 * etc) we will end up with a tree whose pages are about fillfactor% full,
 * instead of the 50% full result that we'd get without this special case.
 * This is the same as nbtsort.c produces for a newly-created tree.  Note
 * that leaf and nonleaf pages use different fillfactors.
 *
 * We are passed the intended insert position of the new tuple, expressed as
 * the offsetnumber of the tuple it must go in front of.  (This could be
 * maxoff+1 if the tuple is to go at the end.)
 *
 * We return the index of the first existing tuple that should go on the
 * righthand page, plus a boolean indicating whether the new tuple goes on
 * the left or right page.  The bool is necessary to disambiguate the case
 * where firstright == newitemoff.
 */</comment>
<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>_bt_findsplitloc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				 <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
				 <parameter><decl><type><name>OffsetNumber</name></type> <name>newitemoff</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name></type> <name>newitemsz</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newitemonleft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FindSplitData</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftspace</name></decl>,
				<decl><type ref="prev"/><name>rightspace</name></decl>,
				<decl><type ref="prev"/><name>goodenough</name></decl>,
				<decl><type ref="prev"/><name>olddataitemstotal</name></decl>,
				<decl><type ref="prev"/><name>olddataitemstoleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>goodenoughfound</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */</comment>
	<expr_stmt><expr><name>newitemsz</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Total free space available on a btree page, after fixed overhead */</comment>
	<expr_stmt><expr><name>leftspace</name> <operator>=</operator> <name>rightspace</name> <operator>=</operator>
		<call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BTPageOpaqueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The right page will have the same high key as the old page */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightspace</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
							 <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Count up total space in data items without actually scanning 'em */</comment>
	<expr_stmt><expr><name>olddataitemstotal</name> <operator>=</operator> <name>rightspace</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>PageGetExactFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitemsz</name></name> <operator>=</operator> <name>newitemsz</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name> <operator>=</operator> <call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>is_rightmost</name></name> <operator>=</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>have_split</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>is_leaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>fillfactor</name></name> <operator>=</operator> <call><name>RelationGetFillFactor</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
												 <argument><expr><name>BTREE_DEFAULT_FILLFACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>fillfactor</name></name> <operator>=</operator> <name>BTREE_NONLEAF_FILLFACTOR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitemonleft</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* these just to keep compiler quiet */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>firstright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>best_delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>leftspace</name></name> <operator>=</operator> <name>leftspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>rightspace</name></name> <operator>=</operator> <name>rightspace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>olddataitemstotal</name></name> <operator>=</operator> <name>olddataitemstotal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>newitemoff</name></name> <operator>=</operator> <name>newitemoff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finding the best possible split would require checking all the possible
	 * split points, because of the high-key and left-key special cases.
	 * That's probably more work than it's worth; instead, stop as soon as we
	 * find a "good-enough" split, where good-enough is defined as an
	 * imbalance in free space of no more than pagesize/16 (arbitrary...) This
	 * should let us stop near the middle on most pages, instead of plowing to
	 * the end.
	 */</comment>
	<expr_stmt><expr><name>goodenough</name> <operator>=</operator> <name>leftspace</name> <operator>/</operator> <literal type="number">16</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan through the data items and calculate space usage for a split at
	 * each possible position.
	 */</comment>
	<expr_stmt><expr><name>olddataitemstoleft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>goodenoughfound</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/*
		 * Will the new item go to left or right of split?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>offnum</name> <operator>&gt;</operator> <name>newitemoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_checksplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<if type="elseif">else if <condition>(<expr><name>offnum</name> <operator>&lt;</operator> <name>newitemoff</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>_bt_checksplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* need to try it both ways! */</comment>
			<expr_stmt><expr><call><name>_bt_checksplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>_bt_checksplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>olddataitemstoleft</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Abort scan once we find a good-enough choice */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>have_split</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>best_delta</name></name> <operator>&lt;=</operator> <name>goodenough</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>goodenoughfound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>olddataitemstoleft</name> <operator>+=</operator> <name>itemsz</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the new item goes as the last item, check for splitting so that all
	 * the old items go to the left page and the new item goes to the right
	 * page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newitemoff</name> <operator>&gt;</operator> <name>maxoff</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>goodenoughfound</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_checksplitloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>newitemoff</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>olddataitemstotal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * I believe it is not possible to fail to find a feasible split, but just
	 * in case ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>have_split</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find a feasible split point for index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>newitemonleft</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>newitemonleft</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>state</name><operator>.</operator><name>firstright</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine to analyze a particular possible split choice (ie, firstright
 * and newitemonleft settings), and record the best split so far in *state.
 *
 * firstoldonright is the offset of the first item on the original page
 * that goes to the right page, and firstoldonrightsz is the size of that
 * tuple. firstoldonright can be &gt; max offset, which means that all the old
 * items go to the left page and only the new item goes to the right page.
 * In that case, firstoldonrightsz is not used.
 *
 * olddataitemstoleft is the total size of all old items to the left of
 * firstoldonright.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_checksplitloc</name><parameter_list>(<parameter><decl><type><name>FindSplitData</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
				  <parameter><decl><type><name>OffsetNumber</name></type> <name>firstoldonright</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>newitemonleft</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>olddataitemstoleft</name></decl></parameter>,
				  <parameter><decl><type><name>Size</name></type> <name>firstoldonrightsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftfree</name></decl>,
				<decl><type ref="prev"/><name>rightfree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>firstrightitemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newitemisfirstonright</name></decl>;</decl_stmt>

	<comment type="block">/* Is the new item going to be the first item on the right page? */</comment>
	<expr_stmt><expr><name>newitemisfirstonright</name> <operator>=</operator> <operator>(</operator><name>firstoldonright</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemoff</name></name>
							 <operator>&amp;&amp;</operator> <operator>!</operator><name>newitemonleft</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newitemisfirstonright</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstrightitemsz</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstrightitemsz</name> <operator>=</operator> <name>firstoldonrightsz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Account for all the old tuples */</comment>
	<expr_stmt><expr><name>leftfree</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>leftspace</name></name> <operator>-</operator> <name>olddataitemstoleft</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightfree</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>rightspace</name></name> <operator>-</operator>
		<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>olddataitemstotal</name></name> <operator>-</operator> <name>olddataitemstoleft</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The first item on the right page becomes the high key of the left page;
	 * therefore it counts against left space as well as right space. When
	 * index has included attributes, then those attributes of left page high
	 * key will be truncated leaving that page with slightly more free space.
	 * However, that shouldn't affect our ability to find valid split
	 * location, because anyway split location should exists even without high
	 * key truncation.
	 */</comment>
	<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <name>firstrightitemsz</name></expr>;</expr_stmt>

	<comment type="block">/* account for the new item */</comment>
	<if_stmt><if>if <condition>(<expr><name>newitemonleft</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>leftfree</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightfree</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>newitemsz</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If we are not on the leaf level, we will be able to discard the key
	 * data from the first item that winds up on the right page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>is_leaf</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightfree</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>firstrightitemsz</name> <operator>-</operator>
			<operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If feasible split point, remember best delta.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftfree</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rightfree</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>delta</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>is_rightmost</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If splitting a rightmost page, try to put (100-fillfactor)% of
			 * free space on left page. See comments for _bt_findsplitloc.
			 */</comment>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>fillfactor</name></name> <operator>*</operator> <name>leftfree</name><operator>)</operator>
				<operator>-</operator> <operator>(</operator><operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>fillfactor</name></name><operator>)</operator> <operator>*</operator> <name>rightfree</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise, aim for equal free space on both sides */</comment>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>leftfree</name> <operator>-</operator> <name>rightfree</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>have_split</name></name> <operator>||</operator> <name>delta</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>best_delta</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>have_split</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>newitemonleft</name></name> <operator>=</operator> <name>newitemonleft</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>firstright</name></name> <operator>=</operator> <name>firstoldonright</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>best_delta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_insert_parent() -- Insert downlink into parent after a page split.
 *
 * On entry, buf and rbuf are the left and right split pages, which we
 * still hold write locks on per the L&amp;Y algorithm.  We release the
 * write locks once we have write lock on the parent page.  (Any sooner,
 * and it'd be possible for some other process to try to split or delete
 * one of these pages, and get confused because it cannot find the downlink.)
 *
 * stack - stack showing how we got here.  Will be NULL when splitting true
 *			root, or during concurrent root split, where we can be inefficient
 * is_root - we split the true root
 * is_only - we split a page alone on its level (might have been fast root)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_insert_parent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
				  <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>,
				  <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_root</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_only</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Here we have to do something Lehman and Yao don't talk about: deal with
	 * a root split and construction of a new root.  If our stack is empty
	 * then we have just split a node on what had been the root level when we
	 * descended the tree.  If it was still the root then we perform a
	 * new-root construction.  If it *wasn't* the root anymore, search to find
	 * the next higher level that someone constructed meanwhile, and find the
	 * right place to insert as for the normal case.
	 *
	 * If we have to search for the parent level, we do so by re-descending
	 * from the root.  This is not super-efficient, but it's rare enough not
	 * to matter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_root</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* create a new root node and update the metapage */</comment>
		<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_newroot</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* release the split buffers */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>bknum</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rbknum</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>new_item</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTStackData</name></type> <name>fakestack</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>ritem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>pbuf</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"concurrent ROOT page split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Find the leftmost page at the next level up */</comment>
			<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>_bt_get_endpoint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>lpageop</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Set up a phony stack entry pointing there */</comment>
			<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>&amp;</operator><name>fakestack</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_btentry</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get high key from left page == lower bound for new right page */</comment>
		<expr_stmt><expr><name>ritem</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* form an index tuple that points at the new right page */</comment>
		<expr_stmt><expr><name>new_item</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>ritem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><name>rbknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the parent buffer and get the parent page.
		 *
		 * Oops - if we were moved right then we need to change stack item! We
		 * want to find parent pointing to where we are, right ?	- vadim
		 * 05/27/97
		 */</comment>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_btentry</name></name> <operator>=</operator> <name>bknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>_bt_getstackbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we can unlock the right child. The left child will be unlocked
		 * by _bt_insertonpg().
		 */</comment>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for error only after writing children */</comment>
		<if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <name>InvalidBuffer</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find parent key in index \"%s\" for split pages %u/%u"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bknum</name></expr></argument>, <argument><expr><name>rbknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Recursively update the parent */</comment>
		<expr_stmt><expr><call><name>_bt_insertonpg</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr></argument>,
					   <argument><expr><name>new_item</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
					   <argument><expr><name>is_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* be tidy */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_finish_split() -- Finish an incomplete split
 *
 * A crash or other failure can leave a split incomplete.  The insertion
 * routines won't allow to insert on a page that is incompletely split.
 * Before inserting on such a page, call _bt_finish_split().
 *
 * On entry, 'lbuf' must be locked in write-mode.  On exit, it is unlocked
 * and unpinned.
 */</comment>
<function><type><name>void</name></type>
<name>_bt_finish_split</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lpageop</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rpageop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>was_only</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lock right sibling, the one missing the downlink */</comment>
	<expr_stmt><expr><name>rbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>lpageop</name><operator>-&gt;</operator><name>btpo_next</name></name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpageop</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Could this be a root split? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

		<comment type="block">/* acquire lock on the metapage */</comment>
		<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>was_root</name> <operator>=</operator> <operator>(</operator><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>==</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>was_root</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Was this the only page on the level before split? */</comment>
	<expr_stmt><expr><name>was_only</name> <operator>=</operator> <operator>(</operator><call><name>P_LEFTMOST</name><argument_list>(<argument><expr><name>lpageop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>rpageop</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"finishing incomplete split of %u/%u"</literal></expr></argument>,
		 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_insert_parent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>was_root</name></expr></argument>, <argument><expr><name>was_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_getstackbuf() -- Walk back up the tree one step, and find the item
 *						 we last looked at in the parent.
 *
 *		This is possible because we save the downlink from the parent item,
 *		which is enough to uniquely identify it.  Insertions into the parent
 *		level could cause the item to move right; deletions could cause it
 *		to move left, but not left of the page we previously found it in.
 *
 *		Adjusts bts_blkno &amp; bts_offset if changed.
 *
 *		Returns InvalidBuffer if item not found (should not happen).
 */</comment>
<function><type><name>Buffer</name></type>
<name>_bt_getstackbuf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BTStack</name></type> <name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>start</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>access</name> <operator>==</operator> <name>BT_WRITE</name> <operator>&amp;&amp;</operator> <call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_IGNORE</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
						<decl><type ref="prev"/><name>minoff</name></decl>,
						<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>item</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * start = InvalidOffsetNumber means "search the whole page". We
			 * need this test anyway due to possibility that page has a high
			 * key now when it didn't before.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>minoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <name>minoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Need this check too, to guard against possibility that page
			 * split since we visited it originally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * These loops will check every item on the page --- but in an
			 * order that's attuned to the probability of where it actually
			 * is.  Scan to the right first, then to the left.
			 */</comment>
			<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>start</name></expr>;</init>
				 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
				 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_btentry</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Return accurate pointer to where link is now */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
					<return>return <expr><name>buf</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</init>
				 <condition><expr><name>offnum</name> <operator>&gt;=</operator> <name>minoff</name></expr>;</condition>
				 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberPrev</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>BTreeInnerTupleGetDownLink</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>bts_btentry</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Return accurate pointer to where link is now */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>bts_offset</name></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt>
					<return>return <expr><name>buf</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The item we're looking for moved right at least one page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>P_RIGHTMOST</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidBuffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>btpo_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_newroot() -- Create a new root page for the index.
 *
 *		We've just split the old root page and need to create a new one.
 *		In order to do this, we add a new root page to the file, then lock
 *		the metadata page and update it.  This is guaranteed to be deadlock-
 *		free, because all readers release their locks on the metadata page
 *		before trying to lock the root, and all writers lock the root before
 *		trying to lock the metadata page.  We have a write lock on the old
 *		root page, so we have not introduced any cycles into the waits-for
 *		graph.
 *
 *		On entry, lbuf (the old root) and rbuf (its new peer) are write-
 *		locked. On exit, a new root page exists with entries for the
 *		two new children, metapage is updated and unlocked/unpinned.
 *		The new root buffer is returned to caller which has to unlock/unpin
 *		lbuf, rbuf &amp; rootbuf.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>_bt_newroot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>rbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>rootbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name></decl>,
				<decl><type ref="prev"/><name>rootpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lbkno</name></decl>,
				<decl><type ref="prev"/><name>rbkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rootblknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>rootopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>lopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>left_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>left_item_sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>right_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>right_item_sz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTMetaPageData</name> <modifier>*</modifier></type><name>metad</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lbkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rbkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get a new root page */</comment>
	<expr_stmt><expr><name>rootbuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootpage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootblknum</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* acquire lock on the metapage */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_bt_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>BTREE_METAPAGE</name></expr></argument>, <argument><expr><name>BT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapg</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metad</name> <operator>=</operator> <call><name>BTPageGetMeta</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create downlink item for left page (old root).  Since this will be the
	 * first item in a non-leaf page, it implicitly has minus-infinity key
	 * value, so we need not store any actual key in it.
	 */</comment>
	<expr_stmt><expr><name>left_item_sz</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>left_item_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_item</name><operator>-&gt;</operator><name>t_info</name></name> <operator>=</operator> <name>left_item_sz</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><name>lbkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create downlink item for right page.  The key for it is obtained from
	 * the "high key" position in the left page.
	 */</comment>
	<expr_stmt><expr><name>itemid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_item_sz</name> <operator>=</operator> <call><name>ItemIdGetLength</name><argument_list>(<argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>itemid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_item</name> <operator>=</operator> <call><name>CopyIndexTuple</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BTreeInnerTupleSetDownLink</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>, <argument><expr><name>rbkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NO EREPORT(ERROR) from here till newroot op is logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* upgrade metapage if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>metad</name><operator>-&gt;</operator><name>btm_version</name></name> <operator>&lt;</operator> <name>BTREE_VERSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_upgrademetapage</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set btree special data */</comment>
	<expr_stmt><expr><name>rootopaque</name> <operator>=</operator> <operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_prev</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_next</name></name> <operator>=</operator> <name>P_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>=</operator> <name>BTP_ROOT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>btpo</name><operator>.</operator><name>level</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rootopaque</name><operator>-&gt;</operator><name>btpo_cycleid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* update metapage data */</comment>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_root</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastroot</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metad</name><operator>-&gt;</operator><name>btm_fastlevel</name></name> <operator>=</operator> <name><name>rootopaque</name><operator>-&gt;</operator><name>btpo</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert the left page pointer into the new root page.  The root page is
	 * the rightmost page on its level so there is no "high key" in it; the
	 * two items will go into positions P_HIKEY and P_FIRSTKEY.
	 *
	 * Note: we *must* insert the two items in item-number order, for the
	 * benefit of _bt_restore_page().
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>left_item</name></expr></argument>, <argument><expr><name>left_item_sz</name></expr></argument>, <argument><expr><name>P_HIKEY</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add leftkey to new root page"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * insert the right page pointer into the new root page.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BTreeTupleGetNAtts</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator>
		   <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>right_item</name></expr></argument>, <argument><expr><name>right_item_sz</name></expr></argument>, <argument><expr><name>P_FIRSTKEY</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"failed to add rightkey to new root page"</literal>
			 <literal type="string">" while splitting block %u of index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clear the incomplete-split flag in the left child */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_INCOMPLETE_SPLIT</name><argument_list>(<argument><expr><name>lopaque</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lopaque</name><operator>-&gt;</operator><name>btpo_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BTP_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_btree_newroot</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>xl_btree_metadata</name></type> <name>md</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>rootblk</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfBtreeNewroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rootbuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lbuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name> <operator>|</operator> <name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastroot</name></name> <operator>=</operator> <name>rootblknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>fastlevel</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_level</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>oldest_btpo_xact</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_oldest_btpo_xact</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>md</name><operator>.</operator><name>last_cleanup_num_heap_tuples</name></name> <operator>=</operator> <name><name>metad</name><operator>-&gt;</operator><name>btm_last_cleanup_num_heap_tuples</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>md</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xl_btree_metadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Direct access to page is not good but faster - we should implement
		 * some new func in page API.
		 */</comment>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>rootpage</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>,
							<argument><expr><operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_special</name> <operator>-</operator>
							<operator>(</operator><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>rootpage</name><operator>)</operator><operator>-&gt;</operator><name>pd_upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_BTREE_ID</name></expr></argument>, <argument><expr><name>XLOG_BTREE_NEWROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>rootpage</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapg</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with metapage */</comment>
	<expr_stmt><expr><call><name>_bt_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>left_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>right_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rootbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_bt_pgaddtup() -- add a tuple to a particular page in the index.
 *
 *		This routine adds the tuple to the page as requested.  It does
 *		not affect pin/lock status, but you'd better have a write lock
 *		and pin on the target buffer!  Don't forget to write and release
 *		the buffer afterwards, either.
 *
 *		The main difference between this routine and a bare PageAddItem call
 *		is that this code knows that the leftmost index tuple on a non-leaf
 *		btree page doesn't need to have a key.  Therefore, it strips such
 *		tuples down to just the tuple header.  CAUTION: this works ONLY if
 *		we insert the tuples in order, so that the given itup_off does
 *		represent the final position of the tuple!
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_pgaddtup</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
			 <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>,
			 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
			 <parameter><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTupleData</name></type> <name>trunctuple</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>P_ISLEAF</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>itup_off</name> <operator>==</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>trunctuple</name> <operator>=</operator> <operator>*</operator><name>itup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trunctuple</name><operator>.</operator><name>t_info</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BTreeTupleSetNAtts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trunctuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>&amp;</operator><name>trunctuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_isequal - used in _bt_doinsert in check for duplicates.
 *
 * This is very similar to _bt_compare, except for NULL handling.
 * Rule is simple: NOT_NULL not equal NULL, NULL not equal NULL too.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_bt_isequal</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>itupdesc</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>keysz</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Better be comparing to a leaf item */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>P_ISLEAF</name><argument_list>(<argument><expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's okay that we might perform a comparison against a truncated page
	 * high key when caller needs to determine if _bt_check_unique scan must
	 * continue on to the next page.  Caller never asks us to compare non-key
	 * attributes within an INCLUDE index.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>keysz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>scankey</name><operator>-&gt;</operator><name>sk_attno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>itupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* NULLs are never equal to anything */</comment>
		<if_stmt><if>if <condition>(<expr><name>isNull</name> <operator>||</operator> <operator>(</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
												 <argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
												 <argument><expr><name>datum</name></expr></argument>,
												 <argument><expr><name><name>scankey</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>scankey</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if we get here, the keys are equal */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _bt_vacuum_one_page - vacuum just one index page.
 *
 * Try to remove LP_DEAD items from the given page.  The passed buffer
 * must be exclusive-locked, but unlike a real VACUUM, we don't need a
 * super-exclusive "cleanup" lock (see nbtree/README).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>deletable</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeletable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>minoff</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTPageOpaque</name></type> <name>opaque</name> <init>= <expr><operator>(</operator><name>BTPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Scan over all items to see which ones need to be deleted according to
	 * LP_DEAD flags.
	 */</comment>
	<expr_stmt><expr><name>minoff</name> <operator>=</operator> <call><name>P_FIRSTDATAKEY</name><argument_list>(<argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>minoff</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>ndeletable</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_delitems_delete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>, <argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: if we didn't find any LP_DEAD items, then the page's
	 * BTP_HAS_GARBAGE hint bit is falsely set.  We do not bother expending a
	 * separate write to clear it, however.  We will clear it when we split
	 * the page.
	 */</comment>
</block_content>}</block></function>
</unit>
